!(function (e) {
  var t = {};

  function n(r) {
    if (t[r]) return t[r].exports;
    var i = (t[r] = {
      i: r,
      l: !1,
      exports: {},
    });
    return e[r].call(i.exports, i, i.exports, n), (i.l = !0), i.exports;
  }
  (n.m = e),
    (n.c = t),
    (n.d = function (e, t, r) {
      n.o(e, t) ||
        Object.defineProperty(e, t, {
          enumerable: !0,
          get: r,
        });
    }),
    (n.r = function (e) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, {
          value: "Module",
        }),
        Object.defineProperty(e, "__esModule", {
          value: !0,
        });
    }),
    (n.t = function (e, t) {
      if ((1 & t && (e = n(e)), 8 & t)) return e;
      if (4 & t && "object" == typeof e && e && e.__esModule) return e;
      var r = Object.create(null);
      if (
        (n.r(r),
        Object.defineProperty(r, "default", {
          enumerable: !0,
          value: e,
        }),
        2 & t && "string" != typeof e)
      )
        for (var i in e)
          n.d(
            r,
            i,
            function (t) {
              return e[t];
            }.bind(null, i)
          );
      return r;
    }),
    (n.n = function (e) {
      var t =
        e && e.__esModule
          ? function () {
              return e.default;
            }
          : function () {
              return e;
            };
      return n.d(t, "a", t), t;
    }),
    (n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }),
    (n.p = ""),
    n((n.s = 22));
})([
  function (e, t, n) {
    "use strict";
    n.r(t),
      n.d(t, "ACESFilmicToneMapping", function () {
        return ne;
      }),
      n.d(t, "AddEquation", function () {
        return T;
      }),
      n.d(t, "AddOperation", function () {
        return Z;
      }),
      n.d(t, "AdditiveAnimationBlendMode", function () {
        return qt;
      }),
      n.d(t, "AdditiveBlending", function () {
        return w;
      }),
      n.d(t, "AlphaFormat", function () {
        return Be;
      }),
      n.d(t, "AlwaysDepth", function () {
        return G;
      }),
      n.d(t, "AlwaysStencilFunc", function () {
        return Sn;
      }),
      n.d(t, "AmbientLight", function () {
        return rd;
      }),
      n.d(t, "AmbientLightProbe", function () {
        return Sd;
      }),
      n.d(t, "AnimationClip", function () {
        return Th;
      }),
      n.d(t, "AnimationLoader", function () {
        return kh;
      }),
      n.d(t, "AnimationMixer", function () {
        return ep;
      }),
      n.d(t, "AnimationObjectGroup", function () {
        return Kd;
      }),
      n.d(t, "AnimationUtils", function () {
        return dh;
      }),
      n.d(t, "ArcCurve", function () {
        return $c;
      }),
      n.d(t, "ArrayCamera", function () {
        return vl;
      }),
      n.d(t, "ArrowHelper", function () {
        return Vp;
      }),
      n.d(t, "Audio", function () {
        return Od;
      }),
      n.d(t, "AudioAnalyser", function () {
        return Hd;
      }),
      n.d(t, "AudioContext", function () {
        return wd;
      }),
      n.d(t, "AudioListener", function () {
        return Dd;
      }),
      n.d(t, "AudioLoader", function () {
        return _d;
      }),
      n.d(t, "AxesHelper", function () {
        return jp;
      }),
      n.d(t, "AxisHelper", function () {
        return xf;
      }),
      n.d(t, "BackSide", function () {
        return m;
      }),
      n.d(t, "BasicDepthPacking", function () {
        return on;
      }),
      n.d(t, "BasicShadowMap", function () {
        return u;
      }),
      n.d(t, "BinaryTextureLoader", function () {
        return Sf;
      }),
      n.d(t, "Bone", function () {
        return nc;
      }),
      n.d(t, "BooleanKeyframeTrack", function () {
        return yh;
      }),
      n.d(t, "BoundingBoxHelper", function () {
        return bf;
      }),
      n.d(t, "Box2", function () {
        return up;
      }),
      n.d(t, "Box3", function () {
        return ur;
      }),
      n.d(t, "Box3Helper", function () {
        return Np;
      }),
      n.d(t, "BoxBufferGeometry", function () {
        return wo;
      }),
      n.d(t, "BoxGeometry", function () {
        return wo;
      }),
      n.d(t, "BoxHelper", function () {
        return Fp;
      }),
      n.d(t, "BufferAttribute", function () {
        return ki;
      }),
      n.d(t, "BufferGeometry", function () {
        return eo;
      }),
      n.d(t, "BufferGeometryLoader", function () {
        return ud;
      }),
      n.d(t, "ByteType", function () {
        return Te;
      }),
      n.d(t, "Cache", function () {
        return Ah;
      }),
      n.d(t, "Camera", function () {
        return Eo;
      }),
      n.d(t, "CameraHelper", function () {
        return Dp;
      }),
      n.d(t, "CanvasRenderer", function () {
        return Ef;
      }),
      n.d(t, "CanvasTexture", function () {
        return kc;
      }),
      n.d(t, "CatmullRomCurve3", function () {
        return Qc;
      }),
      n.d(t, "CineonToneMapping", function () {
        return te;
      }),
      n.d(t, "CircleBufferGeometry", function () {
        return Oc;
      }),
      n.d(t, "CircleGeometry", function () {
        return Oc;
      }),
      n.d(t, "ClampToEdgeWrapping", function () {
        return de;
      }),
      n.d(t, "Clock", function () {
        return Cd;
      }),
      n.d(t, "Color", function () {
        return Pi;
      }),
      n.d(t, "ColorKeyframeTrack", function () {
        return xh;
      }),
      n.d(t, "CompressedTexture", function () {
        return Ic;
      }),
      n.d(t, "CompressedTextureLoader", function () {
        return Dh;
      }),
      n.d(t, "ConeBufferGeometry", function () {
        return Fc;
      }),
      n.d(t, "ConeGeometry", function () {
        return Fc;
      }),
      n.d(t, "CubeCamera", function () {
        return Co;
      }),
      n.d(t, "CubeReflectionMapping", function () {
        return oe;
      }),
      n.d(t, "CubeRefractionMapping", function () {
        return ae;
      }),
      n.d(t, "CubeTexture", function () {
        return Po;
      }),
      n.d(t, "CubeTextureLoader", function () {
        return Bh;
      }),
      n.d(t, "CubeUVReflectionMapping", function () {
        return ce;
      }),
      n.d(t, "CubeUVRefractionMapping", function () {
        return ue;
      }),
      n.d(t, "CubicBezierCurve", function () {
        return ru;
      }),
      n.d(t, "CubicBezierCurve3", function () {
        return iu;
      }),
      n.d(t, "CubicInterpolant", function () {
        return fh;
      }),
      n.d(t, "CullFaceBack", function () {
        return s;
      }),
      n.d(t, "CullFaceFront", function () {
        return l;
      }),
      n.d(t, "CullFaceFrontBack", function () {
        return c;
      }),
      n.d(t, "CullFaceNone", function () {
        return a;
      }),
      n.d(t, "Curve", function () {
        return Wc;
      }),
      n.d(t, "CurvePath", function () {
        return Uh;
      }),
      n.d(t, "CustomBlending", function () {
        return S;
      }),
      n.d(t, "CustomToneMapping", function () {
        return re;
      }),
      n.d(t, "CylinderBufferGeometry", function () {
        return Bc;
      }),
      n.d(t, "CylinderGeometry", function () {
        return Bc;
      }),
      n.d(t, "Cylindrical", function () {
        return lp;
      }),
      n.d(t, "DataTexture", function () {
        return rc;
      }),
      n.d(t, "DataTexture2DArray", function () {
        return Pa;
      }),
      n.d(t, "DataTexture3D", function () {
        return La;
      }),
      n.d(t, "DataTextureLoader", function () {
        return Fh;
      }),
      n.d(t, "DataUtils", function () {
        return $p;
      }),
      n.d(t, "DecrementStencilOp", function () {
        return pn;
      }),
      n.d(t, "DecrementWrapStencilOp", function () {
        return mn;
      }),
      n.d(t, "DefaultLoadingManager", function () {
        return Ph;
      }),
      n.d(t, "DepthFormat", function () {
        return Ge;
      }),
      n.d(t, "DepthStencilFormat", function () {
        return Ve;
      }),
      n.d(t, "DepthTexture", function () {
        return Dc;
      }),
      n.d(t, "DirectionalLight", function () {
        return nd;
      }),
      n.d(t, "DirectionalLightHelper", function () {
        return Rp;
      }),
      n.d(t, "DiscreteInterpolant", function () {
        return gh;
      }),
      n.d(t, "DodecahedronBufferGeometry", function () {
        return Uc;
      }),
      n.d(t, "DodecahedronGeometry", function () {
        return Uc;
      }),
      n.d(t, "DoubleSide", function () {
        return g;
      }),
      n.d(t, "DstAlphaFactor", function () {
        return B;
      }),
      n.d(t, "DstColorFactor", function () {
        return N;
      }),
      n.d(t, "DynamicBufferAttribute", function () {
        return cf;
      }),
      n.d(t, "DynamicCopyUsage", function () {
        return In;
      }),
      n.d(t, "DynamicDrawUsage", function () {
        return En;
      }),
      n.d(t, "DynamicReadUsage", function () {
        return Pn;
      }),
      n.d(t, "EdgesGeometry", function () {
        return jc;
      }),
      n.d(t, "EdgesHelper", function () {
        return wf;
      }),
      n.d(t, "EllipseCurve", function () {
        return qc;
      }),
      n.d(t, "EqualDepth", function () {
        return W;
      }),
      n.d(t, "EqualStencilFunc", function () {
        return xn;
      }),
      n.d(t, "EquirectangularReflectionMapping", function () {
        return se;
      }),
      n.d(t, "EquirectangularRefractionMapping", function () {
        return le;
      }),
      n.d(t, "Euler", function () {
        return Xr;
      }),
      n.d(t, "EventDispatcher", function () {
        return Bn;
      }),
      n.d(t, "ExtrudeBufferGeometry", function () {
        return Uu;
      }),
      n.d(t, "ExtrudeGeometry", function () {
        return Uu;
      }),
      n.d(t, "FaceColors", function () {
        return Zp;
      }),
      n.d(t, "FileLoader", function () {
        return Ih;
      }),
      n.d(t, "FlatShading", function () {
        return v;
      }),
      n.d(t, "Float16BufferAttribute", function () {
        return Hi;
      }),
      n.d(t, "Float32Attribute", function () {
        return vf;
      }),
      n.d(t, "Float32BufferAttribute", function () {
        return Gi;
      }),
      n.d(t, "Float64Attribute", function () {
        return yf;
      }),
      n.d(t, "Float64BufferAttribute", function () {
        return Vi;
      }),
      n.d(t, "FloatType", function () {
        return Le;
      }),
      n.d(t, "Fog", function () {
        return El;
      }),
      n.d(t, "FogExp2", function () {
        return Tl;
      }),
      n.d(t, "Font", function () {
        return vd;
      }),
      n.d(t, "FontLoader", function () {
        return xd;
      }),
      n.d(t, "FrontSide", function () {
        return f;
      }),
      n.d(t, "Frustum", function () {
        return Fo;
      }),
      n.d(t, "GLBufferAttribute", function () {
        return rp;
      }),
      n.d(t, "GLSL1", function () {
        return Dn;
      }),
      n.d(t, "GLSL3", function () {
        return On;
      }),
      n.d(t, "GammaEncoding", function () {
        return Kt;
      }),
      n.d(t, "GreaterDepth", function () {
        return $;
      }),
      n.d(t, "GreaterEqualDepth", function () {
        return q;
      }),
      n.d(t, "GreaterEqualStencilFunc", function () {
        return Mn;
      }),
      n.d(t, "GreaterStencilFunc", function () {
        return wn;
      }),
      n.d(t, "GridHelper", function () {
        return Ep;
      }),
      n.d(t, "Group", function () {
        return yl;
      }),
      n.d(t, "HalfFloatType", function () {
        return Re;
      }),
      n.d(t, "HemisphereLight", function () {
        return Vh;
      }),
      n.d(t, "HemisphereLightHelper", function () {
        return Tp;
      }),
      n.d(t, "HemisphereLightProbe", function () {
        return Md;
      }),
      n.d(t, "IcosahedronBufferGeometry", function () {
        return Hu;
      }),
      n.d(t, "IcosahedronGeometry", function () {
        return Hu;
      }),
      n.d(t, "ImageBitmapLoader", function () {
        return md;
      }),
      n.d(t, "ImageLoader", function () {
        return Oh;
      }),
      n.d(t, "ImageUtils", function () {
        return Kn;
      }),
      n.d(t, "ImmediateRenderObject", function () {
        return fp;
      }),
      n.d(t, "IncrementStencilOp", function () {
        return dn;
      }),
      n.d(t, "IncrementWrapStencilOp", function () {
        return fn;
      }),
      n.d(t, "InstancedBufferAttribute", function () {
        return sc;
      }),
      n.d(t, "InstancedBufferGeometry", function () {
        return cd;
      }),
      n.d(t, "InstancedInterleavedBuffer", function () {
        return np;
      }),
      n.d(t, "InstancedMesh", function () {
        return dc;
      }),
      n.d(t, "Int16Attribute", function () {
        return pf;
      }),
      n.d(t, "Int16BufferAttribute", function () {
        return Fi;
      }),
      n.d(t, "Int32Attribute", function () {
        return mf;
      }),
      n.d(t, "Int32BufferAttribute", function () {
        return Ui;
      }),
      n.d(t, "Int8Attribute", function () {
        return uf;
      }),
      n.d(t, "Int8BufferAttribute", function () {
        return Di;
      }),
      n.d(t, "IntType", function () {
        return Ce;
      }),
      n.d(t, "InterleavedBuffer", function () {
        return Cl;
      }),
      n.d(t, "InterleavedBufferAttribute", function () {
        return Ll;
      }),
      n.d(t, "Interpolant", function () {
        return ph;
      }),
      n.d(t, "InterpolateDiscrete", function () {
        return Ut;
      }),
      n.d(t, "InterpolateLinear", function () {
        return zt;
      }),
      n.d(t, "InterpolateSmooth", function () {
        return Ht;
      }),
      n.d(t, "InvertStencilOp", function () {
        return gn;
      }),
      n.d(t, "JSONLoader", function () {
        return Af;
      }),
      n.d(t, "KeepStencilOp", function () {
        return un;
      }),
      n.d(t, "KeyframeTrack", function () {
        return vh;
      }),
      n.d(t, "LOD", function () {
        return Yl;
      }),
      n.d(t, "LatheBufferGeometry", function () {
        return Gu;
      }),
      n.d(t, "LatheGeometry", function () {
        return Gu;
      }),
      n.d(t, "Layers", function () {
        return Yr;
      }),
      n.d(t, "LensFlare", function () {
        return Pf;
      }),
      n.d(t, "LessDepth", function () {
        return V;
      }),
      n.d(t, "LessEqualDepth", function () {
        return j;
      }),
      n.d(t, "LessEqualStencilFunc", function () {
        return bn;
      }),
      n.d(t, "LessStencilFunc", function () {
        return yn;
      }),
      n.d(t, "Light", function () {
        return Gh;
      }),
      n.d(t, "LightProbe", function () {
        return ad;
      }),
      n.d(t, "Line", function () {
        return xc;
      }),
      n.d(t, "Line3", function () {
        return pp;
      }),
      n.d(t, "LineBasicMaterial", function () {
        return pc;
      }),
      n.d(t, "LineCurve", function () {
        return ou;
      }),
      n.d(t, "LineCurve3", function () {
        return au;
      }),
      n.d(t, "LineDashedMaterial", function () {
        return uh;
      }),
      n.d(t, "LineLoop", function () {
        return Mc;
      }),
      n.d(t, "LinePieces", function () {
        return Yp;
      }),
      n.d(t, "LineSegments", function () {
        return _c;
      }),
      n.d(t, "LineStrip", function () {
        return Xp;
      }),
      n.d(t, "LinearEncoding", function () {
        return Jt;
      }),
      n.d(t, "LinearFilter", function () {
        return xe;
      }),
      n.d(t, "LinearInterpolant", function () {
        return mh;
      }),
      n.d(t, "LinearMipMapLinearFilter", function () {
        return Me;
      }),
      n.d(t, "LinearMipMapNearestFilter", function () {
        return we;
      }),
      n.d(t, "LinearMipmapLinearFilter", function () {
        return _e;
      }),
      n.d(t, "LinearMipmapNearestFilter", function () {
        return be;
      }),
      n.d(t, "LinearToneMapping", function () {
        return Q;
      }),
      n.d(t, "Loader", function () {
        return Lh;
      }),
      n.d(t, "LoaderUtils", function () {
        return ld;
      }),
      n.d(t, "LoadingManager", function () {
        return Ch;
      }),
      n.d(t, "LogLuvEncoding", function () {
        return en;
      }),
      n.d(t, "LoopOnce", function () {
        return Bt;
      }),
      n.d(t, "LoopPingPong", function () {
        return Nt;
      }),
      n.d(t, "LoopRepeat", function () {
        return Ft;
      }),
      n.d(t, "LuminanceAlphaFormat", function () {
        return ze;
      }),
      n.d(t, "LuminanceFormat", function () {
        return Ue;
      }),
      n.d(t, "MOUSE", function () {
        return i;
      }),
      n.d(t, "Material", function () {
        return _i;
      }),
      n.d(t, "MaterialLoader", function () {
        return sd;
      }),
      n.d(t, "Math", function () {
        return Xn;
      }),
      n.d(t, "MathUtils", function () {
        return Xn;
      }),
      n.d(t, "Matrix3", function () {
        return Jn;
      }),
      n.d(t, "Matrix4", function () {
        return Nr;
      }),
      n.d(t, "MaxEquation", function () {
        return P;
      }),
      n.d(t, "Mesh", function () {
        return xo;
      }),
      n.d(t, "MeshBasicMaterial", function () {
        return Li;
      }),
      n.d(t, "MeshDepthMaterial", function () {
        return hl;
      }),
      n.d(t, "MeshDistanceMaterial", function () {
        return dl;
      }),
      n.d(t, "MeshFaceMaterial", function () {
        return Qp;
      }),
      n.d(t, "MeshLambertMaterial", function () {
        return lh;
      }),
      n.d(t, "MeshMatcapMaterial", function () {
        return ch;
      }),
      n.d(t, "MeshNormalMaterial", function () {
        return sh;
      }),
      n.d(t, "MeshPhongMaterial", function () {
        return oh;
      }),
      n.d(t, "MeshPhysicalMaterial", function () {
        return ih;
      }),
      n.d(t, "MeshStandardMaterial", function () {
        return rh;
      }),
      n.d(t, "MeshToonMaterial", function () {
        return ah;
      }),
      n.d(t, "MinEquation", function () {
        return C;
      }),
      n.d(t, "MirroredRepeatWrapping", function () {
        return pe;
      }),
      n.d(t, "MixOperation", function () {
        return J;
      }),
      n.d(t, "MultiMaterial", function () {
        return ef;
      }),
      n.d(t, "MultiplyBlending", function () {
        return M;
      }),
      n.d(t, "MultiplyOperation", function () {
        return Y;
      }),
      n.d(t, "NearestFilter", function () {
        return fe;
      }),
      n.d(t, "NearestMipMapLinearFilter", function () {
        return ye;
      }),
      n.d(t, "NearestMipMapNearestFilter", function () {
        return ge;
      }),
      n.d(t, "NearestMipmapLinearFilter", function () {
        return ve;
      }),
      n.d(t, "NearestMipmapNearestFilter", function () {
        return me;
      }),
      n.d(t, "NeverDepth", function () {
        return H;
      }),
      n.d(t, "NeverStencilFunc", function () {
        return vn;
      }),
      n.d(t, "NoBlending", function () {
        return x;
      }),
      n.d(t, "NoColors", function () {
        return Jp;
      }),
      n.d(t, "NoToneMapping", function () {
        return K;
      }),
      n.d(t, "NormalAnimationBlendMode", function () {
        return Wt;
      }),
      n.d(t, "NormalBlending", function () {
        return b;
      }),
      n.d(t, "NotEqualDepth", function () {
        return X;
      }),
      n.d(t, "NotEqualStencilFunc", function () {
        return _n;
      }),
      n.d(t, "NumberKeyframeTrack", function () {
        return bh;
      }),
      n.d(t, "Object3D", function () {
        return ci;
      }),
      n.d(t, "ObjectLoader", function () {
        return hd;
      }),
      n.d(t, "ObjectSpaceNormalMap", function () {
        return ln;
      }),
      n.d(t, "OctahedronBufferGeometry", function () {
        return Vu;
      }),
      n.d(t, "OctahedronGeometry", function () {
        return Vu;
      }),
      n.d(t, "OneFactor", function () {
        return R;
      }),
      n.d(t, "OneMinusDstAlphaFactor", function () {
        return F;
      }),
      n.d(t, "OneMinusDstColorFactor", function () {
        return U;
      }),
      n.d(t, "OneMinusSrcAlphaFactor", function () {
        return O;
      }),
      n.d(t, "OneMinusSrcColorFactor", function () {
        return k;
      }),
      n.d(t, "OrthographicCamera", function () {
        return Jo;
      }),
      n.d(t, "PCFShadowMap", function () {
        return h;
      }),
      n.d(t, "PCFSoftShadowMap", function () {
        return d;
      }),
      n.d(t, "PMREMGenerator", function () {
        return ha;
      }),
      n.d(t, "ParametricBufferGeometry", function () {
        return ju;
      }),
      n.d(t, "ParametricGeometry", function () {
        return ju;
      }),
      n.d(t, "Particle", function () {
        return nf;
      }),
      n.d(t, "ParticleBasicMaterial", function () {
        return af;
      }),
      n.d(t, "ParticleSystem", function () {
        return rf;
      }),
      n.d(t, "ParticleSystemMaterial", function () {
        return sf;
      }),
      n.d(t, "Path", function () {
        return zh;
      }),
      n.d(t, "PerspectiveCamera", function () {
        return Ao;
      }),
      n.d(t, "Plane", function () {
        return Do;
      }),
      n.d(t, "PlaneBufferGeometry", function () {
        return zo;
      }),
      n.d(t, "PlaneGeometry", function () {
        return zo;
      }),
      n.d(t, "PlaneHelper", function () {
        return Up;
      }),
      n.d(t, "PointCloud", function () {
        return tf;
      }),
      n.d(t, "PointCloudMaterial", function () {
        return of;
      }),
      n.d(t, "PointLight", function () {
        return ed;
      }),
      n.d(t, "PointLightHelper", function () {
        return wp;
      }),
      n.d(t, "Points", function () {
        return Pc;
      }),
      n.d(t, "PointsMaterial", function () {
        return Sc;
      }),
      n.d(t, "PolarGridHelper", function () {
        return Ap;
      }),
      n.d(t, "PolyhedronBufferGeometry", function () {
        return Nc;
      }),
      n.d(t, "PolyhedronGeometry", function () {
        return Nc;
      }),
      n.d(t, "PositionalAudio", function () {
        return zd;
      }),
      n.d(t, "PropertyBinding", function () {
        return Zd;
      }),
      n.d(t, "PropertyMixer", function () {
        return Gd;
      }),
      n.d(t, "QuadraticBezierCurve", function () {
        return su;
      }),
      n.d(t, "QuadraticBezierCurve3", function () {
        return lu;
      }),
      n.d(t, "Quaternion", function () {
        return ar;
      }),
      n.d(t, "QuaternionKeyframeTrack", function () {
        return _h;
      }),
      n.d(t, "QuaternionLinearInterpolant", function () {
        return wh;
      }),
      n.d(t, "REVISION", function () {
        return r;
      }),
      n.d(t, "RGBADepthPacking", function () {
        return an;
      }),
      n.d(t, "RGBAFormat", function () {
        return Ne;
      }),
      n.d(t, "RGBAIntegerFormat", function () {
        return Ye;
      }),
      n.d(t, "RGBA_ASTC_10x10_Format", function () {
        return yt;
      }),
      n.d(t, "RGBA_ASTC_10x5_Format", function () {
        return mt;
      }),
      n.d(t, "RGBA_ASTC_10x6_Format", function () {
        return gt;
      }),
      n.d(t, "RGBA_ASTC_10x8_Format", function () {
        return vt;
      }),
      n.d(t, "RGBA_ASTC_12x10_Format", function () {
        return xt;
      }),
      n.d(t, "RGBA_ASTC_12x12_Format", function () {
        return bt;
      }),
      n.d(t, "RGBA_ASTC_4x4_Format", function () {
        return st;
      }),
      n.d(t, "RGBA_ASTC_5x4_Format", function () {
        return lt;
      }),
      n.d(t, "RGBA_ASTC_5x5_Format", function () {
        return ct;
      }),
      n.d(t, "RGBA_ASTC_6x5_Format", function () {
        return ut;
      }),
      n.d(t, "RGBA_ASTC_6x6_Format", function () {
        return ht;
      }),
      n.d(t, "RGBA_ASTC_8x5_Format", function () {
        return dt;
      }),
      n.d(t, "RGBA_ASTC_8x6_Format", function () {
        return pt;
      }),
      n.d(t, "RGBA_ASTC_8x8_Format", function () {
        return ft;
      }),
      n.d(t, "RGBA_BPTC_Format", function () {
        return wt;
      }),
      n.d(t, "RGBA_ETC2_EAC_Format", function () {
        return at;
      }),
      n.d(t, "RGBA_PVRTC_2BPPV1_Format", function () {
        return rt;
      }),
      n.d(t, "RGBA_PVRTC_4BPPV1_Format", function () {
        return nt;
      }),
      n.d(t, "RGBA_S3TC_DXT1_Format", function () {
        return Ze;
      }),
      n.d(t, "RGBA_S3TC_DXT3_Format", function () {
        return Ke;
      }),
      n.d(t, "RGBA_S3TC_DXT5_Format", function () {
        return Qe;
      }),
      n.d(t, "RGBDEncoding", function () {
        return rn;
      }),
      n.d(t, "RGBEEncoding", function () {
        return Qt;
      }),
      n.d(t, "RGBEFormat", function () {
        return He;
      }),
      n.d(t, "RGBFormat", function () {
        return Fe;
      }),
      n.d(t, "RGBIntegerFormat", function () {
        return Xe;
      }),
      n.d(t, "RGBM16Encoding", function () {
        return nn;
      }),
      n.d(t, "RGBM7Encoding", function () {
        return tn;
      }),
      n.d(t, "RGB_ETC1_Format", function () {
        return it;
      }),
      n.d(t, "RGB_ETC2_Format", function () {
        return ot;
      }),
      n.d(t, "RGB_PVRTC_2BPPV1_Format", function () {
        return tt;
      }),
      n.d(t, "RGB_PVRTC_4BPPV1_Format", function () {
        return et;
      }),
      n.d(t, "RGB_S3TC_DXT1_Format", function () {
        return Je;
      }),
      n.d(t, "RGFormat", function () {
        return qe;
      }),
      n.d(t, "RGIntegerFormat", function () {
        return $e;
      }),
      n.d(t, "RawShaderMaterial", function () {
        return Zo;
      }),
      n.d(t, "Ray", function () {
        return Fr;
      }),
      n.d(t, "Raycaster", function () {
        return ip;
      }),
      n.d(t, "RectAreaLight", function () {
        return id;
      }),
      n.d(t, "RedFormat", function () {
        return je;
      }),
      n.d(t, "RedIntegerFormat", function () {
        return We;
      }),
      n.d(t, "ReinhardToneMapping", function () {
        return ee;
      }),
      n.d(t, "RepeatWrapping", function () {
        return he;
      }),
      n.d(t, "ReplaceStencilOp", function () {
        return hn;
      }),
      n.d(t, "ReverseSubtractEquation", function () {
        return A;
      }),
      n.d(t, "RingBufferGeometry", function () {
        return Wu;
      }),
      n.d(t, "RingGeometry", function () {
        return Wu;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_10x10_Format", function () {
        return kt;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_10x5_Format", function () {
        return Lt;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_10x6_Format", function () {
        return Rt;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_10x8_Format", function () {
        return It;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_12x10_Format", function () {
        return Dt;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_12x12_Format", function () {
        return Ot;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_4x4_Format", function () {
        return _t;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_5x4_Format", function () {
        return Mt;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_5x5_Format", function () {
        return St;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_6x5_Format", function () {
        return Tt;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_6x6_Format", function () {
        return Et;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_8x5_Format", function () {
        return At;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_8x6_Format", function () {
        return Ct;
      }),
      n.d(t, "SRGB8_ALPHA8_ASTC_8x8_Format", function () {
        return Pt;
      }),
      n.d(t, "Scene", function () {
        return Al;
      }),
      n.d(t, "SceneUtils", function () {
        return Cf;
      }),
      n.d(t, "ShaderChunk", function () {
        return Ho;
      }),
      n.d(t, "ShaderLib", function () {
        return Vo;
      }),
      n.d(t, "ShaderMaterial", function () {
        return To;
      }),
      n.d(t, "ShadowMaterial", function () {
        return nh;
      }),
      n.d(t, "Shape", function () {
        return Hh;
      }),
      n.d(t, "ShapeBufferGeometry", function () {
        return qu;
      }),
      n.d(t, "ShapeGeometry", function () {
        return qu;
      }),
      n.d(t, "ShapePath", function () {
        return gd;
      }),
      n.d(t, "ShapeUtils", function () {
        return Bu;
      }),
      n.d(t, "ShortType", function () {
        return Ee;
      }),
      n.d(t, "Skeleton", function () {
        return ac;
      }),
      n.d(t, "SkeletonHelper", function () {
        return bp;
      }),
      n.d(t, "SkinnedMesh", function () {
        return tc;
      }),
      n.d(t, "SmoothShading", function () {
        return y;
      }),
      n.d(t, "Sphere", function () {
        return Pr;
      }),
      n.d(t, "SphereBufferGeometry", function () {
        return $u;
      }),
      n.d(t, "SphereGeometry", function () {
        return $u;
      }),
      n.d(t, "Spherical", function () {
        return sp;
      }),
      n.d(t, "SphericalHarmonics3", function () {
        return od;
      }),
      n.d(t, "SplineCurve", function () {
        return cu;
      }),
      n.d(t, "SpotLight", function () {
        return Yh;
      }),
      n.d(t, "SpotLightHelper", function () {
        return gp;
      }),
      n.d(t, "Sprite", function () {
        return Wl;
      }),
      n.d(t, "SpriteMaterial", function () {
        return Rl;
      }),
      n.d(t, "SrcAlphaFactor", function () {
        return D;
      }),
      n.d(t, "SrcAlphaSaturateFactor", function () {
        return z;
      }),
      n.d(t, "SrcColorFactor", function () {
        return I;
      }),
      n.d(t, "StaticCopyUsage", function () {
        return Rn;
      }),
      n.d(t, "StaticDrawUsage", function () {
        return Tn;
      }),
      n.d(t, "StaticReadUsage", function () {
        return Cn;
      }),
      n.d(t, "StereoCamera", function () {
        return Ad;
      }),
      n.d(t, "StreamCopyUsage", function () {
        return kn;
      }),
      n.d(t, "StreamDrawUsage", function () {
        return An;
      }),
      n.d(t, "StreamReadUsage", function () {
        return Ln;
      }),
      n.d(t, "StringKeyframeTrack", function () {
        return Mh;
      }),
      n.d(t, "SubtractEquation", function () {
        return E;
      }),
      n.d(t, "SubtractiveBlending", function () {
        return _;
      }),
      n.d(t, "TOUCH", function () {
        return o;
      }),
      n.d(t, "TangentSpaceNormalMap", function () {
        return sn;
      }),
      n.d(t, "TetrahedronBufferGeometry", function () {
        return Xu;
      }),
      n.d(t, "TetrahedronGeometry", function () {
        return Xu;
      }),
      n.d(t, "TextBufferGeometry", function () {
        return Yu;
      }),
      n.d(t, "TextGeometry", function () {
        return Yu;
      }),
      n.d(t, "Texture", function () {
        return er;
      }),
      n.d(t, "TextureLoader", function () {
        return Nh;
      }),
      n.d(t, "TorusBufferGeometry", function () {
        return Ju;
      }),
      n.d(t, "TorusGeometry", function () {
        return Ju;
      }),
      n.d(t, "TorusKnotBufferGeometry", function () {
        return Zu;
      }),
      n.d(t, "TorusKnotGeometry", function () {
        return Zu;
      }),
      n.d(t, "Triangle", function () {
        return bi;
      }),
      n.d(t, "TriangleFanDrawMode", function () {
        return Yt;
      }),
      n.d(t, "TriangleStripDrawMode", function () {
        return Xt;
      }),
      n.d(t, "TrianglesDrawMode", function () {
        return $t;
      }),
      n.d(t, "TubeBufferGeometry", function () {
        return Ku;
      }),
      n.d(t, "TubeGeometry", function () {
        return Ku;
      }),
      n.d(t, "UVMapping", function () {
        return ie;
      }),
      n.d(t, "Uint16Attribute", function () {
        return ff;
      }),
      n.d(t, "Uint16BufferAttribute", function () {
        return Ni;
      }),
      n.d(t, "Uint32Attribute", function () {
        return gf;
      }),
      n.d(t, "Uint32BufferAttribute", function () {
        return zi;
      }),
      n.d(t, "Uint8Attribute", function () {
        return hf;
      }),
      n.d(t, "Uint8BufferAttribute", function () {
        return Oi;
      }),
      n.d(t, "Uint8ClampedAttribute", function () {
        return df;
      }),
      n.d(t, "Uint8ClampedBufferAttribute", function () {
        return Bi;
      }),
      n.d(t, "Uniform", function () {
        return tp;
      }),
      n.d(t, "UniformsLib", function () {
        return Go;
      }),
      n.d(t, "UniformsUtils", function () {
        return So;
      }),
      n.d(t, "UnsignedByteType", function () {
        return Se;
      }),
      n.d(t, "UnsignedInt248Type", function () {
        return Oe;
      }),
      n.d(t, "UnsignedIntType", function () {
        return Pe;
      }),
      n.d(t, "UnsignedShort4444Type", function () {
        return Ie;
      }),
      n.d(t, "UnsignedShort5551Type", function () {
        return ke;
      }),
      n.d(t, "UnsignedShort565Type", function () {
        return De;
      }),
      n.d(t, "UnsignedShortType", function () {
        return Ae;
      }),
      n.d(t, "VSMShadowMap", function () {
        return p;
      }),
      n.d(t, "Vector2", function () {
        return Yn;
      }),
      n.d(t, "Vector3", function () {
        return sr;
      }),
      n.d(t, "Vector4", function () {
        return nr;
      }),
      n.d(t, "VectorKeyframeTrack", function () {
        return Sh;
      }),
      n.d(t, "Vertex", function () {
        return lf;
      }),
      n.d(t, "VertexColors", function () {
        return Kp;
      }),
      n.d(t, "VideoTexture", function () {
        return Rc;
      }),
      n.d(t, "WebGL1Renderer", function () {
        return Sl;
      }),
      n.d(t, "WebGLCubeRenderTarget", function () {
        return Lo;
      }),
      n.d(t, "WebGLMultipleRenderTargets", function () {
        return ir;
      }),
      n.d(t, "WebGLMultisampleRenderTarget", function () {
        return or;
      }),
      n.d(t, "WebGLRenderTarget", function () {
        return rr;
      }),
      n.d(t, "WebGLRenderTargetCube", function () {
        return Tf;
      }),
      n.d(t, "WebGLRenderer", function () {
        return Ml;
      }),
      n.d(t, "WebGLUtils", function () {
        return gl;
      }),
      n.d(t, "WireframeGeometry", function () {
        return Qu;
      }),
      n.d(t, "WireframeHelper", function () {
        return _f;
      }),
      n.d(t, "WrapAroundEnding", function () {
        return jt;
      }),
      n.d(t, "XHRLoader", function () {
        return Mf;
      }),
      n.d(t, "ZeroCurvatureEnding", function () {
        return Gt;
      }),
      n.d(t, "ZeroFactor", function () {
        return L;
      }),
      n.d(t, "ZeroSlopeEnding", function () {
        return Vt;
      }),
      n.d(t, "ZeroStencilOp", function () {
        return cn;
      }),
      n.d(t, "sRGBEncoding", function () {
        return Zt;
      });
    /**
     * @license
     * Copyright 2010-2021 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    const r = "132",
      i = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
      },
      o = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3,
      },
      a = 0,
      s = 1,
      l = 2,
      c = 3,
      u = 0,
      h = 1,
      d = 2,
      p = 3,
      f = 0,
      m = 1,
      g = 2,
      v = 1,
      y = 2,
      x = 0,
      b = 1,
      w = 2,
      _ = 3,
      M = 4,
      S = 5,
      T = 100,
      E = 101,
      A = 102,
      C = 103,
      P = 104,
      L = 200,
      R = 201,
      I = 202,
      k = 203,
      D = 204,
      O = 205,
      B = 206,
      F = 207,
      N = 208,
      U = 209,
      z = 210,
      H = 0,
      G = 1,
      V = 2,
      j = 3,
      W = 4,
      q = 5,
      $ = 6,
      X = 7,
      Y = 0,
      J = 1,
      Z = 2,
      K = 0,
      Q = 1,
      ee = 2,
      te = 3,
      ne = 4,
      re = 5,
      ie = 300,
      oe = 301,
      ae = 302,
      se = 303,
      le = 304,
      ce = 306,
      ue = 307,
      he = 1e3,
      de = 1001,
      pe = 1002,
      fe = 1003,
      me = 1004,
      ge = 1004,
      ve = 1005,
      ye = 1005,
      xe = 1006,
      be = 1007,
      we = 1007,
      _e = 1008,
      Me = 1008,
      Se = 1009,
      Te = 1010,
      Ee = 1011,
      Ae = 1012,
      Ce = 1013,
      Pe = 1014,
      Le = 1015,
      Re = 1016,
      Ie = 1017,
      ke = 1018,
      De = 1019,
      Oe = 1020,
      Be = 1021,
      Fe = 1022,
      Ne = 1023,
      Ue = 1024,
      ze = 1025,
      He = Ne,
      Ge = 1026,
      Ve = 1027,
      je = 1028,
      We = 1029,
      qe = 1030,
      $e = 1031,
      Xe = 1032,
      Ye = 1033,
      Je = 33776,
      Ze = 33777,
      Ke = 33778,
      Qe = 33779,
      et = 35840,
      tt = 35841,
      nt = 35842,
      rt = 35843,
      it = 36196,
      ot = 37492,
      at = 37496,
      st = 37808,
      lt = 37809,
      ct = 37810,
      ut = 37811,
      ht = 37812,
      dt = 37813,
      pt = 37814,
      ft = 37815,
      mt = 37816,
      gt = 37817,
      vt = 37818,
      yt = 37819,
      xt = 37820,
      bt = 37821,
      wt = 36492,
      _t = 37840,
      Mt = 37841,
      St = 37842,
      Tt = 37843,
      Et = 37844,
      At = 37845,
      Ct = 37846,
      Pt = 37847,
      Lt = 37848,
      Rt = 37849,
      It = 37850,
      kt = 37851,
      Dt = 37852,
      Ot = 37853,
      Bt = 2200,
      Ft = 2201,
      Nt = 2202,
      Ut = 2300,
      zt = 2301,
      Ht = 2302,
      Gt = 2400,
      Vt = 2401,
      jt = 2402,
      Wt = 2500,
      qt = 2501,
      $t = 0,
      Xt = 1,
      Yt = 2,
      Jt = 3e3,
      Zt = 3001,
      Kt = 3007,
      Qt = 3002,
      en = 3003,
      tn = 3004,
      nn = 3005,
      rn = 3006,
      on = 3200,
      an = 3201,
      sn = 0,
      ln = 1,
      cn = 0,
      un = 7680,
      hn = 7681,
      dn = 7682,
      pn = 7683,
      fn = 34055,
      mn = 34056,
      gn = 5386,
      vn = 512,
      yn = 513,
      xn = 514,
      bn = 515,
      wn = 516,
      _n = 517,
      Mn = 518,
      Sn = 519,
      Tn = 35044,
      En = 35048,
      An = 35040,
      Cn = 35045,
      Pn = 35049,
      Ln = 35041,
      Rn = 35046,
      In = 35050,
      kn = 35042,
      Dn = "100",
      On = "300 es";
    class Bn {
      addEventListener(e, t) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t);
      }
      hasEventListener(e, t) {
        if (void 0 === this._listeners) return !1;
        const n = this._listeners;
        return void 0 !== n[e] && -1 !== n[e].indexOf(t);
      }
      removeEventListener(e, t) {
        if (void 0 === this._listeners) return;
        const n = this._listeners[e];
        if (void 0 !== n) {
          const e = n.indexOf(t);
          -1 !== e && n.splice(e, 1);
        }
      }
      dispatchEvent(e) {
        if (void 0 === this._listeners) return;
        const t = this._listeners[e.type];
        if (void 0 !== t) {
          e.target = this;
          const n = t.slice(0);
          for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
          e.target = null;
        }
      }
    }
    const Fn = [];
    for (let e = 0; e < 256; e++) Fn[e] = (e < 16 ? "0" : "") + e.toString(16);
    let Nn = 1234567;
    const Un = Math.PI / 180,
      zn = 180 / Math.PI;

    function Hn() {
      const e = (4294967295 * Math.random()) | 0,
        t = (4294967295 * Math.random()) | 0,
        n = (4294967295 * Math.random()) | 0,
        r = (4294967295 * Math.random()) | 0;
      return (
        Fn[255 & e] +
        Fn[(e >> 8) & 255] +
        Fn[(e >> 16) & 255] +
        Fn[(e >> 24) & 255] +
        "-" +
        Fn[255 & t] +
        Fn[(t >> 8) & 255] +
        "-" +
        Fn[((t >> 16) & 15) | 64] +
        Fn[(t >> 24) & 255] +
        "-" +
        Fn[(63 & n) | 128] +
        Fn[(n >> 8) & 255] +
        "-" +
        Fn[(n >> 16) & 255] +
        Fn[(n >> 24) & 255] +
        Fn[255 & r] +
        Fn[(r >> 8) & 255] +
        Fn[(r >> 16) & 255] +
        Fn[(r >> 24) & 255]
      ).toUpperCase();
    }

    function Gn(e, t, n) {
      return Math.max(t, Math.min(n, e));
    }

    function Vn(e, t) {
      return ((e % t) + t) % t;
    }

    function jn(e, t, n) {
      return (1 - n) * e + n * t;
    }

    function Wn(e) {
      return 0 == (e & (e - 1)) && 0 !== e;
    }

    function qn(e) {
      return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
    }

    function $n(e) {
      return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
    }
    var Xn = Object.freeze({
      __proto__: null,
      DEG2RAD: Un,
      RAD2DEG: zn,
      generateUUID: Hn,
      clamp: Gn,
      euclideanModulo: Vn,
      mapLinear: function (e, t, n, r, i) {
        return r + ((e - t) * (i - r)) / (n - t);
      },
      inverseLerp: function (e, t, n) {
        return e !== t ? (n - e) / (t - e) : 0;
      },
      lerp: jn,
      damp: function (e, t, n, r) {
        return jn(e, t, 1 - Math.exp(-n * r));
      },
      pingpong: function (e, t = 1) {
        return t - Math.abs(Vn(e, 2 * t) - t);
      },
      smoothstep: function (e, t, n) {
        return e <= t
          ? 0
          : e >= n
          ? 1
          : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
      },
      smootherstep: function (e, t, n) {
        return e <= t
          ? 0
          : e >= n
          ? 1
          : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
      },
      randInt: function (e, t) {
        return e + Math.floor(Math.random() * (t - e + 1));
      },
      randFloat: function (e, t) {
        return e + Math.random() * (t - e);
      },
      randFloatSpread: function (e) {
        return e * (0.5 - Math.random());
      },
      seededRandom: function (e) {
        return (
          void 0 !== e && (Nn = e % 2147483647),
          (Nn = (16807 * Nn) % 2147483647),
          (Nn - 1) / 2147483646
        );
      },
      degToRad: function (e) {
        return e * Un;
      },
      radToDeg: function (e) {
        return e * zn;
      },
      isPowerOfTwo: Wn,
      ceilPowerOfTwo: qn,
      floorPowerOfTwo: $n,
      setQuaternionFromProperEuler: function (e, t, n, r, i) {
        const o = Math.cos,
          a = Math.sin,
          s = o(n / 2),
          l = a(n / 2),
          c = o((t + r) / 2),
          u = a((t + r) / 2),
          h = o((t - r) / 2),
          d = a((t - r) / 2),
          p = o((r - t) / 2),
          f = a((r - t) / 2);
        switch (i) {
          case "XYX":
            e.set(s * u, l * h, l * d, s * c);
            break;
          case "YZY":
            e.set(l * d, s * u, l * h, s * c);
            break;
          case "ZXZ":
            e.set(l * h, l * d, s * u, s * c);
            break;
          case "XZX":
            e.set(s * u, l * f, l * p, s * c);
            break;
          case "YXY":
            e.set(l * p, s * u, l * f, s * c);
            break;
          case "ZYZ":
            e.set(l * f, l * p, s * u, s * c);
            break;
          default:
            console.warn(
              "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                i
            );
        }
      },
    });
    class Yn {
      constructor(e = 0, t = 0) {
        (this.x = e), (this.y = t);
      }
      get width() {
        return this.x;
      }
      set width(e) {
        this.x = e;
      }
      get height() {
        return this.y;
      }
      set height(e) {
        this.y = e;
      }
      set(e, t) {
        return (this.x = e), (this.y = t), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), this;
      }
      add(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(e, t))
          : ((this.x += e.x), (this.y += e.y), this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), this;
      }
      addVectors(e, t) {
        return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
      }
      addScaledVector(e, t) {
        return (this.x += e.x * t), (this.y += e.y * t), this;
      }
      sub(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(e, t))
          : ((this.x -= e.x), (this.y -= e.y), this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), this;
      }
      subVectors(e, t) {
        return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
      }
      multiply(e) {
        return (this.x *= e.x), (this.y *= e.y), this;
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), this;
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      applyMatrix3(e) {
        const t = this.x,
          n = this.y,
          r = e.elements;
        return (
          (this.x = r[0] * t + r[3] * n + r[6]),
          (this.y = r[1] * t + r[4] * n + r[7]),
          this
        );
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          this
        );
      }
      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(e, Math.min(t, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
      }
      ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      }
      round() {
        return (
          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y;
      }
      cross(e) {
        return this.x * e.y - this.y * e.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x,
          n = this.y - e.y;
        return t * t + n * n;
      }
      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
        );
      }
      lerpVectors(e, t, n) {
        return (
          (this.x = e.x + (t.x - e.x) * n),
          (this.y = e.y + (t.y - e.y) * n),
          this
        );
      }
      equals(e) {
        return e.x === this.x && e.y === this.y;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), e;
      }
      fromBufferAttribute(e, t, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          this
        );
      }
      rotateAround(e, t) {
        const n = Math.cos(t),
          r = Math.sin(t),
          i = this.x - e.x,
          o = this.y - e.y;
        return (
          (this.x = i * n - o * r + e.x), (this.y = i * r + o * n + e.y), this
        );
      }
      random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
      }
    }
    Yn.prototype.isVector2 = !0;
    class Jn {
      constructor() {
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
            );
      }
      set(e, t, n, r, i, o, a, s, l) {
        const c = this.elements;
        return (
          (c[0] = e),
          (c[1] = r),
          (c[2] = a),
          (c[3] = t),
          (c[4] = i),
          (c[5] = s),
          (c[6] = n),
          (c[7] = o),
          (c[8] = l),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(e) {
        const t = this.elements,
          n = e.elements;
        return (
          (t[0] = n[0]),
          (t[1] = n[1]),
          (t[2] = n[2]),
          (t[3] = n[3]),
          (t[4] = n[4]),
          (t[5] = n[5]),
          (t[6] = n[6]),
          (t[7] = n[7]),
          (t[8] = n[8]),
          this
        );
      }
      extractBasis(e, t, n) {
        return (
          e.setFromMatrix3Column(this, 0),
          t.setFromMatrix3Column(this, 1),
          n.setFromMatrix3Column(this, 2),
          this
        );
      }
      setFromMatrix4(e) {
        const t = e.elements;
        return (
          this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        );
      }
      multiply(e) {
        return this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const n = e.elements,
          r = t.elements,
          i = this.elements,
          o = n[0],
          a = n[3],
          s = n[6],
          l = n[1],
          c = n[4],
          u = n[7],
          h = n[2],
          d = n[5],
          p = n[8],
          f = r[0],
          m = r[3],
          g = r[6],
          v = r[1],
          y = r[4],
          x = r[7],
          b = r[2],
          w = r[5],
          _ = r[8];
        return (
          (i[0] = o * f + a * v + s * b),
          (i[3] = o * m + a * y + s * w),
          (i[6] = o * g + a * x + s * _),
          (i[1] = l * f + c * v + u * b),
          (i[4] = l * m + c * y + u * w),
          (i[7] = l * g + c * x + u * _),
          (i[2] = h * f + d * v + p * b),
          (i[5] = h * m + d * y + p * w),
          (i[8] = h * g + d * x + p * _),
          this
        );
      }
      multiplyScalar(e) {
        const t = this.elements;
        return (
          (t[0] *= e),
          (t[3] *= e),
          (t[6] *= e),
          (t[1] *= e),
          (t[4] *= e),
          (t[7] *= e),
          (t[2] *= e),
          (t[5] *= e),
          (t[8] *= e),
          this
        );
      }
      determinant() {
        const e = this.elements,
          t = e[0],
          n = e[1],
          r = e[2],
          i = e[3],
          o = e[4],
          a = e[5],
          s = e[6],
          l = e[7],
          c = e[8];
        return (
          t * o * c - t * a * l - n * i * c + n * a * s + r * i * l - r * o * s
        );
      }
      invert() {
        const e = this.elements,
          t = e[0],
          n = e[1],
          r = e[2],
          i = e[3],
          o = e[4],
          a = e[5],
          s = e[6],
          l = e[7],
          c = e[8],
          u = c * o - a * l,
          h = a * s - c * i,
          d = l * i - o * s,
          p = t * u + n * h + r * d;
        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const f = 1 / p;
        return (
          (e[0] = u * f),
          (e[1] = (r * l - c * n) * f),
          (e[2] = (a * n - r * o) * f),
          (e[3] = h * f),
          (e[4] = (c * t - r * s) * f),
          (e[5] = (r * i - a * t) * f),
          (e[6] = d * f),
          (e[7] = (n * s - l * t) * f),
          (e[8] = (o * t - n * i) * f),
          this
        );
      }
      transpose() {
        let e;
        const t = this.elements;
        return (
          (e = t[1]),
          (t[1] = t[3]),
          (t[3] = e),
          (e = t[2]),
          (t[2] = t[6]),
          (t[6] = e),
          (e = t[5]),
          (t[5] = t[7]),
          (t[7] = e),
          this
        );
      }
      getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
      }
      transposeIntoArray(e) {
        const t = this.elements;
        return (
          (e[0] = t[0]),
          (e[1] = t[3]),
          (e[2] = t[6]),
          (e[3] = t[1]),
          (e[4] = t[4]),
          (e[5] = t[7]),
          (e[6] = t[2]),
          (e[7] = t[5]),
          (e[8] = t[8]),
          this
        );
      }
      setUvTransform(e, t, n, r, i, o, a) {
        const s = Math.cos(i),
          l = Math.sin(i);
        return (
          this.set(
            n * s,
            n * l,
            -n * (s * o + l * a) + o + e,
            -r * l,
            r * s,
            -r * (-l * o + s * a) + a + t,
            0,
            0,
            1
          ),
          this
        );
      }
      scale(e, t) {
        const n = this.elements;
        return (
          (n[0] *= e),
          (n[3] *= e),
          (n[6] *= e),
          (n[1] *= t),
          (n[4] *= t),
          (n[7] *= t),
          this
        );
      }
      rotate(e) {
        const t = Math.cos(e),
          n = Math.sin(e),
          r = this.elements,
          i = r[0],
          o = r[3],
          a = r[6],
          s = r[1],
          l = r[4],
          c = r[7];
        return (
          (r[0] = t * i + n * s),
          (r[3] = t * o + n * l),
          (r[6] = t * a + n * c),
          (r[1] = -n * i + t * s),
          (r[4] = -n * o + t * l),
          (r[7] = -n * a + t * c),
          this
        );
      }
      translate(e, t) {
        const n = this.elements;
        return (
          (n[0] += e * n[2]),
          (n[3] += e * n[5]),
          (n[6] += e * n[8]),
          (n[1] += t * n[2]),
          (n[4] += t * n[5]),
          (n[7] += t * n[8]),
          this
        );
      }
      equals(e) {
        const t = this.elements,
          n = e.elements;
        for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const n = this.elements;
        return (
          (e[t] = n[0]),
          (e[t + 1] = n[1]),
          (e[t + 2] = n[2]),
          (e[t + 3] = n[3]),
          (e[t + 4] = n[4]),
          (e[t + 5] = n[5]),
          (e[t + 6] = n[6]),
          (e[t + 7] = n[7]),
          (e[t + 8] = n[8]),
          e
        );
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    }
    let Zn;
    Jn.prototype.isMatrix3 = !0;
    class Kn {
      static getDataURL(e) {
        if (/^data:/i.test(e.src)) return e.src;
        if ("undefined" == typeof HTMLCanvasElement) return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
          void 0 === Zn &&
            (Zn = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "canvas"
            )),
            (Zn.width = e.width),
            (Zn.height = e.height);
          const n = Zn.getContext("2d");
          e instanceof ImageData
            ? n.putImageData(e, 0, 0)
            : n.drawImage(e, 0, 0, e.width, e.height),
            (t = Zn);
        }
        return t.width > 2048 || t.height > 2048
          ? (console.warn(
              "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
              e
            ),
            t.toDataURL("image/jpeg", 0.6))
          : t.toDataURL("image/png");
      }
    }
    let Qn = 0;
    class er extends Bn {
      constructor(
        e = er.DEFAULT_IMAGE,
        t = er.DEFAULT_MAPPING,
        n = de,
        r = de,
        i = xe,
        o = _e,
        a = Ne,
        s = Se,
        l = 1,
        c = Jt
      ) {
        super(),
          Object.defineProperty(this, "id", {
            value: Qn++,
          }),
          (this.uuid = Hn()),
          (this.name = ""),
          (this.image = e),
          (this.mipmaps = []),
          (this.mapping = t),
          (this.wrapS = n),
          (this.wrapT = r),
          (this.magFilter = i),
          (this.minFilter = o),
          (this.anisotropy = l),
          (this.format = a),
          (this.internalFormat = null),
          (this.type = s),
          (this.offset = new Yn(0, 0)),
          (this.repeat = new Yn(1, 1)),
          (this.center = new Yn(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new Jn()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          (this.encoding = c),
          (this.version = 0),
          (this.onUpdate = null),
          (this.isRenderTargetTexture = !1);
      }
      updateMatrix() {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.image = e.image),
          (this.mipmaps = e.mipmaps.slice(0)),
          (this.mapping = e.mapping),
          (this.wrapS = e.wrapS),
          (this.wrapT = e.wrapT),
          (this.magFilter = e.magFilter),
          (this.minFilter = e.minFilter),
          (this.anisotropy = e.anisotropy),
          (this.format = e.format),
          (this.internalFormat = e.internalFormat),
          (this.type = e.type),
          this.offset.copy(e.offset),
          this.repeat.copy(e.repeat),
          this.center.copy(e.center),
          (this.rotation = e.rotation),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this.matrix.copy(e.matrix),
          (this.generateMipmaps = e.generateMipmaps),
          (this.premultiplyAlpha = e.premultiplyAlpha),
          (this.flipY = e.flipY),
          (this.unpackAlignment = e.unpackAlignment),
          (this.encoding = e.encoding),
          this
        );
      }
      toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.textures[this.uuid])
          return e.textures[this.uuid];
        const n = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON",
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment,
        };
        if (void 0 !== this.image) {
          const r = this.image;
          if (
            (void 0 === r.uuid && (r.uuid = Hn()),
            !t && void 0 === e.images[r.uuid])
          ) {
            let t;
            if (Array.isArray(r)) {
              t = [];
              for (let e = 0, n = r.length; e < n; e++)
                r[e].isDataTexture ? t.push(tr(r[e].image)) : t.push(tr(r[e]));
            } else t = tr(r);
            e.images[r.uuid] = {
              uuid: r.uuid,
              url: t,
            };
          }
          n.image = r.uuid;
        }
        return t || (e.textures[this.uuid] = n), n;
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose",
        });
      }
      transformUv(e) {
        if (this.mapping !== ie) return e;
        if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
          switch (this.wrapS) {
            case he:
              e.x = e.x - Math.floor(e.x);
              break;
            case de:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case pe:
              1 === Math.abs(Math.floor(e.x) % 2)
                ? (e.x = Math.ceil(e.x) - e.x)
                : (e.x = e.x - Math.floor(e.x));
          }
        if (e.y < 0 || e.y > 1)
          switch (this.wrapT) {
            case he:
              e.y = e.y - Math.floor(e.y);
              break;
            case de:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case pe:
              1 === Math.abs(Math.floor(e.y) % 2)
                ? (e.y = Math.ceil(e.y) - e.y)
                : (e.y = e.y - Math.floor(e.y));
          }
        return this.flipY && (e.y = 1 - e.y), e;
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
    }

    function tr(e) {
      return ("undefined" != typeof HTMLImageElement &&
        e instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          e instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
        ? Kn.getDataURL(e)
        : e.data
        ? {
            data: Array.prototype.slice.call(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name,
          }
        : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    (er.DEFAULT_IMAGE = void 0),
      (er.DEFAULT_MAPPING = ie),
      (er.prototype.isTexture = !0);
    class nr {
      constructor(e = 0, t = 0, n = 0, r = 1) {
        (this.x = e), (this.y = t), (this.z = n), (this.w = r);
      }
      get width() {
        return this.z;
      }
      set width(e) {
        this.z = e;
      }
      get height() {
        return this.w;
      }
      set height(e) {
        this.w = e;
      }
      set(e, t, n, r) {
        return (this.x = e), (this.y = t), (this.z = n), (this.w = r), this;
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setW(e) {
        return (this.w = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          case 3:
            this.w = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(e) {
        return (
          (this.x = e.x),
          (this.y = e.y),
          (this.z = e.z),
          (this.w = void 0 !== e.w ? e.w : 1),
          this
        );
      }
      add(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(e, t))
          : ((this.x += e.x),
            (this.y += e.y),
            (this.z += e.z),
            (this.w += e.w),
            this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
      }
      addVectors(e, t) {
        return (
          (this.x = e.x + t.x),
          (this.y = e.y + t.y),
          (this.z = e.z + t.z),
          (this.w = e.w + t.w),
          this
        );
      }
      addScaledVector(e, t) {
        return (
          (this.x += e.x * t),
          (this.y += e.y * t),
          (this.z += e.z * t),
          (this.w += e.w * t),
          this
        );
      }
      sub(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(e, t))
          : ((this.x -= e.x),
            (this.y -= e.y),
            (this.z -= e.z),
            (this.w -= e.w),
            this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
      }
      subVectors(e, t) {
        return (
          (this.x = e.x - t.x),
          (this.y = e.y - t.y),
          (this.z = e.z - t.z),
          (this.w = e.w - t.w),
          this
        );
      }
      multiply(e) {
        return (
          (this.x *= e.x),
          (this.y *= e.y),
          (this.z *= e.z),
          (this.w *= e.w),
          this
        );
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
      }
      applyMatrix4(e) {
        const t = this.x,
          n = this.y,
          r = this.z,
          i = this.w,
          o = e.elements;
        return (
          (this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * i),
          (this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * i),
          (this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * i),
          (this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * i),
          this
        );
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return (
          t < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
          this
        );
      }
      setAxisAngleFromRotationMatrix(e) {
        let t, n, r, i;
        const o = e.elements,
          a = o[0],
          s = o[4],
          l = o[8],
          c = o[1],
          u = o[5],
          h = o[9],
          d = o[2],
          p = o[6],
          f = o[10];
        if (
          Math.abs(s - c) < 0.01 &&
          Math.abs(l - d) < 0.01 &&
          Math.abs(h - p) < 0.01
        ) {
          if (
            Math.abs(s + c) < 0.1 &&
            Math.abs(l + d) < 0.1 &&
            Math.abs(h + p) < 0.1 &&
            Math.abs(a + u + f - 3) < 0.1
          )
            return this.set(1, 0, 0, 0), this;
          t = Math.PI;
          const e = (a + 1) / 2,
            o = (u + 1) / 2,
            m = (f + 1) / 2,
            g = (s + c) / 4,
            v = (l + d) / 4,
            y = (h + p) / 4;
          return (
            e > o && e > m
              ? e < 0.01
                ? ((n = 0), (r = 0.707106781), (i = 0.707106781))
                : ((n = Math.sqrt(e)), (r = g / n), (i = v / n))
              : o > m
              ? o < 0.01
                ? ((n = 0.707106781), (r = 0), (i = 0.707106781))
                : ((r = Math.sqrt(o)), (n = g / r), (i = y / r))
              : m < 0.01
              ? ((n = 0.707106781), (r = 0.707106781), (i = 0))
              : ((i = Math.sqrt(m)), (n = v / i), (r = y / i)),
            this.set(n, r, i, t),
            this
          );
        }
        let m = Math.sqrt(
          (p - h) * (p - h) + (l - d) * (l - d) + (c - s) * (c - s)
        );
        return (
          Math.abs(m) < 0.001 && (m = 1),
          (this.x = (p - h) / m),
          (this.y = (l - d) / m),
          (this.z = (c - s) / m),
          (this.w = Math.acos((a + u + f - 1) / 2)),
          this
        );
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          (this.z = Math.min(this.z, e.z)),
          (this.w = Math.min(this.w, e.w)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          (this.z = Math.max(this.z, e.z)),
          (this.w = Math.max(this.w, e.w)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          (this.w = Math.max(e.w, Math.min(t.w, this.w))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          (this.w = Math.max(e, Math.min(t, this.w))),
          this
        );
      }
      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(e, Math.min(t, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      }
      negate() {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
      }
      lengthSq() {
        return (
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      length() {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      manhattanLength() {
        return (
          Math.abs(this.x) +
          Math.abs(this.y) +
          Math.abs(this.z) +
          Math.abs(this.w)
        );
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t),
          (this.y += (e.y - this.y) * t),
          (this.z += (e.z - this.z) * t),
          (this.w += (e.w - this.w) * t),
          this
        );
      }
      lerpVectors(e, t, n) {
        return (
          (this.x = e.x + (t.x - e.x) * n),
          (this.y = e.y + (t.y - e.y) * n),
          (this.z = e.z + (t.z - e.z) * n),
          (this.w = e.w + (t.w - e.w) * n),
          this
        );
      }
      equals(e) {
        return (
          e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        );
      }
      fromArray(e, t = 0) {
        return (
          (this.x = e[t]),
          (this.y = e[t + 1]),
          (this.z = e[t + 2]),
          (this.w = e[t + 3]),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this.x),
          (e[t + 1] = this.y),
          (e[t + 2] = this.z),
          (e[t + 3] = this.w),
          e
        );
      }
      fromBufferAttribute(e, t, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          (this.z = e.getZ(t)),
          (this.w = e.getW(t)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          (this.w = Math.random()),
          this
        );
      }
    }
    nr.prototype.isVector4 = !0;
    class rr extends Bn {
      constructor(e, t, n = {}) {
        super(),
          (this.width = e),
          (this.height = t),
          (this.depth = 1),
          (this.scissor = new nr(0, 0, e, t)),
          (this.scissorTest = !1),
          (this.viewport = new nr(0, 0, e, t)),
          (this.texture = new er(
            void 0,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.encoding
          )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.image = {
            width: e,
            height: t,
            depth: 1,
          }),
          (this.texture.generateMipmaps =
            void 0 !== n.generateMipmaps && n.generateMipmaps),
          (this.texture.internalFormat =
            void 0 !== n.internalFormat ? n.internalFormat : null),
          (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : xe),
          (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
          (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
          (this.depthTexture =
            void 0 !== n.depthTexture ? n.depthTexture : null);
      }
      setTexture(e) {
        (e.image = {
          width: this.width,
          height: this.height,
          depth: this.depth,
        }),
          (this.texture = e);
      }
      setSize(e, t, n = 1) {
        (this.width === e && this.height === t && this.depth === n) ||
          ((this.width = e),
          (this.height = t),
          (this.depth = n),
          (this.texture.image.width = e),
          (this.texture.image.height = t),
          (this.texture.image.depth = n),
          this.dispose()),
          this.viewport.set(0, 0, e, t),
          this.scissor.set(0, 0, e, t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (
          (this.width = e.width),
          (this.height = e.height),
          (this.depth = e.depth),
          this.viewport.copy(e.viewport),
          (this.texture = e.texture.clone()),
          (this.texture.image = {
            ...this.texture.image,
          }),
          (this.depthBuffer = e.depthBuffer),
          (this.stencilBuffer = e.stencilBuffer),
          (this.depthTexture = e.depthTexture),
          this
        );
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose",
        });
      }
    }
    rr.prototype.isWebGLRenderTarget = !0;
    class ir extends rr {
      constructor(e, t, n) {
        super(e, t);
        const r = this.texture;
        this.texture = [];
        for (let e = 0; e < n; e++) this.texture[e] = r.clone();
      }
      setSize(e, t, n = 1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
          (this.width = e), (this.height = t), (this.depth = n);
          for (let r = 0, i = this.texture.length; r < i; r++)
            (this.texture[r].image.width = e),
              (this.texture[r].image.height = t),
              (this.texture[r].image.depth = n);
          this.dispose();
        }
        return (
          this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
        );
      }
      copy(e) {
        this.dispose(),
          (this.width = e.width),
          (this.height = e.height),
          (this.depth = e.depth),
          this.viewport.set(0, 0, this.width, this.height),
          this.scissor.set(0, 0, this.width, this.height),
          (this.depthBuffer = e.depthBuffer),
          (this.stencilBuffer = e.stencilBuffer),
          (this.depthTexture = e.depthTexture),
          (this.texture.length = 0);
        for (let t = 0, n = e.texture.length; t < n; t++)
          this.texture[t] = e.texture[t].clone();
        return this;
      }
    }
    ir.prototype.isWebGLMultipleRenderTargets = !0;
    class or extends rr {
      constructor(e, t, n) {
        super(e, t, n), (this.samples = 4);
      }
      copy(e) {
        return super.copy.call(this, e), (this.samples = e.samples), this;
      }
    }
    or.prototype.isWebGLMultisampleRenderTarget = !0;
    class ar {
      constructor(e = 0, t = 0, n = 0, r = 1) {
        (this._x = e), (this._y = t), (this._z = n), (this._w = r);
      }
      static slerp(e, t, n, r) {
        return (
          console.warn(
            "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
          ),
          n.slerpQuaternions(e, t, r)
        );
      }
      static slerpFlat(e, t, n, r, i, o, a) {
        let s = n[r + 0],
          l = n[r + 1],
          c = n[r + 2],
          u = n[r + 3];
        const h = i[o + 0],
          d = i[o + 1],
          p = i[o + 2],
          f = i[o + 3];
        if (0 === a)
          return (
            (e[t + 0] = s), (e[t + 1] = l), (e[t + 2] = c), void (e[t + 3] = u)
          );
        if (1 === a)
          return (
            (e[t + 0] = h), (e[t + 1] = d), (e[t + 2] = p), void (e[t + 3] = f)
          );
        if (u !== f || s !== h || l !== d || c !== p) {
          let e = 1 - a;
          const t = s * h + l * d + c * p + u * f,
            n = t >= 0 ? 1 : -1,
            r = 1 - t * t;
          if (r > Number.EPSILON) {
            const i = Math.sqrt(r),
              o = Math.atan2(i, t * n);
            (e = Math.sin(e * o) / i), (a = Math.sin(a * o) / i);
          }
          const i = a * n;
          if (
            ((s = s * e + h * i),
            (l = l * e + d * i),
            (c = c * e + p * i),
            (u = u * e + f * i),
            e === 1 - a)
          ) {
            const e = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
            (s *= e), (l *= e), (c *= e), (u *= e);
          }
        }
        (e[t] = s), (e[t + 1] = l), (e[t + 2] = c), (e[t + 3] = u);
      }
      static multiplyQuaternionsFlat(e, t, n, r, i, o) {
        const a = n[r],
          s = n[r + 1],
          l = n[r + 2],
          c = n[r + 3],
          u = i[o],
          h = i[o + 1],
          d = i[o + 2],
          p = i[o + 3];
        return (
          (e[t] = a * p + c * u + s * d - l * h),
          (e[t + 1] = s * p + c * h + l * u - a * d),
          (e[t + 2] = l * p + c * d + a * h - s * u),
          (e[t + 3] = c * p - a * u - s * h - l * d),
          e
        );
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(e) {
        (this._w = e), this._onChangeCallback();
      }
      set(e, t, n, r) {
        return (
          (this._x = e),
          (this._y = t),
          (this._z = n),
          (this._w = r),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(e) {
        return (
          (this._x = e.x),
          (this._y = e.y),
          (this._z = e.z),
          (this._w = e.w),
          this._onChangeCallback(),
          this
        );
      }
      setFromEuler(e, t) {
        if (!e || !e.isEuler)
          throw new Error(
            "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
          );
        const n = e._x,
          r = e._y,
          i = e._z,
          o = e._order,
          a = Math.cos,
          s = Math.sin,
          l = a(n / 2),
          c = a(r / 2),
          u = a(i / 2),
          h = s(n / 2),
          d = s(r / 2),
          p = s(i / 2);
        switch (o) {
          case "XYZ":
            (this._x = h * c * u + l * d * p),
              (this._y = l * d * u - h * c * p),
              (this._z = l * c * p + h * d * u),
              (this._w = l * c * u - h * d * p);
            break;
          case "YXZ":
            (this._x = h * c * u + l * d * p),
              (this._y = l * d * u - h * c * p),
              (this._z = l * c * p - h * d * u),
              (this._w = l * c * u + h * d * p);
            break;
          case "ZXY":
            (this._x = h * c * u - l * d * p),
              (this._y = l * d * u + h * c * p),
              (this._z = l * c * p + h * d * u),
              (this._w = l * c * u - h * d * p);
            break;
          case "ZYX":
            (this._x = h * c * u - l * d * p),
              (this._y = l * d * u + h * c * p),
              (this._z = l * c * p - h * d * u),
              (this._w = l * c * u + h * d * p);
            break;
          case "YZX":
            (this._x = h * c * u + l * d * p),
              (this._y = l * d * u + h * c * p),
              (this._z = l * c * p - h * d * u),
              (this._w = l * c * u - h * d * p);
            break;
          case "XZY":
            (this._x = h * c * u - l * d * p),
              (this._y = l * d * u - h * c * p),
              (this._z = l * c * p + h * d * u),
              (this._w = l * c * u + h * d * p);
            break;
          default:
            console.warn(
              "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                o
            );
        }
        return !1 !== t && this._onChangeCallback(), this;
      }
      setFromAxisAngle(e, t) {
        const n = t / 2,
          r = Math.sin(n);
        return (
          (this._x = e.x * r),
          (this._y = e.y * r),
          (this._z = e.z * r),
          (this._w = Math.cos(n)),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(e) {
        const t = e.elements,
          n = t[0],
          r = t[4],
          i = t[8],
          o = t[1],
          a = t[5],
          s = t[9],
          l = t[2],
          c = t[6],
          u = t[10],
          h = n + a + u;
        if (h > 0) {
          const e = 0.5 / Math.sqrt(h + 1);
          (this._w = 0.25 / e),
            (this._x = (c - s) * e),
            (this._y = (i - l) * e),
            (this._z = (o - r) * e);
        } else if (n > a && n > u) {
          const e = 2 * Math.sqrt(1 + n - a - u);
          (this._w = (c - s) / e),
            (this._x = 0.25 * e),
            (this._y = (r + o) / e),
            (this._z = (i + l) / e);
        } else if (a > u) {
          const e = 2 * Math.sqrt(1 + a - n - u);
          (this._w = (i - l) / e),
            (this._x = (r + o) / e),
            (this._y = 0.25 * e),
            (this._z = (s + c) / e);
        } else {
          const e = 2 * Math.sqrt(1 + u - n - a);
          (this._w = (o - r) / e),
            (this._x = (i + l) / e),
            (this._y = (s + c) / e),
            (this._z = 0.25 * e);
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return (
          n < Number.EPSILON
            ? ((n = 0),
              Math.abs(e.x) > Math.abs(e.z)
                ? ((this._x = -e.y),
                  (this._y = e.x),
                  (this._z = 0),
                  (this._w = n))
                : ((this._x = 0),
                  (this._y = -e.z),
                  (this._z = e.y),
                  (this._w = n)))
            : ((this._x = e.y * t.z - e.z * t.y),
              (this._y = e.z * t.x - e.x * t.z),
              (this._z = e.x * t.y - e.y * t.x),
              (this._w = n)),
          this.normalize()
        );
      }
      angleTo(e) {
        return 2 * Math.acos(Math.abs(Gn(this.dot(e), -1, 1)));
      }
      rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (0 === n) return this;
        const r = Math.min(1, t / n);
        return this.slerp(e, r), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return (
          (this._x *= -1),
          (this._y *= -1),
          (this._z *= -1),
          this._onChangeCallback(),
          this
        );
      }
      dot(e) {
        return (
          this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        );
      }
      lengthSq() {
        return (
          this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
        );
      }
      length() {
        return Math.sqrt(
          this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
        );
      }
      normalize() {
        let e = this.length();
        return (
          0 === e
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((e = 1 / e),
              (this._x = this._x * e),
              (this._y = this._y * e),
              (this._z = this._z * e),
              (this._w = this._w * e)),
          this._onChangeCallback(),
          this
        );
      }
      multiply(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
            ),
            this.multiplyQuaternions(e, t))
          : this.multiplyQuaternions(this, e);
      }
      premultiply(e) {
        return this.multiplyQuaternions(e, this);
      }
      multiplyQuaternions(e, t) {
        const n = e._x,
          r = e._y,
          i = e._z,
          o = e._w,
          a = t._x,
          s = t._y,
          l = t._z,
          c = t._w;
        return (
          (this._x = n * c + o * a + r * l - i * s),
          (this._y = r * c + o * s + i * a - n * l),
          (this._z = i * c + o * l + n * s - r * a),
          (this._w = o * c - n * a - r * s - i * l),
          this._onChangeCallback(),
          this
        );
      }
      slerp(e, t) {
        if (0 === t) return this;
        if (1 === t) return this.copy(e);
        const n = this._x,
          r = this._y,
          i = this._z,
          o = this._w;
        let a = o * e._w + n * e._x + r * e._y + i * e._z;
        if (
          (a < 0
            ? ((this._w = -e._w),
              (this._x = -e._x),
              (this._y = -e._y),
              (this._z = -e._z),
              (a = -a))
            : this.copy(e),
          a >= 1)
        )
          return (
            (this._w = o), (this._x = n), (this._y = r), (this._z = i), this
          );
        const s = 1 - a * a;
        if (s <= Number.EPSILON) {
          const e = 1 - t;
          return (
            (this._w = e * o + t * this._w),
            (this._x = e * n + t * this._x),
            (this._y = e * r + t * this._y),
            (this._z = e * i + t * this._z),
            this.normalize(),
            this._onChangeCallback(),
            this
          );
        }
        const l = Math.sqrt(s),
          c = Math.atan2(l, a),
          u = Math.sin((1 - t) * c) / l,
          h = Math.sin(t * c) / l;
        return (
          (this._w = o * u + this._w * h),
          (this._x = n * u + this._x * h),
          (this._y = r * u + this._y * h),
          (this._z = i * u + this._z * h),
          this._onChangeCallback(),
          this
        );
      }
      slerpQuaternions(e, t, n) {
        this.copy(e).slerp(t, n);
      }
      equals(e) {
        return (
          e._x === this._x &&
          e._y === this._y &&
          e._z === this._z &&
          e._w === this._w
        );
      }
      fromArray(e, t = 0) {
        return (
          (this._x = e[t]),
          (this._y = e[t + 1]),
          (this._z = e[t + 2]),
          (this._w = e[t + 3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this._x),
          (e[t + 1] = this._y),
          (e[t + 2] = this._z),
          (e[t + 3] = this._w),
          e
        );
      }
      fromBufferAttribute(e, t) {
        return (
          (this._x = e.getX(t)),
          (this._y = e.getY(t)),
          (this._z = e.getZ(t)),
          (this._w = e.getW(t)),
          this
        );
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
    }
    ar.prototype.isQuaternion = !0;
    class sr {
      constructor(e = 0, t = 0, n = 0) {
        (this.x = e), (this.y = t), (this.z = n);
      }
      set(e, t, n) {
        return (
          void 0 === n && (n = this.z),
          (this.x = e),
          (this.y = t),
          (this.z = n),
          this
        );
      }
      setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), this;
      }
      setX(e) {
        return (this.x = e), this;
      }
      setY(e) {
        return (this.y = e), this;
      }
      setZ(e) {
        return (this.z = e), this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(e) {
        return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
      }
      add(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
            ),
            this.addVectors(e, t))
          : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
      }
      addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), this;
      }
      addVectors(e, t) {
        return (
          (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
        );
      }
      addScaledVector(e, t) {
        return (
          (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
        );
      }
      sub(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
            ),
            this.subVectors(e, t))
          : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
      }
      subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), this;
      }
      subVectors(e, t) {
        return (
          (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
        );
      }
      multiply(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
            ),
            this.multiplyVectors(e, t))
          : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
      }
      multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), this;
      }
      multiplyVectors(e, t) {
        return (
          (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
        );
      }
      applyEuler(e) {
        return (
          (e && e.isEuler) ||
            console.error(
              "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
            ),
          this.applyQuaternion(cr.setFromEuler(e))
        );
      }
      applyAxisAngle(e, t) {
        return this.applyQuaternion(cr.setFromAxisAngle(e, t));
      }
      applyMatrix3(e) {
        const t = this.x,
          n = this.y,
          r = this.z,
          i = e.elements;
        return (
          (this.x = i[0] * t + i[3] * n + i[6] * r),
          (this.y = i[1] * t + i[4] * n + i[7] * r),
          (this.z = i[2] * t + i[5] * n + i[8] * r),
          this
        );
      }
      applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
      }
      applyMatrix4(e) {
        const t = this.x,
          n = this.y,
          r = this.z,
          i = e.elements,
          o = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
        return (
          (this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * o),
          (this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * o),
          (this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * o),
          this
        );
      }
      applyQuaternion(e) {
        const t = this.x,
          n = this.y,
          r = this.z,
          i = e.x,
          o = e.y,
          a = e.z,
          s = e.w,
          l = s * t + o * r - a * n,
          c = s * n + a * t - i * r,
          u = s * r + i * n - o * t,
          h = -i * t - o * n - a * r;
        return (
          (this.x = l * s + h * -i + c * -a - u * -o),
          (this.y = c * s + h * -o + u * -i - l * -a),
          (this.z = u * s + h * -a + l * -o - c * -i),
          this
        );
      }
      project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
          e.projectionMatrix
        );
      }
      unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
          e.matrixWorld
        );
      }
      transformDirection(e) {
        const t = this.x,
          n = this.y,
          r = this.z,
          i = e.elements;
        return (
          (this.x = i[0] * t + i[4] * n + i[8] * r),
          (this.y = i[1] * t + i[5] * n + i[9] * r),
          (this.z = i[2] * t + i[6] * n + i[10] * r),
          this.normalize()
        );
      }
      divide(e) {
        return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      min(e) {
        return (
          (this.x = Math.min(this.x, e.x)),
          (this.y = Math.min(this.y, e.y)),
          (this.z = Math.min(this.z, e.z)),
          this
        );
      }
      max(e) {
        return (
          (this.x = Math.max(this.x, e.x)),
          (this.y = Math.max(this.y, e.y)),
          (this.z = Math.max(this.z, e.z)),
          this
        );
      }
      clamp(e, t) {
        return (
          (this.x = Math.max(e.x, Math.min(t.x, this.x))),
          (this.y = Math.max(e.y, Math.min(t.y, this.y))),
          (this.z = Math.max(e.z, Math.min(t.z, this.z))),
          this
        );
      }
      clampScalar(e, t) {
        return (
          (this.x = Math.max(e, Math.min(t, this.x))),
          (this.y = Math.max(e, Math.min(t, this.y))),
          (this.z = Math.max(e, Math.min(t, this.z))),
          this
        );
      }
      clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(e, Math.min(t, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return (
          (this.x += (e.x - this.x) * t),
          (this.y += (e.y - this.y) * t),
          (this.z += (e.z - this.z) * t),
          this
        );
      }
      lerpVectors(e, t, n) {
        return (
          (this.x = e.x + (t.x - e.x) * n),
          (this.y = e.y + (t.y - e.y) * n),
          (this.z = e.z + (t.z - e.z) * n),
          this
        );
      }
      cross(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
            ),
            this.crossVectors(e, t))
          : this.crossVectors(this, e);
      }
      crossVectors(e, t) {
        const n = e.x,
          r = e.y,
          i = e.z,
          o = t.x,
          a = t.y,
          s = t.z;
        return (
          (this.x = r * s - i * a),
          (this.y = i * o - n * s),
          (this.z = n * a - r * o),
          this
        );
      }
      projectOnVector(e) {
        const t = e.lengthSq();
        if (0 === t) return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n);
      }
      projectOnPlane(e) {
        return lr.copy(this).projectOnVector(e), this.sub(lr);
      }
      reflect(e) {
        return this.sub(lr.copy(e).multiplyScalar(2 * this.dot(e)));
      }
      angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (0 === t) return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Gn(n, -1, 1));
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x,
          n = this.y - e.y,
          r = this.z - e.z;
        return t * t + n * n + r * r;
      }
      manhattanDistanceTo(e) {
        return (
          Math.abs(this.x - e.x) +
          Math.abs(this.y - e.y) +
          Math.abs(this.z - e.z)
        );
      }
      setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
      }
      setFromSphericalCoords(e, t, n) {
        const r = Math.sin(t) * e;
        return (
          (this.x = r * Math.sin(n)),
          (this.y = Math.cos(t) * e),
          (this.z = r * Math.cos(n)),
          this
        );
      }
      setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
      }
      setFromCylindricalCoords(e, t, n) {
        return (
          (this.x = e * Math.sin(t)),
          (this.y = n),
          (this.z = e * Math.cos(t)),
          this
        );
      }
      setFromMatrixPosition(e) {
        const t = e.elements;
        return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
      }
      setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
          n = this.setFromMatrixColumn(e, 1).length(),
          r = this.setFromMatrixColumn(e, 2).length();
        return (this.x = t), (this.y = n), (this.z = r), this;
      }
      setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, 4 * t);
      }
      setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, 3 * t);
      }
      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
      }
      fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
      }
      fromBufferAttribute(e, t, n) {
        return (
          void 0 !== n &&
            console.warn(
              "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
            ),
          (this.x = e.getX(t)),
          (this.y = e.getY(t)),
          (this.z = e.getZ(t)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          this
        );
      }
    }
    sr.prototype.isVector3 = !0;
    const lr = new sr(),
      cr = new ar();
    class ur {
      constructor(
        e = new sr(1 / 0, 1 / 0, 1 / 0),
        t = new sr(-1 / 0, -1 / 0, -1 / 0)
      ) {
        (this.min = e), (this.max = t);
      }
      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }
      setFromArray(e) {
        let t = 1 / 0,
          n = 1 / 0,
          r = 1 / 0,
          i = -1 / 0,
          o = -1 / 0,
          a = -1 / 0;
        for (let s = 0, l = e.length; s < l; s += 3) {
          const l = e[s],
            c = e[s + 1],
            u = e[s + 2];
          l < t && (t = l),
            c < n && (n = c),
            u < r && (r = u),
            l > i && (i = l),
            c > o && (o = c),
            u > a && (a = u);
        }
        return this.min.set(t, n, r), this.max.set(i, o, a), this;
      }
      setFromBufferAttribute(e) {
        let t = 1 / 0,
          n = 1 / 0,
          r = 1 / 0,
          i = -1 / 0,
          o = -1 / 0,
          a = -1 / 0;
        for (let s = 0, l = e.count; s < l; s++) {
          const l = e.getX(s),
            c = e.getY(s),
            u = e.getZ(s);
          l < t && (t = l),
            c < n && (n = c),
            u < r && (r = u),
            l > i && (i = l),
            c > o && (o = c),
            u > a && (a = u);
        }
        return this.min.set(t, n, r), this.max.set(i, o, a), this;
      }
      setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this;
      }
      setFromCenterAndSize(e, t) {
        const n = dr.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
      }
      setFromObject(e) {
        return this.makeEmpty(), this.expandByObject(e);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      }
      isEmpty() {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      }
      getCenter(e) {
        return this.isEmpty()
          ? e.set(0, 0, 0)
          : e.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(e) {
        return this.isEmpty()
          ? e.set(0, 0, 0)
          : e.subVectors(this.max, this.min);
      }
      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }
      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }
      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }
      expandByObject(e) {
        e.updateWorldMatrix(!1, !1);
        const t = e.geometry;
        void 0 !== t &&
          (null === t.boundingBox && t.computeBoundingBox(),
          pr.copy(t.boundingBox),
          pr.applyMatrix4(e.matrixWorld),
          this.union(pr));
        const n = e.children;
        for (let e = 0, t = n.length; e < t; e++) this.expandByObject(n[e]);
        return this;
      }
      containsPoint(e) {
        return !(
          e.x < this.min.x ||
          e.x > this.max.x ||
          e.y < this.min.y ||
          e.y > this.max.y ||
          e.z < this.min.z ||
          e.z > this.max.z
        );
      }
      containsBox(e) {
        return (
          this.min.x <= e.min.x &&
          e.max.x <= this.max.x &&
          this.min.y <= e.min.y &&
          e.max.y <= this.max.y &&
          this.min.z <= e.min.z &&
          e.max.z <= this.max.z
        );
      }
      getParameter(e, t) {
        return t.set(
          (e.x - this.min.x) / (this.max.x - this.min.x),
          (e.y - this.min.y) / (this.max.y - this.min.y),
          (e.z - this.min.z) / (this.max.z - this.min.z)
        );
      }
      intersectsBox(e) {
        return !(
          e.max.x < this.min.x ||
          e.min.x > this.max.x ||
          e.max.y < this.min.y ||
          e.min.y > this.max.y ||
          e.max.z < this.min.z ||
          e.min.z > this.max.z
        );
      }
      intersectsSphere(e) {
        return (
          this.clampPoint(e.center, dr),
          dr.distanceToSquared(e.center) <= e.radius * e.radius
        );
      }
      intersectsPlane(e) {
        let t, n;
        return (
          e.normal.x > 0
            ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
            : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
          e.normal.y > 0
            ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
            : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
          e.normal.z > 0
            ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
            : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
          t <= -e.constant && n >= -e.constant
        );
      }
      intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(br),
          wr.subVectors(this.max, br),
          fr.subVectors(e.a, br),
          mr.subVectors(e.b, br),
          gr.subVectors(e.c, br),
          vr.subVectors(mr, fr),
          yr.subVectors(gr, mr),
          xr.subVectors(fr, gr);
        let t = [
          0,
          -vr.z,
          vr.y,
          0,
          -yr.z,
          yr.y,
          0,
          -xr.z,
          xr.y,
          vr.z,
          0,
          -vr.x,
          yr.z,
          0,
          -yr.x,
          xr.z,
          0,
          -xr.x,
          -vr.y,
          vr.x,
          0,
          -yr.y,
          yr.x,
          0,
          -xr.y,
          xr.x,
          0,
        ];
        return (
          !!Sr(t, fr, mr, gr, wr) &&
          ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          !!Sr(t, fr, mr, gr, wr) &&
            (_r.crossVectors(vr, yr),
            (t = [_r.x, _r.y, _r.z]),
            Sr(t, fr, mr, gr, wr)))
        );
      }
      clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
      }
      distanceToPoint(e) {
        return dr.copy(e).clamp(this.min, this.max).sub(e).length();
      }
      getBoundingSphere(e) {
        return (
          this.getCenter(e.center),
          (e.radius = 0.5 * this.getSize(dr).length()),
          e
        );
      }
      intersect(e) {
        return (
          this.min.max(e.min),
          this.max.min(e.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      }
      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }
      applyMatrix4(e) {
        return (
          this.isEmpty() ||
            (hr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            hr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            hr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            hr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            hr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            hr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            hr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            hr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(hr)),
          this
        );
      }
      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }
      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }
    }
    ur.prototype.isBox3 = !0;
    const hr = [
        new sr(),
        new sr(),
        new sr(),
        new sr(),
        new sr(),
        new sr(),
        new sr(),
        new sr(),
      ],
      dr = new sr(),
      pr = new ur(),
      fr = new sr(),
      mr = new sr(),
      gr = new sr(),
      vr = new sr(),
      yr = new sr(),
      xr = new sr(),
      br = new sr(),
      wr = new sr(),
      _r = new sr(),
      Mr = new sr();

    function Sr(e, t, n, r, i) {
      for (let o = 0, a = e.length - 3; o <= a; o += 3) {
        Mr.fromArray(e, o);
        const a =
            i.x * Math.abs(Mr.x) + i.y * Math.abs(Mr.y) + i.z * Math.abs(Mr.z),
          s = t.dot(Mr),
          l = n.dot(Mr),
          c = r.dot(Mr);
        if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > a) return !1;
      }
      return !0;
    }
    const Tr = new ur(),
      Er = new sr(),
      Ar = new sr(),
      Cr = new sr();
    class Pr {
      constructor(e = new sr(), t = -1) {
        (this.center = e), (this.radius = t);
      }
      set(e, t) {
        return this.center.copy(e), (this.radius = t), this;
      }
      setFromPoints(e, t) {
        const n = this.center;
        void 0 !== t ? n.copy(t) : Tr.setFromPoints(e).getCenter(n);
        let r = 0;
        for (let t = 0, i = e.length; t < i; t++)
          r = Math.max(r, n.distanceToSquared(e[t]));
        return (this.radius = Math.sqrt(r)), this;
      }
      copy(e) {
        return this.center.copy(e.center), (this.radius = e.radius), this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
      }
      containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
      }
      intersectsBox(e) {
        return e.intersectsSphere(this);
      }
      intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return (
          t.copy(e),
          n > this.radius * this.radius &&
            (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
          t
        );
      }
      getBoundingBox(e) {
        return this.isEmpty()
          ? (e.makeEmpty(), e)
          : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
      }
      applyMatrix4(e) {
        return (
          this.center.applyMatrix4(e),
          (this.radius = this.radius * e.getMaxScaleOnAxis()),
          this
        );
      }
      translate(e) {
        return this.center.add(e), this;
      }
      expandByPoint(e) {
        Cr.subVectors(e, this.center);
        const t = Cr.lengthSq();
        if (t > this.radius * this.radius) {
          const e = Math.sqrt(t),
            n = 0.5 * (e - this.radius);
          this.center.add(Cr.multiplyScalar(n / e)), (this.radius += n);
        }
        return this;
      }
      union(e) {
        return (
          Ar.subVectors(e.center, this.center)
            .normalize()
            .multiplyScalar(e.radius),
          this.expandByPoint(Er.copy(e.center).add(Ar)),
          this.expandByPoint(Er.copy(e.center).sub(Ar)),
          this
        );
      }
      equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const Lr = new sr(),
      Rr = new sr(),
      Ir = new sr(),
      kr = new sr(),
      Dr = new sr(),
      Or = new sr(),
      Br = new sr();
    class Fr {
      constructor(e = new sr(), t = new sr(0, 0, -1)) {
        (this.origin = e), (this.direction = t);
      }
      set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
      }
      copy(e) {
        return (
          this.origin.copy(e.origin), this.direction.copy(e.direction), this
        );
      }
      at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin);
      }
      lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
      }
      recast(e) {
        return this.origin.copy(this.at(e, Lr)), this;
      }
      closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0
          ? t.copy(this.origin)
          : t.copy(this.direction).multiplyScalar(n).add(this.origin);
      }
      distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
      }
      distanceSqToPoint(e) {
        const t = Lr.subVectors(e, this.origin).dot(this.direction);
        return t < 0
          ? this.origin.distanceToSquared(e)
          : (Lr.copy(this.direction).multiplyScalar(t).add(this.origin),
            Lr.distanceToSquared(e));
      }
      distanceSqToSegment(e, t, n, r) {
        Rr.copy(e).add(t).multiplyScalar(0.5),
          Ir.copy(t).sub(e).normalize(),
          kr.copy(this.origin).sub(Rr);
        const i = 0.5 * e.distanceTo(t),
          o = -this.direction.dot(Ir),
          a = kr.dot(this.direction),
          s = -kr.dot(Ir),
          l = kr.lengthSq(),
          c = Math.abs(1 - o * o);
        let u, h, d, p;
        if (c > 0)
          if (((u = o * s - a), (h = o * a - s), (p = i * c), u >= 0))
            if (h >= -p)
              if (h <= p) {
                const e = 1 / c;
                (u *= e),
                  (h *= e),
                  (d = u * (u + o * h + 2 * a) + h * (o * u + h + 2 * s) + l);
              } else
                (h = i),
                  (u = Math.max(0, -(o * h + a))),
                  (d = -u * u + h * (h + 2 * s) + l);
            else
              (h = -i),
                (u = Math.max(0, -(o * h + a))),
                (d = -u * u + h * (h + 2 * s) + l);
          else
            h <= -p
              ? ((u = Math.max(0, -(-o * i + a))),
                (h = u > 0 ? -i : Math.min(Math.max(-i, -s), i)),
                (d = -u * u + h * (h + 2 * s) + l))
              : h <= p
              ? ((u = 0),
                (h = Math.min(Math.max(-i, -s), i)),
                (d = h * (h + 2 * s) + l))
              : ((u = Math.max(0, -(o * i + a))),
                (h = u > 0 ? i : Math.min(Math.max(-i, -s), i)),
                (d = -u * u + h * (h + 2 * s) + l));
        else
          (h = o > 0 ? -i : i),
            (u = Math.max(0, -(o * h + a))),
            (d = -u * u + h * (h + 2 * s) + l);
        return (
          n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
          r && r.copy(Ir).multiplyScalar(h).add(Rr),
          d
        );
      }
      intersectSphere(e, t) {
        Lr.subVectors(e.center, this.origin);
        const n = Lr.dot(this.direction),
          r = Lr.dot(Lr) - n * n,
          i = e.radius * e.radius;
        if (r > i) return null;
        const o = Math.sqrt(i - r),
          a = n - o,
          s = n + o;
        return a < 0 && s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t);
      }
      intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
      }
      distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null;
      }
      intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return null === n ? null : this.at(n, t);
      }
      intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return 0 === t || e.normal.dot(this.direction) * t < 0;
      }
      intersectBox(e, t) {
        let n, r, i, o, a, s;
        const l = 1 / this.direction.x,
          c = 1 / this.direction.y,
          u = 1 / this.direction.z,
          h = this.origin;
        return (
          l >= 0
            ? ((n = (e.min.x - h.x) * l), (r = (e.max.x - h.x) * l))
            : ((n = (e.max.x - h.x) * l), (r = (e.min.x - h.x) * l)),
          c >= 0
            ? ((i = (e.min.y - h.y) * c), (o = (e.max.y - h.y) * c))
            : ((i = (e.max.y - h.y) * c), (o = (e.min.y - h.y) * c)),
          n > o || i > r
            ? null
            : ((i > n || n != n) && (n = i),
              (o < r || r != r) && (r = o),
              u >= 0
                ? ((a = (e.min.z - h.z) * u), (s = (e.max.z - h.z) * u))
                : ((a = (e.max.z - h.z) * u), (s = (e.min.z - h.z) * u)),
              n > s || a > r
                ? null
                : ((a > n || n != n) && (n = a),
                  (s < r || r != r) && (r = s),
                  r < 0 ? null : this.at(n >= 0 ? n : r, t)))
        );
      }
      intersectsBox(e) {
        return null !== this.intersectBox(e, Lr);
      }
      intersectTriangle(e, t, n, r, i) {
        Dr.subVectors(t, e), Or.subVectors(n, e), Br.crossVectors(Dr, Or);
        let o,
          a = this.direction.dot(Br);
        if (a > 0) {
          if (r) return null;
          o = 1;
        } else {
          if (!(a < 0)) return null;
          (o = -1), (a = -a);
        }
        kr.subVectors(this.origin, e);
        const s = o * this.direction.dot(Or.crossVectors(kr, Or));
        if (s < 0) return null;
        const l = o * this.direction.dot(Dr.cross(kr));
        if (l < 0) return null;
        if (s + l > a) return null;
        const c = -o * kr.dot(Br);
        return c < 0 ? null : this.at(c / a, i);
      }
      applyMatrix4(e) {
        return (
          this.origin.applyMatrix4(e),
          this.direction.transformDirection(e),
          this
        );
      }
      equals(e) {
        return (
          e.origin.equals(this.origin) && e.direction.equals(this.direction)
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class Nr {
      constructor() {
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          arguments.length > 0 &&
            console.error(
              "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
            );
      }
      set(e, t, n, r, i, o, a, s, l, c, u, h, d, p, f, m) {
        const g = this.elements;
        return (
          (g[0] = e),
          (g[4] = t),
          (g[8] = n),
          (g[12] = r),
          (g[1] = i),
          (g[5] = o),
          (g[9] = a),
          (g[13] = s),
          (g[2] = l),
          (g[6] = c),
          (g[10] = u),
          (g[14] = h),
          (g[3] = d),
          (g[7] = p),
          (g[11] = f),
          (g[15] = m),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return new Nr().fromArray(this.elements);
      }
      copy(e) {
        const t = this.elements,
          n = e.elements;
        return (
          (t[0] = n[0]),
          (t[1] = n[1]),
          (t[2] = n[2]),
          (t[3] = n[3]),
          (t[4] = n[4]),
          (t[5] = n[5]),
          (t[6] = n[6]),
          (t[7] = n[7]),
          (t[8] = n[8]),
          (t[9] = n[9]),
          (t[10] = n[10]),
          (t[11] = n[11]),
          (t[12] = n[12]),
          (t[13] = n[13]),
          (t[14] = n[14]),
          (t[15] = n[15]),
          this
        );
      }
      copyPosition(e) {
        const t = this.elements,
          n = e.elements;
        return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
      }
      setFromMatrix3(e) {
        const t = e.elements;
        return (
          this.set(
            t[0],
            t[3],
            t[6],
            0,
            t[1],
            t[4],
            t[7],
            0,
            t[2],
            t[5],
            t[8],
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractBasis(e, t, n) {
        return (
          e.setFromMatrixColumn(this, 0),
          t.setFromMatrixColumn(this, 1),
          n.setFromMatrixColumn(this, 2),
          this
        );
      }
      makeBasis(e, t, n) {
        return (
          this.set(
            e.x,
            t.x,
            n.x,
            0,
            e.y,
            t.y,
            n.y,
            0,
            e.z,
            t.z,
            n.z,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractRotation(e) {
        const t = this.elements,
          n = e.elements,
          r = 1 / Ur.setFromMatrixColumn(e, 0).length(),
          i = 1 / Ur.setFromMatrixColumn(e, 1).length(),
          o = 1 / Ur.setFromMatrixColumn(e, 2).length();
        return (
          (t[0] = n[0] * r),
          (t[1] = n[1] * r),
          (t[2] = n[2] * r),
          (t[3] = 0),
          (t[4] = n[4] * i),
          (t[5] = n[5] * i),
          (t[6] = n[6] * i),
          (t[7] = 0),
          (t[8] = n[8] * o),
          (t[9] = n[9] * o),
          (t[10] = n[10] * o),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      }
      makeRotationFromEuler(e) {
        (e && e.isEuler) ||
          console.error(
            "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
          );
        const t = this.elements,
          n = e.x,
          r = e.y,
          i = e.z,
          o = Math.cos(n),
          a = Math.sin(n),
          s = Math.cos(r),
          l = Math.sin(r),
          c = Math.cos(i),
          u = Math.sin(i);
        if ("XYZ" === e.order) {
          const e = o * c,
            n = o * u,
            r = a * c,
            i = a * u;
          (t[0] = s * c),
            (t[4] = -s * u),
            (t[8] = l),
            (t[1] = n + r * l),
            (t[5] = e - i * l),
            (t[9] = -a * s),
            (t[2] = i - e * l),
            (t[6] = r + n * l),
            (t[10] = o * s);
        } else if ("YXZ" === e.order) {
          const e = s * c,
            n = s * u,
            r = l * c,
            i = l * u;
          (t[0] = e + i * a),
            (t[4] = r * a - n),
            (t[8] = o * l),
            (t[1] = o * u),
            (t[5] = o * c),
            (t[9] = -a),
            (t[2] = n * a - r),
            (t[6] = i + e * a),
            (t[10] = o * s);
        } else if ("ZXY" === e.order) {
          const e = s * c,
            n = s * u,
            r = l * c,
            i = l * u;
          (t[0] = e - i * a),
            (t[4] = -o * u),
            (t[8] = r + n * a),
            (t[1] = n + r * a),
            (t[5] = o * c),
            (t[9] = i - e * a),
            (t[2] = -o * l),
            (t[6] = a),
            (t[10] = o * s);
        } else if ("ZYX" === e.order) {
          const e = o * c,
            n = o * u,
            r = a * c,
            i = a * u;
          (t[0] = s * c),
            (t[4] = r * l - n),
            (t[8] = e * l + i),
            (t[1] = s * u),
            (t[5] = i * l + e),
            (t[9] = n * l - r),
            (t[2] = -l),
            (t[6] = a * s),
            (t[10] = o * s);
        } else if ("YZX" === e.order) {
          const e = o * s,
            n = o * l,
            r = a * s,
            i = a * l;
          (t[0] = s * c),
            (t[4] = i - e * u),
            (t[8] = r * u + n),
            (t[1] = u),
            (t[5] = o * c),
            (t[9] = -a * c),
            (t[2] = -l * c),
            (t[6] = n * u + r),
            (t[10] = e - i * u);
        } else if ("XZY" === e.order) {
          const e = o * s,
            n = o * l,
            r = a * s,
            i = a * l;
          (t[0] = s * c),
            (t[4] = -u),
            (t[8] = l * c),
            (t[1] = e * u + i),
            (t[5] = o * c),
            (t[9] = n * u - r),
            (t[2] = r * u - n),
            (t[6] = a * c),
            (t[10] = i * u + e);
        }
        return (
          (t[3] = 0),
          (t[7] = 0),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      }
      makeRotationFromQuaternion(e) {
        return this.compose(Hr, e, Gr);
      }
      lookAt(e, t, n) {
        const r = this.elements;
        return (
          Wr.subVectors(e, t),
          0 === Wr.lengthSq() && (Wr.z = 1),
          Wr.normalize(),
          Vr.crossVectors(n, Wr),
          0 === Vr.lengthSq() &&
            (1 === Math.abs(n.z) ? (Wr.x += 1e-4) : (Wr.z += 1e-4),
            Wr.normalize(),
            Vr.crossVectors(n, Wr)),
          Vr.normalize(),
          jr.crossVectors(Wr, Vr),
          (r[0] = Vr.x),
          (r[4] = jr.x),
          (r[8] = Wr.x),
          (r[1] = Vr.y),
          (r[5] = jr.y),
          (r[9] = Wr.y),
          (r[2] = Vr.z),
          (r[6] = jr.z),
          (r[10] = Wr.z),
          this
        );
      }
      multiply(e, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
            ),
            this.multiplyMatrices(e, t))
          : this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const n = e.elements,
          r = t.elements,
          i = this.elements,
          o = n[0],
          a = n[4],
          s = n[8],
          l = n[12],
          c = n[1],
          u = n[5],
          h = n[9],
          d = n[13],
          p = n[2],
          f = n[6],
          m = n[10],
          g = n[14],
          v = n[3],
          y = n[7],
          x = n[11],
          b = n[15],
          w = r[0],
          _ = r[4],
          M = r[8],
          S = r[12],
          T = r[1],
          E = r[5],
          A = r[9],
          C = r[13],
          P = r[2],
          L = r[6],
          R = r[10],
          I = r[14],
          k = r[3],
          D = r[7],
          O = r[11],
          B = r[15];
        return (
          (i[0] = o * w + a * T + s * P + l * k),
          (i[4] = o * _ + a * E + s * L + l * D),
          (i[8] = o * M + a * A + s * R + l * O),
          (i[12] = o * S + a * C + s * I + l * B),
          (i[1] = c * w + u * T + h * P + d * k),
          (i[5] = c * _ + u * E + h * L + d * D),
          (i[9] = c * M + u * A + h * R + d * O),
          (i[13] = c * S + u * C + h * I + d * B),
          (i[2] = p * w + f * T + m * P + g * k),
          (i[6] = p * _ + f * E + m * L + g * D),
          (i[10] = p * M + f * A + m * R + g * O),
          (i[14] = p * S + f * C + m * I + g * B),
          (i[3] = v * w + y * T + x * P + b * k),
          (i[7] = v * _ + y * E + x * L + b * D),
          (i[11] = v * M + y * A + x * R + b * O),
          (i[15] = v * S + y * C + x * I + b * B),
          this
        );
      }
      multiplyScalar(e) {
        const t = this.elements;
        return (
          (t[0] *= e),
          (t[4] *= e),
          (t[8] *= e),
          (t[12] *= e),
          (t[1] *= e),
          (t[5] *= e),
          (t[9] *= e),
          (t[13] *= e),
          (t[2] *= e),
          (t[6] *= e),
          (t[10] *= e),
          (t[14] *= e),
          (t[3] *= e),
          (t[7] *= e),
          (t[11] *= e),
          (t[15] *= e),
          this
        );
      }
      determinant() {
        const e = this.elements,
          t = e[0],
          n = e[4],
          r = e[8],
          i = e[12],
          o = e[1],
          a = e[5],
          s = e[9],
          l = e[13],
          c = e[2],
          u = e[6],
          h = e[10],
          d = e[14];
        return (
          e[3] *
            (+i * s * u -
              r * l * u -
              i * a * h +
              n * l * h +
              r * a * d -
              n * s * d) +
          e[7] *
            (+t * s * d -
              t * l * h +
              i * o * h -
              r * o * d +
              r * l * c -
              i * s * c) +
          e[11] *
            (+t * l * u -
              t * a * d -
              i * o * u +
              n * o * d +
              i * a * c -
              n * l * c) +
          e[15] *
            (-r * a * c -
              t * s * u +
              t * a * h +
              r * o * u -
              n * o * h +
              n * s * c)
        );
      }
      transpose() {
        const e = this.elements;
        let t;
        return (
          (t = e[1]),
          (e[1] = e[4]),
          (e[4] = t),
          (t = e[2]),
          (e[2] = e[8]),
          (e[8] = t),
          (t = e[6]),
          (e[6] = e[9]),
          (e[9] = t),
          (t = e[3]),
          (e[3] = e[12]),
          (e[12] = t),
          (t = e[7]),
          (e[7] = e[13]),
          (e[13] = t),
          (t = e[11]),
          (e[11] = e[14]),
          (e[14] = t),
          this
        );
      }
      setPosition(e, t, n) {
        const r = this.elements;
        return (
          e.isVector3
            ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
            : ((r[12] = e), (r[13] = t), (r[14] = n)),
          this
        );
      }
      invert() {
        const e = this.elements,
          t = e[0],
          n = e[1],
          r = e[2],
          i = e[3],
          o = e[4],
          a = e[5],
          s = e[6],
          l = e[7],
          c = e[8],
          u = e[9],
          h = e[10],
          d = e[11],
          p = e[12],
          f = e[13],
          m = e[14],
          g = e[15],
          v =
            u * m * l -
            f * h * l +
            f * s * d -
            a * m * d -
            u * s * g +
            a * h * g,
          y =
            p * h * l -
            c * m * l -
            p * s * d +
            o * m * d +
            c * s * g -
            o * h * g,
          x =
            c * f * l -
            p * u * l +
            p * a * d -
            o * f * d -
            c * a * g +
            o * u * g,
          b =
            p * u * s -
            c * f * s -
            p * a * h +
            o * f * h +
            c * a * m -
            o * u * m,
          w = t * v + n * y + r * x + i * b;
        if (0 === w)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const _ = 1 / w;
        return (
          (e[0] = v * _),
          (e[1] =
            (f * h * i -
              u * m * i -
              f * r * d +
              n * m * d +
              u * r * g -
              n * h * g) *
            _),
          (e[2] =
            (a * m * i -
              f * s * i +
              f * r * l -
              n * m * l -
              a * r * g +
              n * s * g) *
            _),
          (e[3] =
            (u * s * i -
              a * h * i -
              u * r * l +
              n * h * l +
              a * r * d -
              n * s * d) *
            _),
          (e[4] = y * _),
          (e[5] =
            (c * m * i -
              p * h * i +
              p * r * d -
              t * m * d -
              c * r * g +
              t * h * g) *
            _),
          (e[6] =
            (p * s * i -
              o * m * i -
              p * r * l +
              t * m * l +
              o * r * g -
              t * s * g) *
            _),
          (e[7] =
            (o * h * i -
              c * s * i +
              c * r * l -
              t * h * l -
              o * r * d +
              t * s * d) *
            _),
          (e[8] = x * _),
          (e[9] =
            (p * u * i -
              c * f * i -
              p * n * d +
              t * f * d +
              c * n * g -
              t * u * g) *
            _),
          (e[10] =
            (o * f * i -
              p * a * i +
              p * n * l -
              t * f * l -
              o * n * g +
              t * a * g) *
            _),
          (e[11] =
            (c * a * i -
              o * u * i -
              c * n * l +
              t * u * l +
              o * n * d -
              t * a * d) *
            _),
          (e[12] = b * _),
          (e[13] =
            (c * f * r -
              p * u * r +
              p * n * h -
              t * f * h -
              c * n * m +
              t * u * m) *
            _),
          (e[14] =
            (p * a * r -
              o * f * r -
              p * n * s +
              t * f * s +
              o * n * m -
              t * a * m) *
            _),
          (e[15] =
            (o * u * r -
              c * a * r +
              c * n * s -
              t * u * s -
              o * n * h +
              t * a * h) *
            _),
          this
        );
      }
      scale(e) {
        const t = this.elements,
          n = e.x,
          r = e.y,
          i = e.z;
        return (
          (t[0] *= n),
          (t[4] *= r),
          (t[8] *= i),
          (t[1] *= n),
          (t[5] *= r),
          (t[9] *= i),
          (t[2] *= n),
          (t[6] *= r),
          (t[10] *= i),
          (t[3] *= n),
          (t[7] *= r),
          (t[11] *= i),
          this
        );
      }
      getMaxScaleOnAxis() {
        const e = this.elements,
          t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
          n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
          r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, r));
      }
      makeTranslation(e, t, n) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
      }
      makeRotationX(e) {
        const t = Math.cos(e),
          n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(e) {
        const t = Math.cos(e),
          n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(e) {
        const t = Math.cos(e),
          n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(e, t) {
        const n = Math.cos(t),
          r = Math.sin(t),
          i = 1 - n,
          o = e.x,
          a = e.y,
          s = e.z,
          l = i * o,
          c = i * a;
        return (
          this.set(
            l * o + n,
            l * a - r * s,
            l * s + r * a,
            0,
            l * a + r * s,
            c * a + n,
            c * s - r * o,
            0,
            l * s - r * a,
            c * s + r * o,
            i * s * s + n,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
      }
      makeShear(e, t, n, r, i, o) {
        return this.set(1, n, i, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
      }
      compose(e, t, n) {
        const r = this.elements,
          i = t._x,
          o = t._y,
          a = t._z,
          s = t._w,
          l = i + i,
          c = o + o,
          u = a + a,
          h = i * l,
          d = i * c,
          p = i * u,
          f = o * c,
          m = o * u,
          g = a * u,
          v = s * l,
          y = s * c,
          x = s * u,
          b = n.x,
          w = n.y,
          _ = n.z;
        return (
          (r[0] = (1 - (f + g)) * b),
          (r[1] = (d + x) * b),
          (r[2] = (p - y) * b),
          (r[3] = 0),
          (r[4] = (d - x) * w),
          (r[5] = (1 - (h + g)) * w),
          (r[6] = (m + v) * w),
          (r[7] = 0),
          (r[8] = (p + y) * _),
          (r[9] = (m - v) * _),
          (r[10] = (1 - (h + f)) * _),
          (r[11] = 0),
          (r[12] = e.x),
          (r[13] = e.y),
          (r[14] = e.z),
          (r[15] = 1),
          this
        );
      }
      decompose(e, t, n) {
        const r = this.elements;
        let i = Ur.set(r[0], r[1], r[2]).length();
        const o = Ur.set(r[4], r[5], r[6]).length(),
          a = Ur.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (i = -i),
          (e.x = r[12]),
          (e.y = r[13]),
          (e.z = r[14]),
          zr.copy(this);
        const s = 1 / i,
          l = 1 / o,
          c = 1 / a;
        return (
          (zr.elements[0] *= s),
          (zr.elements[1] *= s),
          (zr.elements[2] *= s),
          (zr.elements[4] *= l),
          (zr.elements[5] *= l),
          (zr.elements[6] *= l),
          (zr.elements[8] *= c),
          (zr.elements[9] *= c),
          (zr.elements[10] *= c),
          t.setFromRotationMatrix(zr),
          (n.x = i),
          (n.y = o),
          (n.z = a),
          this
        );
      }
      makePerspective(e, t, n, r, i, o) {
        void 0 === o &&
          console.warn(
            "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
          );
        const a = this.elements,
          s = (2 * i) / (t - e),
          l = (2 * i) / (n - r),
          c = (t + e) / (t - e),
          u = (n + r) / (n - r),
          h = -(o + i) / (o - i),
          d = (-2 * o * i) / (o - i);
        return (
          (a[0] = s),
          (a[4] = 0),
          (a[8] = c),
          (a[12] = 0),
          (a[1] = 0),
          (a[5] = l),
          (a[9] = u),
          (a[13] = 0),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = h),
          (a[14] = d),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = -1),
          (a[15] = 0),
          this
        );
      }
      makeOrthographic(e, t, n, r, i, o) {
        const a = this.elements,
          s = 1 / (t - e),
          l = 1 / (n - r),
          c = 1 / (o - i),
          u = (t + e) * s,
          h = (n + r) * l,
          d = (o + i) * c;
        return (
          (a[0] = 2 * s),
          (a[4] = 0),
          (a[8] = 0),
          (a[12] = -u),
          (a[1] = 0),
          (a[5] = 2 * l),
          (a[9] = 0),
          (a[13] = -h),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = -2 * c),
          (a[14] = -d),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = 0),
          (a[15] = 1),
          this
        );
      }
      equals(e) {
        const t = this.elements,
          n = e.elements;
        for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;
        return !0;
      }
      fromArray(e, t = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const n = this.elements;
        return (
          (e[t] = n[0]),
          (e[t + 1] = n[1]),
          (e[t + 2] = n[2]),
          (e[t + 3] = n[3]),
          (e[t + 4] = n[4]),
          (e[t + 5] = n[5]),
          (e[t + 6] = n[6]),
          (e[t + 7] = n[7]),
          (e[t + 8] = n[8]),
          (e[t + 9] = n[9]),
          (e[t + 10] = n[10]),
          (e[t + 11] = n[11]),
          (e[t + 12] = n[12]),
          (e[t + 13] = n[13]),
          (e[t + 14] = n[14]),
          (e[t + 15] = n[15]),
          e
        );
      }
    }
    Nr.prototype.isMatrix4 = !0;
    const Ur = new sr(),
      zr = new Nr(),
      Hr = new sr(0, 0, 0),
      Gr = new sr(1, 1, 1),
      Vr = new sr(),
      jr = new sr(),
      Wr = new sr(),
      qr = new Nr(),
      $r = new ar();
    class Xr {
      constructor(e = 0, t = 0, n = 0, r = Xr.DefaultOrder) {
        (this._x = e), (this._y = t), (this._z = n), (this._order = r);
      }
      get x() {
        return this._x;
      }
      set x(e) {
        (this._x = e), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        (this._y = e), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        (this._z = e), this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(e) {
        (this._order = e), this._onChangeCallback();
      }
      set(e, t, n, r = this._order) {
        return (
          (this._x = e),
          (this._y = t),
          (this._z = n),
          (this._order = r),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(e) {
        return (
          (this._x = e._x),
          (this._y = e._y),
          (this._z = e._z),
          (this._order = e._order),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(e, t = this._order, n = !0) {
        const r = e.elements,
          i = r[0],
          o = r[4],
          a = r[8],
          s = r[1],
          l = r[5],
          c = r[9],
          u = r[2],
          h = r[6],
          d = r[10];
        switch (t) {
          case "XYZ":
            (this._y = Math.asin(Gn(a, -1, 1))),
              Math.abs(a) < 0.9999999
                ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-o, i)))
                : ((this._x = Math.atan2(h, l)), (this._z = 0));
            break;
          case "YXZ":
            (this._x = Math.asin(-Gn(c, -1, 1))),
              Math.abs(c) < 0.9999999
                ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(s, l)))
                : ((this._y = Math.atan2(-u, i)), (this._z = 0));
            break;
          case "ZXY":
            (this._x = Math.asin(Gn(h, -1, 1))),
              Math.abs(h) < 0.9999999
                ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-o, l)))
                : ((this._y = 0), (this._z = Math.atan2(s, i)));
            break;
          case "ZYX":
            (this._y = Math.asin(-Gn(u, -1, 1))),
              Math.abs(u) < 0.9999999
                ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(s, i)))
                : ((this._x = 0), (this._z = Math.atan2(-o, l)));
            break;
          case "YZX":
            (this._z = Math.asin(Gn(s, -1, 1))),
              Math.abs(s) < 0.9999999
                ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-u, i)))
                : ((this._x = 0), (this._y = Math.atan2(a, d)));
            break;
          case "XZY":
            (this._z = Math.asin(-Gn(o, -1, 1))),
              Math.abs(o) < 0.9999999
                ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(a, i)))
                : ((this._x = Math.atan2(-c, d)), (this._y = 0));
            break;
          default:
            console.warn(
              "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                t
            );
        }
        return (this._order = t), !0 === n && this._onChangeCallback(), this;
      }
      setFromQuaternion(e, t, n) {
        return (
          qr.makeRotationFromQuaternion(e), this.setFromRotationMatrix(qr, t, n)
        );
      }
      setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t);
      }
      reorder(e) {
        return $r.setFromEuler(this), this.setFromQuaternion($r, e);
      }
      equals(e) {
        return (
          e._x === this._x &&
          e._y === this._y &&
          e._z === this._z &&
          e._order === this._order
        );
      }
      fromArray(e) {
        return (
          (this._x = e[0]),
          (this._y = e[1]),
          (this._z = e[2]),
          void 0 !== e[3] && (this._order = e[3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(e = [], t = 0) {
        return (
          (e[t] = this._x),
          (e[t + 1] = this._y),
          (e[t + 2] = this._z),
          (e[t + 3] = this._order),
          e
        );
      }
      toVector3(e) {
        return e
          ? e.set(this._x, this._y, this._z)
          : new sr(this._x, this._y, this._z);
      }
      _onChange(e) {
        return (this._onChangeCallback = e), this;
      }
      _onChangeCallback() {}
    }
    (Xr.prototype.isEuler = !0),
      (Xr.DefaultOrder = "XYZ"),
      (Xr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
    class Yr {
      constructor() {
        this.mask = 1;
      }
      set(e) {
        this.mask = (1 << e) | 0;
      }
      enable(e) {
        this.mask |= (1 << e) | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(e) {
        this.mask ^= (1 << e) | 0;
      }
      disable(e) {
        this.mask &= ~((1 << e) | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(e) {
        return 0 != (this.mask & e.mask);
      }
    }
    let Jr = 0;
    const Zr = new sr(),
      Kr = new ar(),
      Qr = new Nr(),
      ei = new sr(),
      ti = new sr(),
      ni = new sr(),
      ri = new ar(),
      ii = new sr(1, 0, 0),
      oi = new sr(0, 1, 0),
      ai = new sr(0, 0, 1),
      si = {
        type: "added",
      },
      li = {
        type: "removed",
      };
    class ci extends Bn {
      constructor() {
        super(),
          Object.defineProperty(this, "id", {
            value: Jr++,
          }),
          (this.uuid = Hn()),
          (this.name = ""),
          (this.type = "Object3D"),
          (this.parent = null),
          (this.children = []),
          (this.up = ci.DefaultUp.clone());
        const e = new sr(),
          t = new Xr(),
          n = new ar(),
          r = new sr(1, 1, 1);
        t._onChange(function () {
          n.setFromEuler(t, !1);
        }),
          n._onChange(function () {
            t.setFromQuaternion(n, void 0, !1);
          }),
          Object.defineProperties(this, {
            position: {
              configurable: !0,
              enumerable: !0,
              value: e,
            },
            rotation: {
              configurable: !0,
              enumerable: !0,
              value: t,
            },
            quaternion: {
              configurable: !0,
              enumerable: !0,
              value: n,
            },
            scale: {
              configurable: !0,
              enumerable: !0,
              value: r,
            },
            modelViewMatrix: {
              value: new Nr(),
            },
            normalMatrix: {
              value: new Jn(),
            },
          }),
          (this.matrix = new Nr()),
          (this.matrixWorld = new Nr()),
          (this.matrixAutoUpdate = ci.DefaultMatrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = !1),
          (this.layers = new Yr()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.animations = []),
          (this.userData = {});
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(e),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
      }
      setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
      }
      setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0);
      }
      setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
      }
      setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
      }
      rotateOnAxis(e, t) {
        return Kr.setFromAxisAngle(e, t), this.quaternion.multiply(Kr), this;
      }
      rotateOnWorldAxis(e, t) {
        return Kr.setFromAxisAngle(e, t), this.quaternion.premultiply(Kr), this;
      }
      rotateX(e) {
        return this.rotateOnAxis(ii, e);
      }
      rotateY(e) {
        return this.rotateOnAxis(oi, e);
      }
      rotateZ(e) {
        return this.rotateOnAxis(ai, e);
      }
      translateOnAxis(e, t) {
        return (
          Zr.copy(e).applyQuaternion(this.quaternion),
          this.position.add(Zr.multiplyScalar(t)),
          this
        );
      }
      translateX(e) {
        return this.translateOnAxis(ii, e);
      }
      translateY(e) {
        return this.translateOnAxis(oi, e);
      }
      translateZ(e) {
        return this.translateOnAxis(ai, e);
      }
      localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(e) {
        return e.applyMatrix4(Qr.copy(this.matrixWorld).invert());
      }
      lookAt(e, t, n) {
        e.isVector3 ? ei.copy(e) : ei.set(e, t, n);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
          ti.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight
            ? Qr.lookAt(ti, ei, this.up)
            : Qr.lookAt(ei, ti, this.up),
          this.quaternion.setFromRotationMatrix(Qr),
          r &&
            (Qr.extractRotation(r.matrixWorld),
            Kr.setFromRotationMatrix(Qr),
            this.quaternion.premultiply(Kr.invert()));
      }
      add(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
          return this;
        }
        return e === this
          ? (console.error(
              "THREE.Object3D.add: object can't be added as a child of itself.",
              e
            ),
            this)
          : (e && e.isObject3D
              ? (null !== e.parent && e.parent.remove(e),
                (e.parent = this),
                this.children.push(e),
                e.dispatchEvent(si))
              : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  e
                ),
            this);
      }
      remove(e) {
        if (arguments.length > 1) {
          for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
          return this;
        }
        const t = this.children.indexOf(e);
        return (
          -1 !== t &&
            ((e.parent = null),
            this.children.splice(t, 1),
            e.dispatchEvent(li)),
          this
        );
      }
      removeFromParent() {
        const e = this.parent;
        return null !== e && e.remove(this), this;
      }
      clear() {
        for (let e = 0; e < this.children.length; e++) {
          const t = this.children[e];
          (t.parent = null), t.dispatchEvent(li);
        }
        return (this.children.length = 0), this;
      }
      attach(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          Qr.copy(this.matrixWorld).invert(),
          null !== e.parent &&
            (e.parent.updateWorldMatrix(!0, !1),
            Qr.multiply(e.parent.matrixWorld)),
          e.applyMatrix4(Qr),
          this.add(e),
          e.updateWorldMatrix(!1, !0),
          this
        );
      }
      getObjectById(e) {
        return this.getObjectByProperty("id", e);
      }
      getObjectByName(e) {
        return this.getObjectByProperty("name", e);
      }
      getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let n = 0, r = this.children.length; n < r; n++) {
          const r = this.children[n].getObjectByProperty(e, t);
          if (void 0 !== r) return r;
        }
      }
      getWorldPosition(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          e.setFromMatrixPosition(this.matrixWorld)
        );
      }
      getWorldQuaternion(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(ti, e, ni),
          e
        );
      }
      getWorldScale(e) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(ti, ri, e),
          e
        );
      }
      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
      }
      raycast() {}
      traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e);
      }
      traverseVisible(e) {
        if (!1 === this.visible) return;
        e(this);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e);
      }
      traverseAncestors(e) {
        const t = this.parent;
        null !== t && (e(t), t.traverseAncestors(e));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      }
      updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || e) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            (this.matrixWorldNeedsUpdate = !1),
            (e = !0));
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e);
      }
      updateWorldMatrix(e, t) {
        const n = this.parent;
        if (
          (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          !0 === t)
        ) {
          const e = this.children;
          for (let t = 0, n = e.length; t < n; t++)
            e[t].updateWorldMatrix(!1, !0);
        }
      }
      toJSON(e) {
        const t = void 0 === e || "string" == typeof e,
          n = {};
        t &&
          ((e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
          }),
          (n.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON",
          }));
        const r = {};

        function i(t, n) {
          return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
        }
        if (
          ((r.uuid = this.uuid),
          (r.type = this.type),
          "" !== this.name && (r.name = this.name),
          !0 === this.castShadow && (r.castShadow = !0),
          !0 === this.receiveShadow && (r.receiveShadow = !0),
          !1 === this.visible && (r.visible = !1),
          !1 === this.frustumCulled && (r.frustumCulled = !1),
          0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
          "{}" !== JSON.stringify(this.userData) &&
            (r.userData = this.userData),
          (r.layers = this.layers.mask),
          (r.matrix = this.matrix.toArray()),
          !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
          this.isInstancedMesh &&
            ((r.type = "InstancedMesh"),
            (r.count = this.count),
            (r.instanceMatrix = this.instanceMatrix.toJSON()),
            null !== this.instanceColor &&
              (r.instanceColor = this.instanceColor.toJSON())),
          this.isScene)
        )
          this.background &&
            (this.background.isColor
              ? (r.background = this.background.toJSON())
              : this.background.isTexture &&
                (r.background = this.background.toJSON(e).uuid)),
            this.environment &&
              this.environment.isTexture &&
              (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
          r.geometry = i(e.geometries, this.geometry);
          const t = this.geometry.parameters;
          if (void 0 !== t && void 0 !== t.shapes) {
            const n = t.shapes;
            if (Array.isArray(n))
              for (let t = 0, r = n.length; t < r; t++) {
                const r = n[t];
                i(e.shapes, r);
              }
            else i(e.shapes, n);
          }
        }
        if (
          (this.isSkinnedMesh &&
            ((r.bindMode = this.bindMode),
            (r.bindMatrix = this.bindMatrix.toArray()),
            void 0 !== this.skeleton &&
              (i(e.skeletons, this.skeleton),
              (r.skeleton = this.skeleton.uuid))),
          void 0 !== this.material)
        )
          if (Array.isArray(this.material)) {
            const t = [];
            for (let n = 0, r = this.material.length; n < r; n++)
              t.push(i(e.materials, this.material[n]));
            r.material = t;
          } else r.material = i(e.materials, this.material);
        if (this.children.length > 0) {
          r.children = [];
          for (let t = 0; t < this.children.length; t++)
            r.children.push(this.children[t].toJSON(e).object);
        }
        if (this.animations.length > 0) {
          r.animations = [];
          for (let t = 0; t < this.animations.length; t++) {
            const n = this.animations[t];
            r.animations.push(i(e.animations, n));
          }
        }
        if (t) {
          const t = o(e.geometries),
            r = o(e.materials),
            i = o(e.textures),
            a = o(e.images),
            s = o(e.shapes),
            l = o(e.skeletons),
            c = o(e.animations);
          t.length > 0 && (n.geometries = t),
            r.length > 0 && (n.materials = r),
            i.length > 0 && (n.textures = i),
            a.length > 0 && (n.images = a),
            s.length > 0 && (n.shapes = s),
            l.length > 0 && (n.skeletons = l),
            c.length > 0 && (n.animations = c);
        }
        return (n.object = r), n;

        function o(e) {
          const t = [];
          for (const n in e) {
            const r = e[n];
            delete r.metadata, t.push(r);
          }
          return t;
        }
      }
      clone(e) {
        return new this.constructor().copy(this, e);
      }
      copy(e, t = !0) {
        if (
          ((this.name = e.name),
          this.up.copy(e.up),
          this.position.copy(e.position),
          (this.rotation.order = e.rotation.order),
          this.quaternion.copy(e.quaternion),
          this.scale.copy(e.scale),
          this.matrix.copy(e.matrix),
          this.matrixWorld.copy(e.matrixWorld),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
          (this.layers.mask = e.layers.mask),
          (this.visible = e.visible),
          (this.castShadow = e.castShadow),
          (this.receiveShadow = e.receiveShadow),
          (this.frustumCulled = e.frustumCulled),
          (this.renderOrder = e.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          !0 === t)
        )
          for (let t = 0; t < e.children.length; t++) {
            const n = e.children[t];
            this.add(n.clone());
          }
        return this;
      }
    }
    (ci.DefaultUp = new sr(0, 1, 0)),
      (ci.DefaultMatrixAutoUpdate = !0),
      (ci.prototype.isObject3D = !0);
    const ui = new sr(),
      hi = new sr(),
      di = new sr(),
      pi = new sr(),
      fi = new sr(),
      mi = new sr(),
      gi = new sr(),
      vi = new sr(),
      yi = new sr(),
      xi = new sr();
    class bi {
      constructor(e = new sr(), t = new sr(), n = new sr()) {
        (this.a = e), (this.b = t), (this.c = n);
      }
      static getNormal(e, t, n, r) {
        r.subVectors(n, t), ui.subVectors(e, t), r.cross(ui);
        const i = r.lengthSq();
        return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0);
      }
      static getBarycoord(e, t, n, r, i) {
        ui.subVectors(r, t), hi.subVectors(n, t), di.subVectors(e, t);
        const o = ui.dot(ui),
          a = ui.dot(hi),
          s = ui.dot(di),
          l = hi.dot(hi),
          c = hi.dot(di),
          u = o * l - a * a;
        if (0 === u) return i.set(-2, -1, -1);
        const h = 1 / u,
          d = (l * s - a * c) * h,
          p = (o * c - a * s) * h;
        return i.set(1 - d - p, p, d);
      }
      static containsPoint(e, t, n, r) {
        return (
          this.getBarycoord(e, t, n, r, pi),
          pi.x >= 0 && pi.y >= 0 && pi.x + pi.y <= 1
        );
      }
      static getUV(e, t, n, r, i, o, a, s) {
        return (
          this.getBarycoord(e, t, n, r, pi),
          s.set(0, 0),
          s.addScaledVector(i, pi.x),
          s.addScaledVector(o, pi.y),
          s.addScaledVector(a, pi.z),
          s
        );
      }
      static isFrontFacing(e, t, n, r) {
        return (
          ui.subVectors(n, t), hi.subVectors(e, t), ui.cross(hi).dot(r) < 0
        );
      }
      set(e, t, n) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
      }
      setFromPointsAndIndices(e, t, n, r) {
        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
      }
      getArea() {
        return (
          ui.subVectors(this.c, this.b),
          hi.subVectors(this.a, this.b),
          0.5 * ui.cross(hi).length()
        );
      }
      getMidpoint(e) {
        return e
          .addVectors(this.a, this.b)
          .add(this.c)
          .multiplyScalar(1 / 3);
      }
      getNormal(e) {
        return bi.getNormal(this.a, this.b, this.c, e);
      }
      getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(e, t) {
        return bi.getBarycoord(e, this.a, this.b, this.c, t);
      }
      getUV(e, t, n, r, i) {
        return bi.getUV(e, this.a, this.b, this.c, t, n, r, i);
      }
      containsPoint(e) {
        return bi.containsPoint(e, this.a, this.b, this.c);
      }
      isFrontFacing(e) {
        return bi.isFrontFacing(this.a, this.b, this.c, e);
      }
      intersectsBox(e) {
        return e.intersectsTriangle(this);
      }
      closestPointToPoint(e, t) {
        const n = this.a,
          r = this.b,
          i = this.c;
        let o, a;
        fi.subVectors(r, n), mi.subVectors(i, n), vi.subVectors(e, n);
        const s = fi.dot(vi),
          l = mi.dot(vi);
        if (s <= 0 && l <= 0) return t.copy(n);
        yi.subVectors(e, r);
        const c = fi.dot(yi),
          u = mi.dot(yi);
        if (c >= 0 && u <= c) return t.copy(r);
        const h = s * u - c * l;
        if (h <= 0 && s >= 0 && c <= 0)
          return (o = s / (s - c)), t.copy(n).addScaledVector(fi, o);
        xi.subVectors(e, i);
        const d = fi.dot(xi),
          p = mi.dot(xi);
        if (p >= 0 && d <= p) return t.copy(i);
        const f = d * l - s * p;
        if (f <= 0 && l >= 0 && p <= 0)
          return (a = l / (l - p)), t.copy(n).addScaledVector(mi, a);
        const m = c * p - d * u;
        if (m <= 0 && u - c >= 0 && d - p >= 0)
          return (
            gi.subVectors(i, r),
            (a = (u - c) / (u - c + (d - p))),
            t.copy(r).addScaledVector(gi, a)
          );
        const g = 1 / (m + f + h);
        return (
          (o = f * g),
          (a = h * g),
          t.copy(n).addScaledVector(fi, o).addScaledVector(mi, a)
        );
      }
      equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
      }
    }
    let wi = 0;
    class _i extends Bn {
      constructor() {
        super(),
          Object.defineProperty(this, "id", {
            value: wi++,
          }),
          (this.uuid = Hn()),
          (this.name = ""),
          (this.type = "Material"),
          (this.fog = !0),
          (this.blending = b),
          (this.side = f),
          (this.vertexColors = !1),
          (this.opacity = 1),
          (this.format = Ne),
          (this.transparent = !1),
          (this.blendSrc = D),
          (this.blendDst = O),
          (this.blendEquation = T),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = j),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.stencilWriteMask = 255),
          (this.stencilFunc = Sn),
          (this.stencilRef = 0),
          (this.stencilFuncMask = 255),
          (this.stencilFail = un),
          (this.stencilZFail = un),
          (this.stencilZPass = un),
          (this.stencilWrite = !1),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaToCoverage = !1),
          (this.premultipliedAlpha = !1),
          (this.visible = !0),
          (this.toneMapped = !0),
          (this.userData = {}),
          (this.version = 0),
          (this._alphaTest = 0);
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
      }
      onBuild() {}
      onBeforeCompile() {}
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(e) {
        if (void 0 !== e)
          for (const t in e) {
            const n = e[t];
            if (void 0 === n) {
              console.warn(
                "THREE.Material: '" + t + "' parameter is undefined."
              );
              continue;
            }
            if ("shading" === t) {
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
              ),
                (this.flatShading = n === v);
              continue;
            }
            const r = this[t];
            void 0 !== r
              ? r && r.isColor
                ? r.set(n)
                : r && r.isVector3 && n && n.isVector3
                ? r.copy(n)
                : (this[t] = n)
              : console.warn(
                  "THREE." +
                    this.type +
                    ": '" +
                    t +
                    "' is not a property of this material."
                );
          }
      }
      toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        t &&
          (e = {
            textures: {},
            images: {},
          });
        const n = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON",
          },
        };

        function r(e) {
          const t = [];
          for (const n in e) {
            const r = e[n];
            delete r.metadata, t.push(r);
          }
          return t;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          "" !== this.name && (n.name = this.name),
          this.color && this.color.isColor && (n.color = this.color.getHex()),
          void 0 !== this.roughness && (n.roughness = this.roughness),
          void 0 !== this.metalness && (n.metalness = this.metalness),
          this.sheenTint &&
            this.sheenTint.isColor &&
            (n.sheenTint = this.sheenTint.getHex()),
          this.emissive &&
            this.emissive.isColor &&
            (n.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            1 !== this.emissiveIntensity &&
            (n.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (n.specular = this.specular.getHex()),
          void 0 !== this.specularIntensity &&
            (n.specularIntensity = this.specularIntensity),
          this.specularTint &&
            this.specularTint.isColor &&
            (n.specularTint = this.specularTint.getHex()),
          void 0 !== this.shininess && (n.shininess = this.shininess),
          void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness &&
            (n.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap &&
            this.clearcoatMap.isTexture &&
            (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
          this.clearcoatRoughnessMap &&
            this.clearcoatRoughnessMap.isTexture &&
            (n.clearcoatRoughnessMap =
              this.clearcoatRoughnessMap.toJSON(e).uuid),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (n.matcap = this.matcap.toJSON(e).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (n.alphaMap = this.alphaMap.toJSON(e).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            ((n.lightMap = this.lightMap.toJSON(e).uuid),
            (n.lightMapIntensity = this.lightMapIntensity)),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((n.aoMap = this.aoMap.toJSON(e).uuid),
            (n.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
            (n.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((n.normalMap = this.normalMap.toJSON(e).uuid),
            (n.normalMapType = this.normalMapType),
            (n.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
            (n.displacementScale = this.displacementScale),
            (n.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (n.specularMap = this.specularMap.toJSON(e).uuid),
          this.specularIntensityMap &&
            this.specularIntensityMap.isTexture &&
            (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
          this.specularTintMap &&
            this.specularTintMap.isTexture &&
            (n.specularTintMap = this.specularTintMap.toJSON(e).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((n.envMap = this.envMap.toJSON(e).uuid),
            void 0 !== this.combine && (n.combine = this.combine)),
          void 0 !== this.envMapIntensity &&
            (n.envMapIntensity = this.envMapIntensity),
          void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
          void 0 !== this.refractionRatio &&
            (n.refractionRatio = this.refractionRatio),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (n.gradientMap = this.gradientMap.toJSON(e).uuid),
          void 0 !== this.transmission && (n.transmission = this.transmission),
          this.transmissionMap &&
            this.transmissionMap.isTexture &&
            (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
          void 0 !== this.thickness && (n.thickness = this.thickness),
          this.thicknessMap &&
            this.thicknessMap.isTexture &&
            (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
          void 0 !== this.attenuationDistance &&
            (n.attenuationDistance = this.attenuationDistance),
          void 0 !== this.attenuationTint &&
            (n.attenuationTint = this.attenuationTint.getHex()),
          void 0 !== this.size && (n.size = this.size),
          null !== this.shadowSide && (n.shadowSide = this.shadowSide),
          void 0 !== this.sizeAttenuation &&
            (n.sizeAttenuation = this.sizeAttenuation),
          this.blending !== b && (n.blending = this.blending),
          this.side !== f && (n.side = this.side),
          this.vertexColors && (n.vertexColors = !0),
          this.opacity < 1 && (n.opacity = this.opacity),
          this.format !== Ne && (n.format = this.format),
          !0 === this.transparent && (n.transparent = this.transparent),
          (n.depthFunc = this.depthFunc),
          (n.depthTest = this.depthTest),
          (n.depthWrite = this.depthWrite),
          (n.colorWrite = this.colorWrite),
          (n.stencilWrite = this.stencilWrite),
          (n.stencilWriteMask = this.stencilWriteMask),
          (n.stencilFunc = this.stencilFunc),
          (n.stencilRef = this.stencilRef),
          (n.stencilFuncMask = this.stencilFuncMask),
          (n.stencilFail = this.stencilFail),
          (n.stencilZFail = this.stencilZFail),
          (n.stencilZPass = this.stencilZPass),
          this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
          !0 === this.polygonOffset && (n.polygonOffset = !0),
          0 !== this.polygonOffsetFactor &&
            (n.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits &&
            (n.polygonOffsetUnits = this.polygonOffsetUnits),
          this.linewidth &&
            1 !== this.linewidth &&
            (n.linewidth = this.linewidth),
          void 0 !== this.dashSize && (n.dashSize = this.dashSize),
          void 0 !== this.gapSize && (n.gapSize = this.gapSize),
          void 0 !== this.scale && (n.scale = this.scale),
          !0 === this.dithering && (n.dithering = !0),
          this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
          !0 === this.alphaToCoverage &&
            (n.alphaToCoverage = this.alphaToCoverage),
          !0 === this.premultipliedAlpha &&
            (n.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (n.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (n.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (n.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (n.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.flatShading && (n.flatShading = this.flatShading),
          !1 === this.visible && (n.visible = !1),
          !1 === this.toneMapped && (n.toneMapped = !1),
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          t)
        ) {
          const t = r(e.textures),
            i = r(e.images);
          t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i);
        }
        return n;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        (this.name = e.name),
          (this.fog = e.fog),
          (this.blending = e.blending),
          (this.side = e.side),
          (this.vertexColors = e.vertexColors),
          (this.opacity = e.opacity),
          (this.format = e.format),
          (this.transparent = e.transparent),
          (this.blendSrc = e.blendSrc),
          (this.blendDst = e.blendDst),
          (this.blendEquation = e.blendEquation),
          (this.blendSrcAlpha = e.blendSrcAlpha),
          (this.blendDstAlpha = e.blendDstAlpha),
          (this.blendEquationAlpha = e.blendEquationAlpha),
          (this.depthFunc = e.depthFunc),
          (this.depthTest = e.depthTest),
          (this.depthWrite = e.depthWrite),
          (this.stencilWriteMask = e.stencilWriteMask),
          (this.stencilFunc = e.stencilFunc),
          (this.stencilRef = e.stencilRef),
          (this.stencilFuncMask = e.stencilFuncMask),
          (this.stencilFail = e.stencilFail),
          (this.stencilZFail = e.stencilZFail),
          (this.stencilZPass = e.stencilZPass),
          (this.stencilWrite = e.stencilWrite);
        const t = e.clippingPlanes;
        let n = null;
        if (null !== t) {
          const e = t.length;
          n = new Array(e);
          for (let r = 0; r !== e; ++r) n[r] = t[r].clone();
        }
        return (
          (this.clippingPlanes = n),
          (this.clipIntersection = e.clipIntersection),
          (this.clipShadows = e.clipShadows),
          (this.shadowSide = e.shadowSide),
          (this.colorWrite = e.colorWrite),
          (this.precision = e.precision),
          (this.polygonOffset = e.polygonOffset),
          (this.polygonOffsetFactor = e.polygonOffsetFactor),
          (this.polygonOffsetUnits = e.polygonOffsetUnits),
          (this.dithering = e.dithering),
          (this.alphaTest = e.alphaTest),
          (this.alphaToCoverage = e.alphaToCoverage),
          (this.premultipliedAlpha = e.premultipliedAlpha),
          (this.visible = e.visible),
          (this.toneMapped = e.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(e.userData))),
          this
        );
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose",
        });
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
    }
    _i.prototype.isMaterial = !0;
    const Mi = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      },
      Si = {
        h: 0,
        s: 0,
        l: 0,
      },
      Ti = {
        h: 0,
        s: 0,
        l: 0,
      };

    function Ei(e, t, n) {
      return (
        n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6
          ? e + 6 * (t - e) * n
          : n < 0.5
          ? t
          : n < 2 / 3
          ? e + 6 * (t - e) * (2 / 3 - n)
          : e
      );
    }

    function Ai(e) {
      return e < 0.04045
        ? 0.0773993808 * e
        : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
    }

    function Ci(e) {
      return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
    }
    class Pi {
      constructor(e, t, n) {
        return void 0 === t && void 0 === n
          ? this.set(e)
          : this.setRGB(e, t, n);
      }
      set(e) {
        return (
          e && e.isColor
            ? this.copy(e)
            : "number" == typeof e
            ? this.setHex(e)
            : "string" == typeof e && this.setStyle(e),
          this
        );
      }
      setScalar(e) {
        return (this.r = e), (this.g = e), (this.b = e), this;
      }
      setHex(e) {
        return (
          (e = Math.floor(e)),
          (this.r = ((e >> 16) & 255) / 255),
          (this.g = ((e >> 8) & 255) / 255),
          (this.b = (255 & e) / 255),
          this
        );
      }
      setRGB(e, t, n) {
        return (this.r = e), (this.g = t), (this.b = n), this;
      }
      setHSL(e, t, n) {
        if (((e = Vn(e, 1)), (t = Gn(t, 0, 1)), (n = Gn(n, 0, 1)), 0 === t))
          this.r = this.g = this.b = n;
        else {
          const r = n <= 0.5 ? n * (1 + t) : n + t - n * t,
            i = 2 * n - r;
          (this.r = Ei(i, r, e + 1 / 3)),
            (this.g = Ei(i, r, e)),
            (this.b = Ei(i, r, e - 1 / 3));
        }
        return this;
      }
      setStyle(e) {
        function t(t) {
          void 0 !== t &&
            parseFloat(t) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + e + " will be ignored."
            );
        }
        let n;
        if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
          let e;
          const r = n[1],
            i = n[2];
          switch (r) {
            case "rgb":
            case "rgba":
              if (
                (e =
                  /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    i
                  ))
              )
                return (
                  (this.r = Math.min(255, parseInt(e[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(e[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(e[3], 10)) / 255),
                  t(e[4]),
                  this
                );
              if (
                (e =
                  /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    i
                  ))
              )
                return (
                  (this.r = Math.min(100, parseInt(e[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(e[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(e[3], 10)) / 100),
                  t(e[4]),
                  this
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (e =
                  /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    i
                  ))
              ) {
                const n = parseFloat(e[1]) / 360,
                  r = parseInt(e[2], 10) / 100,
                  i = parseInt(e[3], 10) / 100;
                return t(e[4]), this.setHSL(n, r, i);
              }
          }
        } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
          const e = n[1],
            t = e.length;
          if (3 === t)
            return (
              (this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255),
              (this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255),
              (this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255),
              this
            );
          if (6 === t)
            return (
              (this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255),
              (this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255),
              (this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255),
              this
            );
        }
        return e && e.length > 0 ? this.setColorName(e) : this;
      }
      setColorName(e) {
        const t = Mi[e.toLowerCase()];
        return (
          void 0 !== t
            ? this.setHex(t)
            : console.warn("THREE.Color: Unknown color " + e),
          this
        );
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(e) {
        return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
      }
      copyGammaToLinear(e, t = 2) {
        return (
          (this.r = Math.pow(e.r, t)),
          (this.g = Math.pow(e.g, t)),
          (this.b = Math.pow(e.b, t)),
          this
        );
      }
      copyLinearToGamma(e, t = 2) {
        const n = t > 0 ? 1 / t : 1;
        return (
          (this.r = Math.pow(e.r, n)),
          (this.g = Math.pow(e.g, n)),
          (this.b = Math.pow(e.b, n)),
          this
        );
      }
      convertGammaToLinear(e) {
        return this.copyGammaToLinear(this, e), this;
      }
      convertLinearToGamma(e) {
        return this.copyLinearToGamma(this, e), this;
      }
      copySRGBToLinear(e) {
        return (this.r = Ai(e.r)), (this.g = Ai(e.g)), (this.b = Ai(e.b)), this;
      }
      copyLinearToSRGB(e) {
        return (this.r = Ci(e.r)), (this.g = Ci(e.g)), (this.b = Ci(e.b)), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex() {
        return (
          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        );
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }
      getHSL(e) {
        const t = this.r,
          n = this.g,
          r = this.b,
          i = Math.max(t, n, r),
          o = Math.min(t, n, r);
        let a, s;
        const l = (o + i) / 2;
        if (o === i) (a = 0), (s = 0);
        else {
          const e = i - o;
          switch (((s = l <= 0.5 ? e / (i + o) : e / (2 - i - o)), i)) {
            case t:
              a = (n - r) / e + (n < r ? 6 : 0);
              break;
            case n:
              a = (r - t) / e + 2;
              break;
            case r:
              a = (t - n) / e + 4;
          }
          a /= 6;
        }
        return (e.h = a), (e.s = s), (e.l = l), e;
      }
      getStyle() {
        return (
          "rgb(" +
          ((255 * this.r) | 0) +
          "," +
          ((255 * this.g) | 0) +
          "," +
          ((255 * this.b) | 0) +
          ")"
        );
      }
      offsetHSL(e, t, n) {
        return (
          this.getHSL(Si),
          (Si.h += e),
          (Si.s += t),
          (Si.l += n),
          this.setHSL(Si.h, Si.s, Si.l),
          this
        );
      }
      add(e) {
        return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
      }
      addColors(e, t) {
        return (
          (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
        );
      }
      addScalar(e) {
        return (this.r += e), (this.g += e), (this.b += e), this;
      }
      sub(e) {
        return (
          (this.r = Math.max(0, this.r - e.r)),
          (this.g = Math.max(0, this.g - e.g)),
          (this.b = Math.max(0, this.b - e.b)),
          this
        );
      }
      multiply(e) {
        return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
      }
      multiplyScalar(e) {
        return (this.r *= e), (this.g *= e), (this.b *= e), this;
      }
      lerp(e, t) {
        return (
          (this.r += (e.r - this.r) * t),
          (this.g += (e.g - this.g) * t),
          (this.b += (e.b - this.b) * t),
          this
        );
      }
      lerpColors(e, t, n) {
        return (
          (this.r = e.r + (t.r - e.r) * n),
          (this.g = e.g + (t.g - e.g) * n),
          (this.b = e.b + (t.b - e.b) * n),
          this
        );
      }
      lerpHSL(e, t) {
        this.getHSL(Si), e.getHSL(Ti);
        const n = jn(Si.h, Ti.h, t),
          r = jn(Si.s, Ti.s, t),
          i = jn(Si.l, Ti.l, t);
        return this.setHSL(n, r, i), this;
      }
      equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
      }
      fromArray(e, t = 0) {
        return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
      }
      toArray(e = [], t = 0) {
        return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
      }
      fromBufferAttribute(e, t) {
        return (
          (this.r = e.getX(t)),
          (this.g = e.getY(t)),
          (this.b = e.getZ(t)),
          !0 === e.normalized &&
            ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
          this
        );
      }
      toJSON() {
        return this.getHex();
      }
    }
    (Pi.NAMES = Mi),
      (Pi.prototype.isColor = !0),
      (Pi.prototype.r = 1),
      (Pi.prototype.g = 1),
      (Pi.prototype.b = 1);
    class Li extends _i {
      constructor(e) {
        super(),
          (this.type = "MeshBasicMaterial"),
          (this.color = new Pi(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Y),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          this
        );
      }
    }
    Li.prototype.isMeshBasicMaterial = !0;
    const Ri = new sr(),
      Ii = new Yn();
    class ki {
      constructor(e, t, n) {
        if (Array.isArray(e))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array."
          );
        (this.name = ""),
          (this.array = e),
          (this.itemSize = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.normalized = !0 === n),
          (this.usage = Tn),
          (this.updateRange = {
            offset: 0,
            count: -1,
          }),
          (this.version = 0);
      }
      onUploadCallback() {}
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.name = e.name),
          (this.array = new e.array.constructor(e.array)),
          (this.itemSize = e.itemSize),
          (this.count = e.count),
          (this.normalized = e.normalized),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, n) {
        (e *= this.itemSize), (n *= t.itemSize);
        for (let r = 0, i = this.itemSize; r < i; r++)
          this.array[e + r] = t.array[n + r];
        return this;
      }
      copyArray(e) {
        return this.array.set(e), this;
      }
      copyColorsArray(e) {
        const t = this.array;
        let n = 0;
        for (let r = 0, i = e.length; r < i; r++) {
          let i = e[r];
          void 0 === i &&
            (console.warn(
              "THREE.BufferAttribute.copyColorsArray(): color is undefined",
              r
            ),
            (i = new Pi())),
            (t[n++] = i.r),
            (t[n++] = i.g),
            (t[n++] = i.b);
        }
        return this;
      }
      copyVector2sArray(e) {
        const t = this.array;
        let n = 0;
        for (let r = 0, i = e.length; r < i; r++) {
          let i = e[r];
          void 0 === i &&
            (console.warn(
              "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
              r
            ),
            (i = new Yn())),
            (t[n++] = i.x),
            (t[n++] = i.y);
        }
        return this;
      }
      copyVector3sArray(e) {
        const t = this.array;
        let n = 0;
        for (let r = 0, i = e.length; r < i; r++) {
          let i = e[r];
          void 0 === i &&
            (console.warn(
              "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
              r
            ),
            (i = new sr())),
            (t[n++] = i.x),
            (t[n++] = i.y),
            (t[n++] = i.z);
        }
        return this;
      }
      copyVector4sArray(e) {
        const t = this.array;
        let n = 0;
        for (let r = 0, i = e.length; r < i; r++) {
          let i = e[r];
          void 0 === i &&
            (console.warn(
              "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
              r
            ),
            (i = new nr())),
            (t[n++] = i.x),
            (t[n++] = i.y),
            (t[n++] = i.z),
            (t[n++] = i.w);
        }
        return this;
      }
      applyMatrix3(e) {
        if (2 === this.itemSize)
          for (let t = 0, n = this.count; t < n; t++)
            Ii.fromBufferAttribute(this, t),
              Ii.applyMatrix3(e),
              this.setXY(t, Ii.x, Ii.y);
        else if (3 === this.itemSize)
          for (let t = 0, n = this.count; t < n; t++)
            Ri.fromBufferAttribute(this, t),
              Ri.applyMatrix3(e),
              this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this;
      }
      applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Ri.x = this.getX(t)),
            (Ri.y = this.getY(t)),
            (Ri.z = this.getZ(t)),
            Ri.applyMatrix4(e),
            this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Ri.x = this.getX(t)),
            (Ri.y = this.getY(t)),
            (Ri.z = this.getZ(t)),
            Ri.applyNormalMatrix(e),
            this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Ri.x = this.getX(t)),
            (Ri.y = this.getY(t)),
            (Ri.z = this.getZ(t)),
            Ri.transformDirection(e),
            this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      getX(e) {
        return this.array[e * this.itemSize];
      }
      setX(e, t) {
        return (this.array[e * this.itemSize] = t), this;
      }
      getY(e) {
        return this.array[e * this.itemSize + 1];
      }
      setY(e, t) {
        return (this.array[e * this.itemSize + 1] = t), this;
      }
      getZ(e) {
        return this.array[e * this.itemSize + 2];
      }
      setZ(e, t) {
        return (this.array[e * this.itemSize + 2] = t), this;
      }
      getW(e) {
        return this.array[e * this.itemSize + 3];
      }
      setW(e, t) {
        return (this.array[e * this.itemSize + 3] = t), this;
      }
      setXY(e, t, n) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          this
        );
      }
      setXYZ(e, t, n, r) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          (this.array[e + 2] = r),
          this
        );
      }
      setXYZW(e, t, n, r, i) {
        return (
          (e *= this.itemSize),
          (this.array[e + 0] = t),
          (this.array[e + 1] = n),
          (this.array[e + 2] = r),
          (this.array[e + 3] = i),
          this
        );
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const e = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized,
        };
        return (
          "" !== this.name && (e.name = this.name),
          this.usage !== Tn && (e.usage = this.usage),
          (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
            (e.updateRange = this.updateRange),
          e
        );
      }
    }
    ki.prototype.isBufferAttribute = !0;
    class Di extends ki {
      constructor(e, t, n) {
        super(new Int8Array(e), t, n);
      }
    }
    class Oi extends ki {
      constructor(e, t, n) {
        super(new Uint8Array(e), t, n);
      }
    }
    class Bi extends ki {
      constructor(e, t, n) {
        super(new Uint8ClampedArray(e), t, n);
      }
    }
    class Fi extends ki {
      constructor(e, t, n) {
        super(new Int16Array(e), t, n);
      }
    }
    class Ni extends ki {
      constructor(e, t, n) {
        super(new Uint16Array(e), t, n);
      }
    }
    class Ui extends ki {
      constructor(e, t, n) {
        super(new Int32Array(e), t, n);
      }
    }
    class zi extends ki {
      constructor(e, t, n) {
        super(new Uint32Array(e), t, n);
      }
    }
    class Hi extends ki {
      constructor(e, t, n) {
        super(new Uint16Array(e), t, n);
      }
    }
    Hi.prototype.isFloat16BufferAttribute = !0;
    class Gi extends ki {
      constructor(e, t, n) {
        super(new Float32Array(e), t, n);
      }
    }
    class Vi extends ki {
      constructor(e, t, n) {
        super(new Float64Array(e), t, n);
      }
    }

    function ji(e) {
      if (0 === e.length) return -1 / 0;
      let t = e[0];
      for (let n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
      return t;
    }
    const Wi = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray: Uint8ClampedArray,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array,
    };

    function qi(e, t) {
      return new Wi[e](t);
    }
    let $i = 0;
    const Xi = new Nr(),
      Yi = new ci(),
      Ji = new sr(),
      Zi = new ur(),
      Ki = new ur(),
      Qi = new sr();
    class eo extends Bn {
      constructor() {
        super(),
          Object.defineProperty(this, "id", {
            value: $i++,
          }),
          (this.uuid = Hn()),
          (this.name = ""),
          (this.type = "BufferGeometry"),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.morphTargetsRelative = !1),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = {
            start: 0,
            count: 1 / 0,
          }),
          (this.userData = {});
      }
      getIndex() {
        return this.index;
      }
      setIndex(e) {
        return (
          Array.isArray(e)
            ? (this.index = new (ji(e) > 65535 ? zi : Ni)(e, 1))
            : (this.index = e),
          this
        );
      }
      getAttribute(e) {
        return this.attributes[e];
      }
      setAttribute(e, t) {
        return (this.attributes[e] = t), this;
      }
      deleteAttribute(e) {
        return delete this.attributes[e], this;
      }
      hasAttribute(e) {
        return void 0 !== this.attributes[e];
      }
      addGroup(e, t, n = 0) {
        this.groups.push({
          start: e,
          count: t,
          materialIndex: n,
        });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(e, t) {
        (this.drawRange.start = e), (this.drawRange.count = t);
      }
      applyMatrix4(e) {
        const t = this.attributes.position;
        void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
        const n = this.attributes.normal;
        if (void 0 !== n) {
          const t = new Jn().getNormalMatrix(e);
          n.applyNormalMatrix(t), (n.needsUpdate = !0);
        }
        const r = this.attributes.tangent;
        return (
          void 0 !== r && (r.transformDirection(e), (r.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      }
      applyQuaternion(e) {
        return Xi.makeRotationFromQuaternion(e), this.applyMatrix4(Xi), this;
      }
      rotateX(e) {
        return Xi.makeRotationX(e), this.applyMatrix4(Xi), this;
      }
      rotateY(e) {
        return Xi.makeRotationY(e), this.applyMatrix4(Xi), this;
      }
      rotateZ(e) {
        return Xi.makeRotationZ(e), this.applyMatrix4(Xi), this;
      }
      translate(e, t, n) {
        return Xi.makeTranslation(e, t, n), this.applyMatrix4(Xi), this;
      }
      scale(e, t, n) {
        return Xi.makeScale(e, t, n), this.applyMatrix4(Xi), this;
      }
      lookAt(e) {
        return (
          Yi.lookAt(e), Yi.updateMatrix(), this.applyMatrix4(Yi.matrix), this
        );
      }
      center() {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(Ji).negate(),
          this.translate(Ji.x, Ji.y, Ji.z),
          this
        );
      }
      setFromPoints(e) {
        const t = [];
        for (let n = 0, r = e.length; n < r; n++) {
          const r = e[n];
          t.push(r.x, r.y, r.z || 0);
        }
        return this.setAttribute("position", new Gi(t, 3)), this;
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new ur());
        const e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingBox.set(
              new sr(-1 / 0, -1 / 0, -1 / 0),
              new sr(1 / 0, 1 / 0, 1 / 0)
            )
          );
        if (void 0 !== e) {
          if ((this.boundingBox.setFromBufferAttribute(e), t))
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e];
              Zi.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (Qi.addVectors(this.boundingBox.min, Zi.min),
                    this.boundingBox.expandByPoint(Qi),
                    Qi.addVectors(this.boundingBox.max, Zi.max),
                    this.boundingBox.expandByPoint(Qi))
                  : (this.boundingBox.expandByPoint(Zi.min),
                    this.boundingBox.expandByPoint(Zi.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new Pr());
        const e = this.attributes.position,
          t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingSphere.set(new sr(), 1 / 0)
          );
        if (e) {
          const n = this.boundingSphere.center;
          if ((Zi.setFromBufferAttribute(e), t))
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e];
              Ki.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (Qi.addVectors(Zi.min, Ki.min),
                    Zi.expandByPoint(Qi),
                    Qi.addVectors(Zi.max, Ki.max),
                    Zi.expandByPoint(Qi))
                  : (Zi.expandByPoint(Ki.min), Zi.expandByPoint(Ki.max));
            }
          Zi.getCenter(n);
          let r = 0;
          for (let t = 0, i = e.count; t < i; t++)
            Qi.fromBufferAttribute(e, t),
              (r = Math.max(r, n.distanceToSquared(Qi)));
          if (t)
            for (let i = 0, o = t.length; i < o; i++) {
              const o = t[i],
                a = this.morphTargetsRelative;
              for (let t = 0, i = o.count; t < i; t++)
                Qi.fromBufferAttribute(o, t),
                  a && (Ji.fromBufferAttribute(e, t), Qi.add(Ji)),
                  (r = Math.max(r, n.distanceToSquared(Qi)));
            }
          (this.boundingSphere.radius = Math.sqrt(r)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      }
      computeTangents() {
        const e = this.index,
          t = this.attributes;
        if (
          null === e ||
          void 0 === t.position ||
          void 0 === t.normal ||
          void 0 === t.uv
        )
          return void console.error(
            "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
          );
        const n = e.array,
          r = t.position.array,
          i = t.normal.array,
          o = t.uv.array,
          a = r.length / 3;
        void 0 === t.tangent &&
          this.setAttribute("tangent", new ki(new Float32Array(4 * a), 4));
        const s = t.tangent.array,
          l = [],
          c = [];
        for (let e = 0; e < a; e++) (l[e] = new sr()), (c[e] = new sr());
        const u = new sr(),
          h = new sr(),
          d = new sr(),
          p = new Yn(),
          f = new Yn(),
          m = new Yn(),
          g = new sr(),
          v = new sr();

        function y(e, t, n) {
          u.fromArray(r, 3 * e),
            h.fromArray(r, 3 * t),
            d.fromArray(r, 3 * n),
            p.fromArray(o, 2 * e),
            f.fromArray(o, 2 * t),
            m.fromArray(o, 2 * n),
            h.sub(u),
            d.sub(u),
            f.sub(p),
            m.sub(p);
          const i = 1 / (f.x * m.y - m.x * f.y);
          isFinite(i) &&
            (g
              .copy(h)
              .multiplyScalar(m.y)
              .addScaledVector(d, -f.y)
              .multiplyScalar(i),
            v
              .copy(d)
              .multiplyScalar(f.x)
              .addScaledVector(h, -m.x)
              .multiplyScalar(i),
            l[e].add(g),
            l[t].add(g),
            l[n].add(g),
            c[e].add(v),
            c[t].add(v),
            c[n].add(v));
        }
        let x = this.groups;
        0 === x.length &&
          (x = [
            {
              start: 0,
              count: n.length,
            },
          ]);
        for (let e = 0, t = x.length; e < t; ++e) {
          const t = x[e],
            r = t.start;
          for (let e = r, i = r + t.count; e < i; e += 3)
            y(n[e + 0], n[e + 1], n[e + 2]);
        }
        const b = new sr(),
          w = new sr(),
          _ = new sr(),
          M = new sr();

        function S(e) {
          _.fromArray(i, 3 * e), M.copy(_);
          const t = l[e];
          b.copy(t),
            b.sub(_.multiplyScalar(_.dot(t))).normalize(),
            w.crossVectors(M, t);
          const n = w.dot(c[e]) < 0 ? -1 : 1;
          (s[4 * e] = b.x),
            (s[4 * e + 1] = b.y),
            (s[4 * e + 2] = b.z),
            (s[4 * e + 3] = n);
        }
        for (let e = 0, t = x.length; e < t; ++e) {
          const t = x[e],
            r = t.start;
          for (let e = r, i = r + t.count; e < i; e += 3)
            S(n[e + 0]), S(n[e + 1]), S(n[e + 2]);
        }
      }
      computeVertexNormals() {
        const e = this.index,
          t = this.getAttribute("position");
        if (void 0 !== t) {
          let n = this.getAttribute("normal");
          if (void 0 === n)
            (n = new ki(new Float32Array(3 * t.count), 3)),
              this.setAttribute("normal", n);
          else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
          const r = new sr(),
            i = new sr(),
            o = new sr(),
            a = new sr(),
            s = new sr(),
            l = new sr(),
            c = new sr(),
            u = new sr();
          if (e)
            for (let h = 0, d = e.count; h < d; h += 3) {
              const d = e.getX(h + 0),
                p = e.getX(h + 1),
                f = e.getX(h + 2);
              r.fromBufferAttribute(t, d),
                i.fromBufferAttribute(t, p),
                o.fromBufferAttribute(t, f),
                c.subVectors(o, i),
                u.subVectors(r, i),
                c.cross(u),
                a.fromBufferAttribute(n, d),
                s.fromBufferAttribute(n, p),
                l.fromBufferAttribute(n, f),
                a.add(c),
                s.add(c),
                l.add(c),
                n.setXYZ(d, a.x, a.y, a.z),
                n.setXYZ(p, s.x, s.y, s.z),
                n.setXYZ(f, l.x, l.y, l.z);
            }
          else
            for (let e = 0, a = t.count; e < a; e += 3)
              r.fromBufferAttribute(t, e + 0),
                i.fromBufferAttribute(t, e + 1),
                o.fromBufferAttribute(t, e + 2),
                c.subVectors(o, i),
                u.subVectors(r, i),
                c.cross(u),
                n.setXYZ(e + 0, c.x, c.y, c.z),
                n.setXYZ(e + 1, c.x, c.y, c.z),
                n.setXYZ(e + 2, c.x, c.y, c.z);
          this.normalizeNormals(), (n.needsUpdate = !0);
        }
      }
      merge(e, t) {
        if (!e || !e.isBufferGeometry)
          return void console.error(
            "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
            e
          );
        void 0 === t &&
          ((t = 0),
          console.warn(
            "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
          ));
        const n = this.attributes;
        for (const r in n) {
          if (void 0 === e.attributes[r]) continue;
          const i = n[r].array,
            o = e.attributes[r],
            a = o.array,
            s = o.itemSize * t,
            l = Math.min(a.length, i.length - s);
          for (let e = 0, t = s; e < l; e++, t++) i[t] = a[e];
        }
        return this;
      }
      normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
          Qi.fromBufferAttribute(e, t),
            Qi.normalize(),
            e.setXYZ(t, Qi.x, Qi.y, Qi.z);
      }
      toNonIndexed() {
        function e(e, t) {
          const n = e.array,
            r = e.itemSize,
            i = e.normalized,
            o = new n.constructor(t.length * r);
          let a = 0,
            s = 0;
          for (let i = 0, l = t.length; i < l; i++) {
            a = e.isInterleavedBufferAttribute
              ? t[i] * e.data.stride + e.offset
              : t[i] * r;
            for (let e = 0; e < r; e++) o[s++] = n[a++];
          }
          return new ki(o, r, i);
        }
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
            ),
            this
          );
        const t = new eo(),
          n = this.index.array,
          r = this.attributes;
        for (const i in r) {
          const o = e(r[i], n);
          t.setAttribute(i, o);
        }
        const i = this.morphAttributes;
        for (const r in i) {
          const o = [],
            a = i[r];
          for (let t = 0, r = a.length; t < r; t++) {
            const r = e(a[t], n);
            o.push(r);
          }
          t.morphAttributes[r] = o;
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let e = 0, n = o.length; e < n; e++) {
          const n = o[e];
          t.addGroup(n.start, n.count, n.materialIndex);
        }
        return t;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((e.uuid = this.uuid),
          (e.type = this.type),
          "" !== this.name && (e.name = this.name),
          Object.keys(this.userData).length > 0 && (e.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          const t = this.parameters;
          for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
          return e;
        }
        e.data = {
          attributes: {},
        };
        const t = this.index;
        null !== t &&
          (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array),
          });
        const n = this.attributes;
        for (const t in n) {
          const r = n[t];
          e.data.attributes[t] = r.toJSON(e.data);
        }
        const r = {};
        let i = !1;
        for (const t in this.morphAttributes) {
          const n = this.morphAttributes[t],
            o = [];
          for (let t = 0, r = n.length; t < r; t++) {
            const r = n[t];
            o.push(r.toJSON(e.data));
          }
          o.length > 0 && ((r[t] = o), (i = !0));
        }
        i &&
          ((e.data.morphAttributes = r),
          (e.data.morphTargetsRelative = this.morphTargetsRelative));
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return (
          null !== a &&
            (e.data.boundingSphere = {
              center: a.center.toArray(),
              radius: a.radius,
            }),
          e
        );
      }
      clone() {
        return new eo().copy(this);
      }
      copy(e) {
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null);
        const t = {};
        this.name = e.name;
        const n = e.index;
        null !== n && this.setIndex(n.clone(t));
        const r = e.attributes;
        for (const e in r) {
          const n = r[e];
          this.setAttribute(e, n.clone(t));
        }
        const i = e.morphAttributes;
        for (const e in i) {
          const n = [],
            r = i[e];
          for (let e = 0, i = r.length; e < i; e++) n.push(r[e].clone(t));
          this.morphAttributes[e] = n;
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let e = 0, t = o.length; e < t; e++) {
          const t = o[e];
          this.addGroup(t.start, t.count, t.materialIndex);
        }
        const a = e.boundingBox;
        null !== a && (this.boundingBox = a.clone());
        const s = e.boundingSphere;
        return (
          null !== s && (this.boundingSphere = s.clone()),
          (this.drawRange.start = e.drawRange.start),
          (this.drawRange.count = e.drawRange.count),
          (this.userData = e.userData),
          this
        );
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose",
        });
      }
    }
    eo.prototype.isBufferGeometry = !0;
    const to = new Nr(),
      no = new Fr(),
      ro = new Pr(),
      io = new sr(),
      oo = new sr(),
      ao = new sr(),
      so = new sr(),
      lo = new sr(),
      co = new sr(),
      uo = new sr(),
      ho = new sr(),
      po = new sr(),
      fo = new Yn(),
      mo = new Yn(),
      go = new Yn(),
      vo = new sr(),
      yo = new sr();
    class xo extends ci {
      constructor(e = new eo(), t = new Li()) {
        super(),
          (this.type = "Mesh"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e) {
        return (
          super.copy(e),
          void 0 !== e.morphTargetInfluences &&
            (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
          void 0 !== e.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              e.morphTargetDictionary
            )),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      updateMorphTargets() {
        const e = this.geometry;
        if (e.isBufferGeometry) {
          const t = e.morphAttributes,
            n = Object.keys(t);
          if (n.length > 0) {
            const e = t[n[0]];
            if (void 0 !== e) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
              }
            }
          }
        } else {
          const t = e.morphTargets;
          void 0 !== t &&
            t.length > 0 &&
            console.error(
              "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
      raycast(e, t) {
        const n = this.geometry,
          r = this.material,
          i = this.matrixWorld;
        if (void 0 === r) return;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          ro.copy(n.boundingSphere),
          ro.applyMatrix4(i),
          !1 === e.ray.intersectsSphere(ro))
        )
          return;
        if (
          (to.copy(i).invert(),
          no.copy(e.ray).applyMatrix4(to),
          null !== n.boundingBox && !1 === no.intersectsBox(n.boundingBox))
        )
          return;
        let o;
        if (n.isBufferGeometry) {
          const i = n.index,
            a = n.attributes.position,
            s = n.morphAttributes.position,
            l = n.morphTargetsRelative,
            c = n.attributes.uv,
            u = n.attributes.uv2,
            h = n.groups,
            d = n.drawRange;
          if (null !== i)
            if (Array.isArray(r))
              for (let n = 0, p = h.length; n < p; n++) {
                const p = h[n],
                  f = r[p.materialIndex];
                for (
                  let n = Math.max(p.start, d.start),
                    r = Math.min(p.start + p.count, d.start + d.count);
                  n < r;
                  n += 3
                ) {
                  const r = i.getX(n),
                    h = i.getX(n + 1),
                    d = i.getX(n + 2);
                  (o = bo(this, f, e, no, a, s, l, c, u, r, h, d)),
                    o &&
                      ((o.faceIndex = Math.floor(n / 3)),
                      (o.face.materialIndex = p.materialIndex),
                      t.push(o));
                }
              }
            else {
              for (
                let n = Math.max(0, d.start),
                  h = Math.min(i.count, d.start + d.count);
                n < h;
                n += 3
              ) {
                const h = i.getX(n),
                  d = i.getX(n + 1),
                  p = i.getX(n + 2);
                (o = bo(this, r, e, no, a, s, l, c, u, h, d, p)),
                  o && ((o.faceIndex = Math.floor(n / 3)), t.push(o));
              }
            }
          else if (void 0 !== a)
            if (Array.isArray(r))
              for (let n = 0, i = h.length; n < i; n++) {
                const i = h[n],
                  p = r[i.materialIndex];
                for (
                  let n = Math.max(i.start, d.start),
                    r = Math.min(i.start + i.count, d.start + d.count);
                  n < r;
                  n += 3
                ) {
                  (o = bo(this, p, e, no, a, s, l, c, u, n, n + 1, n + 2)),
                    o &&
                      ((o.faceIndex = Math.floor(n / 3)),
                      (o.face.materialIndex = i.materialIndex),
                      t.push(o));
                }
              }
            else {
              for (
                let n = Math.max(0, d.start),
                  i = Math.min(a.count, d.start + d.count);
                n < i;
                n += 3
              ) {
                (o = bo(this, r, e, no, a, s, l, c, u, n, n + 1, n + 2)),
                  o && ((o.faceIndex = Math.floor(n / 3)), t.push(o));
              }
            }
        } else
          n.isGeometry &&
            console.error(
              "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
      }
    }

    function bo(e, t, n, r, i, o, a, s, l, c, u, h) {
      io.fromBufferAttribute(i, c),
        oo.fromBufferAttribute(i, u),
        ao.fromBufferAttribute(i, h);
      const d = e.morphTargetInfluences;
      if (o && d) {
        uo.set(0, 0, 0), ho.set(0, 0, 0), po.set(0, 0, 0);
        for (let e = 0, t = o.length; e < t; e++) {
          const t = d[e],
            n = o[e];
          0 !== t &&
            (so.fromBufferAttribute(n, c),
            lo.fromBufferAttribute(n, u),
            co.fromBufferAttribute(n, h),
            a
              ? (uo.addScaledVector(so, t),
                ho.addScaledVector(lo, t),
                po.addScaledVector(co, t))
              : (uo.addScaledVector(so.sub(io), t),
                ho.addScaledVector(lo.sub(oo), t),
                po.addScaledVector(co.sub(ao), t)));
        }
        io.add(uo), oo.add(ho), ao.add(po);
      }
      e.isSkinnedMesh &&
        (e.boneTransform(c, io),
        e.boneTransform(u, oo),
        e.boneTransform(h, ao));
      const p = (function (e, t, n, r, i, o, a, s) {
        let l;
        if (
          ((l =
            t.side === m
              ? r.intersectTriangle(a, o, i, !0, s)
              : r.intersectTriangle(i, o, a, t.side !== g, s)),
          null === l)
        )
          return null;
        yo.copy(s), yo.applyMatrix4(e.matrixWorld);
        const c = n.ray.origin.distanceTo(yo);
        return c < n.near || c > n.far
          ? null
          : {
              distance: c,
              point: yo.clone(),
              object: e,
            };
      })(e, t, n, r, io, oo, ao, vo);
      if (p) {
        s &&
          (fo.fromBufferAttribute(s, c),
          mo.fromBufferAttribute(s, u),
          go.fromBufferAttribute(s, h),
          (p.uv = bi.getUV(vo, io, oo, ao, fo, mo, go, new Yn()))),
          l &&
            (fo.fromBufferAttribute(l, c),
            mo.fromBufferAttribute(l, u),
            go.fromBufferAttribute(l, h),
            (p.uv2 = bi.getUV(vo, io, oo, ao, fo, mo, go, new Yn())));
        const e = {
          a: c,
          b: u,
          c: h,
          normal: new sr(),
          materialIndex: 0,
        };
        bi.getNormal(io, oo, ao, e.normal), (p.face = e);
      }
      return p;
    }
    xo.prototype.isMesh = !0;
    class wo extends eo {
      constructor(e = 1, t = 1, n = 1, r = 1, i = 1, o = 1) {
        super(),
          (this.type = "BoxGeometry"),
          (this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: o,
          });
        const a = this;
        (r = Math.floor(r)), (i = Math.floor(i)), (o = Math.floor(o));
        const s = [],
          l = [],
          c = [],
          u = [];
        let h = 0,
          d = 0;

        function p(e, t, n, r, i, o, p, f, m, g, v) {
          const y = o / m,
            x = p / g,
            b = o / 2,
            w = p / 2,
            _ = f / 2,
            M = m + 1,
            S = g + 1;
          let T = 0,
            E = 0;
          const A = new sr();
          for (let o = 0; o < S; o++) {
            const a = o * x - w;
            for (let s = 0; s < M; s++) {
              const h = s * y - b;
              (A[e] = h * r),
                (A[t] = a * i),
                (A[n] = _),
                l.push(A.x, A.y, A.z),
                (A[e] = 0),
                (A[t] = 0),
                (A[n] = f > 0 ? 1 : -1),
                c.push(A.x, A.y, A.z),
                u.push(s / m),
                u.push(1 - o / g),
                (T += 1);
            }
          }
          for (let e = 0; e < g; e++)
            for (let t = 0; t < m; t++) {
              const n = h + t + M * e,
                r = h + t + M * (e + 1),
                i = h + (t + 1) + M * (e + 1),
                o = h + (t + 1) + M * e;
              s.push(n, r, o), s.push(r, i, o), (E += 6);
            }
          a.addGroup(d, E, v), (d += E), (h += T);
        }
        p("z", "y", "x", -1, -1, n, t, e, o, i, 0),
          p("z", "y", "x", 1, -1, n, t, -e, o, i, 1),
          p("x", "z", "y", 1, 1, e, n, t, r, o, 2),
          p("x", "z", "y", 1, -1, e, n, -t, r, o, 3),
          p("x", "y", "z", 1, -1, e, t, n, r, i, 4),
          p("x", "y", "z", -1, -1, e, t, -n, r, i, 5),
          this.setIndex(s),
          this.setAttribute("position", new Gi(l, 3)),
          this.setAttribute("normal", new Gi(c, 3)),
          this.setAttribute("uv", new Gi(u, 2));
      }
      static fromJSON(e) {
        return new wo(
          e.width,
          e.height,
          e.depth,
          e.widthSegments,
          e.heightSegments,
          e.depthSegments
        );
      }
    }

    function _o(e) {
      const t = {};
      for (const n in e) {
        t[n] = {};
        for (const r in e[n]) {
          const i = e[n][r];
          i &&
          (i.isColor ||
            i.isMatrix3 ||
            i.isMatrix4 ||
            i.isVector2 ||
            i.isVector3 ||
            i.isVector4 ||
            i.isTexture ||
            i.isQuaternion)
            ? (t[n][r] = i.clone())
            : Array.isArray(i)
            ? (t[n][r] = i.slice())
            : (t[n][r] = i);
        }
      }
      return t;
    }

    function Mo(e) {
      const t = {};
      for (let n = 0; n < e.length; n++) {
        const r = _o(e[n]);
        for (const e in r) t[e] = r[e];
      }
      return t;
    }
    const So = {
      clone: _o,
      merge: Mo,
    };
    class To extends _i {
      constructor(e) {
        super(),
          (this.type = "ShaderMaterial"),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.vertexShader =
            "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
          (this.fragmentShader =
            "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0],
          }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          (this.glslVersion = null),
          void 0 !== e &&
            (void 0 !== e.attributes &&
              console.error(
                "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
              ),
            this.setValues(e));
      }
      copy(e) {
        return (
          super.copy(e),
          (this.fragmentShader = e.fragmentShader),
          (this.vertexShader = e.vertexShader),
          (this.uniforms = _o(e.uniforms)),
          (this.defines = Object.assign({}, e.defines)),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.lights = e.lights),
          (this.clipping = e.clipping),
          (this.extensions = Object.assign({}, e.extensions)),
          (this.glslVersion = e.glslVersion),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        (t.glslVersion = this.glslVersion), (t.uniforms = {});
        for (const n in this.uniforms) {
          const r = this.uniforms[n].value;
          r && r.isTexture
            ? (t.uniforms[n] = {
                type: "t",
                value: r.toJSON(e).uuid,
              })
            : r && r.isColor
            ? (t.uniforms[n] = {
                type: "c",
                value: r.getHex(),
              })
            : r && r.isVector2
            ? (t.uniforms[n] = {
                type: "v2",
                value: r.toArray(),
              })
            : r && r.isVector3
            ? (t.uniforms[n] = {
                type: "v3",
                value: r.toArray(),
              })
            : r && r.isVector4
            ? (t.uniforms[n] = {
                type: "v4",
                value: r.toArray(),
              })
            : r && r.isMatrix3
            ? (t.uniforms[n] = {
                type: "m3",
                value: r.toArray(),
              })
            : r && r.isMatrix4
            ? (t.uniforms[n] = {
                type: "m4",
                value: r.toArray(),
              })
            : (t.uniforms[n] = {
                value: r,
              });
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
          (t.vertexShader = this.vertexShader),
          (t.fragmentShader = this.fragmentShader);
        const n = {};
        for (const e in this.extensions)
          !0 === this.extensions[e] && (n[e] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n), t;
      }
    }
    To.prototype.isShaderMaterial = !0;
    class Eo extends ci {
      constructor() {
        super(),
          (this.type = "Camera"),
          (this.matrixWorldInverse = new Nr()),
          (this.projectionMatrix = new Nr()),
          (this.projectionMatrixInverse = new Nr());
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          this.matrixWorldInverse.copy(e.matrixWorldInverse),
          this.projectionMatrix.copy(e.projectionMatrix),
          this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
          this
        );
      }
      getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize();
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    Eo.prototype.isCamera = !0;
    class Ao extends Eo {
      constructor(e = 50, t = 1, n = 0.1, r = 2e3) {
        super(),
          (this.type = "PerspectiveCamera"),
          (this.fov = e),
          (this.zoom = 1),
          (this.near = n),
          (this.far = r),
          (this.focus = 10),
          (this.aspect = t),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.fov = e.fov),
          (this.zoom = e.zoom),
          (this.near = e.near),
          (this.far = e.far),
          (this.focus = e.focus),
          (this.aspect = e.aspect),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          (this.filmGauge = e.filmGauge),
          (this.filmOffset = e.filmOffset),
          this
        );
      }
      setFocalLength(e) {
        const t = (0.5 * this.getFilmHeight()) / e;
        (this.fov = 2 * zn * Math.atan(t)), this.updateProjectionMatrix();
      }
      getFocalLength() {
        const e = Math.tan(0.5 * Un * this.fov);
        return (0.5 * this.getFilmHeight()) / e;
      }
      getEffectiveFOV() {
        return 2 * zn * Math.atan(Math.tan(0.5 * Un * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(e, t, n, r, i, o) {
        (this.aspect = e / t),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = n),
          (this.view.offsetY = r),
          (this.view.width = i),
          (this.view.height = o),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = this.near;
        let t = (e * Math.tan(0.5 * Un * this.fov)) / this.zoom,
          n = 2 * t,
          r = this.aspect * n,
          i = -0.5 * r;
        const o = this.view;
        if (null !== this.view && this.view.enabled) {
          const e = o.fullWidth,
            a = o.fullHeight;
          (i += (o.offsetX * r) / e),
            (t -= (o.offsetY * n) / a),
            (r *= o.width / e),
            (n *= o.height / a);
        }
        const a = this.filmOffset;
        0 !== a && (i += (e * a) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            i,
            i + r,
            t,
            t - n,
            e,
            this.far
          ),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.fov = this.fov),
          (t.object.zoom = this.zoom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          (t.object.focus = this.focus),
          (t.object.aspect = this.aspect),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          (t.object.filmGauge = this.filmGauge),
          (t.object.filmOffset = this.filmOffset),
          t
        );
      }
    }
    Ao.prototype.isPerspectiveCamera = !0;
    class Co extends ci {
      constructor(e, t, n) {
        if (
          (super(),
          (this.type = "CubeCamera"),
          !0 !== n.isWebGLCubeRenderTarget)
        )
          return void console.error(
            "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
          );
        this.renderTarget = n;
        const r = new Ao(90, 1, e, t);
        (r.layers = this.layers),
          r.up.set(0, -1, 0),
          r.lookAt(new sr(1, 0, 0)),
          this.add(r);
        const i = new Ao(90, 1, e, t);
        (i.layers = this.layers),
          i.up.set(0, -1, 0),
          i.lookAt(new sr(-1, 0, 0)),
          this.add(i);
        const o = new Ao(90, 1, e, t);
        (o.layers = this.layers),
          o.up.set(0, 0, 1),
          o.lookAt(new sr(0, 1, 0)),
          this.add(o);
        const a = new Ao(90, 1, e, t);
        (a.layers = this.layers),
          a.up.set(0, 0, -1),
          a.lookAt(new sr(0, -1, 0)),
          this.add(a);
        const s = new Ao(90, 1, e, t);
        (s.layers = this.layers),
          s.up.set(0, -1, 0),
          s.lookAt(new sr(0, 0, 1)),
          this.add(s);
        const l = new Ao(90, 1, e, t);
        (l.layers = this.layers),
          l.up.set(0, -1, 0),
          l.lookAt(new sr(0, 0, -1)),
          this.add(l);
      }
      update(e, t) {
        null === this.parent && this.updateMatrixWorld();
        const n = this.renderTarget,
          [r, i, o, a, s, l] = this.children,
          c = e.xr.enabled,
          u = e.getRenderTarget();
        e.xr.enabled = !1;
        const h = n.texture.generateMipmaps;
        (n.texture.generateMipmaps = !1),
          e.setRenderTarget(n, 0),
          e.render(t, r),
          e.setRenderTarget(n, 1),
          e.render(t, i),
          e.setRenderTarget(n, 2),
          e.render(t, o),
          e.setRenderTarget(n, 3),
          e.render(t, a),
          e.setRenderTarget(n, 4),
          e.render(t, s),
          (n.texture.generateMipmaps = h),
          e.setRenderTarget(n, 5),
          e.render(t, l),
          e.setRenderTarget(u),
          (e.xr.enabled = c);
      }
    }
    class Po extends er {
      constructor(e, t, n, r, i, o, a, s, l, c) {
        super(
          (e = void 0 !== e ? e : []),
          (t = void 0 !== t ? t : oe),
          n,
          r,
          i,
          o,
          (a = void 0 !== a ? a : Fe),
          s,
          l,
          c
        ),
          (this.flipY = !1);
      }
      get images() {
        return this.image;
      }
      set images(e) {
        this.image = e;
      }
    }
    Po.prototype.isCubeTexture = !0;
    class Lo extends rr {
      constructor(e, t, n) {
        Number.isInteger(t) &&
          (console.warn(
            "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
          ),
          (t = n)),
          super(e, e, t),
          (t = t || {}),
          (this.texture = new Po(
            void 0,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.encoding
          )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.generateMipmaps =
            void 0 !== t.generateMipmaps && t.generateMipmaps),
          (this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : xe),
          (this.texture._needsFlipEnvMap = !1);
      }
      fromEquirectangularTexture(e, t) {
        (this.texture.type = t.type),
          (this.texture.format = Ne),
          (this.texture.encoding = t.encoding),
          (this.texture.generateMipmaps = t.generateMipmaps),
          (this.texture.minFilter = t.minFilter),
          (this.texture.magFilter = t.magFilter);
        const n = {
            uniforms: {
              tEquirect: {
                value: null,
              },
            },
            vertexShader:
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            fragmentShader:
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
          },
          r = new wo(5, 5, 5),
          i = new To({
            name: "CubemapFromEquirect",
            uniforms: _o(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: m,
            blending: x,
          });
        i.uniforms.tEquirect.value = t;
        const o = new xo(r, i),
          a = t.minFilter;
        return (
          t.minFilter === _e && (t.minFilter = xe),
          new Co(1, 10, this).update(e, o),
          (t.minFilter = a),
          o.geometry.dispose(),
          o.material.dispose(),
          this
        );
      }
      clear(e, t, n, r) {
        const i = e.getRenderTarget();
        for (let i = 0; i < 6; i++)
          e.setRenderTarget(this, i), e.clear(t, n, r);
        e.setRenderTarget(i);
      }
    }
    Lo.prototype.isWebGLCubeRenderTarget = !0;
    const Ro = new sr(),
      Io = new sr(),
      ko = new Jn();
    class Do {
      constructor(e = new sr(1, 0, 0), t = 0) {
        (this.normal = e), (this.constant = t);
      }
      set(e, t) {
        return this.normal.copy(e), (this.constant = t), this;
      }
      setComponents(e, t, n, r) {
        return this.normal.set(e, t, n), (this.constant = r), this;
      }
      setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
      }
      setFromCoplanarPoints(e, t, n) {
        const r = Ro.subVectors(n, t).cross(Io.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e), this;
      }
      copy(e) {
        return this.normal.copy(e.normal), (this.constant = e.constant), this;
      }
      normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), (this.constant *= e), this;
      }
      negate() {
        return (this.constant *= -1), this.normal.negate(), this;
      }
      distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
      }
      distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
      }
      projectPoint(e, t) {
        return t
          .copy(this.normal)
          .multiplyScalar(-this.distanceToPoint(e))
          .add(e);
      }
      intersectLine(e, t) {
        const n = e.delta(Ro),
          r = this.normal.dot(n);
        if (0 === r)
          return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
        const i = -(e.start.dot(this.normal) + this.constant) / r;
        return i < 0 || i > 1 ? null : t.copy(n).multiplyScalar(i).add(e.start);
      }
      intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
          n = this.distanceToPoint(e.end);
        return (t < 0 && n > 0) || (n < 0 && t > 0);
      }
      intersectsBox(e) {
        return e.intersectsPlane(this);
      }
      intersectsSphere(e) {
        return e.intersectsPlane(this);
      }
      coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(e, t) {
        const n = t || ko.getNormalMatrix(e),
          r = this.coplanarPoint(Ro).applyMatrix4(e),
          i = this.normal.applyMatrix3(n).normalize();
        return (this.constant = -r.dot(i)), this;
      }
      translate(e) {
        return (this.constant -= e.dot(this.normal)), this;
      }
      equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    Do.prototype.isPlane = !0;
    const Oo = new Pr(),
      Bo = new sr();
    class Fo {
      constructor(
        e = new Do(),
        t = new Do(),
        n = new Do(),
        r = new Do(),
        i = new Do(),
        o = new Do()
      ) {
        this.planes = [e, t, n, r, i, o];
      }
      set(e, t, n, r, i, o) {
        const a = this.planes;
        return (
          a[0].copy(e),
          a[1].copy(t),
          a[2].copy(n),
          a[3].copy(r),
          a[4].copy(i),
          a[5].copy(o),
          this
        );
      }
      copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
        return this;
      }
      setFromProjectionMatrix(e) {
        const t = this.planes,
          n = e.elements,
          r = n[0],
          i = n[1],
          o = n[2],
          a = n[3],
          s = n[4],
          l = n[5],
          c = n[6],
          u = n[7],
          h = n[8],
          d = n[9],
          p = n[10],
          f = n[11],
          m = n[12],
          g = n[13],
          v = n[14],
          y = n[15];
        return (
          t[0].setComponents(a - r, u - s, f - h, y - m).normalize(),
          t[1].setComponents(a + r, u + s, f + h, y + m).normalize(),
          t[2].setComponents(a + i, u + l, f + d, y + g).normalize(),
          t[3].setComponents(a - i, u - l, f - d, y - g).normalize(),
          t[4].setComponents(a - o, u - c, f - p, y - v).normalize(),
          t[5].setComponents(a + o, u + c, f + p, y + v).normalize(),
          this
        );
      }
      intersectsObject(e) {
        const t = e.geometry;
        return (
          null === t.boundingSphere && t.computeBoundingSphere(),
          Oo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
          this.intersectsSphere(Oo)
        );
      }
      intersectsSprite(e) {
        return (
          Oo.center.set(0, 0, 0),
          (Oo.radius = 0.7071067811865476),
          Oo.applyMatrix4(e.matrixWorld),
          this.intersectsSphere(Oo)
        );
      }
      intersectsSphere(e) {
        const t = this.planes,
          n = e.center,
          r = -e.radius;
        for (let e = 0; e < 6; e++) {
          if (t[e].distanceToPoint(n) < r) return !1;
        }
        return !0;
      }
      intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
          const r = t[n];
          if (
            ((Bo.x = r.normal.x > 0 ? e.max.x : e.min.x),
            (Bo.y = r.normal.y > 0 ? e.max.y : e.min.y),
            (Bo.z = r.normal.z > 0 ? e.max.z : e.min.z),
            r.distanceToPoint(Bo) < 0)
          )
            return !1;
        }
        return !0;
      }
      containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
        return !0;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }

    function No() {
      let e = null,
        t = !1,
        n = null,
        r = null;

      function i(t, o) {
        n(t, o), (r = e.requestAnimationFrame(i));
      }
      return {
        start: function () {
          !0 !== t &&
            null !== n &&
            ((r = e.requestAnimationFrame(i)), (t = !0));
        },
        stop: function () {
          e.cancelAnimationFrame(r), (t = !1);
        },
        setAnimationLoop: function (e) {
          n = e;
        },
        setContext: function (t) {
          e = t;
        },
      };
    }

    function Uo(e, t) {
      const n = t.isWebGL2,
        r = new WeakMap();
      return {
        get: function (e) {
          return e.isInterleavedBufferAttribute && (e = e.data), r.get(e);
        },
        remove: function (t) {
          t.isInterleavedBufferAttribute && (t = t.data);
          const n = r.get(t);
          n && (e.deleteBuffer(n.buffer), r.delete(t));
        },
        update: function (t, i) {
          if (t.isGLBufferAttribute) {
            const e = r.get(t);
            return void (
              (!e || e.version < t.version) &&
              r.set(t, {
                buffer: t.buffer,
                type: t.type,
                bytesPerElement: t.elementSize,
                version: t.version,
              })
            );
          }
          t.isInterleavedBufferAttribute && (t = t.data);
          const o = r.get(t);
          void 0 === o
            ? r.set(
                t,
                (function (t, r) {
                  const i = t.array,
                    o = t.usage,
                    a = e.createBuffer();
                  e.bindBuffer(r, a),
                    e.bufferData(r, i, o),
                    t.onUploadCallback();
                  let s = 5126;
                  return (
                    i instanceof Float32Array
                      ? (s = 5126)
                      : i instanceof Float64Array
                      ? console.warn(
                          "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                        )
                      : i instanceof Uint16Array
                      ? t.isFloat16BufferAttribute
                        ? n
                          ? (s = 5131)
                          : console.warn(
                              "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                            )
                        : (s = 5123)
                      : i instanceof Int16Array
                      ? (s = 5122)
                      : i instanceof Uint32Array
                      ? (s = 5125)
                      : i instanceof Int32Array
                      ? (s = 5124)
                      : i instanceof Int8Array
                      ? (s = 5120)
                      : (i instanceof Uint8Array ||
                          i instanceof Uint8ClampedArray) &&
                        (s = 5121),
                    {
                      buffer: a,
                      type: s,
                      bytesPerElement: i.BYTES_PER_ELEMENT,
                      version: t.version,
                    }
                  );
                })(t, i)
              )
            : o.version < t.version &&
              (!(function (t, r, i) {
                const o = r.array,
                  a = r.updateRange;
                e.bindBuffer(i, t),
                  -1 === a.count
                    ? e.bufferSubData(i, 0, o)
                    : (n
                        ? e.bufferSubData(
                            i,
                            a.offset * o.BYTES_PER_ELEMENT,
                            o,
                            a.offset,
                            a.count
                          )
                        : e.bufferSubData(
                            i,
                            a.offset * o.BYTES_PER_ELEMENT,
                            o.subarray(a.offset, a.offset + a.count)
                          ),
                      (a.count = -1));
              })(o.buffer, t, i),
              (o.version = t.version));
        },
      };
    }
    class zo extends eo {
      constructor(e = 1, t = 1, n = 1, r = 1) {
        super(),
          (this.type = "PlaneGeometry"),
          (this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r,
          });
        const i = e / 2,
          o = t / 2,
          a = Math.floor(n),
          s = Math.floor(r),
          l = a + 1,
          c = s + 1,
          u = e / a,
          h = t / s,
          d = [],
          p = [],
          f = [],
          m = [];
        for (let e = 0; e < c; e++) {
          const t = e * h - o;
          for (let n = 0; n < l; n++) {
            const r = n * u - i;
            p.push(r, -t, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - e / s);
          }
        }
        for (let e = 0; e < s; e++)
          for (let t = 0; t < a; t++) {
            const n = t + l * e,
              r = t + l * (e + 1),
              i = t + 1 + l * (e + 1),
              o = t + 1 + l * e;
            d.push(n, r, o), d.push(r, i, o);
          }
        this.setIndex(d),
          this.setAttribute("position", new Gi(p, 3)),
          this.setAttribute("normal", new Gi(f, 3)),
          this.setAttribute("uv", new Gi(m, 2));
      }
      static fromJSON(e) {
        return new zo(e.width, e.height, e.widthSegments, e.heightSegments);
      }
    }
    const Ho = {
        alphamap_fragment:
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment:
          "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment:
          "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
        alphatest_pars_fragment:
          "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        aomap_fragment:
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        aomap_pars_fragment:
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex:
          "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs:
          "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float NoH ) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float NoV, float NoL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );\n}\nvec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment:
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common:
          "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment:
          "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex:
          "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment:
          "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment:
          "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment:
          "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in GeometricContext geometry ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
        envmap_vertex:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        fog_fragment:
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment:
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment:
          "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment:
          "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
        lightmap_pars_fragment:
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex:
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin:
          "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment:
          "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment:
          "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment:
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment:
          "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment:
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n#endif",
        lights_physical_pars_fragment:
          "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin:
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps:
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        lights_fragment_end:
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment:
          "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment:
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment:
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex:
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex:
          "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex:
          "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin:
          "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps:
          "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normal_pars_fragment:
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_pars_vertex:
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_vertex:
          "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        normalmap_pars_fragment:
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin:
          "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment:
          "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        output_fragment:
          "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        packing:
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment:
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex:
          "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment:
          "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment:
          "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment:
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment:
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment:
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex:
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex:
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex:
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex:
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment:
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment:
          "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment:
          "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment:
          "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmission_fragment:
          "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = transmission.a;\n#endif",
        transmission_pars_fragment:
          "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
        uv_pars_fragment:
          "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex:
          "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex:
          "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex:
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag:
          "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert:
          "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag:
          "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag:
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        depth_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        distanceRGBA_frag:
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert:
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        linedashed_vert:
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshbasic_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag:
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert:
          "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag:
          "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert:
          "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshnormal_frag:
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        meshnormal_vert:
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        meshphong_frag:
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert:
          "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag:
          "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert:
          "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        meshtoon_frag:
          "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert:
          "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        points_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        points_vert:
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag:
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        shadow_vert:
          "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert:
          "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      },
      Go = {
        common: {
          diffuse: {
            value: new Pi(16777215),
          },
          opacity: {
            value: 1,
          },
          map: {
            value: null,
          },
          uvTransform: {
            value: new Jn(),
          },
          uv2Transform: {
            value: new Jn(),
          },
          alphaMap: {
            value: null,
          },
          alphaTest: {
            value: 0,
          },
        },
        specularmap: {
          specularMap: {
            value: null,
          },
        },
        envmap: {
          envMap: {
            value: null,
          },
          flipEnvMap: {
            value: -1,
          },
          reflectivity: {
            value: 1,
          },
          ior: {
            value: 1.5,
          },
          refractionRatio: {
            value: 0.98,
          },
          maxMipLevel: {
            value: 0,
          },
        },
        aomap: {
          aoMap: {
            value: null,
          },
          aoMapIntensity: {
            value: 1,
          },
        },
        lightmap: {
          lightMap: {
            value: null,
          },
          lightMapIntensity: {
            value: 1,
          },
        },
        emissivemap: {
          emissiveMap: {
            value: null,
          },
        },
        bumpmap: {
          bumpMap: {
            value: null,
          },
          bumpScale: {
            value: 1,
          },
        },
        normalmap: {
          normalMap: {
            value: null,
          },
          normalScale: {
            value: new Yn(1, 1),
          },
        },
        displacementmap: {
          displacementMap: {
            value: null,
          },
          displacementScale: {
            value: 1,
          },
          displacementBias: {
            value: 0,
          },
        },
        roughnessmap: {
          roughnessMap: {
            value: null,
          },
        },
        metalnessmap: {
          metalnessMap: {
            value: null,
          },
        },
        gradientmap: {
          gradientMap: {
            value: null,
          },
        },
        fog: {
          fogDensity: {
            value: 25e-5,
          },
          fogNear: {
            value: 1,
          },
          fogFar: {
            value: 2e3,
          },
          fogColor: {
            value: new Pi(16777215),
          },
        },
        lights: {
          ambientLightColor: {
            value: [],
          },
          lightProbe: {
            value: [],
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {},
            },
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          directionalShadowMap: {
            value: [],
          },
          directionalShadowMatrix: {
            value: [],
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
            },
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          spotShadowMap: {
            value: [],
          },
          spotShadowMatrix: {
            value: [],
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {},
            },
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: {
            value: [],
          },
          pointShadowMatrix: {
            value: [],
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {},
            },
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {},
            },
          },
          ltc_1: {
            value: null,
          },
          ltc_2: {
            value: null,
          },
        },
        points: {
          diffuse: {
            value: new Pi(16777215),
          },
          opacity: {
            value: 1,
          },
          size: {
            value: 1,
          },
          scale: {
            value: 1,
          },
          map: {
            value: null,
          },
          alphaMap: {
            value: null,
          },
          alphaTest: {
            value: 0,
          },
          uvTransform: {
            value: new Jn(),
          },
        },
        sprite: {
          diffuse: {
            value: new Pi(16777215),
          },
          opacity: {
            value: 1,
          },
          center: {
            value: new Yn(0.5, 0.5),
          },
          rotation: {
            value: 0,
          },
          map: {
            value: null,
          },
          alphaMap: {
            value: null,
          },
          alphaTest: {
            value: 0,
          },
          uvTransform: {
            value: new Jn(),
          },
        },
      },
      Vo = {
        basic: {
          uniforms: Mo([
            Go.common,
            Go.specularmap,
            Go.envmap,
            Go.aomap,
            Go.lightmap,
            Go.fog,
          ]),
          vertexShader: Ho.meshbasic_vert,
          fragmentShader: Ho.meshbasic_frag,
        },
        lambert: {
          uniforms: Mo([
            Go.common,
            Go.specularmap,
            Go.envmap,
            Go.aomap,
            Go.lightmap,
            Go.emissivemap,
            Go.fog,
            Go.lights,
            {
              emissive: {
                value: new Pi(0),
              },
            },
          ]),
          vertexShader: Ho.meshlambert_vert,
          fragmentShader: Ho.meshlambert_frag,
        },
        phong: {
          uniforms: Mo([
            Go.common,
            Go.specularmap,
            Go.envmap,
            Go.aomap,
            Go.lightmap,
            Go.emissivemap,
            Go.bumpmap,
            Go.normalmap,
            Go.displacementmap,
            Go.fog,
            Go.lights,
            {
              emissive: {
                value: new Pi(0),
              },
              specular: {
                value: new Pi(1118481),
              },
              shininess: {
                value: 30,
              },
            },
          ]),
          vertexShader: Ho.meshphong_vert,
          fragmentShader: Ho.meshphong_frag,
        },
        standard: {
          uniforms: Mo([
            Go.common,
            Go.envmap,
            Go.aomap,
            Go.lightmap,
            Go.emissivemap,
            Go.bumpmap,
            Go.normalmap,
            Go.displacementmap,
            Go.roughnessmap,
            Go.metalnessmap,
            Go.fog,
            Go.lights,
            {
              emissive: {
                value: new Pi(0),
              },
              roughness: {
                value: 1,
              },
              metalness: {
                value: 0,
              },
              envMapIntensity: {
                value: 1,
              },
            },
          ]),
          vertexShader: Ho.meshphysical_vert,
          fragmentShader: Ho.meshphysical_frag,
        },
        toon: {
          uniforms: Mo([
            Go.common,
            Go.aomap,
            Go.lightmap,
            Go.emissivemap,
            Go.bumpmap,
            Go.normalmap,
            Go.displacementmap,
            Go.gradientmap,
            Go.fog,
            Go.lights,
            {
              emissive: {
                value: new Pi(0),
              },
            },
          ]),
          vertexShader: Ho.meshtoon_vert,
          fragmentShader: Ho.meshtoon_frag,
        },
        matcap: {
          uniforms: Mo([
            Go.common,
            Go.bumpmap,
            Go.normalmap,
            Go.displacementmap,
            Go.fog,
            {
              matcap: {
                value: null,
              },
            },
          ]),
          vertexShader: Ho.meshmatcap_vert,
          fragmentShader: Ho.meshmatcap_frag,
        },
        points: {
          uniforms: Mo([Go.points, Go.fog]),
          vertexShader: Ho.points_vert,
          fragmentShader: Ho.points_frag,
        },
        dashed: {
          uniforms: Mo([
            Go.common,
            Go.fog,
            {
              scale: {
                value: 1,
              },
              dashSize: {
                value: 1,
              },
              totalSize: {
                value: 2,
              },
            },
          ]),
          vertexShader: Ho.linedashed_vert,
          fragmentShader: Ho.linedashed_frag,
        },
        depth: {
          uniforms: Mo([Go.common, Go.displacementmap]),
          vertexShader: Ho.depth_vert,
          fragmentShader: Ho.depth_frag,
        },
        normal: {
          uniforms: Mo([
            Go.common,
            Go.bumpmap,
            Go.normalmap,
            Go.displacementmap,
            {
              opacity: {
                value: 1,
              },
            },
          ]),
          vertexShader: Ho.meshnormal_vert,
          fragmentShader: Ho.meshnormal_frag,
        },
        sprite: {
          uniforms: Mo([Go.sprite, Go.fog]),
          vertexShader: Ho.sprite_vert,
          fragmentShader: Ho.sprite_frag,
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Jn(),
            },
            t2D: {
              value: null,
            },
          },
          vertexShader: Ho.background_vert,
          fragmentShader: Ho.background_frag,
        },
        cube: {
          uniforms: Mo([
            Go.envmap,
            {
              opacity: {
                value: 1,
              },
            },
          ]),
          vertexShader: Ho.cube_vert,
          fragmentShader: Ho.cube_frag,
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null,
            },
          },
          vertexShader: Ho.equirect_vert,
          fragmentShader: Ho.equirect_frag,
        },
        distanceRGBA: {
          uniforms: Mo([
            Go.common,
            Go.displacementmap,
            {
              referencePosition: {
                value: new sr(),
              },
              nearDistance: {
                value: 1,
              },
              farDistance: {
                value: 1e3,
              },
            },
          ]),
          vertexShader: Ho.distanceRGBA_vert,
          fragmentShader: Ho.distanceRGBA_frag,
        },
        shadow: {
          uniforms: Mo([
            Go.lights,
            Go.fog,
            {
              color: {
                value: new Pi(0),
              },
              opacity: {
                value: 1,
              },
            },
          ]),
          vertexShader: Ho.shadow_vert,
          fragmentShader: Ho.shadow_frag,
        },
      };

    function jo(e, t, n, r, i) {
      const o = new Pi(0);
      let a,
        s,
        l = 0,
        c = null,
        u = 0,
        h = null;

      function d(e, t) {
        n.buffers.color.setClear(e.r, e.g, e.b, t, i);
      }
      return {
        getClearColor: function () {
          return o;
        },
        setClearColor: function (e, t = 1) {
          o.set(e), (l = t), d(o, l);
        },
        getClearAlpha: function () {
          return l;
        },
        setClearAlpha: function (e) {
          (l = e), d(o, l);
        },
        render: function (n, i) {
          let p = !1,
            g = !0 === i.isScene ? i.background : null;
          g && g.isTexture && (g = t.get(g));
          const v = e.xr,
            y = v.getSession && v.getSession();
          y && "additive" === y.environmentBlendMode && (g = null),
            null === g ? d(o, l) : g && g.isColor && (d(g, 1), (p = !0)),
            (e.autoClear || p) &&
              e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            g && (g.isCubeTexture || g.mapping === ce)
              ? (void 0 === s &&
                  ((s = new xo(
                    new wo(1, 1, 1),
                    new To({
                      name: "BackgroundCubeMaterial",
                      uniforms: _o(Vo.cube.uniforms),
                      vertexShader: Vo.cube.vertexShader,
                      fragmentShader: Vo.cube.fragmentShader,
                      side: m,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  s.geometry.deleteAttribute("normal"),
                  s.geometry.deleteAttribute("uv"),
                  (s.onBeforeRender = function (e, t, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld);
                  }),
                  Object.defineProperty(s.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  r.update(s)),
                (s.material.uniforms.envMap.value = g),
                (s.material.uniforms.flipEnvMap.value =
                  g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1),
                (c === g && u === g.version && h === e.toneMapping) ||
                  ((s.material.needsUpdate = !0),
                  (c = g),
                  (u = g.version),
                  (h = e.toneMapping)),
                n.unshift(s, s.geometry, s.material, 0, 0, null))
              : g &&
                g.isTexture &&
                (void 0 === a &&
                  ((a = new xo(
                    new zo(2, 2),
                    new To({
                      name: "BackgroundMaterial",
                      uniforms: _o(Vo.background.uniforms),
                      vertexShader: Vo.background.vertexShader,
                      fragmentShader: Vo.background.fragmentShader,
                      side: f,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  a.geometry.deleteAttribute("normal"),
                  Object.defineProperty(a.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  r.update(a)),
                (a.material.uniforms.t2D.value = g),
                !0 === g.matrixAutoUpdate && g.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(g.matrix),
                (c === g && u === g.version && h === e.toneMapping) ||
                  ((a.material.needsUpdate = !0),
                  (c = g),
                  (u = g.version),
                  (h = e.toneMapping)),
                n.unshift(a, a.geometry, a.material, 0, 0, null));
        },
      };
    }

    function Wo(e, t, n, r) {
      const i = e.getParameter(34921),
        o = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
        a = r.isWebGL2 || null !== o,
        s = {},
        l = d(null);
      let c = l;

      function u(t) {
        return r.isWebGL2 ? e.bindVertexArray(t) : o.bindVertexArrayOES(t);
      }

      function h(t) {
        return r.isWebGL2 ? e.deleteVertexArray(t) : o.deleteVertexArrayOES(t);
      }

      function d(e) {
        const t = [],
          n = [],
          r = [];
        for (let e = 0; e < i; e++) (t[e] = 0), (n[e] = 0), (r[e] = 0);
        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: t,
          enabledAttributes: n,
          attributeDivisors: r,
          object: e,
          attributes: {},
          index: null,
        };
      }

      function p() {
        const e = c.newAttributes;
        for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
      }

      function f(e) {
        m(e, 0);
      }

      function m(n, i) {
        const o = c.newAttributes,
          a = c.enabledAttributes,
          s = c.attributeDivisors;
        if (
          ((o[n] = 1),
          0 === a[n] && (e.enableVertexAttribArray(n), (a[n] = 1)),
          s[n] !== i)
        ) {
          (r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
            r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](n, i),
            (s[n] = i);
        }
      }

      function g() {
        const t = c.newAttributes,
          n = c.enabledAttributes;
        for (let r = 0, i = n.length; r < i; r++)
          n[r] !== t[r] && (e.disableVertexAttribArray(r), (n[r] = 0));
      }

      function v(t, n, i, o, a, s) {
        !0 !== r.isWebGL2 || (5124 !== i && 5125 !== i)
          ? e.vertexAttribPointer(t, n, i, o, a, s)
          : e.vertexAttribIPointer(t, n, i, a, s);
      }

      function y() {
        x(), c !== l && ((c = l), u(c.object));
      }

      function x() {
        (l.geometry = null), (l.program = null), (l.wireframe = !1);
      }
      return {
        setup: function (i, l, h, y, x) {
          let b = !1;
          if (a) {
            const t = (function (t, n, i) {
              const a = !0 === i.wireframe;
              let l = s[t.id];
              void 0 === l && ((l = {}), (s[t.id] = l));
              let c = l[n.id];
              void 0 === c && ((c = {}), (l[n.id] = c));
              let u = c[a];
              void 0 === u &&
                ((u = d(
                  r.isWebGL2 ? e.createVertexArray() : o.createVertexArrayOES()
                )),
                (c[a] = u));
              return u;
            })(y, h, l);
            c !== t && ((c = t), u(c.object)),
              (b = (function (e, t) {
                const n = c.attributes,
                  r = e.attributes;
                let i = 0;
                for (const e in r) {
                  const t = n[e],
                    o = r[e];
                  if (void 0 === t) return !0;
                  if (t.attribute !== o) return !0;
                  if (t.data !== o.data) return !0;
                  i++;
                }
                return c.attributesNum !== i || c.index !== t;
              })(y, x)),
              b &&
                (function (e, t) {
                  const n = {},
                    r = e.attributes;
                  let i = 0;
                  for (const e in r) {
                    const t = r[e],
                      o = {};
                    (o.attribute = t),
                      t.data && (o.data = t.data),
                      (n[e] = o),
                      i++;
                  }
                  (c.attributes = n), (c.attributesNum = i), (c.index = t);
                })(y, x);
          } else {
            const e = !0 === l.wireframe;
            (c.geometry === y.id && c.program === h.id && c.wireframe === e) ||
              ((c.geometry = y.id),
              (c.program = h.id),
              (c.wireframe = e),
              (b = !0));
          }
          !0 === i.isInstancedMesh && (b = !0),
            null !== x && n.update(x, 34963),
            b &&
              (!(function (i, o, a, s) {
                if (
                  !1 === r.isWebGL2 &&
                  (i.isInstancedMesh || s.isInstancedBufferGeometry) &&
                  null === t.get("ANGLE_instanced_arrays")
                )
                  return;
                p();
                const l = s.attributes,
                  c = a.getAttributes(),
                  u = o.defaultAttributeValues;
                for (const t in c) {
                  const r = c[t];
                  if (r.location >= 0) {
                    let o = l[t];
                    if (
                      (void 0 === o &&
                        ("instanceMatrix" === t &&
                          i.instanceMatrix &&
                          (o = i.instanceMatrix),
                        "instanceColor" === t &&
                          i.instanceColor &&
                          (o = i.instanceColor)),
                      void 0 !== o)
                    ) {
                      const t = o.normalized,
                        a = o.itemSize,
                        l = n.get(o);
                      if (void 0 === l) continue;
                      const c = l.buffer,
                        u = l.type,
                        h = l.bytesPerElement;
                      if (o.isInterleavedBufferAttribute) {
                        const n = o.data,
                          l = n.stride,
                          d = o.offset;
                        if (n && n.isInstancedInterleavedBuffer) {
                          for (let e = 0; e < r.locationSize; e++)
                            m(r.location + e, n.meshPerAttribute);
                          !0 !== i.isInstancedMesh &&
                            void 0 === s._maxInstanceCount &&
                            (s._maxInstanceCount =
                              n.meshPerAttribute * n.count);
                        } else
                          for (let e = 0; e < r.locationSize; e++)
                            f(r.location + e);
                        e.bindBuffer(34962, c);
                        for (let e = 0; e < r.locationSize; e++)
                          v(
                            r.location + e,
                            a / r.locationSize,
                            u,
                            t,
                            l * h,
                            (d + (a / r.locationSize) * e) * h
                          );
                      } else {
                        if (o.isInstancedBufferAttribute) {
                          for (let e = 0; e < r.locationSize; e++)
                            m(r.location + e, o.meshPerAttribute);
                          !0 !== i.isInstancedMesh &&
                            void 0 === s._maxInstanceCount &&
                            (s._maxInstanceCount =
                              o.meshPerAttribute * o.count);
                        } else
                          for (let e = 0; e < r.locationSize; e++)
                            f(r.location + e);
                        e.bindBuffer(34962, c);
                        for (let e = 0; e < r.locationSize; e++)
                          v(
                            r.location + e,
                            a / r.locationSize,
                            u,
                            t,
                            a * h,
                            (a / r.locationSize) * e * h
                          );
                      }
                    } else if (void 0 !== u) {
                      const n = u[t];
                      if (void 0 !== n)
                        switch (n.length) {
                          case 2:
                            e.vertexAttrib2fv(r.location, n);
                            break;
                          case 3:
                            e.vertexAttrib3fv(r.location, n);
                            break;
                          case 4:
                            e.vertexAttrib4fv(r.location, n);
                            break;
                          default:
                            e.vertexAttrib1fv(r.location, n);
                        }
                    }
                  }
                }
                g();
              })(i, l, h, y),
              null !== x && e.bindBuffer(34963, n.get(x).buffer));
        },
        reset: y,
        resetDefaultState: x,
        dispose: function () {
          y();
          for (const e in s) {
            const t = s[e];
            for (const e in t) {
              const n = t[e];
              for (const e in n) h(n[e].object), delete n[e];
              delete t[e];
            }
            delete s[e];
          }
        },
        releaseStatesOfGeometry: function (e) {
          if (void 0 === s[e.id]) return;
          const t = s[e.id];
          for (const e in t) {
            const n = t[e];
            for (const e in n) h(n[e].object), delete n[e];
            delete t[e];
          }
          delete s[e.id];
        },
        releaseStatesOfProgram: function (e) {
          for (const t in s) {
            const n = s[t];
            if (void 0 === n[e.id]) continue;
            const r = n[e.id];
            for (const e in r) h(r[e].object), delete r[e];
            delete n[e.id];
          }
        },
        initAttributes: p,
        enableAttribute: f,
        disableUnusedAttributes: g,
      };
    }

    function qo(e, t, n, r) {
      const i = r.isWebGL2;
      let o;
      (this.setMode = function (e) {
        o = e;
      }),
        (this.render = function (t, r) {
          e.drawArrays(o, t, r), n.update(r, o, 1);
        }),
        (this.renderInstances = function (r, a, s) {
          if (0 === s) return;
          let l, c;
          if (i) (l = e), (c = "drawArraysInstanced");
          else if (
            ((l = t.get("ANGLE_instanced_arrays")),
            (c = "drawArraysInstancedANGLE"),
            null === l)
          )
            return void console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          l[c](o, r, a, s), n.update(a, o, s);
        });
    }

    function $o(e, t, n) {
      let r;

      function i(t) {
        if ("highp" === t) {
          if (
            e.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
            e.getShaderPrecisionFormat(35632, 36338).precision > 0
          )
            return "highp";
          t = "mediump";
        }
        return "mediump" === t &&
          e.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
          e.getShaderPrecisionFormat(35632, 36337).precision > 0
          ? "mediump"
          : "lowp";
      }
      const o =
        ("undefined" != typeof WebGL2RenderingContext &&
          e instanceof WebGL2RenderingContext) ||
        ("undefined" != typeof WebGL2ComputeRenderingContext &&
          e instanceof WebGL2ComputeRenderingContext);
      let a = void 0 !== n.precision ? n.precision : "highp";
      const s = i(a);
      s !== a &&
        (console.warn(
          "THREE.WebGLRenderer:",
          a,
          "not supported, using",
          s,
          "instead."
        ),
        (a = s));
      const l = o || t.has("WEBGL_draw_buffers"),
        c = !0 === n.logarithmicDepthBuffer,
        u = e.getParameter(34930),
        h = e.getParameter(35660),
        d = e.getParameter(3379),
        p = e.getParameter(34076),
        f = e.getParameter(34921),
        m = e.getParameter(36347),
        g = e.getParameter(36348),
        v = e.getParameter(36349),
        y = h > 0,
        x = o || t.has("OES_texture_float");
      return {
        isWebGL2: o,
        drawBuffers: l,
        getMaxAnisotropy: function () {
          if (void 0 !== r) return r;
          if (!0 === t.has("EXT_texture_filter_anisotropic")) {
            const n = t.get("EXT_texture_filter_anisotropic");
            r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else r = 0;
          return r;
        },
        getMaxPrecision: i,
        precision: a,
        logarithmicDepthBuffer: c,
        maxTextures: u,
        maxVertexTextures: h,
        maxTextureSize: d,
        maxCubemapSize: p,
        maxAttributes: f,
        maxVertexUniforms: m,
        maxVaryings: g,
        maxFragmentUniforms: v,
        vertexTextures: y,
        floatFragmentTextures: x,
        floatVertexTextures: y && x,
        maxSamples: o ? e.getParameter(36183) : 0,
      };
    }

    function Xo(e) {
      const t = this;
      let n = null,
        r = 0,
        i = !1,
        o = !1;
      const a = new Do(),
        s = new Jn(),
        l = {
          value: null,
          needsUpdate: !1,
        };

      function c() {
        l.value !== n && ((l.value = n), (l.needsUpdate = r > 0)),
          (t.numPlanes = r),
          (t.numIntersection = 0);
      }

      function u(e, n, r, i) {
        const o = null !== e ? e.length : 0;
        let c = null;
        if (0 !== o) {
          if (((c = l.value), !0 !== i || null === c)) {
            const t = r + 4 * o,
              i = n.matrixWorldInverse;
            s.getNormalMatrix(i),
              (null === c || c.length < t) && (c = new Float32Array(t));
            for (let t = 0, n = r; t !== o; ++t, n += 4)
              a.copy(e[t]).applyMatrix4(i, s),
                a.normal.toArray(c, n),
                (c[n + 3] = a.constant);
          }
          (l.value = c), (l.needsUpdate = !0);
        }
        return (t.numPlanes = o), (t.numIntersection = 0), c;
      }
      (this.uniform = l),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (e, t, o) {
          const a = 0 !== e.length || t || 0 !== r || i;
          return (i = t), (n = u(e, o, 0)), (r = e.length), a;
        }),
        (this.beginShadows = function () {
          (o = !0), u(null);
        }),
        (this.endShadows = function () {
          (o = !1), c();
        }),
        (this.setState = function (t, a, s) {
          const h = t.clippingPlanes,
            d = t.clipIntersection,
            p = t.clipShadows,
            f = e.get(t);
          if (!i || null === h || 0 === h.length || (o && !p))
            o ? u(null) : c();
          else {
            const e = o ? 0 : r,
              t = 4 * e;
            let i = f.clippingState || null;
            (l.value = i), (i = u(h, a, t, s));
            for (let e = 0; e !== t; ++e) i[e] = n[e];
            (f.clippingState = i),
              (this.numIntersection = d ? this.numPlanes : 0),
              (this.numPlanes += e);
          }
        });
    }

    function Yo(e) {
      let t = new WeakMap();

      function n(e, t) {
        return t === se ? (e.mapping = oe) : t === le && (e.mapping = ae), e;
      }

      function r(e) {
        const n = e.target;
        n.removeEventListener("dispose", r);
        const i = t.get(n);
        void 0 !== i && (t.delete(n), i.dispose());
      }
      return {
        get: function (i) {
          if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
            const o = i.mapping;
            if (o === se || o === le) {
              if (t.has(i)) {
                return n(t.get(i).texture, i.mapping);
              }
              {
                const o = i.image;
                if (o && o.height > 0) {
                  const a = e.getRenderTarget(),
                    s = new Lo(o.height / 2);
                  return (
                    s.fromEquirectangularTexture(e, i),
                    t.set(i, s),
                    e.setRenderTarget(a),
                    i.addEventListener("dispose", r),
                    n(s.texture, i.mapping)
                  );
                }
                return null;
              }
            }
          }
          return i;
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    Vo.physical = {
      uniforms: Mo([
        Vo.standard.uniforms,
        {
          clearcoat: {
            value: 0,
          },
          clearcoatMap: {
            value: null,
          },
          clearcoatRoughness: {
            value: 0,
          },
          clearcoatRoughnessMap: {
            value: null,
          },
          clearcoatNormalScale: {
            value: new Yn(1, 1),
          },
          clearcoatNormalMap: {
            value: null,
          },
          sheenTint: {
            value: new Pi(0),
          },
          transmission: {
            value: 0,
          },
          transmissionMap: {
            value: null,
          },
          transmissionSamplerSize: {
            value: new Yn(),
          },
          transmissionSamplerMap: {
            value: null,
          },
          thickness: {
            value: 0,
          },
          thicknessMap: {
            value: null,
          },
          attenuationDistance: {
            value: 0,
          },
          attenuationTint: {
            value: new Pi(0),
          },
          specularIntensity: {
            value: 0,
          },
          specularIntensityMap: {
            value: null,
          },
          specularTint: {
            value: new Pi(1, 1, 1),
          },
          specularTintMap: {
            value: null,
          },
        },
      ]),
      vertexShader: Ho.meshphysical_vert,
      fragmentShader: Ho.meshphysical_frag,
    };
    class Jo extends Eo {
      constructor(e = -1, t = 1, n = 1, r = -1, i = 0.1, o = 2e3) {
        super(),
          (this.type = "OrthographicCamera"),
          (this.zoom = 1),
          (this.view = null),
          (this.left = e),
          (this.right = t),
          (this.top = n),
          (this.bottom = r),
          (this.near = i),
          (this.far = o),
          this.updateProjectionMatrix();
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          (this.left = e.left),
          (this.right = e.right),
          (this.top = e.top),
          (this.bottom = e.bottom),
          (this.near = e.near),
          (this.far = e.far),
          (this.zoom = e.zoom),
          (this.view = null === e.view ? null : Object.assign({}, e.view)),
          this
        );
      }
      setViewOffset(e, t, n, r, i, o) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = t),
          (this.view.offsetX = n),
          (this.view.offsetY = r),
          (this.view.width = i),
          (this.view.height = o),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
          t = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          r = (this.top + this.bottom) / 2;
        let i = n - e,
          o = n + e,
          a = r + t,
          s = r - t;
        if (null !== this.view && this.view.enabled) {
          const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          (i += e * this.view.offsetX),
            (o = i + e * this.view.width),
            (a -= t * this.view.offsetY),
            (s = a - t * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.zoom = this.zoom),
          (t.object.left = this.left),
          (t.object.right = this.right),
          (t.object.top = this.top),
          (t.object.bottom = this.bottom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          t
        );
      }
    }
    Jo.prototype.isOrthographicCamera = !0;
    class Zo extends To {
      constructor(e) {
        super(e), (this.type = "RawShaderMaterial");
      }
    }
    Zo.prototype.isRawShaderMaterial = !0;
    const Ko = Math.pow(2, 8),
      Qo = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
      ea = 5 + Qo.length,
      ta = {
        [Jt]: 0,
        [Zt]: 1,
        [Qt]: 2,
        [tn]: 3,
        [nn]: 4,
        [rn]: 5,
        [Kt]: 6,
      },
      na = new Jo(),
      { _lodPlanes: ra, _sizeLods: ia, _sigmas: oa } = pa(),
      aa = new Pi();
    let sa = null;
    const la = (1 + Math.sqrt(5)) / 2,
      ca = 1 / la,
      ua = [
        new sr(1, 1, 1),
        new sr(-1, 1, 1),
        new sr(1, 1, -1),
        new sr(-1, 1, -1),
        new sr(0, la, ca),
        new sr(0, la, -ca),
        new sr(ca, 0, la),
        new sr(-ca, 0, la),
        new sr(la, ca, 0),
        new sr(-la, ca, 0),
      ];
    class ha {
      constructor(e) {
        (this._renderer = e),
          (this._pingPongRenderTarget = null),
          (this._blurMaterial = (function (e) {
            const t = new Float32Array(e),
              n = new sr(0, 1, 0);
            return new Zo({
              name: "SphericalGaussianBlur",
              defines: {
                n: e,
              },
              uniforms: {
                envMap: {
                  value: null,
                },
                samples: {
                  value: 1,
                },
                weights: {
                  value: t,
                },
                latitudinal: {
                  value: !1,
                },
                dTheta: {
                  value: 0,
                },
                mipInt: {
                  value: 0,
                },
                poleAxis: {
                  value: n,
                },
                inputEncoding: {
                  value: ta[Jt],
                },
                outputEncoding: {
                  value: ta[Jt],
                },
              },
              vertexShader: ya(),
              fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${xa()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
              blending: x,
              depthTest: !1,
              depthWrite: !1,
            });
          })(20)),
          (this._equirectShader = null),
          (this._cubemapShader = null),
          this._compileMaterial(this._blurMaterial);
      }
      fromScene(e, t = 0, n = 0.1, r = 100) {
        sa = this._renderer.getRenderTarget();
        const i = this._allocateTargets();
        return (
          this._sceneToCubeUV(e, n, r, i),
          t > 0 && this._blur(i, 0, 0, t),
          this._applyPMREM(i),
          this._cleanup(i),
          i
        );
      }
      fromEquirectangular(e) {
        return this._fromTexture(e);
      }
      fromCubemap(e) {
        return this._fromTexture(e);
      }
      compileCubemapShader() {
        null === this._cubemapShader &&
          ((this._cubemapShader = va()),
          this._compileMaterial(this._cubemapShader));
      }
      compileEquirectangularShader() {
        null === this._equirectShader &&
          ((this._equirectShader = ga()),
          this._compileMaterial(this._equirectShader));
      }
      dispose() {
        this._blurMaterial.dispose(),
          null !== this._cubemapShader && this._cubemapShader.dispose(),
          null !== this._equirectShader && this._equirectShader.dispose();
        for (let e = 0; e < ra.length; e++) ra[e].dispose();
      }
      _cleanup(e) {
        this._pingPongRenderTarget.dispose(),
          this._renderer.setRenderTarget(sa),
          (e.scissorTest = !1),
          ma(e, 0, 0, e.width, e.height);
      }
      _fromTexture(e) {
        sa = this._renderer.getRenderTarget();
        const t = this._allocateTargets(e);
        return (
          this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
        );
      }
      _allocateTargets(e) {
        const t = {
            magFilter: fe,
            minFilter: fe,
            generateMipmaps: !1,
            type: Se,
            format: He,
            encoding: da(e) ? e.encoding : Qt,
            depthBuffer: !1,
          },
          n = fa(t);
        return (n.depthBuffer = !e), (this._pingPongRenderTarget = fa(t)), n;
      }
      _compileMaterial(e) {
        const t = new xo(ra[0], e);
        this._renderer.compile(t, na);
      }
      _sceneToCubeUV(e, t, n, r) {
        const i = new Ao(90, 1, t, n),
          o = [1, -1, 1, 1, 1, 1],
          a = [1, 1, 1, -1, -1, -1],
          s = this._renderer,
          l = s.autoClear,
          c = s.outputEncoding,
          u = s.toneMapping;
        s.getClearColor(aa),
          (s.toneMapping = K),
          (s.outputEncoding = Jt),
          (s.autoClear = !1);
        const h = new Li({
            name: "PMREM.Background",
            side: m,
            depthWrite: !1,
            depthTest: !1,
          }),
          d = new xo(new wo(), h);
        let p = !1;
        const f = e.background;
        f
          ? f.isColor && (h.color.copy(f), (e.background = null), (p = !0))
          : (h.color.copy(aa), (p = !0));
        for (let t = 0; t < 6; t++) {
          const n = t % 3;
          0 == n
            ? (i.up.set(0, o[t], 0), i.lookAt(a[t], 0, 0))
            : 1 == n
            ? (i.up.set(0, 0, o[t]), i.lookAt(0, a[t], 0))
            : (i.up.set(0, o[t], 0), i.lookAt(0, 0, a[t])),
            ma(r, n * Ko, t > 2 ? Ko : 0, Ko, Ko),
            s.setRenderTarget(r),
            p && s.render(d, i),
            s.render(e, i);
        }
        d.geometry.dispose(),
          d.material.dispose(),
          (s.toneMapping = u),
          (s.outputEncoding = c),
          (s.autoClear = l),
          (e.background = f);
      }
      _textureToCubeUV(e, t) {
        const n = this._renderer;
        e.isCubeTexture
          ? null == this._cubemapShader && (this._cubemapShader = va())
          : null == this._equirectShader && (this._equirectShader = ga());
        const r = e.isCubeTexture ? this._cubemapShader : this._equirectShader,
          i = new xo(ra[0], r),
          o = r.uniforms;
        (o.envMap.value = e),
          e.isCubeTexture ||
            o.texelSize.value.set(1 / e.image.width, 1 / e.image.height),
          (o.inputEncoding.value = ta[e.encoding]),
          (o.outputEncoding.value = ta[t.texture.encoding]),
          ma(t, 0, 0, 3 * Ko, 2 * Ko),
          n.setRenderTarget(t),
          n.render(i, na);
      }
      _applyPMREM(e) {
        const t = this._renderer,
          n = t.autoClear;
        t.autoClear = !1;
        for (let t = 1; t < ea; t++) {
          const n = Math.sqrt(oa[t] * oa[t] - oa[t - 1] * oa[t - 1]),
            r = ua[(t - 1) % ua.length];
          this._blur(e, t - 1, t, n, r);
        }
        t.autoClear = n;
      }
      _blur(e, t, n, r, i) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, n, r, "latitudinal", i),
          this._halfBlur(o, e, n, n, r, "longitudinal", i);
      }
      _halfBlur(e, t, n, r, i, o, a) {
        const s = this._renderer,
          l = this._blurMaterial;
        "latitudinal" !== o &&
          "longitudinal" !== o &&
          console.error(
            "blur direction must be either latitudinal or longitudinal!"
          );
        const c = new xo(ra[r], l),
          u = l.uniforms,
          h = ia[n] - 1,
          d = isFinite(i) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
          p = i / d,
          f = isFinite(i) ? 1 + Math.floor(3 * p) : 20;
        f > 20 &&
          console.warn(
            `sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
          );
        const m = [];
        let g = 0;
        for (let e = 0; e < 20; ++e) {
          const t = e / p,
            n = Math.exp((-t * t) / 2);
          m.push(n), 0 == e ? (g += n) : e < f && (g += 2 * n);
        }
        for (let e = 0; e < m.length; e++) m[e] = m[e] / g;
        (u.envMap.value = e.texture),
          (u.samples.value = f),
          (u.weights.value = m),
          (u.latitudinal.value = "latitudinal" === o),
          a && (u.poleAxis.value = a),
          (u.dTheta.value = d),
          (u.mipInt.value = 8 - n),
          (u.inputEncoding.value = ta[e.texture.encoding]),
          (u.outputEncoding.value = ta[e.texture.encoding]);
        const v = ia[r];
        ma(
          t,
          3 * Math.max(0, Ko - 2 * v),
          (0 === r ? 0 : 2 * Ko) + 2 * v * (r > 4 ? r - 8 + 4 : 0),
          3 * v,
          2 * v
        ),
          s.setRenderTarget(t),
          s.render(c, na);
      }
    }

    function da(e) {
      return (
        void 0 !== e &&
        e.type === Se &&
        (e.encoding === Jt || e.encoding === Zt || e.encoding === Kt)
      );
    }

    function pa() {
      const e = [],
        t = [],
        n = [];
      let r = 8;
      for (let i = 0; i < ea; i++) {
        const o = Math.pow(2, r);
        t.push(o);
        let a = 1 / o;
        i > 4 ? (a = Qo[i - 8 + 4 - 1]) : 0 == i && (a = 0), n.push(a);
        const s = 1 / (o - 1),
          l = -s / 2,
          c = 1 + s / 2,
          u = [l, l, c, l, c, c, l, l, c, c, l, c],
          h = 6,
          d = 6,
          p = 3,
          f = 2,
          m = 1,
          g = new Float32Array(p * d * h),
          v = new Float32Array(f * d * h),
          y = new Float32Array(m * d * h);
        for (let e = 0; e < h; e++) {
          const t = ((e % 3) * 2) / 3 - 1,
            n = e > 2 ? 0 : -1,
            r = [
              t,
              n,
              0,
              t + 2 / 3,
              n,
              0,
              t + 2 / 3,
              n + 1,
              0,
              t,
              n,
              0,
              t + 2 / 3,
              n + 1,
              0,
              t,
              n + 1,
              0,
            ];
          g.set(r, p * d * e), v.set(u, f * d * e);
          const i = [e, e, e, e, e, e];
          y.set(i, m * d * e);
        }
        const x = new eo();
        x.setAttribute("position", new ki(g, p)),
          x.setAttribute("uv", new ki(v, f)),
          x.setAttribute("faceIndex", new ki(y, m)),
          e.push(x),
          r > 4 && r--;
      }
      return {
        _lodPlanes: e,
        _sizeLods: t,
        _sigmas: n,
      };
    }

    function fa(e) {
      const t = new rr(3 * Ko, 3 * Ko, e);
      return (
        (t.texture.mapping = ce),
        (t.texture.name = "PMREM.cubeUv"),
        (t.scissorTest = !0),
        t
      );
    }

    function ma(e, t, n, r, i) {
      e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i);
    }

    function ga() {
      const e = new Yn(1, 1);
      return new Zo({
        name: "EquirectangularToCubeUV",
        uniforms: {
          envMap: {
            value: null,
          },
          texelSize: {
            value: e,
          },
          inputEncoding: {
            value: ta[Jt],
          },
          outputEncoding: {
            value: ta[Jt],
          },
        },
        vertexShader: ya(),
        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${xa()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
        blending: x,
        depthTest: !1,
        depthWrite: !1,
      });
    }

    function va() {
      return new Zo({
        name: "CubemapToCubeUV",
        uniforms: {
          envMap: {
            value: null,
          },
          inputEncoding: {
            value: ta[Jt],
          },
          outputEncoding: {
            value: ta[Jt],
          },
        },
        vertexShader: ya(),
        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${xa()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
        blending: x,
        depthTest: !1,
        depthWrite: !1,
      });
    }

    function ya() {
      return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
    }

    function xa() {
      return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t";
    }

    function ba(e) {
      let t = new WeakMap(),
        n = null;

      function r(e) {
        const n = e.target;
        n.removeEventListener("dispose", r);
        const i = t.get(n);
        void 0 !== i && (t.delete(n), i.dispose());
      }
      return {
        get: function (i) {
          if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
            const o = i.mapping,
              a = o === se || o === le,
              s = o === oe || o === ae;
            if (a || s) {
              if (t.has(i)) return t.get(i).texture;
              {
                const o = i.image;
                if (
                  (a && o && o.height > 0) ||
                  (s &&
                    o &&
                    (function (e) {
                      let t = 0;
                      for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                      return 6 === t;
                    })(o))
                ) {
                  const o = e.getRenderTarget();
                  null === n && (n = new ha(e));
                  const s = a ? n.fromEquirectangular(i) : n.fromCubemap(i);
                  return (
                    t.set(i, s),
                    e.setRenderTarget(o),
                    i.addEventListener("dispose", r),
                    s.texture
                  );
                }
                return null;
              }
            }
          }
          return i;
        },
        dispose: function () {
          (t = new WeakMap()), null !== n && (n.dispose(), (n = null));
        },
      };
    }

    function wa(e) {
      const t = {};

      function n(n) {
        if (void 0 !== t[n]) return t[n];
        let r;
        switch (n) {
          case "WEBGL_depth_texture":
            r =
              e.getExtension("WEBGL_depth_texture") ||
              e.getExtension("MOZ_WEBGL_depth_texture") ||
              e.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            r =
              e.getExtension("EXT_texture_filter_anisotropic") ||
              e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
              e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            r =
              e.getExtension("WEBGL_compressed_texture_s3tc") ||
              e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            r =
              e.getExtension("WEBGL_compressed_texture_pvrtc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            r = e.getExtension(n);
        }
        return (t[n] = r), r;
      }
      return {
        has: function (e) {
          return null !== n(e);
        },
        init: function (e) {
          e.isWebGL2
            ? n("EXT_color_buffer_float")
            : (n("WEBGL_depth_texture"),
              n("OES_texture_float"),
              n("OES_texture_half_float"),
              n("OES_texture_half_float_linear"),
              n("OES_standard_derivatives"),
              n("OES_element_index_uint"),
              n("OES_vertex_array_object"),
              n("ANGLE_instanced_arrays")),
            n("OES_texture_float_linear"),
            n("EXT_color_buffer_half_float");
        },
        get: function (e) {
          const t = n(e);
          return (
            null === t &&
              console.warn(
                "THREE.WebGLRenderer: " + e + " extension not supported."
              ),
            t
          );
        },
      };
    }

    function _a(e, t, n, r) {
      const i = {},
        o = new WeakMap();

      function a(e) {
        const s = e.target;
        null !== s.index && t.remove(s.index);
        for (const e in s.attributes) t.remove(s.attributes[e]);
        s.removeEventListener("dispose", a), delete i[s.id];
        const l = o.get(s);
        l && (t.remove(l), o.delete(s)),
          r.releaseStatesOfGeometry(s),
          !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
          n.memory.geometries--;
      }

      function s(e) {
        const n = [],
          r = e.index,
          i = e.attributes.position;
        let a = 0;
        if (null !== r) {
          const e = r.array;
          a = r.version;
          for (let t = 0, r = e.length; t < r; t += 3) {
            const r = e[t + 0],
              i = e[t + 1],
              o = e[t + 2];
            n.push(r, i, i, o, o, r);
          }
        } else {
          const e = i.array;
          a = i.version;
          for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
            const e = t + 0,
              r = t + 1,
              i = t + 2;
            n.push(e, r, r, i, i, e);
          }
        }
        const s = new (ji(n) > 65535 ? zi : Ni)(n, 1);
        s.version = a;
        const l = o.get(e);
        l && t.remove(l), o.set(e, s);
      }
      return {
        get: function (e, t) {
          return (
            !0 === i[t.id] ||
              (t.addEventListener("dispose", a),
              (i[t.id] = !0),
              n.memory.geometries++),
            t
          );
        },
        update: function (e) {
          const n = e.attributes;
          for (const e in n) t.update(n[e], 34962);
          const r = e.morphAttributes;
          for (const e in r) {
            const n = r[e];
            for (let e = 0, r = n.length; e < r; e++) t.update(n[e], 34962);
          }
        },
        getWireframeAttribute: function (e) {
          const t = o.get(e);
          if (t) {
            const n = e.index;
            null !== n && t.version < n.version && s(e);
          } else s(e);
          return o.get(e);
        },
      };
    }

    function Ma(e, t, n, r) {
      const i = r.isWebGL2;
      let o, a, s;
      (this.setMode = function (e) {
        o = e;
      }),
        (this.setIndex = function (e) {
          (a = e.type), (s = e.bytesPerElement);
        }),
        (this.render = function (t, r) {
          e.drawElements(o, r, a, t * s), n.update(r, o, 1);
        }),
        (this.renderInstances = function (r, l, c) {
          if (0 === c) return;
          let u, h;
          if (i) (u = e), (h = "drawElementsInstanced");
          else if (
            ((u = t.get("ANGLE_instanced_arrays")),
            (h = "drawElementsInstancedANGLE"),
            null === u)
          )
            return void console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          u[h](o, l, a, r * s, c), n.update(l, o, c);
        });
    }

    function Sa(e) {
      const t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0,
      };
      return {
        memory: {
          geometries: 0,
          textures: 0,
        },
        render: t,
        programs: null,
        autoReset: !0,
        reset: function () {
          t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
        },
        update: function (e, n, r) {
          switch ((t.calls++, n)) {
            case 4:
              t.triangles += r * (e / 3);
              break;
            case 1:
              t.lines += r * (e / 2);
              break;
            case 3:
              t.lines += r * (e - 1);
              break;
            case 2:
              t.lines += r * e;
              break;
            case 0:
              t.points += r * e;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n);
          }
        },
      };
    }

    function Ta(e, t) {
      return e[0] - t[0];
    }

    function Ea(e, t) {
      return Math.abs(t[1]) - Math.abs(e[1]);
    }

    function Aa(e) {
      const t = {},
        n = new Float32Array(8),
        r = [];
      for (let e = 0; e < 8; e++) r[e] = [e, 0];
      return {
        update: function (i, o, a, s) {
          const l = i.morphTargetInfluences,
            c = void 0 === l ? 0 : l.length;
          let u = t[o.id];
          if (void 0 === u || u.length !== c) {
            u = [];
            for (let e = 0; e < c; e++) u[e] = [e, 0];
            t[o.id] = u;
          }
          for (let e = 0; e < c; e++) {
            const t = u[e];
            (t[0] = e), (t[1] = l[e]);
          }
          u.sort(Ea);
          for (let e = 0; e < 8; e++)
            e < c && u[e][1]
              ? ((r[e][0] = u[e][0]), (r[e][1] = u[e][1]))
              : ((r[e][0] = Number.MAX_SAFE_INTEGER), (r[e][1] = 0));
          r.sort(Ta);
          const h = o.morphAttributes.position,
            d = o.morphAttributes.normal;
          let p = 0;
          for (let e = 0; e < 8; e++) {
            const t = r[e],
              i = t[0],
              a = t[1];
            i !== Number.MAX_SAFE_INTEGER && a
              ? (h &&
                  o.getAttribute("morphTarget" + e) !== h[i] &&
                  o.setAttribute("morphTarget" + e, h[i]),
                d &&
                  o.getAttribute("morphNormal" + e) !== d[i] &&
                  o.setAttribute("morphNormal" + e, d[i]),
                (n[e] = a),
                (p += a))
              : (h &&
                  !0 === o.hasAttribute("morphTarget" + e) &&
                  o.deleteAttribute("morphTarget" + e),
                d &&
                  !0 === o.hasAttribute("morphNormal" + e) &&
                  o.deleteAttribute("morphNormal" + e),
                (n[e] = 0));
          }
          const f = o.morphTargetsRelative ? 1 : 1 - p;
          s.getUniforms().setValue(e, "morphTargetBaseInfluence", f),
            s.getUniforms().setValue(e, "morphTargetInfluences", n);
        },
      };
    }

    function Ca(e, t, n, r) {
      let i = new WeakMap();

      function o(e) {
        const t = e.target;
        t.removeEventListener("dispose", o),
          n.remove(t.instanceMatrix),
          null !== t.instanceColor && n.remove(t.instanceColor);
      }
      return {
        update: function (e) {
          const a = r.render.frame,
            s = e.geometry,
            l = t.get(e, s);
          return (
            i.get(l) !== a && (t.update(l), i.set(l, a)),
            e.isInstancedMesh &&
              (!1 === e.hasEventListener("dispose", o) &&
                e.addEventListener("dispose", o),
              n.update(e.instanceMatrix, 34962),
              null !== e.instanceColor && n.update(e.instanceColor, 34962)),
            l
          );
        },
        dispose: function () {
          i = new WeakMap();
        },
      };
    }
    class Pa extends er {
      constructor(e = null, t = 1, n = 1, r = 1) {
        super(null),
          (this.image = {
            data: e,
            width: t,
            height: n,
            depth: r,
          }),
          (this.magFilter = fe),
          (this.minFilter = fe),
          (this.wrapR = de),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
    }
    Pa.prototype.isDataTexture2DArray = !0;
    class La extends er {
      constructor(e = null, t = 1, n = 1, r = 1) {
        super(null),
          (this.image = {
            data: e,
            width: t,
            height: n,
            depth: r,
          }),
          (this.magFilter = fe),
          (this.minFilter = fe),
          (this.wrapR = de),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
    }
    La.prototype.isDataTexture3D = !0;
    const Ra = new er(),
      Ia = new Pa(),
      ka = new La(),
      Da = new Po(),
      Oa = [],
      Ba = [],
      Fa = new Float32Array(16),
      Na = new Float32Array(9),
      Ua = new Float32Array(4);

    function za(e, t, n) {
      const r = e[0];
      if (r <= 0 || r > 0) return e;
      const i = t * n;
      let o = Oa[i];
      if ((void 0 === o && ((o = new Float32Array(i)), (Oa[i] = o)), 0 !== t)) {
        r.toArray(o, 0);
        for (let r = 1, i = 0; r !== t; ++r) (i += n), e[r].toArray(o, i);
      }
      return o;
    }

    function Ha(e, t) {
      if (e.length !== t.length) return !1;
      for (let n = 0, r = e.length; n < r; n++) if (e[n] !== t[n]) return !1;
      return !0;
    }

    function Ga(e, t) {
      for (let n = 0, r = t.length; n < r; n++) e[n] = t[n];
    }

    function Va(e, t) {
      let n = Ba[t];
      void 0 === n && ((n = new Int32Array(t)), (Ba[t] = n));
      for (let r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
      return n;
    }

    function ja(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
    }

    function Wa(e, t) {
      const n = this.cache;
      if (void 0 !== t.x)
        (n[0] === t.x && n[1] === t.y) ||
          (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
      else {
        if (Ha(n, t)) return;
        e.uniform2fv(this.addr, t), Ga(n, t);
      }
    }

    function qa(e, t) {
      const n = this.cache;
      if (void 0 !== t.x)
        (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
          (e.uniform3f(this.addr, t.x, t.y, t.z),
          (n[0] = t.x),
          (n[1] = t.y),
          (n[2] = t.z));
      else if (void 0 !== t.r)
        (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
          (e.uniform3f(this.addr, t.r, t.g, t.b),
          (n[0] = t.r),
          (n[1] = t.g),
          (n[2] = t.b));
      else {
        if (Ha(n, t)) return;
        e.uniform3fv(this.addr, t), Ga(n, t);
      }
    }

    function $a(e, t) {
      const n = this.cache;
      if (void 0 !== t.x)
        (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
          (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
          (n[0] = t.x),
          (n[1] = t.y),
          (n[2] = t.z),
          (n[3] = t.w));
      else {
        if (Ha(n, t)) return;
        e.uniform4fv(this.addr, t), Ga(n, t);
      }
    }

    function Xa(e, t) {
      const n = this.cache,
        r = t.elements;
      if (void 0 === r) {
        if (Ha(n, t)) return;
        e.uniformMatrix2fv(this.addr, !1, t), Ga(n, t);
      } else {
        if (Ha(n, r)) return;
        Ua.set(r), e.uniformMatrix2fv(this.addr, !1, Ua), Ga(n, r);
      }
    }

    function Ya(e, t) {
      const n = this.cache,
        r = t.elements;
      if (void 0 === r) {
        if (Ha(n, t)) return;
        e.uniformMatrix3fv(this.addr, !1, t), Ga(n, t);
      } else {
        if (Ha(n, r)) return;
        Na.set(r), e.uniformMatrix3fv(this.addr, !1, Na), Ga(n, r);
      }
    }

    function Ja(e, t) {
      const n = this.cache,
        r = t.elements;
      if (void 0 === r) {
        if (Ha(n, t)) return;
        e.uniformMatrix4fv(this.addr, !1, t), Ga(n, t);
      } else {
        if (Ha(n, r)) return;
        Fa.set(r), e.uniformMatrix4fv(this.addr, !1, Fa), Ga(n, r);
      }
    }

    function Za(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
    }

    function Ka(e, t) {
      const n = this.cache;
      Ha(n, t) || (e.uniform2iv(this.addr, t), Ga(n, t));
    }

    function Qa(e, t) {
      const n = this.cache;
      Ha(n, t) || (e.uniform3iv(this.addr, t), Ga(n, t));
    }

    function es(e, t) {
      const n = this.cache;
      Ha(n, t) || (e.uniform4iv(this.addr, t), Ga(n, t));
    }

    function ts(e, t) {
      const n = this.cache;
      n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
    }

    function ns(e, t) {
      const n = this.cache;
      Ha(n, t) || (e.uniform2uiv(this.addr, t), Ga(n, t));
    }

    function rs(e, t) {
      const n = this.cache;
      Ha(n, t) || (e.uniform3uiv(this.addr, t), Ga(n, t));
    }

    function is(e, t) {
      const n = this.cache;
      Ha(n, t) || (e.uniform4uiv(this.addr, t), Ga(n, t));
    }

    function os(e, t, n) {
      const r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
        n.safeSetTexture2D(t || Ra, i);
    }

    function as(e, t, n) {
      const r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
        n.setTexture3D(t || ka, i);
    }

    function ss(e, t, n) {
      const r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
        n.safeSetTextureCube(t || Da, i);
    }

    function ls(e, t, n) {
      const r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (e.uniform1i(this.addr, i), (r[0] = i)),
        n.setTexture2DArray(t || Ia, i);
    }

    function cs(e, t) {
      e.uniform1fv(this.addr, t);
    }

    function us(e, t) {
      const n = za(t, this.size, 2);
      e.uniform2fv(this.addr, n);
    }

    function hs(e, t) {
      const n = za(t, this.size, 3);
      e.uniform3fv(this.addr, n);
    }

    function ds(e, t) {
      const n = za(t, this.size, 4);
      e.uniform4fv(this.addr, n);
    }

    function ps(e, t) {
      const n = za(t, this.size, 4);
      e.uniformMatrix2fv(this.addr, !1, n);
    }

    function fs(e, t) {
      const n = za(t, this.size, 9);
      e.uniformMatrix3fv(this.addr, !1, n);
    }

    function ms(e, t) {
      const n = za(t, this.size, 16);
      e.uniformMatrix4fv(this.addr, !1, n);
    }

    function gs(e, t) {
      e.uniform1iv(this.addr, t);
    }

    function vs(e, t) {
      e.uniform2iv(this.addr, t);
    }

    function ys(e, t) {
      e.uniform3iv(this.addr, t);
    }

    function xs(e, t) {
      e.uniform4iv(this.addr, t);
    }

    function bs(e, t) {
      e.uniform1uiv(this.addr, t);
    }

    function ws(e, t) {
      e.uniform2uiv(this.addr, t);
    }

    function _s(e, t) {
      e.uniform3uiv(this.addr, t);
    }

    function Ms(e, t) {
      e.uniform4uiv(this.addr, t);
    }

    function Ss(e, t, n) {
      const r = t.length,
        i = Va(n, r);
      e.uniform1iv(this.addr, i);
      for (let e = 0; e !== r; ++e) n.safeSetTexture2D(t[e] || Ra, i[e]);
    }

    function Ts(e, t, n) {
      const r = t.length,
        i = Va(n, r);
      e.uniform1iv(this.addr, i);
      for (let e = 0; e !== r; ++e) n.safeSetTextureCube(t[e] || Da, i[e]);
    }

    function Es(e, t, n) {
      (this.id = e),
        (this.addr = n),
        (this.cache = []),
        (this.setValue = (function (e) {
          switch (e) {
            case 5126:
              return ja;
            case 35664:
              return Wa;
            case 35665:
              return qa;
            case 35666:
              return $a;
            case 35674:
              return Xa;
            case 35675:
              return Ya;
            case 35676:
              return Ja;
            case 5124:
            case 35670:
              return Za;
            case 35667:
            case 35671:
              return Ka;
            case 35668:
            case 35672:
              return Qa;
            case 35669:
            case 35673:
              return es;
            case 5125:
              return ts;
            case 36294:
              return ns;
            case 36295:
              return rs;
            case 36296:
              return is;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return os;
            case 35679:
            case 36299:
            case 36307:
              return as;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return ss;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return ls;
          }
        })(t.type));
    }

    function As(e, t, n) {
      (this.id = e),
        (this.addr = n),
        (this.cache = []),
        (this.size = t.size),
        (this.setValue = (function (e) {
          switch (e) {
            case 5126:
              return cs;
            case 35664:
              return us;
            case 35665:
              return hs;
            case 35666:
              return ds;
            case 35674:
              return ps;
            case 35675:
              return fs;
            case 35676:
              return ms;
            case 5124:
            case 35670:
              return gs;
            case 35667:
            case 35671:
              return vs;
            case 35668:
            case 35672:
              return ys;
            case 35669:
            case 35673:
              return xs;
            case 5125:
              return bs;
            case 36294:
              return ws;
            case 36295:
              return _s;
            case 36296:
              return Ms;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Ss;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Ts;
          }
        })(t.type));
    }

    function Cs(e) {
      (this.id = e), (this.seq = []), (this.map = {});
    }
    (As.prototype.updateCache = function (e) {
      const t = this.cache;
      e instanceof Float32Array &&
        t.length !== e.length &&
        (this.cache = new Float32Array(e.length)),
        Ga(t, e);
    }),
      (Cs.prototype.setValue = function (e, t, n) {
        const r = this.seq;
        for (let i = 0, o = r.length; i !== o; ++i) {
          const o = r[i];
          o.setValue(e, t[o.id], n);
        }
      });
    const Ps = /(\w+)(\])?(\[|\.)?/g;

    function Ls(e, t) {
      e.seq.push(t), (e.map[t.id] = t);
    }

    function Rs(e, t, n) {
      const r = e.name,
        i = r.length;
      for (Ps.lastIndex = 0; ; ) {
        const o = Ps.exec(r),
          a = Ps.lastIndex;
        let s = o[1];
        const l = "]" === o[2],
          c = o[3];
        if ((l && (s |= 0), void 0 === c || ("[" === c && a + 2 === i))) {
          Ls(n, void 0 === c ? new Es(s, e, t) : new As(s, e, t));
          break;
        }
        {
          let e = n.map[s];
          void 0 === e && ((e = new Cs(s)), Ls(n, e)), (n = e);
        }
      }
    }

    function Is(e, t) {
      (this.seq = []), (this.map = {});
      const n = e.getProgramParameter(t, 35718);
      for (let r = 0; r < n; ++r) {
        const n = e.getActiveUniform(t, r);
        Rs(n, e.getUniformLocation(t, n.name), this);
      }
    }

    function ks(e, t, n) {
      const r = e.createShader(t);
      return e.shaderSource(r, n), e.compileShader(r), r;
    }
    (Is.prototype.setValue = function (e, t, n, r) {
      const i = this.map[t];
      void 0 !== i && i.setValue(e, n, r);
    }),
      (Is.prototype.setOptional = function (e, t, n) {
        const r = t[n];
        void 0 !== r && this.setValue(e, n, r);
      }),
      (Is.upload = function (e, t, n, r) {
        for (let i = 0, o = t.length; i !== o; ++i) {
          const o = t[i],
            a = n[o.id];
          !1 !== a.needsUpdate && o.setValue(e, a.value, r);
        }
      }),
      (Is.seqWithValue = function (e, t) {
        const n = [];
        for (let r = 0, i = e.length; r !== i; ++r) {
          const i = e[r];
          i.id in t && n.push(i);
        }
        return n;
      });
    let Ds = 0;

    function Os(e) {
      switch (e) {
        case Jt:
          return ["Linear", "( value )"];
        case Zt:
          return ["sRGB", "( value )"];
        case Qt:
          return ["RGBE", "( value )"];
        case tn:
          return ["RGBM", "( value, 7.0 )"];
        case nn:
          return ["RGBM", "( value, 16.0 )"];
        case rn:
          return ["RGBD", "( value, 256.0 )"];
        case Kt:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case en:
          return ["LogLuv", "( value )"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
            ["Linear", "( value )"]
          );
      }
    }

    function Bs(e, t, n) {
      const r = e.getShaderParameter(t, 35713),
        i = e.getShaderInfoLog(t).trim();
      return r && "" === i
        ? ""
        : n.toUpperCase() +
            "\n\n" +
            i +
            "\n\n" +
            (function (e) {
              const t = e.split("\n");
              for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
              return t.join("\n");
            })(e.getShaderSource(t));
    }

    function Fs(e, t) {
      const n = Os(t);
      return (
        "vec4 " +
        e +
        "( vec4 value ) { return " +
        n[0] +
        "ToLinear" +
        n[1] +
        "; }"
      );
    }

    function Ns(e, t) {
      const n = Os(t);
      return (
        "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
      );
    }

    function Us(e, t) {
      let n;
      switch (t) {
        case Q:
          n = "Linear";
          break;
        case ee:
          n = "Reinhard";
          break;
        case te:
          n = "OptimizedCineon";
          break;
        case ne:
          n = "ACESFilmic";
          break;
        case re:
          n = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
            (n = "Linear");
      }
      return (
        "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
      );
    }

    function zs(e) {
      return "" !== e;
    }

    function Hs(e, t) {
      return e
        .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
    }

    function Gs(e, t) {
      return e
        .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
        .replace(
          /UNION_CLIPPING_PLANES/g,
          t.numClippingPlanes - t.numClipIntersection
        );
    }
    const Vs = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function js(e) {
      return e.replace(Vs, Ws);
    }

    function Ws(e, t) {
      const n = Ho[t];
      if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
      return js(n);
    }
    const qs =
        /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      $s =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function Xs(e) {
      return e.replace($s, Js).replace(qs, Ys);
    }

    function Ys(e, t, n, r) {
      return (
        console.warn(
          "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
        ),
        Js(e, t, n, r)
      );
    }

    function Js(e, t, n, r) {
      let i = "";
      for (let e = parseInt(t); e < parseInt(n); e++)
        i += r
          .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
          .replace(/UNROLLED_LOOP_INDEX/g, e);
      return i;
    }

    function Zs(e) {
      let t =
        "precision " +
        e.precision +
        " float;\nprecision " +
        e.precision +
        " int;";
      return (
        "highp" === e.precision
          ? (t += "\n#define HIGH_PRECISION")
          : "mediump" === e.precision
          ? (t += "\n#define MEDIUM_PRECISION")
          : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
        t
      );
    }

    function Ks(e, t, n, r) {
      const i = e.getContext(),
        o = n.defines;
      let a = n.vertexShader,
        s = n.fragmentShader;
      const l = (function (e) {
          let t = "SHADOWMAP_TYPE_BASIC";
          return (
            e.shadowMapType === h
              ? (t = "SHADOWMAP_TYPE_PCF")
              : e.shadowMapType === d
              ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
              : e.shadowMapType === p && (t = "SHADOWMAP_TYPE_VSM"),
            t
          );
        })(n),
        c = (function (e) {
          let t = "ENVMAP_TYPE_CUBE";
          if (e.envMap)
            switch (e.envMapMode) {
              case oe:
              case ae:
                t = "ENVMAP_TYPE_CUBE";
                break;
              case ce:
              case ue:
                t = "ENVMAP_TYPE_CUBE_UV";
            }
          return t;
        })(n),
        u = (function (e) {
          let t = "ENVMAP_MODE_REFLECTION";
          if (e.envMap)
            switch (e.envMapMode) {
              case ae:
              case ue:
                t = "ENVMAP_MODE_REFRACTION";
            }
          return t;
        })(n),
        f = (function (e) {
          let t = "ENVMAP_BLENDING_NONE";
          if (e.envMap)
            switch (e.combine) {
              case Y:
                t = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case J:
                t = "ENVMAP_BLENDING_MIX";
                break;
              case Z:
                t = "ENVMAP_BLENDING_ADD";
            }
          return t;
        })(n),
        m = e.gammaFactor > 0 ? e.gammaFactor : 1,
        g = n.isWebGL2
          ? ""
          : (function (e) {
              return [
                e.extensionDerivatives ||
                e.envMapCubeUV ||
                e.bumpMap ||
                e.tangentSpaceNormalMap ||
                e.clearcoatNormalMap ||
                e.flatShading ||
                "physical" === e.shaderID
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
                e.rendererExtensionFragDepth
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (e.extensionShaderTextureLOD || e.envMap || e.transmission) &&
                e.rendererExtensionShaderTextureLod
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : "",
              ]
                .filter(zs)
                .join("\n");
            })(n),
        v = (function (e) {
          const t = [];
          for (const n in e) {
            const r = e[n];
            !1 !== r && t.push("#define " + n + " " + r);
          }
          return t.join("\n");
        })(o),
        y = i.createProgram();
      let x,
        b,
        w = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
      n.isRawShaderMaterial
        ? ((x = [v].filter(zs).join("\n")),
          x.length > 0 && (x += "\n"),
          (b = [g, v].filter(zs).join("\n")),
          b.length > 0 && (b += "\n"))
        : ((x = [
            Zs(n),
            "#define SHADER_NAME " + n.shaderName,
            v,
            n.instancing ? "#define USE_INSTANCING" : "",
            n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
            "#define GAMMA_FACTOR " + m,
            "#define MAX_BONES " + n.maxBones,
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + u : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMap && n.objectSpaceNormalMap
              ? "#define OBJECTSPACE_NORMALMAP"
              : "",
            n.normalMap && n.tangentSpaceNormalMap
              ? "#define TANGENTSPACE_NORMALMAP"
              : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.displacementMap && n.supportsVertexTextures
              ? "#define USE_DISPLACEMENTMAP"
              : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.transmission ? "#define USE_TRANSMISSION" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            n.vertexTangents ? "#define USE_TANGENT" : "",
            n.vertexColors ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUvs ? "#define USE_UV" : "",
            n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.skinning ? "#define USE_SKINNING" : "",
            n.useVertexTexture ? "#define BONE_TEXTURE" : "",
            n.morphTargets ? "#define USE_MORPHTARGETS" : "",
            n.morphNormals && !1 === n.flatShading
              ? "#define USE_MORPHNORMALS"
              : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "\tattribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "\tattribute vec3 instanceColor;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_TANGENT",
            "\tattribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "\tattribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "\tattribute vec3 color;",
            "#endif",
            "#ifdef USE_MORPHTARGETS",
            "\tattribute vec3 morphTarget0;",
            "\tattribute vec3 morphTarget1;",
            "\tattribute vec3 morphTarget2;",
            "\tattribute vec3 morphTarget3;",
            "\t#ifdef USE_MORPHNORMALS",
            "\t\tattribute vec3 morphNormal0;",
            "\t\tattribute vec3 morphNormal1;",
            "\t\tattribute vec3 morphNormal2;",
            "\t\tattribute vec3 morphNormal3;",
            "\t#else",
            "\t\tattribute vec3 morphTarget4;",
            "\t\tattribute vec3 morphTarget5;",
            "\t\tattribute vec3 morphTarget6;",
            "\t\tattribute vec3 morphTarget7;",
            "\t#endif",
            "#endif",
            "#ifdef USE_SKINNING",
            "\tattribute vec4 skinIndex;",
            "\tattribute vec4 skinWeight;",
            "#endif",
            "\n",
          ]
            .filter(zs)
            .join("\n")),
          (b = [
            g,
            Zs(n),
            "#define SHADER_NAME " + n.shaderName,
            v,
            "#define GAMMA_FACTOR " + m,
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.matcap ? "#define USE_MATCAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + c : "",
            n.envMap ? "#define " + u : "",
            n.envMap ? "#define " + f : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMap && n.objectSpaceNormalMap
              ? "#define OBJECTSPACE_NORMALMAP"
              : "",
            n.normalMap && n.tangentSpaceNormalMap
              ? "#define TANGENTSPACE_NORMALMAP"
              : "",
            n.clearcoat ? "#define USE_CLEARCOAT" : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.alphaTest ? "#define USE_ALPHATEST" : "",
            n.sheenTint ? "#define USE_SHEEN" : "",
            n.transmission ? "#define USE_TRANSMISSION" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            n.vertexTangents ? "#define USE_TANGENT" : "",
            n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUvs ? "#define USE_UV" : "",
            n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            n.gradientMap ? "#define USE_GRADIENTMAP" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            n.physicallyCorrectLights
              ? "#define PHYSICALLY_CORRECT_LIGHTS"
              : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            (n.extensionShaderTextureLOD || n.envMap) &&
            n.rendererExtensionShaderTextureLod
              ? "#define TEXTURE_LOD_EXT"
              : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            n.toneMapping !== K ? "#define TONE_MAPPING" : "",
            n.toneMapping !== K ? Ho.tonemapping_pars_fragment : "",
            n.toneMapping !== K ? Us("toneMapping", n.toneMapping) : "",
            n.dithering ? "#define DITHERING" : "",
            n.format === Fe ? "#define OPAQUE" : "",
            Ho.encodings_pars_fragment,
            n.map ? Fs("mapTexelToLinear", n.mapEncoding) : "",
            n.matcap ? Fs("matcapTexelToLinear", n.matcapEncoding) : "",
            n.envMap ? Fs("envMapTexelToLinear", n.envMapEncoding) : "",
            n.emissiveMap
              ? Fs("emissiveMapTexelToLinear", n.emissiveMapEncoding)
              : "",
            n.specularTintMap
              ? Fs("specularTintMapTexelToLinear", n.specularTintMapEncoding)
              : "",
            n.lightMap ? Fs("lightMapTexelToLinear", n.lightMapEncoding) : "",
            Ns("linearToOutputTexel", n.outputEncoding),
            n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
            "\n",
          ]
            .filter(zs)
            .join("\n"))),
        (a = js(a)),
        (a = Hs(a, n)),
        (a = Gs(a, n)),
        (s = js(s)),
        (s = Hs(s, n)),
        (s = Gs(s, n)),
        (a = Xs(a)),
        (s = Xs(s)),
        n.isWebGL2 &&
          !0 !== n.isRawShaderMaterial &&
          ((w = "#version 300 es\n"),
          (x =
            [
              "#define attribute in",
              "#define varying out",
              "#define texture2D texture",
            ].join("\n") +
            "\n" +
            x),
          (b =
            [
              "#define varying in",
              n.glslVersion === On ? "" : "out highp vec4 pc_fragColor;",
              n.glslVersion === On ? "" : "#define gl_FragColor pc_fragColor",
              "#define gl_FragDepthEXT gl_FragDepth",
              "#define texture2D texture",
              "#define textureCube texture",
              "#define texture2DProj textureProj",
              "#define texture2DLodEXT textureLod",
              "#define texture2DProjLodEXT textureProjLod",
              "#define textureCubeLodEXT textureLod",
              "#define texture2DGradEXT textureGrad",
              "#define texture2DProjGradEXT textureProjGrad",
              "#define textureCubeGradEXT textureGrad",
            ].join("\n") +
            "\n" +
            b));
      const _ = w + b + s,
        M = ks(i, 35633, w + x + a),
        S = ks(i, 35632, _);
      if (
        (i.attachShader(y, M),
        i.attachShader(y, S),
        void 0 !== n.index0AttributeName
          ? i.bindAttribLocation(y, 0, n.index0AttributeName)
          : !0 === n.morphTargets && i.bindAttribLocation(y, 0, "position"),
        i.linkProgram(y),
        e.debug.checkShaderErrors)
      ) {
        const e = i.getProgramInfoLog(y).trim(),
          t = i.getShaderInfoLog(M).trim(),
          n = i.getShaderInfoLog(S).trim();
        let r = !0,
          o = !0;
        if (!1 === i.getProgramParameter(y, 35714)) {
          r = !1;
          const t = Bs(i, M, "vertex"),
            n = Bs(i, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(y, 35715) +
              "\n\nProgram Info Log: " +
              e +
              "\n" +
              t +
              "\n" +
              n
          );
        } else
          "" !== e
            ? console.warn("THREE.WebGLProgram: Program Info Log:", e)
            : ("" !== t && "" !== n) || (o = !1);
        o &&
          (this.diagnostics = {
            runnable: r,
            programLog: e,
            vertexShader: {
              log: t,
              prefix: x,
            },
            fragmentShader: {
              log: n,
              prefix: b,
            },
          });
      }
      let T, E;
      return (
        i.deleteShader(M),
        i.deleteShader(S),
        (this.getUniforms = function () {
          return void 0 === T && (T = new Is(i, y)), T;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === E &&
              (E = (function (e, t) {
                const n = {},
                  r = e.getProgramParameter(t, 35721);
                for (let i = 0; i < r; i++) {
                  const r = e.getActiveAttrib(t, i),
                    o = r.name;
                  let a = 1;
                  35674 === r.type && (a = 2),
                    35675 === r.type && (a = 3),
                    35676 === r.type && (a = 4),
                    (n[o] = {
                      type: r.type,
                      location: e.getAttribLocation(t, o),
                      locationSize: a,
                    });
                }
                return n;
              })(i, y)),
            E
          );
        }),
        (this.destroy = function () {
          r.releaseStatesOfProgram(this),
            i.deleteProgram(y),
            (this.program = void 0);
        }),
        (this.name = n.shaderName),
        (this.id = Ds++),
        (this.cacheKey = t),
        (this.usedTimes = 1),
        (this.program = y),
        (this.vertexShader = M),
        (this.fragmentShader = S),
        this
      );
    }

    function Qs(e, t, n, r, i, o, a) {
      const s = [],
        l = i.isWebGL2,
        c = i.logarithmicDepthBuffer,
        u = i.floatVertexTextures,
        h = i.maxVertexUniforms,
        d = i.vertexTextures;
      let p = i.precision;
      const f = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        },
        v = [
          "precision",
          "isWebGL2",
          "supportsVertexTextures",
          "outputEncoding",
          "instancing",
          "instancingColor",
          "map",
          "mapEncoding",
          "matcap",
          "matcapEncoding",
          "envMap",
          "envMapMode",
          "envMapEncoding",
          "envMapCubeUV",
          "lightMap",
          "lightMapEncoding",
          "aoMap",
          "emissiveMap",
          "emissiveMapEncoding",
          "bumpMap",
          "normalMap",
          "objectSpaceNormalMap",
          "tangentSpaceNormalMap",
          "clearcoat",
          "clearcoatMap",
          "clearcoatRoughnessMap",
          "clearcoatNormalMap",
          "displacementMap",
          "specularMap",
          "specularIntensityMap",
          "specularTintMap",
          "specularTintMapEncoding",
          "roughnessMap",
          "metalnessMap",
          "gradientMap",
          "alphaMap",
          "alphaTest",
          "combine",
          "vertexColors",
          "vertexAlphas",
          "vertexTangents",
          "vertexUvs",
          "uvsVertexOnly",
          "fog",
          "useFog",
          "fogExp2",
          "flatShading",
          "sizeAttenuation",
          "logarithmicDepthBuffer",
          "skinning",
          "maxBones",
          "useVertexTexture",
          "morphTargets",
          "morphNormals",
          "premultipliedAlpha",
          "numDirLights",
          "numPointLights",
          "numSpotLights",
          "numHemiLights",
          "numRectAreaLights",
          "numDirLightShadows",
          "numPointLightShadows",
          "numSpotLightShadows",
          "shadowMapEnabled",
          "shadowMapType",
          "toneMapping",
          "physicallyCorrectLights",
          "doubleSided",
          "flipSided",
          "numClippingPlanes",
          "numClipIntersection",
          "depthPacking",
          "dithering",
          "format",
          "sheenTint",
          "transmission",
          "transmissionMap",
          "thicknessMap",
        ];

      function y(e) {
        let t;
        return (
          e && e.isTexture
            ? (t = e.encoding)
            : e && e.isWebGLRenderTarget
            ? (console.warn(
                "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
              ),
              (t = e.texture.encoding))
            : (t = Jt),
          t
        );
      }
      return {
        getParameters: function (o, s, v, x, b) {
          const w = x.fog,
            _ = o.isMeshStandardMaterial ? x.environment : null,
            M = (o.isMeshStandardMaterial ? n : t).get(o.envMap || _),
            S = f[o.type],
            T = b.isSkinnedMesh
              ? (function (e) {
                  const t = e.skeleton.bones;
                  if (u) return 1024;
                  {
                    const e = h,
                      n = Math.floor((e - 20) / 4),
                      r = Math.min(n, t.length);
                    return r < t.length
                      ? (console.warn(
                          "THREE.WebGLRenderer: Skeleton has " +
                            t.length +
                            " bones. This GPU supports " +
                            r +
                            "."
                        ),
                        0)
                      : r;
                  }
                })(b)
              : 0;
          let E, A;
          if (
            (null !== o.precision &&
              ((p = i.getMaxPrecision(o.precision)),
              p !== o.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  o.precision,
                  "not supported, using",
                  p,
                  "instead."
                )),
            S)
          ) {
            const e = Vo[S];
            (E = e.vertexShader), (A = e.fragmentShader);
          } else (E = o.vertexShader), (A = o.fragmentShader);
          const C = e.getRenderTarget(),
            P = o.alphaTest > 0,
            L = o.clearcoat > 0;
          return {
            isWebGL2: l,
            shaderID: S,
            shaderName: o.type,
            vertexShader: E,
            fragmentShader: A,
            defines: o.defines,
            isRawShaderMaterial: !0 === o.isRawShaderMaterial,
            glslVersion: o.glslVersion,
            precision: p,
            instancing: !0 === b.isInstancedMesh,
            instancingColor:
              !0 === b.isInstancedMesh && null !== b.instanceColor,
            supportsVertexTextures: d,
            outputEncoding: null !== C ? y(C.texture) : e.outputEncoding,
            map: !!o.map,
            mapEncoding: y(o.map),
            matcap: !!o.matcap,
            matcapEncoding: y(o.matcap),
            envMap: !!M,
            envMapMode: M && M.mapping,
            envMapEncoding: y(M),
            envMapCubeUV: !!M && (M.mapping === ce || M.mapping === ue),
            lightMap: !!o.lightMap,
            lightMapEncoding: y(o.lightMap),
            aoMap: !!o.aoMap,
            emissiveMap: !!o.emissiveMap,
            emissiveMapEncoding: y(o.emissiveMap),
            bumpMap: !!o.bumpMap,
            normalMap: !!o.normalMap,
            objectSpaceNormalMap: o.normalMapType === ln,
            tangentSpaceNormalMap: o.normalMapType === sn,
            clearcoat: L,
            clearcoatMap: L && !!o.clearcoatMap,
            clearcoatRoughnessMap: L && !!o.clearcoatRoughnessMap,
            clearcoatNormalMap: L && !!o.clearcoatNormalMap,
            displacementMap: !!o.displacementMap,
            roughnessMap: !!o.roughnessMap,
            metalnessMap: !!o.metalnessMap,
            specularMap: !!o.specularMap,
            specularIntensityMap: !!o.specularIntensityMap,
            specularTintMap: !!o.specularTintMap,
            specularTintMapEncoding: y(o.specularTintMap),
            alphaMap: !!o.alphaMap,
            alphaTest: P,
            gradientMap: !!o.gradientMap,
            sheenTint:
              !!o.sheenTint &&
              (o.sheenTint.r > 0 || o.sheenTint.g > 0 || o.sheenTint.b > 0),
            transmission: o.transmission > 0,
            transmissionMap: !!o.transmissionMap,
            thicknessMap: !!o.thicknessMap,
            combine: o.combine,
            vertexTangents:
              !!o.normalMap && !!b.geometry && !!b.geometry.attributes.tangent,
            vertexColors: o.vertexColors,
            vertexAlphas:
              !0 === o.vertexColors &&
              !!b.geometry &&
              !!b.geometry.attributes.color &&
              4 === b.geometry.attributes.color.itemSize,
            vertexUvs: !!(
              o.map ||
              o.bumpMap ||
              o.normalMap ||
              o.specularMap ||
              o.alphaMap ||
              o.emissiveMap ||
              o.roughnessMap ||
              o.metalnessMap ||
              o.clearcoatMap ||
              o.clearcoatRoughnessMap ||
              o.clearcoatNormalMap ||
              o.displacementMap ||
              o.transmissionMap ||
              o.thicknessMap ||
              o.specularIntensityMap ||
              o.specularTintMap
            ),
            uvsVertexOnly: !(
              o.map ||
              o.bumpMap ||
              o.normalMap ||
              o.specularMap ||
              o.alphaMap ||
              o.emissiveMap ||
              o.roughnessMap ||
              o.metalnessMap ||
              o.clearcoatNormalMap ||
              o.transmission > 0 ||
              o.transmissionMap ||
              o.thicknessMap ||
              o.specularIntensityMap ||
              o.specularTintMap ||
              !o.displacementMap
            ),
            fog: !!w,
            useFog: o.fog,
            fogExp2: w && w.isFogExp2,
            flatShading: !!o.flatShading,
            sizeAttenuation: o.sizeAttenuation,
            logarithmicDepthBuffer: c,
            skinning: !0 === b.isSkinnedMesh && T > 0,
            maxBones: T,
            useVertexTexture: u,
            morphTargets: !!b.geometry && !!b.geometry.morphAttributes.position,
            morphNormals: !!b.geometry && !!b.geometry.morphAttributes.normal,
            numDirLights: s.directional.length,
            numPointLights: s.point.length,
            numSpotLights: s.spot.length,
            numRectAreaLights: s.rectArea.length,
            numHemiLights: s.hemi.length,
            numDirLightShadows: s.directionalShadowMap.length,
            numPointLightShadows: s.pointShadowMap.length,
            numSpotLightShadows: s.spotShadowMap.length,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            format: o.format,
            dithering: o.dithering,
            shadowMapEnabled: e.shadowMap.enabled && v.length > 0,
            shadowMapType: e.shadowMap.type,
            toneMapping: o.toneMapped ? e.toneMapping : K,
            physicallyCorrectLights: e.physicallyCorrectLights,
            premultipliedAlpha: o.premultipliedAlpha,
            doubleSided: o.side === g,
            flipSided: o.side === m,
            depthPacking: void 0 !== o.depthPacking && o.depthPacking,
            index0AttributeName: o.index0AttributeName,
            extensionDerivatives: o.extensions && o.extensions.derivatives,
            extensionFragDepth: o.extensions && o.extensions.fragDepth,
            extensionDrawBuffers: o.extensions && o.extensions.drawBuffers,
            extensionShaderTextureLOD:
              o.extensions && o.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: l || r.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: l || r.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              l || r.has("EXT_shader_texture_lod"),
            customProgramCacheKey: o.customProgramCacheKey(),
          };
        },
        getProgramCacheKey: function (t) {
          const n = [];
          if (
            (t.shaderID
              ? n.push(t.shaderID)
              : (n.push(t.fragmentShader), n.push(t.vertexShader)),
            void 0 !== t.defines)
          )
            for (const e in t.defines) n.push(e), n.push(t.defines[e]);
          if (!1 === t.isRawShaderMaterial) {
            for (let e = 0; e < v.length; e++) n.push(t[v[e]]);
            n.push(e.outputEncoding), n.push(e.gammaFactor);
          }
          return n.push(t.customProgramCacheKey), n.join();
        },
        getUniforms: function (e) {
          const t = f[e.type];
          let n;
          if (t) {
            const e = Vo[t];
            n = So.clone(e.uniforms);
          } else n = e.uniforms;
          return n;
        },
        acquireProgram: function (t, n) {
          let r;
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e];
            if (t.cacheKey === n) {
              (r = t), ++r.usedTimes;
              break;
            }
          }
          return void 0 === r && ((r = new Ks(e, n, t, o)), s.push(r)), r;
        },
        releaseProgram: function (e) {
          if (0 == --e.usedTimes) {
            const t = s.indexOf(e);
            (s[t] = s[s.length - 1]), s.pop(), e.destroy();
          }
        },
        programs: s,
      };
    }

    function el() {
      let e = new WeakMap();
      return {
        get: function (t) {
          let n = e.get(t);
          return void 0 === n && ((n = {}), e.set(t, n)), n;
        },
        remove: function (t) {
          e.delete(t);
        },
        update: function (t, n, r) {
          e.get(t)[n] = r;
        },
        dispose: function () {
          e = new WeakMap();
        },
      };
    }

    function tl(e, t) {
      return e.groupOrder !== t.groupOrder
        ? e.groupOrder - t.groupOrder
        : e.renderOrder !== t.renderOrder
        ? e.renderOrder - t.renderOrder
        : e.program !== t.program
        ? e.program.id - t.program.id
        : e.material.id !== t.material.id
        ? e.material.id - t.material.id
        : e.z !== t.z
        ? e.z - t.z
        : e.id - t.id;
    }

    function nl(e, t) {
      return e.groupOrder !== t.groupOrder
        ? e.groupOrder - t.groupOrder
        : e.renderOrder !== t.renderOrder
        ? e.renderOrder - t.renderOrder
        : e.z !== t.z
        ? t.z - e.z
        : e.id - t.id;
    }

    function rl(e) {
      const t = [];
      let n = 0;
      const r = [],
        i = [],
        o = [],
        a = {
          id: -1,
        };

      function s(r, i, o, s, l, c) {
        let u = t[n];
        const h = e.get(o);
        return (
          void 0 === u
            ? ((u = {
                id: r.id,
                object: r,
                geometry: i,
                material: o,
                program: h.program || a,
                groupOrder: s,
                renderOrder: r.renderOrder,
                z: l,
                group: c,
              }),
              (t[n] = u))
            : ((u.id = r.id),
              (u.object = r),
              (u.geometry = i),
              (u.material = o),
              (u.program = h.program || a),
              (u.groupOrder = s),
              (u.renderOrder = r.renderOrder),
              (u.z = l),
              (u.group = c)),
          n++,
          u
        );
      }
      return {
        opaque: r,
        transmissive: i,
        transparent: o,
        init: function () {
          (n = 0), (r.length = 0), (i.length = 0), (o.length = 0);
        },
        push: function (e, t, n, a, l, c) {
          const u = s(e, t, n, a, l, c);
          n.transmission > 0
            ? i.push(u)
            : !0 === n.transparent
            ? o.push(u)
            : r.push(u);
        },
        unshift: function (e, t, n, a, l, c) {
          const u = s(e, t, n, a, l, c);
          n.transmission > 0
            ? i.unshift(u)
            : !0 === n.transparent
            ? o.unshift(u)
            : r.unshift(u);
        },
        finish: function () {
          for (let e = n, r = t.length; e < r; e++) {
            const n = t[e];
            if (null === n.id) break;
            (n.id = null),
              (n.object = null),
              (n.geometry = null),
              (n.material = null),
              (n.program = null),
              (n.group = null);
          }
        },
        sort: function (e, t) {
          r.length > 1 && r.sort(e || tl),
            i.length > 1 && i.sort(t || nl),
            o.length > 1 && o.sort(t || nl);
        },
      };
    }

    function il(e) {
      let t = new WeakMap();
      return {
        get: function (n, r) {
          let i;
          return (
            !1 === t.has(n)
              ? ((i = new rl(e)), t.set(n, [i]))
              : r >= t.get(n).length
              ? ((i = new rl(e)), t.get(n).push(i))
              : (i = t.get(n)[r]),
            i
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }

    function ol() {
      const e = {};
      return {
        get: function (t) {
          if (void 0 !== e[t.id]) return e[t.id];
          let n;
          switch (t.type) {
            case "DirectionalLight":
              n = {
                direction: new sr(),
                color: new Pi(),
              };
              break;
            case "SpotLight":
              n = {
                position: new sr(),
                direction: new sr(),
                color: new Pi(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
              };
              break;
            case "PointLight":
              n = {
                position: new sr(),
                color: new Pi(),
                distance: 0,
                decay: 0,
              };
              break;
            case "HemisphereLight":
              n = {
                direction: new sr(),
                skyColor: new Pi(),
                groundColor: new Pi(),
              };
              break;
            case "RectAreaLight":
              n = {
                color: new Pi(),
                position: new sr(),
                halfWidth: new sr(),
                halfHeight: new sr(),
              };
          }
          return (e[t.id] = n), n;
        },
      };
    }
    let al = 0;

    function sl(e, t) {
      return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0);
    }

    function ll(e, t) {
      const n = new ol(),
        r = (function () {
          const e = {};
          return {
            get: function (t) {
              if (void 0 !== e[t.id]) return e[t.id];
              let n;
              switch (t.type) {
                case "DirectionalLight":
                case "SpotLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Yn(),
                  };
                  break;
                case "PointLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Yn(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (e[t.id] = n), n;
            },
          };
        })(),
        i = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
        };
      for (let e = 0; e < 9; e++) i.probe.push(new sr());
      const o = new sr(),
        a = new Nr(),
        s = new Nr();
      return {
        setup: function (o, a) {
          let s = 0,
            l = 0,
            c = 0;
          for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
          let u = 0,
            h = 0,
            d = 0,
            p = 0,
            f = 0,
            m = 0,
            g = 0,
            v = 0;
          o.sort(sl);
          const y = !0 !== a ? Math.PI : 1;
          for (let e = 0, t = o.length; e < t; e++) {
            const t = o[e],
              a = t.color,
              x = t.intensity,
              b = t.distance,
              w = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
            if (t.isAmbientLight)
              (s += a.r * x * y), (l += a.g * x * y), (c += a.b * x * y);
            else if (t.isLightProbe)
              for (let e = 0; e < 9; e++)
                i.probe[e].addScaledVector(t.sh.coefficients[e], x);
            else if (t.isDirectionalLight) {
              const e = n.get(t);
              if (
                (e.color.copy(t.color).multiplyScalar(t.intensity * y),
                t.castShadow)
              ) {
                const e = t.shadow,
                  n = r.get(t);
                (n.shadowBias = e.bias),
                  (n.shadowNormalBias = e.normalBias),
                  (n.shadowRadius = e.radius),
                  (n.shadowMapSize = e.mapSize),
                  (i.directionalShadow[u] = n),
                  (i.directionalShadowMap[u] = w),
                  (i.directionalShadowMatrix[u] = t.shadow.matrix),
                  m++;
              }
              (i.directional[u] = e), u++;
            } else if (t.isSpotLight) {
              const e = n.get(t);
              if (
                (e.position.setFromMatrixPosition(t.matrixWorld),
                e.color.copy(a).multiplyScalar(x * y),
                (e.distance = b),
                (e.coneCos = Math.cos(t.angle)),
                (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
                (e.decay = t.decay),
                t.castShadow)
              ) {
                const e = t.shadow,
                  n = r.get(t);
                (n.shadowBias = e.bias),
                  (n.shadowNormalBias = e.normalBias),
                  (n.shadowRadius = e.radius),
                  (n.shadowMapSize = e.mapSize),
                  (i.spotShadow[d] = n),
                  (i.spotShadowMap[d] = w),
                  (i.spotShadowMatrix[d] = t.shadow.matrix),
                  v++;
              }
              (i.spot[d] = e), d++;
            } else if (t.isRectAreaLight) {
              const e = n.get(t);
              e.color.copy(a).multiplyScalar(x),
                e.halfWidth.set(0.5 * t.width, 0, 0),
                e.halfHeight.set(0, 0.5 * t.height, 0),
                (i.rectArea[p] = e),
                p++;
            } else if (t.isPointLight) {
              const e = n.get(t);
              if (
                (e.color.copy(t.color).multiplyScalar(t.intensity * y),
                (e.distance = t.distance),
                (e.decay = t.decay),
                t.castShadow)
              ) {
                const e = t.shadow,
                  n = r.get(t);
                (n.shadowBias = e.bias),
                  (n.shadowNormalBias = e.normalBias),
                  (n.shadowRadius = e.radius),
                  (n.shadowMapSize = e.mapSize),
                  (n.shadowCameraNear = e.camera.near),
                  (n.shadowCameraFar = e.camera.far),
                  (i.pointShadow[h] = n),
                  (i.pointShadowMap[h] = w),
                  (i.pointShadowMatrix[h] = t.shadow.matrix),
                  g++;
              }
              (i.point[h] = e), h++;
            } else if (t.isHemisphereLight) {
              const e = n.get(t);
              e.skyColor.copy(t.color).multiplyScalar(x * y),
                e.groundColor.copy(t.groundColor).multiplyScalar(x * y),
                (i.hemi[f] = e),
                f++;
            }
          }
          p > 0 &&
            (t.isWebGL2 || !0 === e.has("OES_texture_float_linear")
              ? ((i.rectAreaLTC1 = Go.LTC_FLOAT_1),
                (i.rectAreaLTC2 = Go.LTC_FLOAT_2))
              : !0 === e.has("OES_texture_half_float_linear")
              ? ((i.rectAreaLTC1 = Go.LTC_HALF_1),
                (i.rectAreaLTC2 = Go.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (i.ambient[0] = s),
            (i.ambient[1] = l),
            (i.ambient[2] = c);
          const x = i.hash;
          (x.directionalLength === u &&
            x.pointLength === h &&
            x.spotLength === d &&
            x.rectAreaLength === p &&
            x.hemiLength === f &&
            x.numDirectionalShadows === m &&
            x.numPointShadows === g &&
            x.numSpotShadows === v) ||
            ((i.directional.length = u),
            (i.spot.length = d),
            (i.rectArea.length = p),
            (i.point.length = h),
            (i.hemi.length = f),
            (i.directionalShadow.length = m),
            (i.directionalShadowMap.length = m),
            (i.pointShadow.length = g),
            (i.pointShadowMap.length = g),
            (i.spotShadow.length = v),
            (i.spotShadowMap.length = v),
            (i.directionalShadowMatrix.length = m),
            (i.pointShadowMatrix.length = g),
            (i.spotShadowMatrix.length = v),
            (x.directionalLength = u),
            (x.pointLength = h),
            (x.spotLength = d),
            (x.rectAreaLength = p),
            (x.hemiLength = f),
            (x.numDirectionalShadows = m),
            (x.numPointShadows = g),
            (x.numSpotShadows = v),
            (i.version = al++));
        },
        setupView: function (e, t) {
          let n = 0,
            r = 0,
            l = 0,
            c = 0,
            u = 0;
          const h = t.matrixWorldInverse;
          for (let t = 0, d = e.length; t < d; t++) {
            const d = e[t];
            if (d.isDirectionalLight) {
              const e = i.directional[n];
              e.direction.setFromMatrixPosition(d.matrixWorld),
                o.setFromMatrixPosition(d.target.matrixWorld),
                e.direction.sub(o),
                e.direction.transformDirection(h),
                n++;
            } else if (d.isSpotLight) {
              const e = i.spot[l];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(h),
                e.direction.setFromMatrixPosition(d.matrixWorld),
                o.setFromMatrixPosition(d.target.matrixWorld),
                e.direction.sub(o),
                e.direction.transformDirection(h),
                l++;
            } else if (d.isRectAreaLight) {
              const e = i.rectArea[c];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(h),
                s.identity(),
                a.copy(d.matrixWorld),
                a.premultiply(h),
                s.extractRotation(a),
                e.halfWidth.set(0.5 * d.width, 0, 0),
                e.halfHeight.set(0, 0.5 * d.height, 0),
                e.halfWidth.applyMatrix4(s),
                e.halfHeight.applyMatrix4(s),
                c++;
            } else if (d.isPointLight) {
              const e = i.point[r];
              e.position.setFromMatrixPosition(d.matrixWorld),
                e.position.applyMatrix4(h),
                r++;
            } else if (d.isHemisphereLight) {
              const e = i.hemi[u];
              e.direction.setFromMatrixPosition(d.matrixWorld),
                e.direction.transformDirection(h),
                e.direction.normalize(),
                u++;
            }
          }
        },
        state: i,
      };
    }

    function cl(e, t) {
      const n = new ll(e, t),
        r = [],
        i = [];
      return {
        init: function () {
          (r.length = 0), (i.length = 0);
        },
        state: {
          lightsArray: r,
          shadowsArray: i,
          lights: n,
        },
        setupLights: function (e) {
          n.setup(r, e);
        },
        setupLightsView: function (e) {
          n.setupView(r, e);
        },
        pushLight: function (e) {
          r.push(e);
        },
        pushShadow: function (e) {
          i.push(e);
        },
      };
    }

    function ul(e, t) {
      let n = new WeakMap();
      return {
        get: function (r, i = 0) {
          let o;
          return (
            !1 === n.has(r)
              ? ((o = new cl(e, t)), n.set(r, [o]))
              : i >= n.get(r).length
              ? ((o = new cl(e, t)), n.get(r).push(o))
              : (o = n.get(r)[i]),
            o
          );
        },
        dispose: function () {
          n = new WeakMap();
        },
      };
    }
    class hl extends _i {
      constructor(e) {
        super(),
          (this.type = "MeshDepthMaterial"),
          (this.depthPacking = on),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.depthPacking = e.depthPacking),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          this
        );
      }
    }
    hl.prototype.isMeshDepthMaterial = !0;
    class dl extends _i {
      constructor(e) {
        super(),
          (this.type = "MeshDistanceMaterial"),
          (this.referencePosition = new sr()),
          (this.nearDistance = 1),
          (this.farDistance = 1e3),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.fog = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.referencePosition.copy(e.referencePosition),
          (this.nearDistance = e.nearDistance),
          (this.farDistance = e.farDistance),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          this
        );
      }
    }
    dl.prototype.isMeshDistanceMaterial = !0;

    function pl(e, t, n) {
      let r = new Fo();
      const i = new Yn(),
        o = new Yn(),
        a = new nr(),
        s = new hl({
          depthPacking: an,
        }),
        l = new dl(),
        c = {},
        u = n.maxTextureSize,
        d = {
          0: m,
          1: f,
          2: g,
        },
        v = new To({
          uniforms: {
            shadow_pass: {
              value: null,
            },
            resolution: {
              value: new Yn(),
            },
            radius: {
              value: 4,
            },
            samples: {
              value: 8,
            },
          },
          vertexShader:
            "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
          fragmentShader:
            "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
        }),
        y = v.clone();
      y.defines.HORIZONTAL_PASS = 1;
      const b = new eo();
      b.setAttribute(
        "position",
        new ki(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
      );
      const w = new xo(b, v),
        _ = this;

      function M(n, r) {
        const i = t.update(w);
        (v.uniforms.shadow_pass.value = n.map.texture),
          (v.uniforms.resolution.value = n.mapSize),
          (v.uniforms.radius.value = n.radius),
          (v.uniforms.samples.value = n.blurSamples),
          e.setRenderTarget(n.mapPass),
          e.clear(),
          e.renderBufferDirect(r, null, i, v, w, null),
          (y.uniforms.shadow_pass.value = n.mapPass.texture),
          (y.uniforms.resolution.value = n.mapSize),
          (y.uniforms.radius.value = n.radius),
          (y.uniforms.samples.value = n.blurSamples),
          e.setRenderTarget(n.map),
          e.clear(),
          e.renderBufferDirect(r, null, i, y, w, null);
      }

      function S(t, n, r, i, o, a, u) {
        let h = null;
        const f =
          !0 === i.isPointLight
            ? t.customDistanceMaterial
            : t.customDepthMaterial;
        if (
          ((h = void 0 !== f ? f : !0 === i.isPointLight ? l : s),
          (e.localClippingEnabled &&
            !0 === r.clipShadows &&
            0 !== r.clippingPlanes.length) ||
            (r.displacementMap && 0 !== r.displacementScale) ||
            (r.alphaMap && r.alphaTest > 0))
        ) {
          const e = h.uuid,
            t = r.uuid;
          let n = c[e];
          void 0 === n && ((n = {}), (c[e] = n));
          let i = n[t];
          void 0 === i && ((i = h.clone()), (n[t] = i)), (h = i);
        }
        return (
          (h.visible = r.visible),
          (h.wireframe = r.wireframe),
          (h.side =
            u === p
              ? null !== r.shadowSide
                ? r.shadowSide
                : r.side
              : null !== r.shadowSide
              ? r.shadowSide
              : d[r.side]),
          (h.alphaMap = r.alphaMap),
          (h.alphaTest = r.alphaTest),
          (h.clipShadows = r.clipShadows),
          (h.clippingPlanes = r.clippingPlanes),
          (h.clipIntersection = r.clipIntersection),
          (h.displacementMap = r.displacementMap),
          (h.displacementScale = r.displacementScale),
          (h.displacementBias = r.displacementBias),
          (h.wireframeLinewidth = r.wireframeLinewidth),
          (h.linewidth = r.linewidth),
          !0 === i.isPointLight &&
            !0 === h.isMeshDistanceMaterial &&
            (h.referencePosition.setFromMatrixPosition(i.matrixWorld),
            (h.nearDistance = o),
            (h.farDistance = a)),
          h
        );
      }

      function T(n, i, o, a, s) {
        if (!1 === n.visible) return;
        if (
          n.layers.test(i.layers) &&
          (n.isMesh || n.isLine || n.isPoints) &&
          (n.castShadow || (n.receiveShadow && s === p)) &&
          (!n.frustumCulled || r.intersectsObject(n))
        ) {
          n.modelViewMatrix.multiplyMatrices(
            o.matrixWorldInverse,
            n.matrixWorld
          );
          const r = t.update(n),
            i = n.material;
          if (Array.isArray(i)) {
            const t = r.groups;
            for (let l = 0, c = t.length; l < c; l++) {
              const c = t[l],
                u = i[c.materialIndex];
              if (u && u.visible) {
                const t = S(n, 0, u, a, o.near, o.far, s);
                e.renderBufferDirect(o, null, r, t, n, c);
              }
            }
          } else if (i.visible) {
            const t = S(n, 0, i, a, o.near, o.far, s);
            e.renderBufferDirect(o, null, r, t, n, null);
          }
        }
        const l = n.children;
        for (let e = 0, t = l.length; e < t; e++) T(l[e], i, o, a, s);
      }
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = h),
        (this.render = function (t, n, s) {
          if (!1 === _.enabled) return;
          if (!1 === _.autoUpdate && !1 === _.needsUpdate) return;
          if (0 === t.length) return;
          const l = e.getRenderTarget(),
            c = e.getActiveCubeFace(),
            h = e.getActiveMipmapLevel(),
            d = e.state;
          d.setBlending(x),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
          for (let l = 0, c = t.length; l < c; l++) {
            const c = t[l],
              h = c.shadow;
            if (void 0 === h) {
              console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
              continue;
            }
            if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
            i.copy(h.mapSize);
            const f = h.getFrameExtents();
            if (
              (i.multiply(f),
              o.copy(h.mapSize),
              (i.x > u || i.y > u) &&
                (i.x > u &&
                  ((o.x = Math.floor(u / f.x)),
                  (i.x = o.x * f.x),
                  (h.mapSize.x = o.x)),
                i.y > u &&
                  ((o.y = Math.floor(u / f.y)),
                  (i.y = o.y * f.y),
                  (h.mapSize.y = o.y))),
              null === h.map && !h.isPointLightShadow && this.type === p)
            ) {
              const e = {
                minFilter: xe,
                magFilter: xe,
                format: Ne,
              };
              (h.map = new rr(i.x, i.y, e)),
                (h.map.texture.name = c.name + ".shadowMap"),
                (h.mapPass = new rr(i.x, i.y, e)),
                h.camera.updateProjectionMatrix();
            }
            if (null === h.map) {
              const e = {
                minFilter: fe,
                magFilter: fe,
                format: Ne,
              };
              (h.map = new rr(i.x, i.y, e)),
                (h.map.texture.name = c.name + ".shadowMap"),
                h.camera.updateProjectionMatrix();
            }
            e.setRenderTarget(h.map), e.clear();
            const m = h.getViewportCount();
            for (let e = 0; e < m; e++) {
              const t = h.getViewport(e);
              a.set(o.x * t.x, o.y * t.y, o.x * t.z, o.y * t.w),
                d.viewport(a),
                h.updateMatrices(c, e),
                (r = h.getFrustum()),
                T(n, s, h.camera, c, this.type);
            }
            h.isPointLightShadow || this.type !== p || M(h, s),
              (h.needsUpdate = !1);
          }
          (_.needsUpdate = !1), e.setRenderTarget(l, c, h);
        });
    }

    function fl(e, t, n) {
      const r = n.isWebGL2;
      const i = new (function () {
          let t = !1;
          const n = new nr();
          let r = null;
          const i = new nr(0, 0, 0, 0);
          return {
            setMask: function (n) {
              r === n || t || (e.colorMask(n, n, n, n), (r = n));
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t, r, o, a, s) {
              !0 === s && ((t *= a), (r *= a), (o *= a)),
                n.set(t, r, o, a),
                !1 === i.equals(n) && (e.clearColor(t, r, o, a), i.copy(n));
            },
            reset: function () {
              (t = !1), (r = null), i.set(-1, 0, 0, 0);
            },
          };
        })(),
        o = new (function () {
          let t = !1,
            n = null,
            r = null,
            i = null;
          return {
            setTest: function (e) {
              e ? ye(2929) : xe(2929);
            },
            setMask: function (r) {
              n === r || t || (e.depthMask(r), (n = r));
            },
            setFunc: function (t) {
              if (r !== t) {
                if (t)
                  switch (t) {
                    case H:
                      e.depthFunc(512);
                      break;
                    case G:
                      e.depthFunc(519);
                      break;
                    case V:
                      e.depthFunc(513);
                      break;
                    case j:
                      e.depthFunc(515);
                      break;
                    case W:
                      e.depthFunc(514);
                      break;
                    case q:
                      e.depthFunc(518);
                      break;
                    case $:
                      e.depthFunc(516);
                      break;
                    case X:
                      e.depthFunc(517);
                      break;
                    default:
                      e.depthFunc(515);
                  }
                else e.depthFunc(515);
                r = t;
              }
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              i !== t && (e.clearDepth(t), (i = t));
            },
            reset: function () {
              (t = !1), (n = null), (r = null), (i = null);
            },
          };
        })(),
        c = new (function () {
          let t = !1,
            n = null,
            r = null,
            i = null,
            o = null,
            a = null,
            s = null,
            l = null,
            c = null;
          return {
            setTest: function (e) {
              t || (e ? ye(2960) : xe(2960));
            },
            setMask: function (r) {
              n === r || t || (e.stencilMask(r), (n = r));
            },
            setFunc: function (t, n, a) {
              (r === t && i === n && o === a) ||
                (e.stencilFunc(t, n, a), (r = t), (i = n), (o = a));
            },
            setOp: function (t, n, r) {
              (a === t && s === n && l === r) ||
                (e.stencilOp(t, n, r), (a = t), (s = n), (l = r));
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              c !== t && (e.clearStencil(t), (c = t));
            },
            reset: function () {
              (t = !1),
                (n = null),
                (r = null),
                (i = null),
                (o = null),
                (a = null),
                (s = null),
                (l = null),
                (c = null);
            },
          };
        })();
      let u = {},
        h = null,
        d = {},
        p = null,
        f = !1,
        v = null,
        y = null,
        Y = null,
        J = null,
        Z = null,
        K = null,
        Q = null,
        ee = !1,
        te = null,
        ne = null,
        re = null,
        ie = null,
        oe = null;
      const ae = e.getParameter(35661);
      let se = !1,
        le = 0;
      const ce = e.getParameter(7938);
      -1 !== ce.indexOf("WebGL")
        ? ((le = parseFloat(/^WebGL (\d)/.exec(ce)[1])), (se = le >= 1))
        : -1 !== ce.indexOf("OpenGL ES") &&
          ((le = parseFloat(/^OpenGL ES (\d)/.exec(ce)[1])), (se = le >= 2));
      let ue = null,
        he = {};
      const de = e.getParameter(3088),
        pe = e.getParameter(2978),
        fe = new nr().fromArray(de),
        me = new nr().fromArray(pe);

      function ge(t, n, r) {
        const i = new Uint8Array(4),
          o = e.createTexture();
        e.bindTexture(t, o),
          e.texParameteri(t, 10241, 9728),
          e.texParameteri(t, 10240, 9728);
        for (let t = 0; t < r; t++)
          e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, i);
        return o;
      }
      const ve = {};

      function ye(t) {
        !0 !== u[t] && (e.enable(t), (u[t] = !0));
      }

      function xe(t) {
        !1 !== u[t] && (e.disable(t), (u[t] = !1));
      }
      (ve[3553] = ge(3553, 3553, 1)),
        (ve[34067] = ge(34067, 34069, 6)),
        i.setClear(0, 0, 0, 1),
        o.setClear(1),
        c.setClear(0),
        ye(2929),
        o.setFunc(j),
        Me(!1),
        Se(s),
        ye(2884),
        _e(x);
      const be = {
        [T]: 32774,
        [E]: 32778,
        [A]: 32779,
      };
      if (r) (be[C] = 32775), (be[P] = 32776);
      else {
        const e = t.get("EXT_blend_minmax");
        null !== e && ((be[C] = e.MIN_EXT), (be[P] = e.MAX_EXT));
      }
      const we = {
        [L]: 0,
        [R]: 1,
        [I]: 768,
        [D]: 770,
        [z]: 776,
        [N]: 774,
        [B]: 772,
        [k]: 769,
        [O]: 771,
        [U]: 775,
        [F]: 773,
      };

      function _e(t, n, r, i, o, a, s, l) {
        if (t !== x) {
          if ((!1 === f && (ye(3042), (f = !0)), t === S))
            (o = o || n),
              (a = a || r),
              (s = s || i),
              (n === y && o === Z) ||
                (e.blendEquationSeparate(be[n], be[o]), (y = n), (Z = o)),
              (r === Y && i === J && a === K && s === Q) ||
                (e.blendFuncSeparate(we[r], we[i], we[a], we[s]),
                (Y = r),
                (J = i),
                (K = a),
                (Q = s)),
              (v = t),
              (ee = null);
          else if (t !== v || l !== ee) {
            if (
              ((y === T && Z === T) ||
                (e.blendEquation(32774), (y = T), (Z = T)),
              l)
            )
              switch (t) {
                case b:
                  e.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case w:
                  e.blendFunc(1, 1);
                  break;
                case _:
                  e.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case M:
                  e.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", t);
              }
            else
              switch (t) {
                case b:
                  e.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case w:
                  e.blendFunc(770, 1);
                  break;
                case _:
                  e.blendFunc(0, 769);
                  break;
                case M:
                  e.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", t);
              }
            (Y = null), (J = null), (K = null), (Q = null), (v = t), (ee = l);
          }
        } else !0 === f && (xe(3042), (f = !1));
      }

      function Me(t) {
        te !== t && (t ? e.frontFace(2304) : e.frontFace(2305), (te = t));
      }

      function Se(t) {
        t !== a
          ? (ye(2884),
            t !== ne &&
              (t === s
                ? e.cullFace(1029)
                : t === l
                ? e.cullFace(1028)
                : e.cullFace(1032)))
          : xe(2884),
          (ne = t);
      }

      function Te(t, n, r) {
        t
          ? (ye(32823),
            (ie === n && oe === r) ||
              (e.polygonOffset(n, r), (ie = n), (oe = r)))
          : xe(32823);
      }

      function Ee(t) {
        void 0 === t && (t = 33984 + ae - 1),
          ue !== t && (e.activeTexture(t), (ue = t));
      }
      return {
        buffers: {
          color: i,
          depth: o,
          stencil: c,
        },
        enable: ye,
        disable: xe,
        bindFramebuffer: function (t, n) {
          return (
            null === n && null !== h && (n = h),
            d[t] !== n &&
              (e.bindFramebuffer(t, n),
              (d[t] = n),
              r &&
                (36009 === t && (d[36160] = n), 36160 === t && (d[36009] = n)),
              !0)
          );
        },
        bindXRFramebuffer: function (t) {
          t !== h && (e.bindFramebuffer(36160, t), (h = t));
        },
        useProgram: function (t) {
          return p !== t && (e.useProgram(t), (p = t), !0);
        },
        setBlending: _e,
        setMaterial: function (e, t) {
          e.side === g ? xe(2884) : ye(2884);
          let n = e.side === m;
          t && (n = !n),
            Me(n),
            e.blending === b && !1 === e.transparent
              ? _e(x)
              : _e(
                  e.blending,
                  e.blendEquation,
                  e.blendSrc,
                  e.blendDst,
                  e.blendEquationAlpha,
                  e.blendSrcAlpha,
                  e.blendDstAlpha,
                  e.premultipliedAlpha
                ),
            o.setFunc(e.depthFunc),
            o.setTest(e.depthTest),
            o.setMask(e.depthWrite),
            i.setMask(e.colorWrite);
          const r = e.stencilWrite;
          c.setTest(r),
            r &&
              (c.setMask(e.stencilWriteMask),
              c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
              c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
            Te(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
            !0 === e.alphaToCoverage ? ye(32926) : xe(32926);
        },
        setFlipSided: Me,
        setCullFace: Se,
        setLineWidth: function (t) {
          t !== re && (se && e.lineWidth(t), (re = t));
        },
        setPolygonOffset: Te,
        setScissorTest: function (e) {
          e ? ye(3089) : xe(3089);
        },
        activeTexture: Ee,
        bindTexture: function (t, n) {
          null === ue && Ee();
          let r = he[ue];
          void 0 === r &&
            ((r = {
              type: void 0,
              texture: void 0,
            }),
            (he[ue] = r)),
            (r.type === t && r.texture === n) ||
              (e.bindTexture(t, n || ve[t]), (r.type = t), (r.texture = n));
        },
        unbindTexture: function () {
          const t = he[ue];
          void 0 !== t &&
            void 0 !== t.type &&
            (e.bindTexture(t.type, null),
            (t.type = void 0),
            (t.texture = void 0));
        },
        compressedTexImage2D: function () {
          try {
            e.compressedTexImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texImage2D: function () {
          try {
            e.texImage2D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        texImage3D: function () {
          try {
            e.texImage3D.apply(e, arguments);
          } catch (e) {
            console.error("THREE.WebGLState:", e);
          }
        },
        scissor: function (t) {
          !1 === fe.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), fe.copy(t));
        },
        viewport: function (t) {
          !1 === me.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), me.copy(t));
        },
        reset: function () {
          e.disable(3042),
            e.disable(2884),
            e.disable(2929),
            e.disable(32823),
            e.disable(3089),
            e.disable(2960),
            e.disable(32926),
            e.blendEquation(32774),
            e.blendFunc(1, 0),
            e.blendFuncSeparate(1, 0, 1, 0),
            e.colorMask(!0, !0, !0, !0),
            e.clearColor(0, 0, 0, 0),
            e.depthMask(!0),
            e.depthFunc(513),
            e.clearDepth(1),
            e.stencilMask(4294967295),
            e.stencilFunc(519, 0, 4294967295),
            e.stencilOp(7680, 7680, 7680),
            e.clearStencil(0),
            e.cullFace(1029),
            e.frontFace(2305),
            e.polygonOffset(0, 0),
            e.activeTexture(33984),
            e.bindFramebuffer(36160, null),
            !0 === r &&
              (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)),
            e.useProgram(null),
            e.lineWidth(1),
            e.scissor(0, 0, e.canvas.width, e.canvas.height),
            e.viewport(0, 0, e.canvas.width, e.canvas.height),
            (u = {}),
            (ue = null),
            (he = {}),
            (h = null),
            (d = {}),
            (p = null),
            (f = !1),
            (v = null),
            (y = null),
            (Y = null),
            (J = null),
            (Z = null),
            (K = null),
            (Q = null),
            (ee = !1),
            (te = null),
            (ne = null),
            (re = null),
            (ie = null),
            (oe = null),
            fe.set(0, 0, e.canvas.width, e.canvas.height),
            me.set(0, 0, e.canvas.width, e.canvas.height),
            i.reset(),
            o.reset(),
            c.reset();
        },
      };
    }

    function ml(e, t, n, r, i, o, a) {
      const s = i.isWebGL2,
        l = i.maxTextures,
        c = i.maxCubemapSize,
        u = i.maxTextureSize,
        h = i.maxSamples,
        d = new WeakMap();
      let p,
        f = !1;
      try {
        f =
          "undefined" != typeof OffscreenCanvas &&
          null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (e) {}

      function m(e, t) {
        return f
          ? new OffscreenCanvas(e, t)
          : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      }

      function g(e, t, n, r) {
        let i = 1;
        if (
          ((e.width > r || e.height > r) &&
            (i = r / Math.max(e.width, e.height)),
          i < 1 || !0 === t)
        ) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              e instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              e instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ) {
            const r = t ? $n : Math.floor,
              o = r(i * e.width),
              a = r(i * e.height);
            void 0 === p && (p = m(o, a));
            const s = n ? m(o, a) : p;
            return (
              (s.width = o),
              (s.height = a),
              s.getContext("2d").drawImage(e, 0, 0, o, a),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  e.width +
                  "x" +
                  e.height +
                  ") to (" +
                  o +
                  "x" +
                  a +
                  ")."
              ),
              s
            );
          }
          return (
            "data" in e &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  e.width +
                  "x" +
                  e.height +
                  ")."
              ),
            e
          );
        }
        return e;
      }

      function v(e) {
        return Wn(e.width) && Wn(e.height);
      }

      function y(e, t) {
        return (
          e.generateMipmaps && t && e.minFilter !== fe && e.minFilter !== xe
        );
      }

      function x(t, n, i, o, a = 1) {
        e.generateMipmap(t),
          (r.get(n).__maxMipLevel = Math.log2(Math.max(i, o, a)));
      }

      function b(n, r, i) {
        if (!1 === s) return r;
        if (null !== n) {
          if (void 0 !== e[n]) return e[n];
          console.warn(
            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
              n +
              "'"
          );
        }
        let o = r;
        return (
          6403 === r &&
            (5126 === i && (o = 33326),
            5131 === i && (o = 33325),
            5121 === i && (o = 33321)),
          6407 === r &&
            (5126 === i && (o = 34837),
            5131 === i && (o = 34843),
            5121 === i && (o = 32849)),
          6408 === r &&
            (5126 === i && (o = 34836),
            5131 === i && (o = 34842),
            5121 === i && (o = 32856)),
          (33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o) ||
            t.get("EXT_color_buffer_float"),
          o
        );
      }

      function w(e) {
        return e === fe || e === me || e === ve ? 9728 : 9729;
      }

      function _(t) {
        const n = t.target;
        n.removeEventListener("dispose", _),
          (function (t) {
            const n = r.get(t);
            if (void 0 === n.__webglInit) return;
            e.deleteTexture(n.__webglTexture), r.remove(t);
          })(n),
          n.isVideoTexture && d.delete(n),
          a.memory.textures--;
      }

      function M(t) {
        const n = t.target;
        n.removeEventListener("dispose", M),
          (function (t) {
            const n = t.texture,
              i = r.get(t),
              o = r.get(n);
            if (!t) return;
            void 0 !== o.__webglTexture &&
              (e.deleteTexture(o.__webglTexture), a.memory.textures--);
            t.depthTexture && t.depthTexture.dispose();
            if (t.isWebGLCubeRenderTarget)
              for (let t = 0; t < 6; t++)
                e.deleteFramebuffer(i.__webglFramebuffer[t]),
                  i.__webglDepthbuffer &&
                    e.deleteRenderbuffer(i.__webglDepthbuffer[t]);
            else
              e.deleteFramebuffer(i.__webglFramebuffer),
                i.__webglDepthbuffer &&
                  e.deleteRenderbuffer(i.__webglDepthbuffer),
                i.__webglMultisampledFramebuffer &&
                  e.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                i.__webglColorRenderbuffer &&
                  e.deleteRenderbuffer(i.__webglColorRenderbuffer),
                i.__webglDepthRenderbuffer &&
                  e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
            if (t.isWebGLMultipleRenderTargets)
              for (let t = 0, i = n.length; t < i; t++) {
                const i = r.get(n[t]);
                i.__webglTexture &&
                  (e.deleteTexture(i.__webglTexture), a.memory.textures--),
                  r.remove(n[t]);
              }
            r.remove(n), r.remove(t);
          })(n);
      }
      let S = 0;

      function T(e, t) {
        const i = r.get(e);
        if (
          (e.isVideoTexture &&
            (function (e) {
              const t = a.render.frame;
              d.get(e) !== t && (d.set(e, t), e.update());
            })(e),
          e.version > 0 && i.__version !== e.version)
        ) {
          const n = e.image;
          if (void 0 === n)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is undefined"
            );
          else {
            if (!1 !== n.complete) return void R(i, e, t);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
            );
          }
        }
        n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture);
      }

      function E(t, i) {
        const a = r.get(t);
        t.version > 0 && a.__version !== t.version
          ? (function (t, r, i) {
              if (6 !== r.image.length) return;
              L(t, r),
                n.activeTexture(33984 + i),
                n.bindTexture(34067, t.__webglTexture),
                e.pixelStorei(37440, r.flipY),
                e.pixelStorei(37441, r.premultiplyAlpha),
                e.pixelStorei(3317, r.unpackAlignment),
                e.pixelStorei(37443, 0);
              const a =
                  r &&
                  (r.isCompressedTexture || r.image[0].isCompressedTexture),
                l = r.image[0] && r.image[0].isDataTexture,
                u = [];
              for (let e = 0; e < 6; e++)
                u[e] =
                  a || l
                    ? l
                      ? r.image[e].image
                      : r.image[e]
                    : g(r.image[e], !1, !0, c);
              const h = u[0],
                d = v(h) || s,
                p = o.convert(r.format),
                f = o.convert(r.type),
                m = b(r.internalFormat, p, f);
              let w;
              if ((P(34067, r, d), a)) {
                for (let e = 0; e < 6; e++) {
                  w = u[e].mipmaps;
                  for (let t = 0; t < w.length; t++) {
                    const i = w[t];
                    r.format !== Ne && r.format !== Fe
                      ? null !== p
                        ? n.compressedTexImage2D(
                            34069 + e,
                            t,
                            m,
                            i.width,
                            i.height,
                            0,
                            i.data
                          )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                          )
                      : n.texImage2D(
                          34069 + e,
                          t,
                          m,
                          i.width,
                          i.height,
                          0,
                          p,
                          f,
                          i.data
                        );
                  }
                }
                t.__maxMipLevel = w.length - 1;
              } else {
                w = r.mipmaps;
                for (let e = 0; e < 6; e++)
                  if (l) {
                    n.texImage2D(
                      34069 + e,
                      0,
                      m,
                      u[e].width,
                      u[e].height,
                      0,
                      p,
                      f,
                      u[e].data
                    );
                    for (let t = 0; t < w.length; t++) {
                      const r = w[t].image[e].image;
                      n.texImage2D(
                        34069 + e,
                        t + 1,
                        m,
                        r.width,
                        r.height,
                        0,
                        p,
                        f,
                        r.data
                      );
                    }
                  } else {
                    n.texImage2D(34069 + e, 0, m, p, f, u[e]);
                    for (let t = 0; t < w.length; t++) {
                      const r = w[t];
                      n.texImage2D(34069 + e, t + 1, m, p, f, r.image[e]);
                    }
                  }
                t.__maxMipLevel = w.length;
              }
              y(r, d) && x(34067, r, h.width, h.height);
              (t.__version = r.version), r.onUpdate && r.onUpdate(r);
            })(a, t, i)
          : (n.activeTexture(33984 + i),
            n.bindTexture(34067, a.__webglTexture));
      }
      const A = {
          [he]: 10497,
          [de]: 33071,
          [pe]: 33648,
        },
        C = {
          [fe]: 9728,
          [me]: 9984,
          [ve]: 9986,
          [xe]: 9729,
          [be]: 9985,
          [_e]: 9987,
        };

      function P(n, o, a) {
        if (
          (a
            ? (e.texParameteri(n, 10242, A[o.wrapS]),
              e.texParameteri(n, 10243, A[o.wrapT]),
              (32879 !== n && 35866 !== n) ||
                e.texParameteri(n, 32882, A[o.wrapR]),
              e.texParameteri(n, 10240, C[o.magFilter]),
              e.texParameteri(n, 10241, C[o.minFilter]))
            : (e.texParameteri(n, 10242, 33071),
              e.texParameteri(n, 10243, 33071),
              (32879 !== n && 35866 !== n) || e.texParameteri(n, 32882, 33071),
              (o.wrapS === de && o.wrapT === de) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                ),
              e.texParameteri(n, 10240, w(o.magFilter)),
              e.texParameteri(n, 10241, w(o.minFilter)),
              o.minFilter !== fe &&
                o.minFilter !== xe &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                )),
          !0 === t.has("EXT_texture_filter_anisotropic"))
        ) {
          const a = t.get("EXT_texture_filter_anisotropic");
          if (o.type === Le && !1 === t.has("OES_texture_float_linear")) return;
          if (
            !1 === s &&
            o.type === Re &&
            !1 === t.has("OES_texture_half_float_linear")
          )
            return;
          (o.anisotropy > 1 || r.get(o).__currentAnisotropy) &&
            (e.texParameterf(
              n,
              a.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(o.anisotropy, i.getMaxAnisotropy())
            ),
            (r.get(o).__currentAnisotropy = o.anisotropy));
        }
      }

      function L(t, n) {
        void 0 === t.__webglInit &&
          ((t.__webglInit = !0),
          n.addEventListener("dispose", _),
          (t.__webglTexture = e.createTexture()),
          a.memory.textures++);
      }

      function R(t, r, i) {
        let a = 3553;
        r.isDataTexture2DArray && (a = 35866),
          r.isDataTexture3D && (a = 32879),
          L(t, r),
          n.activeTexture(33984 + i),
          n.bindTexture(a, t.__webglTexture),
          e.pixelStorei(37440, r.flipY),
          e.pixelStorei(37441, r.premultiplyAlpha),
          e.pixelStorei(3317, r.unpackAlignment),
          e.pixelStorei(37443, 0);
        const l =
            (function (e) {
              return (
                !s &&
                (e.wrapS !== de ||
                  e.wrapT !== de ||
                  (e.minFilter !== fe && e.minFilter !== xe))
              );
            })(r) && !1 === v(r.image),
          c = g(r.image, l, !1, u),
          h = v(c) || s,
          d = o.convert(r.format);
        let p,
          f = o.convert(r.type),
          m = b(r.internalFormat, d, f);
        P(a, r, h);
        const w = r.mipmaps;
        if (r.isDepthTexture)
          (m = 6402),
            s
              ? (m =
                  r.type === Le
                    ? 36012
                    : r.type === Pe
                    ? 33190
                    : r.type === Oe
                    ? 35056
                    : 33189)
              : r.type === Le &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2."
                ),
            r.format === Ge &&
              6402 === m &&
              r.type !== Ae &&
              r.type !== Pe &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (r.type = Ae),
              (f = o.convert(r.type))),
            r.format === Ve &&
              6402 === m &&
              ((m = 34041),
              r.type !== Oe &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (r.type = Oe),
                (f = o.convert(r.type)))),
            n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
        else if (r.isDataTexture)
          if (w.length > 0 && h) {
            for (let e = 0, t = w.length; e < t; e++)
              (p = w[e]),
                n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
            (r.generateMipmaps = !1), (t.__maxMipLevel = w.length - 1);
          } else
            n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data),
              (t.__maxMipLevel = 0);
        else if (r.isCompressedTexture) {
          for (let e = 0, t = w.length; e < t; e++)
            (p = w[e]),
              r.format !== Ne && r.format !== Fe
                ? null !== d
                  ? n.compressedTexImage2D(
                      3553,
                      e,
                      m,
                      p.width,
                      p.height,
                      0,
                      p.data
                    )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
          t.__maxMipLevel = w.length - 1;
        } else if (r.isDataTexture2DArray)
          n.texImage3D(
            35866,
            0,
            m,
            c.width,
            c.height,
            c.depth,
            0,
            d,
            f,
            c.data
          ),
            (t.__maxMipLevel = 0);
        else if (r.isDataTexture3D)
          n.texImage3D(
            32879,
            0,
            m,
            c.width,
            c.height,
            c.depth,
            0,
            d,
            f,
            c.data
          ),
            (t.__maxMipLevel = 0);
        else if (w.length > 0 && h) {
          for (let e = 0, t = w.length; e < t; e++)
            (p = w[e]), n.texImage2D(3553, e, m, d, f, p);
          (r.generateMipmaps = !1), (t.__maxMipLevel = w.length - 1);
        } else n.texImage2D(3553, 0, m, d, f, c), (t.__maxMipLevel = 0);
        y(r, h) && x(a, r, c.width, c.height),
          (t.__version = r.version),
          r.onUpdate && r.onUpdate(r);
      }

      function I(t, i, a, s, l) {
        const c = o.convert(a.format),
          u = o.convert(a.type),
          h = b(a.internalFormat, c, u);
        32879 === l || 35866 === l
          ? n.texImage3D(l, 0, h, i.width, i.height, i.depth, 0, c, u, null)
          : n.texImage2D(l, 0, h, i.width, i.height, 0, c, u, null),
          n.bindFramebuffer(36160, t),
          e.framebufferTexture2D(36160, s, l, r.get(a).__webglTexture, 0),
          n.bindFramebuffer(36160, null);
      }

      function k(t, n, r) {
        if ((e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer)) {
          let i = 33189;
          if (r) {
            const t = n.depthTexture;
            t &&
              t.isDepthTexture &&
              (t.type === Le ? (i = 36012) : t.type === Pe && (i = 33190));
            const r = O(n);
            e.renderbufferStorageMultisample(36161, r, i, n.width, n.height);
          } else e.renderbufferStorage(36161, i, n.width, n.height);
          e.framebufferRenderbuffer(36160, 36096, 36161, t);
        } else if (n.depthBuffer && n.stencilBuffer) {
          if (r) {
            const t = O(n);
            e.renderbufferStorageMultisample(
              36161,
              t,
              35056,
              n.width,
              n.height
            );
          } else e.renderbufferStorage(36161, 34041, n.width, n.height);
          e.framebufferRenderbuffer(36160, 33306, 36161, t);
        } else {
          const t =
              !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
            i = o.convert(t.format),
            a = o.convert(t.type),
            s = b(t.internalFormat, i, a);
          if (r) {
            const t = O(n);
            e.renderbufferStorageMultisample(36161, t, s, n.width, n.height);
          } else e.renderbufferStorage(36161, s, n.width, n.height);
        }
        e.bindRenderbuffer(36161, null);
      }

      function D(t) {
        const i = r.get(t),
          o = !0 === t.isWebGLCubeRenderTarget;
        if (t.depthTexture) {
          if (o)
            throw new Error(
              "target.depthTexture not supported in Cube render targets"
            );
          !(function (t, i) {
            if (i && i.isWebGLCubeRenderTarget)
              throw new Error(
                "Depth Texture with cube render targets is not supported"
              );
            if (
              (n.bindFramebuffer(36160, t),
              !i.depthTexture || !i.depthTexture.isDepthTexture)
            )
              throw new Error(
                "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
              );
            (r.get(i.depthTexture).__webglTexture &&
              i.depthTexture.image.width === i.width &&
              i.depthTexture.image.height === i.height) ||
              ((i.depthTexture.image.width = i.width),
              (i.depthTexture.image.height = i.height),
              (i.depthTexture.needsUpdate = !0)),
              T(i.depthTexture, 0);
            const o = r.get(i.depthTexture).__webglTexture;
            if (i.depthTexture.format === Ge)
              e.framebufferTexture2D(36160, 36096, 3553, o, 0);
            else {
              if (i.depthTexture.format !== Ve)
                throw new Error("Unknown depthTexture format");
              e.framebufferTexture2D(36160, 33306, 3553, o, 0);
            }
          })(i.__webglFramebuffer, t);
        } else if (o) {
          i.__webglDepthbuffer = [];
          for (let r = 0; r < 6; r++)
            n.bindFramebuffer(36160, i.__webglFramebuffer[r]),
              (i.__webglDepthbuffer[r] = e.createRenderbuffer()),
              k(i.__webglDepthbuffer[r], t, !1);
        } else
          n.bindFramebuffer(36160, i.__webglFramebuffer),
            (i.__webglDepthbuffer = e.createRenderbuffer()),
            k(i.__webglDepthbuffer, t, !1);
        n.bindFramebuffer(36160, null);
      }

      function O(e) {
        return s && e.isWebGLMultisampleRenderTarget
          ? Math.min(h, e.samples)
          : 0;
      }
      let B = !1,
        F = !1;
      (this.allocateTextureUnit = function () {
        const e = S;
        return (
          e >= l &&
            console.warn(
              "THREE.WebGLTextures: Trying to use " +
                e +
                " texture units while this GPU supports only " +
                l
            ),
          (S += 1),
          e
        );
      }),
        (this.resetTextureUnits = function () {
          S = 0;
        }),
        (this.setTexture2D = T),
        (this.setTexture2DArray = function (e, t) {
          const i = r.get(e);
          e.version > 0 && i.__version !== e.version
            ? R(i, e, t)
            : (n.activeTexture(33984 + t),
              n.bindTexture(35866, i.__webglTexture));
        }),
        (this.setTexture3D = function (e, t) {
          const i = r.get(e);
          e.version > 0 && i.__version !== e.version
            ? R(i, e, t)
            : (n.activeTexture(33984 + t),
              n.bindTexture(32879, i.__webglTexture));
        }),
        (this.setTextureCube = E),
        (this.setupRenderTarget = function (t) {
          const l = t.texture,
            c = r.get(t),
            u = r.get(l);
          t.addEventListener("dispose", M),
            !0 !== t.isWebGLMultipleRenderTargets &&
              ((u.__webglTexture = e.createTexture()),
              (u.__version = l.version),
              a.memory.textures++);
          const h = !0 === t.isWebGLCubeRenderTarget,
            d = !0 === t.isWebGLMultipleRenderTargets,
            p = !0 === t.isWebGLMultisampleRenderTarget,
            f = l.isDataTexture3D || l.isDataTexture2DArray,
            m = v(t) || s;
          if (
            (!s ||
              l.format !== Fe ||
              (l.type !== Le && l.type !== Re) ||
              ((l.format = Ne),
              console.warn(
                "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
              )),
            h)
          ) {
            c.__webglFramebuffer = [];
            for (let t = 0; t < 6; t++)
              c.__webglFramebuffer[t] = e.createFramebuffer();
          } else if (((c.__webglFramebuffer = e.createFramebuffer()), d))
            if (i.drawBuffers) {
              const n = t.texture;
              for (let t = 0, i = n.length; t < i; t++) {
                const i = r.get(n[t]);
                void 0 === i.__webglTexture &&
                  ((i.__webglTexture = e.createTexture()), a.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          else if (p)
            if (s) {
              (c.__webglMultisampledFramebuffer = e.createFramebuffer()),
                (c.__webglColorRenderbuffer = e.createRenderbuffer()),
                e.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
              const r = o.convert(l.format),
                i = o.convert(l.type),
                a = b(l.internalFormat, r, i),
                s = O(t);
              e.renderbufferStorageMultisample(36161, s, a, t.width, t.height),
                n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                e.framebufferRenderbuffer(
                  36160,
                  36064,
                  36161,
                  c.__webglColorRenderbuffer
                ),
                e.bindRenderbuffer(36161, null),
                t.depthBuffer &&
                  ((c.__webglDepthRenderbuffer = e.createRenderbuffer()),
                  k(c.__webglDepthRenderbuffer, t, !0)),
                n.bindFramebuffer(36160, null);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
          if (h) {
            n.bindTexture(34067, u.__webglTexture), P(34067, l, m);
            for (let e = 0; e < 6; e++)
              I(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
            y(l, m) && x(34067, l, t.width, t.height), n.unbindTexture();
          } else if (d) {
            const e = t.texture;
            for (let i = 0, o = e.length; i < o; i++) {
              const o = e[i],
                a = r.get(o);
              n.bindTexture(3553, a.__webglTexture),
                P(3553, o, m),
                I(c.__webglFramebuffer, t, o, 36064 + i, 3553),
                y(o, m) && x(3553, o, t.width, t.height);
            }
            n.unbindTexture();
          } else {
            let e = 3553;
            if (f)
              if (s) {
                e = l.isDataTexture3D ? 32879 : 35866;
              } else
                console.warn(
                  "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                );
            n.bindTexture(e, u.__webglTexture),
              P(e, l, m),
              I(c.__webglFramebuffer, t, l, 36064, e),
              y(l, m) && x(e, l, t.width, t.height, t.depth),
              n.unbindTexture();
          }
          t.depthBuffer && D(t);
        }),
        (this.updateRenderTargetMipmap = function (e) {
          const t = v(e) || s,
            i = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
          for (let o = 0, a = i.length; o < a; o++) {
            const a = i[o];
            if (y(a, t)) {
              const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                i = r.get(a).__webglTexture;
              n.bindTexture(t, i),
                x(t, a, e.width, e.height),
                n.unbindTexture();
            }
          }
        }),
        (this.updateMultisampleRenderTarget = function (t) {
          if (t.isWebGLMultisampleRenderTarget)
            if (s) {
              const i = t.width,
                o = t.height;
              let a = 16384;
              t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024);
              const s = r.get(t);
              n.bindFramebuffer(36008, s.__webglMultisampledFramebuffer),
                n.bindFramebuffer(36009, s.__webglFramebuffer),
                e.blitFramebuffer(0, 0, i, o, 0, 0, i, o, a, 9728),
                n.bindFramebuffer(36008, null),
                n.bindFramebuffer(36009, s.__webglMultisampledFramebuffer);
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
              );
        }),
        (this.safeSetTexture2D = function (e, t) {
          e &&
            e.isWebGLRenderTarget &&
            (!1 === B &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (B = !0)),
            (e = e.texture)),
            T(e, t);
        }),
        (this.safeSetTextureCube = function (e, t) {
          e &&
            e.isWebGLCubeRenderTarget &&
            (!1 === F &&
              (console.warn(
                "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (F = !0)),
            (e = e.texture)),
            E(e, t);
        });
    }

    function gl(e, t, n) {
      const r = n.isWebGL2;
      return {
        convert: function (e) {
          let n;
          if (e === Se) return 5121;
          if (e === Ie) return 32819;
          if (e === ke) return 32820;
          if (e === De) return 33635;
          if (e === Te) return 5120;
          if (e === Ee) return 5122;
          if (e === Ae) return 5123;
          if (e === Ce) return 5124;
          if (e === Pe) return 5125;
          if (e === Le) return 5126;
          if (e === Re)
            return r
              ? 5131
              : ((n = t.get("OES_texture_half_float")),
                null !== n ? n.HALF_FLOAT_OES : null);
          if (e === Be) return 6406;
          if (e === Fe) return 6407;
          if (e === Ne) return 6408;
          if (e === Ue) return 6409;
          if (e === ze) return 6410;
          if (e === Ge) return 6402;
          if (e === Ve) return 34041;
          if (e === je) return 6403;
          if (e === We) return 36244;
          if (e === qe) return 33319;
          if (e === $e) return 33320;
          if (e === Xe) return 36248;
          if (e === Ye) return 36249;
          if (e === Je || e === Ze || e === Ke || e === Qe) {
            if (((n = t.get("WEBGL_compressed_texture_s3tc")), null === n))
              return null;
            if (e === Je) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (e === Ze) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (e === Ke) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (e === Qe) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (e === et || e === tt || e === nt || e === rt) {
            if (((n = t.get("WEBGL_compressed_texture_pvrtc")), null === n))
              return null;
            if (e === et) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (e === tt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (e === nt) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (e === rt) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (e === it)
            return (
              (n = t.get("WEBGL_compressed_texture_etc1")),
              null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (
            (e === ot || e === at) &&
            ((n = t.get("WEBGL_compressed_texture_etc")), null !== n)
          ) {
            if (e === ot) return n.COMPRESSED_RGB8_ETC2;
            if (e === at) return n.COMPRESSED_RGBA8_ETC2_EAC;
          }
          return e === st ||
            e === lt ||
            e === ct ||
            e === ut ||
            e === ht ||
            e === dt ||
            e === pt ||
            e === ft ||
            e === mt ||
            e === gt ||
            e === vt ||
            e === yt ||
            e === xt ||
            e === bt ||
            e === _t ||
            e === Mt ||
            e === St ||
            e === Tt ||
            e === Et ||
            e === At ||
            e === Ct ||
            e === Pt ||
            e === Lt ||
            e === Rt ||
            e === It ||
            e === kt ||
            e === Dt ||
            e === Ot
            ? ((n = t.get("WEBGL_compressed_texture_astc")),
              null !== n ? e : null)
            : e === wt
            ? ((n = t.get("EXT_texture_compression_bptc")),
              null !== n ? e : null)
            : e === Oe
            ? r
              ? 34042
              : ((n = t.get("WEBGL_depth_texture")),
                null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
            : void 0;
        },
      };
    }
    class vl extends Ao {
      constructor(e = []) {
        super(), (this.cameras = e);
      }
    }
    vl.prototype.isArrayCamera = !0;
    class yl extends ci {
      constructor() {
        super(), (this.type = "Group");
      }
    }
    yl.prototype.isGroup = !0;
    const xl = {
      type: "move",
    };
    class bl {
      constructor() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
      }
      getHandSpace() {
        return (
          null === this._hand &&
            ((this._hand = new yl()),
            (this._hand.matrixAutoUpdate = !1),
            (this._hand.visible = !1),
            (this._hand.joints = {}),
            (this._hand.inputState = {
              pinching: !1,
            })),
          this._hand
        );
      }
      getTargetRaySpace() {
        return (
          null === this._targetRay &&
            ((this._targetRay = new yl()),
            (this._targetRay.matrixAutoUpdate = !1),
            (this._targetRay.visible = !1),
            (this._targetRay.hasLinearVelocity = !1),
            (this._targetRay.linearVelocity = new sr()),
            (this._targetRay.hasAngularVelocity = !1),
            (this._targetRay.angularVelocity = new sr())),
          this._targetRay
        );
      }
      getGripSpace() {
        return (
          null === this._grip &&
            ((this._grip = new yl()),
            (this._grip.matrixAutoUpdate = !1),
            (this._grip.visible = !1),
            (this._grip.hasLinearVelocity = !1),
            (this._grip.linearVelocity = new sr()),
            (this._grip.hasAngularVelocity = !1),
            (this._grip.angularVelocity = new sr())),
          this._grip
        );
      }
      dispatchEvent(e) {
        return (
          null !== this._targetRay && this._targetRay.dispatchEvent(e),
          null !== this._grip && this._grip.dispatchEvent(e),
          null !== this._hand && this._hand.dispatchEvent(e),
          this
        );
      }
      disconnect(e) {
        return (
          this.dispatchEvent({
            type: "disconnected",
            data: e,
          }),
          null !== this._targetRay && (this._targetRay.visible = !1),
          null !== this._grip && (this._grip.visible = !1),
          null !== this._hand && (this._hand.visible = !1),
          this
        );
      }
      update(e, t, n) {
        let r = null,
          i = null,
          o = null;
        const a = this._targetRay,
          s = this._grip,
          l = this._hand;
        if (e && "visible-blurred" !== t.session.visibilityState)
          if (
            (null !== a &&
              ((r = t.getPose(e.targetRaySpace, n)),
              null !== r &&
                (a.matrix.fromArray(r.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                r.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(r.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                r.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(r.angularVelocity))
                  : (a.hasAngularVelocity = !1),
                this.dispatchEvent(xl))),
            l && e.hand)
          ) {
            o = !0;
            for (const r of e.hand.values()) {
              const e = t.getJointPose(r, n);
              if (void 0 === l.joints[r.jointName]) {
                const e = new yl();
                (e.matrixAutoUpdate = !1),
                  (e.visible = !1),
                  (l.joints[r.jointName] = e),
                  l.add(e);
              }
              const i = l.joints[r.jointName];
              null !== e &&
                (i.matrix.fromArray(e.transform.matrix),
                i.matrix.decompose(i.position, i.rotation, i.scale),
                (i.jointRadius = e.radius)),
                (i.visible = null !== e);
            }
            const r = l.joints["index-finger-tip"],
              i = l.joints["thumb-tip"],
              a = r.position.distanceTo(i.position),
              s = 0.02,
              c = 0.005;
            l.inputState.pinching && a > s + c
              ? ((l.inputState.pinching = !1),
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: e.handedness,
                  target: this,
                }))
              : !l.inputState.pinching &&
                a <= s - c &&
                ((l.inputState.pinching = !0),
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: e.handedness,
                  target: this,
                }));
          } else
            null !== s &&
              e.gripSpace &&
              ((i = t.getPose(e.gripSpace, n)),
              null !== i &&
                (s.matrix.fromArray(i.transform.matrix),
                s.matrix.decompose(s.position, s.rotation, s.scale),
                i.linearVelocity
                  ? ((s.hasLinearVelocity = !0),
                    s.linearVelocity.copy(i.linearVelocity))
                  : (s.hasLinearVelocity = !1),
                i.angularVelocity
                  ? ((s.hasAngularVelocity = !0),
                    s.angularVelocity.copy(i.angularVelocity))
                  : (s.hasAngularVelocity = !1)));
        return (
          null !== a && (a.visible = null !== r),
          null !== s && (s.visible = null !== i),
          null !== l && (l.visible = null !== o),
          this
        );
      }
    }
    class wl extends Bn {
      constructor(e, t) {
        super();
        const n = this,
          r = e.state;
        let i = null,
          o = 1,
          a = null,
          s = "local-floor",
          l = null,
          c = null,
          u = null,
          h = null,
          d = null,
          p = !1,
          f = null,
          m = null,
          g = null,
          v = null,
          y = null,
          x = null;
        const b = [],
          w = new Map(),
          _ = new Ao();
        _.layers.enable(1), (_.viewport = new nr());
        const M = new Ao();
        M.layers.enable(2), (M.viewport = new nr());
        const S = [_, M],
          T = new vl();
        T.layers.enable(1), T.layers.enable(2);
        let E = null,
          A = null;

        function C(e) {
          const t = w.get(e.inputSource);
          t &&
            t.dispatchEvent({
              type: e.type,
              data: e.inputSource,
            });
        }

        function P() {
          w.forEach(function (e, t) {
            e.disconnect(t);
          }),
            w.clear(),
            (E = null),
            (A = null),
            r.bindXRFramebuffer(null),
            e.setRenderTarget(e.getRenderTarget()),
            u && t.deleteFramebuffer(u),
            f && t.deleteFramebuffer(f),
            m && t.deleteRenderbuffer(m),
            g && t.deleteRenderbuffer(g),
            (u = null),
            (f = null),
            (m = null),
            (g = null),
            (d = null),
            (h = null),
            (c = null),
            (i = null),
            O.stop(),
            (n.isPresenting = !1),
            n.dispatchEvent({
              type: "sessionend",
            });
        }

        function L(e) {
          const t = i.inputSources;
          for (let e = 0; e < b.length; e++) w.set(t[e], b[e]);
          for (let t = 0; t < e.removed.length; t++) {
            const n = e.removed[t],
              r = w.get(n);
            r &&
              (r.dispatchEvent({
                type: "disconnected",
                data: n,
              }),
              w.delete(n));
          }
          for (let t = 0; t < e.added.length; t++) {
            const n = e.added[t],
              r = w.get(n);
            r &&
              r.dispatchEvent({
                type: "connected",
                data: n,
              });
          }
        }
        (this.cameraAutoUpdate = !0),
          (this.enabled = !1),
          (this.isPresenting = !1),
          (this.getController = function (e) {
            let t = b[e];
            return (
              void 0 === t && ((t = new bl()), (b[e] = t)),
              t.getTargetRaySpace()
            );
          }),
          (this.getControllerGrip = function (e) {
            let t = b[e];
            return (
              void 0 === t && ((t = new bl()), (b[e] = t)), t.getGripSpace()
            );
          }),
          (this.getHand = function (e) {
            let t = b[e];
            return (
              void 0 === t && ((t = new bl()), (b[e] = t)), t.getHandSpace()
            );
          }),
          (this.setFramebufferScaleFactor = function (e) {
            (o = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
          (this.setReferenceSpaceType = function (e) {
            (s = e),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change reference space type while presenting."
                );
          }),
          (this.getReferenceSpace = function () {
            return a;
          }),
          (this.getBaseLayer = function () {
            return null !== h ? h : d;
          }),
          (this.getBinding = function () {
            return c;
          }),
          (this.getFrame = function () {
            return v;
          }),
          (this.getSession = function () {
            return i;
          }),
          (this.setSession = async function (e) {
            if (((i = e), null !== i)) {
              i.addEventListener("select", C),
                i.addEventListener("selectstart", C),
                i.addEventListener("selectend", C),
                i.addEventListener("squeeze", C),
                i.addEventListener("squeezestart", C),
                i.addEventListener("squeezeend", C),
                i.addEventListener("end", P),
                i.addEventListener("inputsourceschange", L);
              const e = t.getContextAttributes();
              if (
                (!0 !== e.xrCompatible && (await t.makeXRCompatible()),
                void 0 === i.renderState.layers)
              ) {
                const n = {
                  antialias: e.antialias,
                  alpha: e.alpha,
                  depth: e.depth,
                  stencil: e.stencil,
                  framebufferScaleFactor: o,
                };
                (d = new XRWebGLLayer(i, t, n)),
                  i.updateRenderState({
                    baseLayer: d,
                  });
              } else if (t instanceof WebGLRenderingContext) {
                const n = {
                  antialias: !0,
                  alpha: e.alpha,
                  depth: e.depth,
                  stencil: e.stencil,
                  framebufferScaleFactor: o,
                };
                (d = new XRWebGLLayer(i, t, n)),
                  i.updateRenderState({
                    layers: [d],
                  });
              } else {
                p = e.antialias;
                let n = null;
                e.depth &&
                  ((x = 256),
                  e.stencil && (x |= 1024),
                  (y = e.stencil ? 33306 : 36096),
                  (n = e.stencil ? 35056 : 33190));
                const a = {
                  colorFormat: e.alpha ? 32856 : 32849,
                  depthFormat: n,
                  scaleFactor: o,
                };
                (c = new XRWebGLBinding(i, t)),
                  (h = c.createProjectionLayer(a)),
                  (u = t.createFramebuffer()),
                  i.updateRenderState({
                    layers: [h],
                  }),
                  p &&
                    ((f = t.createFramebuffer()),
                    (m = t.createRenderbuffer()),
                    t.bindRenderbuffer(36161, m),
                    t.renderbufferStorageMultisample(
                      36161,
                      4,
                      32856,
                      h.textureWidth,
                      h.textureHeight
                    ),
                    r.bindFramebuffer(36160, f),
                    t.framebufferRenderbuffer(36160, 36064, 36161, m),
                    t.bindRenderbuffer(36161, null),
                    null !== n &&
                      ((g = t.createRenderbuffer()),
                      t.bindRenderbuffer(36161, g),
                      t.renderbufferStorageMultisample(
                        36161,
                        4,
                        n,
                        h.textureWidth,
                        h.textureHeight
                      ),
                      t.framebufferRenderbuffer(36160, y, 36161, g),
                      t.bindRenderbuffer(36161, null)),
                    r.bindFramebuffer(36160, null));
              }
              (a = await i.requestReferenceSpace(s)),
                O.setContext(i),
                O.start(),
                (n.isPresenting = !0),
                n.dispatchEvent({
                  type: "sessionstart",
                });
            }
          });
        const R = new sr(),
          I = new sr();

        function k(e, t) {
          null === t
            ? e.matrixWorld.copy(e.matrix)
            : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.copy(e.matrixWorld).invert();
        }
        (this.updateCamera = function (e) {
          if (null === i) return;
          (T.near = M.near = _.near = e.near),
            (T.far = M.far = _.far = e.far),
            (E === T.near && A === T.far) ||
              (i.updateRenderState({
                depthNear: T.near,
                depthFar: T.far,
              }),
              (E = T.near),
              (A = T.far));
          const t = e.parent,
            n = T.cameras;
          k(T, t);
          for (let e = 0; e < n.length; e++) k(n[e], t);
          T.matrixWorld.decompose(T.position, T.quaternion, T.scale),
            e.position.copy(T.position),
            e.quaternion.copy(T.quaternion),
            e.scale.copy(T.scale),
            e.matrix.copy(T.matrix),
            e.matrixWorld.copy(T.matrixWorld);
          const r = e.children;
          for (let e = 0, t = r.length; e < t; e++) r[e].updateMatrixWorld(!0);
          2 === n.length
            ? (function (e, t, n) {
                R.setFromMatrixPosition(t.matrixWorld),
                  I.setFromMatrixPosition(n.matrixWorld);
                const r = R.distanceTo(I),
                  i = t.projectionMatrix.elements,
                  o = n.projectionMatrix.elements,
                  a = i[14] / (i[10] - 1),
                  s = i[14] / (i[10] + 1),
                  l = (i[9] + 1) / i[5],
                  c = (i[9] - 1) / i[5],
                  u = (i[8] - 1) / i[0],
                  h = (o[8] + 1) / o[0],
                  d = a * u,
                  p = a * h,
                  f = r / (-u + h),
                  m = f * -u;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                  e.translateX(m),
                  e.translateZ(f),
                  e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                  e.matrixWorldInverse.copy(e.matrixWorld).invert();
                const g = a + f,
                  v = s + f,
                  y = d - m,
                  x = p + (r - m),
                  b = ((l * s) / v) * g,
                  w = ((c * s) / v) * g;
                e.projectionMatrix.makePerspective(y, x, b, w, g, v);
              })(T, _, M)
            : T.projectionMatrix.copy(_.projectionMatrix);
        }),
          (this.getCamera = function () {
            return T;
          }),
          (this.getFoveation = function () {
            return null !== h
              ? h.fixedFoveation
              : null !== d
              ? d.fixedFoveation
              : void 0;
          }),
          (this.setFoveation = function (e) {
            null !== h && (h.fixedFoveation = e),
              null !== d &&
                void 0 !== d.fixedFoveation &&
                (d.fixedFoveation = e);
          });
        let D = null;
        const O = new No();
        O.setAnimationLoop(function (e, n) {
          if (((l = n.getViewerPose(a)), (v = n), null !== l)) {
            const e = l.views;
            null !== d && r.bindXRFramebuffer(d.framebuffer);
            let n = !1;
            e.length !== T.cameras.length && ((T.cameras.length = 0), (n = !0));
            for (let i = 0; i < e.length; i++) {
              const o = e[i];
              let a = null;
              if (null !== d) a = d.getViewport(o);
              else {
                const e = c.getViewSubImage(h, o);
                r.bindXRFramebuffer(u),
                  void 0 !== e.depthStencilTexture &&
                    t.framebufferTexture2D(
                      36160,
                      y,
                      3553,
                      e.depthStencilTexture,
                      0
                    ),
                  t.framebufferTexture2D(36160, 36064, 3553, e.colorTexture, 0),
                  (a = e.viewport);
              }
              const s = S[i];
              s.matrix.fromArray(o.transform.matrix),
                s.projectionMatrix.fromArray(o.projectionMatrix),
                s.viewport.set(a.x, a.y, a.width, a.height),
                0 === i && T.matrix.copy(s.matrix),
                !0 === n && T.cameras.push(s);
            }
            p && (r.bindXRFramebuffer(f), null !== x && t.clear(x));
          }
          const o = i.inputSources;
          for (let e = 0; e < b.length; e++) {
            const t = b[e],
              r = o[e];
            t.update(r, n, a);
          }
          if ((D && D(e, n), p)) {
            const e = h.textureWidth,
              n = h.textureHeight;
            r.bindFramebuffer(36008, f),
              r.bindFramebuffer(36009, u),
              t.invalidateFramebuffer(36008, [y]),
              t.invalidateFramebuffer(36009, [y]),
              t.blitFramebuffer(0, 0, e, n, 0, 0, e, n, 16384, 9728),
              t.invalidateFramebuffer(36008, [36064]),
              r.bindFramebuffer(36008, null),
              r.bindFramebuffer(36009, null),
              r.bindFramebuffer(36160, f);
          }
          v = null;
        }),
          (this.setAnimationLoop = function (e) {
            D = e;
          }),
          (this.dispose = function () {});
      }
    }

    function _l(e) {
      function t(t, n) {
        (t.opacity.value = n.opacity),
          n.color && t.diffuse.value.copy(n.color),
          n.emissive &&
            t.emissive.value
              .copy(n.emissive)
              .multiplyScalar(n.emissiveIntensity),
          n.map && (t.map.value = n.map),
          n.alphaMap && (t.alphaMap.value = n.alphaMap),
          n.specularMap && (t.specularMap.value = n.specularMap),
          n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
        const r = e.get(n).envMap;
        if (r) {
          (t.envMap.value = r),
            (t.flipEnvMap.value =
              r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1),
            (t.reflectivity.value = n.reflectivity),
            (t.ior.value = n.ior),
            (t.refractionRatio.value = n.refractionRatio);
          const i = e.get(r).__maxMipLevel;
          void 0 !== i && (t.maxMipLevel.value = i);
        }
        let i, o;
        n.lightMap &&
          ((t.lightMap.value = n.lightMap),
          (t.lightMapIntensity.value = n.lightMapIntensity)),
          n.aoMap &&
            ((t.aoMap.value = n.aoMap),
            (t.aoMapIntensity.value = n.aoMapIntensity)),
          n.map
            ? (i = n.map)
            : n.specularMap
            ? (i = n.specularMap)
            : n.displacementMap
            ? (i = n.displacementMap)
            : n.normalMap
            ? (i = n.normalMap)
            : n.bumpMap
            ? (i = n.bumpMap)
            : n.roughnessMap
            ? (i = n.roughnessMap)
            : n.metalnessMap
            ? (i = n.metalnessMap)
            : n.alphaMap
            ? (i = n.alphaMap)
            : n.emissiveMap
            ? (i = n.emissiveMap)
            : n.clearcoatMap
            ? (i = n.clearcoatMap)
            : n.clearcoatNormalMap
            ? (i = n.clearcoatNormalMap)
            : n.clearcoatRoughnessMap
            ? (i = n.clearcoatRoughnessMap)
            : n.specularIntensityMap
            ? (i = n.specularIntensityMap)
            : n.specularTintMap
            ? (i = n.specularTintMap)
            : n.transmissionMap
            ? (i = n.transmissionMap)
            : n.thicknessMap && (i = n.thicknessMap),
          void 0 !== i &&
            (i.isWebGLRenderTarget && (i = i.texture),
            !0 === i.matrixAutoUpdate && i.updateMatrix(),
            t.uvTransform.value.copy(i.matrix)),
          n.aoMap ? (o = n.aoMap) : n.lightMap && (o = n.lightMap),
          void 0 !== o &&
            (o.isWebGLRenderTarget && (o = o.texture),
            !0 === o.matrixAutoUpdate && o.updateMatrix(),
            t.uv2Transform.value.copy(o.matrix));
      }

      function n(t, n) {
        (t.roughness.value = n.roughness),
          (t.metalness.value = n.metalness),
          n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
          n.metalnessMap && (t.metalnessMap.value = n.metalnessMap),
          n.emissiveMap && (t.emissiveMap.value = n.emissiveMap),
          n.bumpMap &&
            ((t.bumpMap.value = n.bumpMap),
            (t.bumpScale.value = n.bumpScale),
            n.side === m && (t.bumpScale.value *= -1)),
          n.normalMap &&
            ((t.normalMap.value = n.normalMap),
            t.normalScale.value.copy(n.normalScale),
            n.side === m && t.normalScale.value.negate()),
          n.displacementMap &&
            ((t.displacementMap.value = n.displacementMap),
            (t.displacementScale.value = n.displacementScale),
            (t.displacementBias.value = n.displacementBias)),
          e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity);
      }
      return {
        refreshFogUniforms: function (e, t) {
          e.fogColor.value.copy(t.color),
            t.isFog
              ? ((e.fogNear.value = t.near), (e.fogFar.value = t.far))
              : t.isFogExp2 && (e.fogDensity.value = t.density);
        },
        refreshMaterialUniforms: function (e, r, i, o, a) {
          r.isMeshBasicMaterial
            ? t(e, r)
            : r.isMeshLambertMaterial
            ? (t(e, r),
              (function (e, t) {
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
              })(e, r))
            : r.isMeshToonMaterial
            ? (t(e, r),
              (function (e, t) {
                t.gradientMap && (e.gradientMap.value = t.gradientMap);
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  t.side === m && (e.bumpScale.value *= -1));
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  t.side === m && e.normalScale.value.negate());
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, r))
            : r.isMeshPhongMaterial
            ? (t(e, r),
              (function (e, t) {
                e.specular.value.copy(t.specular),
                  (e.shininess.value = Math.max(t.shininess, 1e-4)),
                  t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  t.side === m && (e.bumpScale.value *= -1));
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  t.side === m && e.normalScale.value.negate());
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, r))
            : r.isMeshStandardMaterial
            ? (t(e, r),
              r.isMeshPhysicalMaterial
                ? (function (e, t, r) {
                    n(e, t),
                      (e.ior.value = t.ior),
                      t.sheenTint && e.sheenTint.value.copy(t.sheenTint);
                    t.clearcoat > 0 &&
                      ((e.clearcoat.value = t.clearcoat),
                      (e.clearcoatRoughness.value = t.clearcoatRoughness),
                      t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                      t.clearcoatRoughnessMap &&
                        (e.clearcoatRoughnessMap.value =
                          t.clearcoatRoughnessMap),
                      t.clearcoatNormalMap &&
                        (e.clearcoatNormalScale.value.copy(
                          t.clearcoatNormalScale
                        ),
                        (e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                        t.side === m && e.clearcoatNormalScale.value.negate()));
                    t.transmission > 0 &&
                      ((e.transmission.value = t.transmission),
                      (e.transmissionSamplerMap.value = r.texture),
                      e.transmissionSamplerSize.value.set(r.width, r.height),
                      t.transmissionMap &&
                        (e.transmissionMap.value = t.transmissionMap),
                      (e.thickness.value = t.thickness),
                      t.thicknessMap && (e.thicknessMap.value = t.thicknessMap),
                      (e.attenuationDistance.value = t.attenuationDistance),
                      e.attenuationTint.value.copy(t.attenuationTint));
                    (e.specularIntensity.value = t.specularIntensity),
                      e.specularTint.value.copy(t.specularTint),
                      t.specularIntensityMap &&
                        (e.specularIntensityMap.value = t.specularIntensityMap);
                    t.specularTintMap &&
                      (e.specularTintMap.value = t.specularTintMap);
                  })(e, r, a)
                : n(e, r))
            : r.isMeshMatcapMaterial
            ? (t(e, r),
              (function (e, t) {
                t.matcap && (e.matcap.value = t.matcap);
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  t.side === m && (e.bumpScale.value *= -1));
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  t.side === m && e.normalScale.value.negate());
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, r))
            : r.isMeshDepthMaterial
            ? (t(e, r),
              (function (e, t) {
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, r))
            : r.isMeshDistanceMaterial
            ? (t(e, r),
              (function (e, t) {
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
                e.referencePosition.value.copy(t.referencePosition),
                  (e.nearDistance.value = t.nearDistance),
                  (e.farDistance.value = t.farDistance);
              })(e, r))
            : r.isMeshNormalMaterial
            ? (t(e, r),
              (function (e, t) {
                t.bumpMap &&
                  ((e.bumpMap.value = t.bumpMap),
                  (e.bumpScale.value = t.bumpScale),
                  t.side === m && (e.bumpScale.value *= -1));
                t.normalMap &&
                  ((e.normalMap.value = t.normalMap),
                  e.normalScale.value.copy(t.normalScale),
                  t.side === m && e.normalScale.value.negate());
                t.displacementMap &&
                  ((e.displacementMap.value = t.displacementMap),
                  (e.displacementScale.value = t.displacementScale),
                  (e.displacementBias.value = t.displacementBias));
              })(e, r))
            : r.isLineBasicMaterial
            ? ((function (e, t) {
                e.diffuse.value.copy(t.color), (e.opacity.value = t.opacity);
              })(e, r),
              r.isLineDashedMaterial &&
                (function (e, t) {
                  (e.dashSize.value = t.dashSize),
                    (e.totalSize.value = t.dashSize + t.gapSize),
                    (e.scale.value = t.scale);
                })(e, r))
            : r.isPointsMaterial
            ? (function (e, t, n, r) {
                e.diffuse.value.copy(t.color),
                  (e.opacity.value = t.opacity),
                  (e.size.value = t.size * n),
                  (e.scale.value = 0.5 * r),
                  t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                let i;
                t.map ? (i = t.map) : t.alphaMap && (i = t.alphaMap);
                void 0 !== i &&
                  (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                  e.uvTransform.value.copy(i.matrix));
              })(e, r, i, o)
            : r.isSpriteMaterial
            ? (function (e, t) {
                e.diffuse.value.copy(t.color),
                  (e.opacity.value = t.opacity),
                  (e.rotation.value = t.rotation),
                  t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                let n;
                t.map ? (n = t.map) : t.alphaMap && (n = t.alphaMap);
                void 0 !== n &&
                  (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                  e.uvTransform.value.copy(n.matrix));
              })(e, r)
            : r.isShadowMaterial
            ? (e.color.value.copy(r.color), (e.opacity.value = r.opacity))
            : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
        },
      };
    }

    function Ml(e = {}) {
      const t =
          void 0 !== e.canvas
            ? e.canvas
            : (function () {
                const e = document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                );
                return (e.style.display = "block"), e;
              })(),
        n = void 0 !== e.context ? e.context : null,
        r = void 0 !== e.alpha && e.alpha,
        i = void 0 === e.depth || e.depth,
        o = void 0 === e.stencil || e.stencil,
        a = void 0 !== e.antialias && e.antialias,
        s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
        l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
        c = void 0 !== e.powerPreference ? e.powerPreference : "default",
        u =
          void 0 !== e.failIfMajorPerformanceCaveat &&
          e.failIfMajorPerformanceCaveat;
      let h = null,
        d = null;
      const p = [],
        v = [];
      (this.domElement = t),
        (this.debug = {
          checkShaderErrors: !0,
        }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.gammaFactor = 2),
        (this.outputEncoding = Jt),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = K),
        (this.toneMappingExposure = 1);
      const y = this;
      let x = !1,
        b = 0,
        w = 0,
        _ = null,
        M = -1,
        S = null;
      const T = new nr(),
        E = new nr();
      let A = null,
        C = t.width,
        P = t.height,
        L = 1,
        R = null,
        I = null;
      const k = new nr(0, 0, C, P),
        D = new nr(0, 0, C, P);
      let O = !1;
      const B = [],
        F = new Fo();
      let N = !1,
        U = !1,
        z = null;
      const H = new Nr(),
        G = new sr(),
        V = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };

      function j() {
        return null === _ ? L : 1;
      }
      let W,
        q,
        $,
        X,
        Y,
        J,
        Z,
        Q,
        ee,
        te,
        ne,
        re,
        ie,
        oe,
        ae,
        se,
        le,
        ce,
        ue,
        he,
        pe,
        me,
        ge,
        ve = n;

      function ye(e, n) {
        for (let r = 0; r < e.length; r++) {
          const i = e[r],
            o = t.getContext(i, n);
          if (null !== o) return o;
        }
        return null;
      }
      try {
        const e = {
          alpha: r,
          depth: i,
          stencil: o,
          antialias: a,
          premultipliedAlpha: s,
          preserveDrawingBuffer: l,
          powerPreference: c,
          failIfMajorPerformanceCaveat: u,
        };
        if (
          (t.addEventListener("webglcontextlost", we, !1),
          t.addEventListener("webglcontextrestored", Me, !1),
          null === ve)
        ) {
          const t = ["webgl2", "webgl", "experimental-webgl"];
          if (
            (!0 === y.isWebGL1Renderer && t.shift(),
            (ve = ye(t, e)),
            null === ve)
          )
            throw ye(t)
              ? new Error(
                  "Error creating WebGL context with your selected attributes."
                )
              : new Error("Error creating WebGL context.");
        }
        void 0 === ve.getShaderPrecisionFormat &&
          (ve.getShaderPrecisionFormat = function () {
            return {
              rangeMin: 1,
              rangeMax: 1,
              precision: 1,
            };
          });
      } catch (e) {
        throw (console.error("THREE.WebGLRenderer: " + e.message), e);
      }

      function xe() {
        (W = new wa(ve)),
          (q = new $o(ve, W, e)),
          W.init(q),
          (me = new gl(ve, W, q)),
          ($ = new fl(ve, W, q)),
          (B[0] = 1029),
          (X = new Sa(ve)),
          (Y = new el()),
          (J = new ml(ve, W, $, Y, q, me, X)),
          (Z = new Yo(y)),
          (Q = new ba(y)),
          (ee = new Uo(ve, q)),
          (ge = new Wo(ve, W, ee, q)),
          (te = new _a(ve, ee, X, ge)),
          (ne = new Ca(ve, te, ee, X)),
          (ue = new Aa(ve)),
          (se = new Xo(Y)),
          (re = new Qs(y, Z, Q, W, q, ge, se)),
          (ie = new _l(Y)),
          (oe = new il(Y)),
          (ae = new ul(W, q)),
          (ce = new jo(y, Z, $, ne, s)),
          (le = new pl(y, ne, q)),
          (he = new qo(ve, W, X, q)),
          (pe = new Ma(ve, W, X, q)),
          (X.programs = re.programs),
          (y.capabilities = q),
          (y.extensions = W),
          (y.properties = Y),
          (y.renderLists = oe),
          (y.shadowMap = le),
          (y.state = $),
          (y.info = X);
      }
      xe();
      const be = new wl(y, ve);

      function we(e) {
        e.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (x = !0);
      }

      function Me() {
        console.log("THREE.WebGLRenderer: Context Restored."), (x = !1);
        const e = X.autoReset,
          t = le.enabled,
          n = le.autoUpdate,
          r = le.needsUpdate,
          i = le.type;
        xe(),
          (X.autoReset = e),
          (le.enabled = t),
          (le.autoUpdate = n),
          (le.needsUpdate = r),
          (le.type = i);
      }

      function Te(e) {
        const t = e.target;
        t.removeEventListener("dispose", Te),
          (function (e) {
            (function (e) {
              const t = Y.get(e).programs;
              void 0 !== t &&
                t.forEach(function (e) {
                  re.releaseProgram(e);
                });
            })(e),
              Y.remove(e);
          })(t);
      }
      (this.xr = be),
        (this.getContext = function () {
          return ve;
        }),
        (this.getContextAttributes = function () {
          return ve.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const e = W.get("WEBGL_lose_context");
          e && e.loseContext();
        }),
        (this.forceContextRestore = function () {
          const e = W.get("WEBGL_lose_context");
          e && e.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return L;
        }),
        (this.setPixelRatio = function (e) {
          void 0 !== e && ((L = e), this.setSize(C, P, !1));
        }),
        (this.getSize = function (e) {
          return e.set(C, P);
        }),
        (this.setSize = function (e, n, r) {
          be.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((C = e),
              (P = n),
              (t.width = Math.floor(e * L)),
              (t.height = Math.floor(n * L)),
              !1 !== r &&
                ((t.style.width = e + "px"), (t.style.height = n + "px")),
              this.setViewport(0, 0, e, n));
        }),
        (this.getDrawingBufferSize = function (e) {
          return e.set(C * L, P * L).floor();
        }),
        (this.setDrawingBufferSize = function (e, n, r) {
          (C = e),
            (P = n),
            (L = r),
            (t.width = Math.floor(e * r)),
            (t.height = Math.floor(n * r)),
            this.setViewport(0, 0, e, n);
        }),
        (this.getCurrentViewport = function (e) {
          return e.copy(T);
        }),
        (this.getViewport = function (e) {
          return e.copy(k);
        }),
        (this.setViewport = function (e, t, n, r) {
          e.isVector4 ? k.set(e.x, e.y, e.z, e.w) : k.set(e, t, n, r),
            $.viewport(T.copy(k).multiplyScalar(L).floor());
        }),
        (this.getScissor = function (e) {
          return e.copy(D);
        }),
        (this.setScissor = function (e, t, n, r) {
          e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, r),
            $.scissor(E.copy(D).multiplyScalar(L).floor());
        }),
        (this.getScissorTest = function () {
          return O;
        }),
        (this.setScissorTest = function (e) {
          $.setScissorTest((O = e));
        }),
        (this.setOpaqueSort = function (e) {
          R = e;
        }),
        (this.setTransparentSort = function (e) {
          I = e;
        }),
        (this.getClearColor = function (e) {
          return e.copy(ce.getClearColor());
        }),
        (this.setClearColor = function () {
          ce.setClearColor.apply(ce, arguments);
        }),
        (this.getClearAlpha = function () {
          return ce.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          ce.setClearAlpha.apply(ce, arguments);
        }),
        (this.clear = function (e, t, n) {
          let r = 0;
          (void 0 === e || e) && (r |= 16384),
            (void 0 === t || t) && (r |= 256),
            (void 0 === n || n) && (r |= 1024),
            ve.clear(r);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          t.removeEventListener("webglcontextlost", we, !1),
            t.removeEventListener("webglcontextrestored", Me, !1),
            oe.dispose(),
            ae.dispose(),
            Y.dispose(),
            Z.dispose(),
            Q.dispose(),
            ne.dispose(),
            ge.dispose(),
            be.dispose(),
            be.removeEventListener("sessionstart", Ae),
            be.removeEventListener("sessionend", Ce),
            z && (z.dispose(), (z = null)),
            Pe.stop();
        }),
        (this.renderBufferImmediate = function (e, t) {
          ge.initAttributes();
          const n = Y.get(e);
          e.hasPositions && !n.position && (n.position = ve.createBuffer()),
            e.hasNormals && !n.normal && (n.normal = ve.createBuffer()),
            e.hasUvs && !n.uv && (n.uv = ve.createBuffer()),
            e.hasColors && !n.color && (n.color = ve.createBuffer());
          const r = t.getAttributes();
          e.hasPositions &&
            (ve.bindBuffer(34962, n.position),
            ve.bufferData(34962, e.positionArray, 35048),
            ge.enableAttribute(r.position.location),
            ve.vertexAttribPointer(r.position.location, 3, 5126, !1, 0, 0)),
            e.hasNormals &&
              (ve.bindBuffer(34962, n.normal),
              ve.bufferData(34962, e.normalArray, 35048),
              ge.enableAttribute(r.normal.location),
              ve.vertexAttribPointer(r.normal.location, 3, 5126, !1, 0, 0)),
            e.hasUvs &&
              (ve.bindBuffer(34962, n.uv),
              ve.bufferData(34962, e.uvArray, 35048),
              ge.enableAttribute(r.uv.location),
              ve.vertexAttribPointer(r.uv.location, 2, 5126, !1, 0, 0)),
            e.hasColors &&
              (ve.bindBuffer(34962, n.color),
              ve.bufferData(34962, e.colorArray, 35048),
              ge.enableAttribute(r.color.location),
              ve.vertexAttribPointer(r.color.location, 3, 5126, !1, 0, 0)),
            ge.disableUnusedAttributes(),
            ve.drawArrays(4, 0, e.count),
            (e.count = 0);
        }),
        (this.renderBufferDirect = function (e, t, n, r, i, o) {
          null === t && (t = V);
          const a = i.isMesh && i.matrixWorld.determinant() < 0,
            s = Fe(e, t, r, i);
          $.setMaterial(r, a);
          let l = n.index;
          const c = n.attributes.position;
          if (null === l) {
            if (void 0 === c || 0 === c.count) return;
          } else if (0 === l.count) return;
          let u,
            h = 1;
          !0 === r.wireframe && ((l = te.getWireframeAttribute(n)), (h = 2)),
            (void 0 === n.morphAttributes.position &&
              void 0 === n.morphAttributes.normal) ||
              ue.update(i, n, r, s),
            ge.setup(i, r, s, n, l);
          let d = he;
          null !== l && ((u = ee.get(l)), (d = pe), d.setIndex(u));
          const p = null !== l ? l.count : c.count,
            f = n.drawRange.start * h,
            m = n.drawRange.count * h,
            g = null !== o ? o.start * h : 0,
            v = null !== o ? o.count * h : 1 / 0,
            y = Math.max(f, g),
            x = Math.min(p, f + m, g + v) - 1,
            b = Math.max(0, x - y + 1);
          if (0 !== b) {
            if (i.isMesh)
              !0 === r.wireframe
                ? ($.setLineWidth(r.wireframeLinewidth * j()), d.setMode(1))
                : d.setMode(4);
            else if (i.isLine) {
              let e = r.linewidth;
              void 0 === e && (e = 1),
                $.setLineWidth(e * j()),
                i.isLineSegments
                  ? d.setMode(1)
                  : i.isLineLoop
                  ? d.setMode(2)
                  : d.setMode(3);
            } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
            if (i.isInstancedMesh) d.renderInstances(y, b, i.count);
            else if (n.isInstancedBufferGeometry) {
              const e = Math.min(n.instanceCount, n._maxInstanceCount);
              d.renderInstances(y, b, e);
            } else d.render(y, b);
          }
        }),
        (this.compile = function (e, t) {
          (d = ae.get(e)),
            d.init(),
            v.push(d),
            e.traverseVisible(function (e) {
              e.isLight &&
                e.layers.test(t.layers) &&
                (d.pushLight(e), e.castShadow && d.pushShadow(e));
            }),
            d.setupLights(y.physicallyCorrectLights),
            e.traverse(function (t) {
              const n = t.material;
              if (n)
                if (Array.isArray(n))
                  for (let r = 0; r < n.length; r++) {
                    Oe(n[r], e, t);
                  }
                else Oe(n, e, t);
            }),
            v.pop(),
            (d = null);
        });
      let Ee = null;

      function Ae() {
        Pe.stop();
      }

      function Ce() {
        Pe.start();
      }
      const Pe = new No();

      function Ie(e, t, n, r) {
        const i = e.opaque,
          o = e.transmissive,
          s = e.transparent;
        d.setupLightsView(n),
          o.length > 0 &&
            (function (e, t, n) {
              if (null === z) {
                const e = !0 === a && !0 === q.isWebGL2;
                z = new (e ? or : rr)(1024, 1024, {
                  generateMipmaps: !0,
                  type: null !== me.convert(Re) ? Re : Se,
                  minFilter: _e,
                  magFilter: fe,
                  wrapS: de,
                  wrapT: de,
                });
              }
              const r = y.getRenderTarget();
              y.setRenderTarget(z), y.clear();
              const i = y.toneMapping;
              (y.toneMapping = K),
                ke(e, t, n),
                (y.toneMapping = i),
                J.updateMultisampleRenderTarget(z),
                J.updateRenderTargetMipmap(z),
                y.setRenderTarget(r);
            })(i, t, n),
          r && $.viewport(T.copy(r)),
          i.length > 0 && ke(i, t, n),
          o.length > 0 && ke(o, t, n),
          s.length > 0 && ke(s, t, n);
      }

      function ke(e, t, n) {
        const r = !0 === t.isScene ? t.overrideMaterial : null;
        for (let i = 0, o = e.length; i < o; i++) {
          const o = e[i],
            a = o.object,
            s = o.geometry,
            l = null === r ? o.material : r,
            c = o.group;
          a.layers.test(n.layers) && De(a, t, n, s, l, c);
        }
      }

      function De(e, t, n, r, i, o) {
        if (
          (e.onBeforeRender(y, t, n, r, i, o),
          e.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            e.matrixWorld
          ),
          e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
          e.isImmediateRenderObject)
        ) {
          const r = Fe(n, t, i, e);
          $.setMaterial(i),
            ge.reset(),
            (function (e, t) {
              e.render(function (e) {
                y.renderBufferImmediate(e, t);
              });
            })(e, r);
        } else
          !0 === i.transparent && i.side === g
            ? ((i.side = m),
              (i.needsUpdate = !0),
              y.renderBufferDirect(n, t, r, i, e, o),
              (i.side = f),
              (i.needsUpdate = !0),
              y.renderBufferDirect(n, t, r, i, e, o),
              (i.side = g))
            : y.renderBufferDirect(n, t, r, i, e, o);
        e.onAfterRender(y, t, n, r, i, o);
      }

      function Oe(e, t, n) {
        !0 !== t.isScene && (t = V);
        const r = Y.get(e),
          i = d.state.lights,
          o = d.state.shadowsArray,
          a = i.state.version,
          s = re.getParameters(e, i.state, o, t, n),
          l = re.getProgramCacheKey(s);
        let c = r.programs;
        (r.environment = e.isMeshStandardMaterial ? t.environment : null),
          (r.fog = t.fog),
          (r.envMap = (e.isMeshStandardMaterial ? Q : Z).get(
            e.envMap || r.environment
          )),
          void 0 === c &&
            (e.addEventListener("dispose", Te),
            (c = new Map()),
            (r.programs = c));
        let u = c.get(l);
        if (void 0 !== u) {
          if (r.currentProgram === u && r.lightsStateVersion === a)
            return Be(e, s), u;
        } else
          (s.uniforms = re.getUniforms(e)),
            e.onBuild(s, y),
            e.onBeforeCompile(s, y),
            (u = re.acquireProgram(s, l)),
            c.set(l, u),
            (r.uniforms = s.uniforms);
        const h = r.uniforms;
        ((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) ||
          (h.clippingPlanes = se.uniform),
          Be(e, s),
          (r.needsLights = (function (e) {
            return (
              e.isMeshLambertMaterial ||
              e.isMeshToonMaterial ||
              e.isMeshPhongMaterial ||
              e.isMeshStandardMaterial ||
              e.isShadowMaterial ||
              (e.isShaderMaterial && !0 === e.lights)
            );
          })(e)),
          (r.lightsStateVersion = a),
          r.needsLights &&
            ((h.ambientLightColor.value = i.state.ambient),
            (h.lightProbe.value = i.state.probe),
            (h.directionalLights.value = i.state.directional),
            (h.directionalLightShadows.value = i.state.directionalShadow),
            (h.spotLights.value = i.state.spot),
            (h.spotLightShadows.value = i.state.spotShadow),
            (h.rectAreaLights.value = i.state.rectArea),
            (h.ltc_1.value = i.state.rectAreaLTC1),
            (h.ltc_2.value = i.state.rectAreaLTC2),
            (h.pointLights.value = i.state.point),
            (h.pointLightShadows.value = i.state.pointShadow),
            (h.hemisphereLights.value = i.state.hemi),
            (h.directionalShadowMap.value = i.state.directionalShadowMap),
            (h.directionalShadowMatrix.value = i.state.directionalShadowMatrix),
            (h.spotShadowMap.value = i.state.spotShadowMap),
            (h.spotShadowMatrix.value = i.state.spotShadowMatrix),
            (h.pointShadowMap.value = i.state.pointShadowMap),
            (h.pointShadowMatrix.value = i.state.pointShadowMatrix));
        const p = u.getUniforms(),
          f = Is.seqWithValue(p.seq, h);
        return (r.currentProgram = u), (r.uniformsList = f), u;
      }

      function Be(e, t) {
        const n = Y.get(e);
        (n.outputEncoding = t.outputEncoding),
          (n.instancing = t.instancing),
          (n.skinning = t.skinning),
          (n.morphTargets = t.morphTargets),
          (n.morphNormals = t.morphNormals),
          (n.numClippingPlanes = t.numClippingPlanes),
          (n.numIntersection = t.numClipIntersection),
          (n.vertexAlphas = t.vertexAlphas),
          (n.vertexTangents = t.vertexTangents);
      }

      function Fe(e, t, n, r) {
        !0 !== t.isScene && (t = V), J.resetTextureUnits();
        const i = t.fog,
          o = n.isMeshStandardMaterial ? t.environment : null,
          a = null === _ ? y.outputEncoding : _.texture.encoding,
          s = (n.isMeshStandardMaterial ? Q : Z).get(n.envMap || o),
          l =
            !0 === n.vertexColors &&
            !!r.geometry &&
            !!r.geometry.attributes.color &&
            4 === r.geometry.attributes.color.itemSize,
          c = !!r.geometry && !!r.geometry.attributes.tangent,
          u = !!r.geometry && !!r.geometry.morphAttributes.position,
          h = !!r.geometry && !!r.geometry.morphAttributes.normal,
          p = Y.get(n),
          f = d.state.lights;
        if (!0 === N && (!0 === U || e !== S)) {
          const t = e === S && n.id === M;
          se.setState(n, e, t);
        }
        let m = !1;
        n.version === p.__version
          ? (p.needsLights && p.lightsStateVersion !== f.state.version) ||
            p.outputEncoding !== a ||
            (r.isInstancedMesh && !1 === p.instancing)
            ? (m = !0)
            : r.isInstancedMesh || !0 !== p.instancing
            ? r.isSkinnedMesh && !1 === p.skinning
              ? (m = !0)
              : r.isSkinnedMesh || !0 !== p.skinning
              ? p.envMap !== s || (n.fog && p.fog !== i)
                ? (m = !0)
                : void 0 === p.numClippingPlanes ||
                  (p.numClippingPlanes === se.numPlanes &&
                    p.numIntersection === se.numIntersection)
                ? (p.vertexAlphas !== l ||
                    p.vertexTangents !== c ||
                    p.morphTargets !== u ||
                    p.morphNormals !== h) &&
                  (m = !0)
                : (m = !0)
              : (m = !0)
            : (m = !0)
          : ((m = !0), (p.__version = n.version));
        let g = p.currentProgram;
        !0 === m && (g = Oe(n, t, r));
        let v = !1,
          x = !1,
          b = !1;
        const w = g.getUniforms(),
          T = p.uniforms;
        if (
          ($.useProgram(g.program) && ((v = !0), (x = !0), (b = !0)),
          n.id !== M && ((M = n.id), (x = !0)),
          v || S !== e)
        ) {
          if (
            (w.setValue(ve, "projectionMatrix", e.projectionMatrix),
            q.logarithmicDepthBuffer &&
              w.setValue(
                ve,
                "logDepthBufFC",
                2 / (Math.log(e.far + 1) / Math.LN2)
              ),
            S !== e && ((S = e), (x = !0), (b = !0)),
            n.isShaderMaterial ||
              n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshStandardMaterial ||
              n.envMap)
          ) {
            const t = w.map.cameraPosition;
            void 0 !== t &&
              t.setValue(ve, G.setFromMatrixPosition(e.matrixWorld));
          }
          (n.isMeshPhongMaterial ||
            n.isMeshToonMaterial ||
            n.isMeshLambertMaterial ||
            n.isMeshBasicMaterial ||
            n.isMeshStandardMaterial ||
            n.isShaderMaterial) &&
            w.setValue(ve, "isOrthographic", !0 === e.isOrthographicCamera),
            (n.isMeshPhongMaterial ||
              n.isMeshToonMaterial ||
              n.isMeshLambertMaterial ||
              n.isMeshBasicMaterial ||
              n.isMeshStandardMaterial ||
              n.isShaderMaterial ||
              n.isShadowMaterial ||
              r.isSkinnedMesh) &&
              w.setValue(ve, "viewMatrix", e.matrixWorldInverse);
        }
        if (r.isSkinnedMesh) {
          w.setOptional(ve, r, "bindMatrix"),
            w.setOptional(ve, r, "bindMatrixInverse");
          const e = r.skeleton;
          e &&
            (q.floatVertexTextures
              ? (null === e.boneTexture && e.computeBoneTexture(),
                w.setValue(ve, "boneTexture", e.boneTexture, J),
                w.setValue(ve, "boneTextureSize", e.boneTextureSize))
              : w.setOptional(ve, e, "boneMatrices"));
        }
        var E, A;
        return (
          (x || p.receiveShadow !== r.receiveShadow) &&
            ((p.receiveShadow = r.receiveShadow),
            w.setValue(ve, "receiveShadow", r.receiveShadow)),
          x &&
            (w.setValue(ve, "toneMappingExposure", y.toneMappingExposure),
            p.needsLights &&
              ((A = b),
              ((E = T).ambientLightColor.needsUpdate = A),
              (E.lightProbe.needsUpdate = A),
              (E.directionalLights.needsUpdate = A),
              (E.directionalLightShadows.needsUpdate = A),
              (E.pointLights.needsUpdate = A),
              (E.pointLightShadows.needsUpdate = A),
              (E.spotLights.needsUpdate = A),
              (E.spotLightShadows.needsUpdate = A),
              (E.rectAreaLights.needsUpdate = A),
              (E.hemisphereLights.needsUpdate = A)),
            i && n.fog && ie.refreshFogUniforms(T, i),
            ie.refreshMaterialUniforms(T, n, L, P, z),
            Is.upload(ve, p.uniformsList, T, J)),
          n.isShaderMaterial &&
            !0 === n.uniformsNeedUpdate &&
            (Is.upload(ve, p.uniformsList, T, J), (n.uniformsNeedUpdate = !1)),
          n.isSpriteMaterial && w.setValue(ve, "center", r.center),
          w.setValue(ve, "modelViewMatrix", r.modelViewMatrix),
          w.setValue(ve, "normalMatrix", r.normalMatrix),
          w.setValue(ve, "modelMatrix", r.matrixWorld),
          g
        );
      }
      Pe.setAnimationLoop(function (e) {
        Ee && Ee(e);
      }),
        "undefined" != typeof window && Pe.setContext(window),
        (this.setAnimationLoop = function (e) {
          (Ee = e), be.setAnimationLoop(e), null === e ? Pe.stop() : Pe.start();
        }),
        be.addEventListener("sessionstart", Ae),
        be.addEventListener("sessionend", Ce),
        (this.render = function (e, t) {
          if (void 0 !== t && !0 !== t.isCamera)
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
          if (!0 === x) return;
          !0 === e.autoUpdate && e.updateMatrixWorld(),
            null === t.parent && t.updateMatrixWorld(),
            !0 === be.enabled &&
              !0 === be.isPresenting &&
              (!0 === be.cameraAutoUpdate && be.updateCamera(t),
              (t = be.getCamera())),
            !0 === e.isScene && e.onBeforeRender(y, e, t, _),
            (d = ae.get(e, v.length)),
            d.init(),
            v.push(d),
            H.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            F.setFromProjectionMatrix(H),
            (U = this.localClippingEnabled),
            (N = se.init(this.clippingPlanes, U, t)),
            (h = oe.get(e, p.length)),
            h.init(),
            p.push(h),
            (function e(t, n, r, i) {
              if (!1 === t.visible) return;
              if (t.layers.test(n.layers))
                if (t.isGroup) r = t.renderOrder;
                else if (t.isLOD) !0 === t.autoUpdate && t.update(n);
                else if (t.isLight)
                  d.pushLight(t), t.castShadow && d.pushShadow(t);
                else if (t.isSprite) {
                  if (!t.frustumCulled || F.intersectsSprite(t)) {
                    i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);
                    const e = ne.update(t),
                      n = t.material;
                    n.visible && h.push(t, e, n, r, G.z, null);
                  }
                } else if (t.isImmediateRenderObject)
                  i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H),
                    h.push(t, null, t.material, r, G.z, null);
                else if (
                  (t.isMesh || t.isLine || t.isPoints) &&
                  (t.isSkinnedMesh &&
                    t.skeleton.frame !== X.render.frame &&
                    (t.skeleton.update(), (t.skeleton.frame = X.render.frame)),
                  !t.frustumCulled || F.intersectsObject(t))
                ) {
                  i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);
                  const e = ne.update(t),
                    n = t.material;
                  if (Array.isArray(n)) {
                    const i = e.groups;
                    for (let o = 0, a = i.length; o < a; o++) {
                      const a = i[o],
                        s = n[a.materialIndex];
                      s && s.visible && h.push(t, e, s, r, G.z, a);
                    }
                  } else n.visible && h.push(t, e, n, r, G.z, null);
                }
              const o = t.children;
              for (let t = 0, a = o.length; t < a; t++) e(o[t], n, r, i);
            })(e, t, 0, y.sortObjects),
            h.finish(),
            !0 === y.sortObjects && h.sort(R, I),
            !0 === N && se.beginShadows();
          const n = d.state.shadowsArray;
          if (
            (le.render(n, e, t),
            !0 === N && se.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            ce.render(h, e),
            d.setupLights(y.physicallyCorrectLights),
            t.isArrayCamera)
          ) {
            const n = t.cameras;
            for (let t = 0, r = n.length; t < r; t++) {
              const r = n[t];
              Ie(h, e, r, r.viewport);
            }
          } else Ie(h, e, t);
          null !== _ &&
            (J.updateMultisampleRenderTarget(_), J.updateRenderTargetMipmap(_)),
            !0 === e.isScene && e.onAfterRender(y, e, t),
            $.buffers.depth.setTest(!0),
            $.buffers.depth.setMask(!0),
            $.buffers.color.setMask(!0),
            $.setPolygonOffset(!1),
            ge.resetDefaultState(),
            (M = -1),
            (S = null),
            v.pop(),
            (d = v.length > 0 ? v[v.length - 1] : null),
            p.pop(),
            (h = p.length > 0 ? p[p.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return b;
        }),
        (this.getActiveMipmapLevel = function () {
          return w;
        }),
        (this.getRenderTarget = function () {
          return _;
        }),
        (this.setRenderTarget = function (e, t = 0, n = 0) {
          (_ = e),
            (b = t),
            (w = n),
            e &&
              void 0 === Y.get(e).__webglFramebuffer &&
              J.setupRenderTarget(e);
          let r = null,
            i = !1,
            o = !1;
          if (e) {
            const n = e.texture;
            (n.isDataTexture3D || n.isDataTexture2DArray) && (o = !0);
            const a = Y.get(e).__webglFramebuffer;
            e.isWebGLCubeRenderTarget
              ? ((r = a[t]), (i = !0))
              : (r = e.isWebGLMultisampleRenderTarget
                  ? Y.get(e).__webglMultisampledFramebuffer
                  : a),
              T.copy(e.viewport),
              E.copy(e.scissor),
              (A = e.scissorTest);
          } else
            T.copy(k).multiplyScalar(L).floor(),
              E.copy(D).multiplyScalar(L).floor(),
              (A = O);
          if ($.bindFramebuffer(36160, r) && q.drawBuffers) {
            let t = !1;
            if (e)
              if (e.isWebGLMultipleRenderTargets) {
                const n = e.texture;
                if (B.length !== n.length || 36064 !== B[0]) {
                  for (let e = 0, t = n.length; e < t; e++) B[e] = 36064 + e;
                  (B.length = n.length), (t = !0);
                }
              } else
                (1 === B.length && 36064 === B[0]) ||
                  ((B[0] = 36064), (B.length = 1), (t = !0));
            else
              (1 === B.length && 1029 === B[0]) ||
                ((B[0] = 1029), (B.length = 1), (t = !0));
            t &&
              (q.isWebGL2
                ? ve.drawBuffers(B)
                : W.get("WEBGL_draw_buffers").drawBuffersWEBGL(B));
          }
          if (($.viewport(T), $.scissor(E), $.setScissorTest(A), i)) {
            const r = Y.get(e.texture);
            ve.framebufferTexture2D(
              36160,
              36064,
              34069 + t,
              r.__webglTexture,
              n
            );
          } else if (o) {
            const r = Y.get(e.texture),
              i = t || 0;
            ve.framebufferTextureLayer(
              36160,
              36064,
              r.__webglTexture,
              n || 0,
              i
            );
          }
          M = -1;
        }),
        (this.readRenderTargetPixels = function (e, t, n, r, i, o, a) {
          if (!e || !e.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          let s = Y.get(e).__webglFramebuffer;
          if ((e.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s)) {
            $.bindFramebuffer(36160, s);
            try {
              const a = e.texture,
                s = a.format,
                l = a.type;
              if (s !== Ne && me.convert(s) !== ve.getParameter(35739))
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                );
              const c =
                l === Re &&
                (W.has("EXT_color_buffer_half_float") ||
                  (q.isWebGL2 && W.has("EXT_color_buffer_float")));
              if (
                !(
                  l === Se ||
                  me.convert(l) === ve.getParameter(35738) ||
                  (l === Le &&
                    (q.isWebGL2 ||
                      W.has("OES_texture_float") ||
                      W.has("WEBGL_color_buffer_float"))) ||
                  c
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
              36053 === ve.checkFramebufferStatus(36160)
                ? t >= 0 &&
                  t <= e.width - r &&
                  n >= 0 &&
                  n <= e.height - i &&
                  ve.readPixels(t, n, r, i, me.convert(s), me.convert(l), o)
                : console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                  );
            } finally {
              const e = null !== _ ? Y.get(_).__webglFramebuffer : null;
              $.bindFramebuffer(36160, e);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (e, t, n = 0) {
          const r = Math.pow(2, -n),
            i = Math.floor(t.image.width * r),
            o = Math.floor(t.image.height * r);
          let a = me.convert(t.format);
          q.isWebGL2 && (6407 === a && (a = 32849), 6408 === a && (a = 32856)),
            J.setTexture2D(t, 0),
            ve.copyTexImage2D(3553, n, a, e.x, e.y, i, o, 0),
            $.unbindTexture();
        }),
        (this.copyTextureToTexture = function (e, t, n, r = 0) {
          const i = t.image.width,
            o = t.image.height,
            a = me.convert(n.format),
            s = me.convert(n.type);
          J.setTexture2D(n, 0),
            ve.pixelStorei(37440, n.flipY),
            ve.pixelStorei(37441, n.premultiplyAlpha),
            ve.pixelStorei(3317, n.unpackAlignment),
            t.isDataTexture
              ? ve.texSubImage2D(3553, r, e.x, e.y, i, o, a, s, t.image.data)
              : t.isCompressedTexture
              ? ve.compressedTexSubImage2D(
                  3553,
                  r,
                  e.x,
                  e.y,
                  t.mipmaps[0].width,
                  t.mipmaps[0].height,
                  a,
                  t.mipmaps[0].data
                )
              : ve.texSubImage2D(3553, r, e.x, e.y, a, s, t.image),
            0 === r && n.generateMipmaps && ve.generateMipmap(3553),
            $.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (e, t, n, r, i = 0) {
          if (y.isWebGL1Renderer)
            return void console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
            );
          const o = e.max.x - e.min.x + 1,
            a = e.max.y - e.min.y + 1,
            s = e.max.z - e.min.z + 1,
            l = me.convert(r.format),
            c = me.convert(r.type);
          let u;
          if (r.isDataTexture3D) J.setTexture3D(r, 0), (u = 32879);
          else {
            if (!r.isDataTexture2DArray)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
            J.setTexture2DArray(r, 0), (u = 35866);
          }
          ve.pixelStorei(37440, r.flipY),
            ve.pixelStorei(37441, r.premultiplyAlpha),
            ve.pixelStorei(3317, r.unpackAlignment);
          const h = ve.getParameter(3314),
            d = ve.getParameter(32878),
            p = ve.getParameter(3316),
            f = ve.getParameter(3315),
            m = ve.getParameter(32877),
            g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
          ve.pixelStorei(3314, g.width),
            ve.pixelStorei(32878, g.height),
            ve.pixelStorei(3316, e.min.x),
            ve.pixelStorei(3315, e.min.y),
            ve.pixelStorei(32877, e.min.z),
            n.isDataTexture || n.isDataTexture3D
              ? ve.texSubImage3D(u, i, t.x, t.y, t.z, o, a, s, l, c, g.data)
              : n.isCompressedTexture
              ? (console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                ),
                ve.compressedTexSubImage3D(
                  u,
                  i,
                  t.x,
                  t.y,
                  t.z,
                  o,
                  a,
                  s,
                  l,
                  g.data
                ))
              : ve.texSubImage3D(u, i, t.x, t.y, t.z, o, a, s, l, c, g),
            ve.pixelStorei(3314, h),
            ve.pixelStorei(32878, d),
            ve.pixelStorei(3316, p),
            ve.pixelStorei(3315, f),
            ve.pixelStorei(32877, m),
            0 === i && r.generateMipmaps && ve.generateMipmap(u),
            $.unbindTexture();
        }),
        (this.initTexture = function (e) {
          J.setTexture2D(e, 0), $.unbindTexture();
        }),
        (this.resetState = function () {
          (b = 0), (w = 0), (_ = null), $.reset(), ge.reset();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", {
              detail: this,
            })
          );
    }
    class Sl extends Ml {}
    Sl.prototype.isWebGL1Renderer = !0;
    class Tl {
      constructor(e, t = 25e-5) {
        (this.name = ""), (this.color = new Pi(e)), (this.density = t);
      }
      clone() {
        return new Tl(this.color, this.density);
      }
      toJSON() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density,
        };
      }
    }
    Tl.prototype.isFogExp2 = !0;
    class El {
      constructor(e, t = 1, n = 1e3) {
        (this.name = ""),
          (this.color = new Pi(e)),
          (this.near = t),
          (this.far = n);
      }
      clone() {
        return new El(this.color, this.near, this.far);
      }
      toJSON() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far,
        };
      }
    }
    El.prototype.isFog = !0;
    class Al extends ci {
      constructor() {
        super(),
          (this.type = "Scene"),
          (this.background = null),
          (this.environment = null),
          (this.fog = null),
          (this.overrideMaterial = null),
          (this.autoUpdate = !0),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", {
                detail: this,
              })
            );
      }
      copy(e, t) {
        return (
          super.copy(e, t),
          null !== e.background && (this.background = e.background.clone()),
          null !== e.environment && (this.environment = e.environment.clone()),
          null !== e.fog && (this.fog = e.fog.clone()),
          null !== e.overrideMaterial &&
            (this.overrideMaterial = e.overrideMaterial.clone()),
          (this.autoUpdate = e.autoUpdate),
          (this.matrixAutoUpdate = e.matrixAutoUpdate),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return null !== this.fog && (t.object.fog = this.fog.toJSON()), t;
      }
    }
    Al.prototype.isScene = !0;
    class Cl {
      constructor(e, t) {
        (this.array = e),
          (this.stride = t),
          (this.count = void 0 !== e ? e.length / t : 0),
          (this.usage = Tn),
          (this.updateRange = {
            offset: 0,
            count: -1,
          }),
          (this.version = 0),
          (this.uuid = Hn());
      }
      onUploadCallback() {}
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setUsage(e) {
        return (this.usage = e), this;
      }
      copy(e) {
        return (
          (this.array = new e.array.constructor(e.array)),
          (this.count = e.count),
          (this.stride = e.stride),
          (this.usage = e.usage),
          this
        );
      }
      copyAt(e, t, n) {
        (e *= this.stride), (n *= t.stride);
        for (let r = 0, i = this.stride; r < i; r++)
          this.array[e + r] = t.array[n + r];
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      clone(e) {
        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid &&
            (this.array.buffer._uuid = Hn()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] =
              this.array.slice(0).buffer);
        const t = new this.array.constructor(
            e.arrayBuffers[this.array.buffer._uuid]
          ),
          n = new this.constructor(t, this.stride);
        return n.setUsage(this.usage), n;
      }
      onUpload(e) {
        return (this.onUploadCallback = e), this;
      }
      toJSON(e) {
        return (
          void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
          void 0 === this.array.buffer._uuid &&
            (this.array.buffer._uuid = Hn()),
          void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
            (e.arrayBuffers[this.array.buffer._uuid] =
              Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
          {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride,
          }
        );
      }
    }
    Cl.prototype.isInterleavedBuffer = !0;
    const Pl = new sr();
    class Ll {
      constructor(e, t, n, r = !1) {
        (this.name = ""),
          (this.data = e),
          (this.itemSize = t),
          (this.offset = n),
          (this.normalized = !0 === r);
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(e) {
        this.data.needsUpdate = e;
      }
      applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
          (Pl.x = this.getX(t)),
            (Pl.y = this.getY(t)),
            (Pl.z = this.getZ(t)),
            Pl.applyMatrix4(e),
            this.setXYZ(t, Pl.x, Pl.y, Pl.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Pl.x = this.getX(t)),
            (Pl.y = this.getY(t)),
            (Pl.z = this.getZ(t)),
            Pl.applyNormalMatrix(e),
            this.setXYZ(t, Pl.x, Pl.y, Pl.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
          (Pl.x = this.getX(t)),
            (Pl.y = this.getY(t)),
            (Pl.z = this.getZ(t)),
            Pl.transformDirection(e),
            this.setXYZ(t, Pl.x, Pl.y, Pl.z);
        return this;
      }
      setX(e, t) {
        return (this.data.array[e * this.data.stride + this.offset] = t), this;
      }
      setY(e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 1] = t), this
        );
      }
      setZ(e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 2] = t), this
        );
      }
      setW(e, t) {
        return (
          (this.data.array[e * this.data.stride + this.offset + 3] = t), this
        );
      }
      getX(e) {
        return this.data.array[e * this.data.stride + this.offset];
      }
      getY(e) {
        return this.data.array[e * this.data.stride + this.offset + 1];
      }
      getZ(e) {
        return this.data.array[e * this.data.stride + this.offset + 2];
      }
      getW(e) {
        return this.data.array[e * this.data.stride + this.offset + 3];
      }
      setXY(e, t, n) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          this
        );
      }
      setXYZ(e, t, n, r) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          (this.data.array[e + 2] = r),
          this
        );
      }
      setXYZW(e, t, n, r, i) {
        return (
          (e = e * this.data.stride + this.offset),
          (this.data.array[e + 0] = t),
          (this.data.array[e + 1] = n),
          (this.data.array[e + 2] = r),
          (this.data.array[e + 3] = i),
          this
        );
      }
      clone(e) {
        if (void 0 === e) {
          console.log(
            "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
          );
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++)
              e.push(this.data.array[n + t]);
          }
          return new ki(
            new this.array.constructor(e),
            this.itemSize,
            this.normalized
          );
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
          new Ll(
            e.interleavedBuffers[this.data.uuid],
            this.itemSize,
            this.offset,
            this.normalized
          )
        );
      }
      toJSON(e) {
        if (void 0 === e) {
          console.log(
            "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
          );
          const e = [];
          for (let t = 0; t < this.count; t++) {
            const n = t * this.data.stride + this.offset;
            for (let t = 0; t < this.itemSize; t++)
              e.push(this.data.array[n + t]);
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: e,
            normalized: this.normalized,
          };
        }
        return (
          void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
          void 0 === e.interleavedBuffers[this.data.uuid] &&
            (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
          {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized,
          }
        );
      }
    }
    Ll.prototype.isInterleavedBufferAttribute = !0;
    class Rl extends _i {
      constructor(e) {
        super(),
          (this.type = "SpriteMaterial"),
          (this.color = new Pi(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.rotation = 0),
          (this.sizeAttenuation = !0),
          (this.transparent = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.rotation = e.rotation),
          (this.sizeAttenuation = e.sizeAttenuation),
          this
        );
      }
    }
    let Il;
    Rl.prototype.isSpriteMaterial = !0;
    const kl = new sr(),
      Dl = new sr(),
      Ol = new sr(),
      Bl = new Yn(),
      Fl = new Yn(),
      Nl = new Nr(),
      Ul = new sr(),
      zl = new sr(),
      Hl = new sr(),
      Gl = new Yn(),
      Vl = new Yn(),
      jl = new Yn();
    class Wl extends ci {
      constructor(e) {
        if ((super(), (this.type = "Sprite"), void 0 === Il)) {
          Il = new eo();
          const e = new Float32Array([
              -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5,
              0.5, 0, 0, 1,
            ]),
            t = new Cl(e, 5);
          Il.setIndex([0, 1, 2, 0, 2, 3]),
            Il.setAttribute("position", new Ll(t, 3, 0, !1)),
            Il.setAttribute("uv", new Ll(t, 2, 3, !1));
        }
        (this.geometry = Il),
          (this.material = void 0 !== e ? e : new Rl()),
          (this.center = new Yn(0.5, 0.5));
      }
      raycast(e, t) {
        null === e.camera &&
          console.error(
            'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
          ),
          Dl.setFromMatrixScale(this.matrixWorld),
          Nl.copy(e.camera.matrixWorld),
          this.modelViewMatrix.multiplyMatrices(
            e.camera.matrixWorldInverse,
            this.matrixWorld
          ),
          Ol.setFromMatrixPosition(this.modelViewMatrix),
          e.camera.isPerspectiveCamera &&
            !1 === this.material.sizeAttenuation &&
            Dl.multiplyScalar(-Ol.z);
        const n = this.material.rotation;
        let r, i;
        0 !== n && ((i = Math.cos(n)), (r = Math.sin(n)));
        const o = this.center;
        ql(Ul.set(-0.5, -0.5, 0), Ol, o, Dl, r, i),
          ql(zl.set(0.5, -0.5, 0), Ol, o, Dl, r, i),
          ql(Hl.set(0.5, 0.5, 0), Ol, o, Dl, r, i),
          Gl.set(0, 0),
          Vl.set(1, 0),
          jl.set(1, 1);
        let a = e.ray.intersectTriangle(Ul, zl, Hl, !1, kl);
        if (
          null === a &&
          (ql(zl.set(-0.5, 0.5, 0), Ol, o, Dl, r, i),
          Vl.set(0, 1),
          (a = e.ray.intersectTriangle(Ul, Hl, zl, !1, kl)),
          null === a)
        )
          return;
        const s = e.ray.origin.distanceTo(kl);
        s < e.near ||
          s > e.far ||
          t.push({
            distance: s,
            point: kl.clone(),
            uv: bi.getUV(kl, Ul, zl, Hl, Gl, Vl, jl, new Yn()),
            face: null,
            object: this,
          });
      }
      copy(e) {
        return (
          super.copy(e),
          void 0 !== e.center && this.center.copy(e.center),
          (this.material = e.material),
          this
        );
      }
    }

    function ql(e, t, n, r, i, o) {
      Bl.subVectors(e, n).addScalar(0.5).multiply(r),
        void 0 !== i
          ? ((Fl.x = o * Bl.x - i * Bl.y), (Fl.y = i * Bl.x + o * Bl.y))
          : Fl.copy(Bl),
        e.copy(t),
        (e.x += Fl.x),
        (e.y += Fl.y),
        e.applyMatrix4(Nl);
    }
    Wl.prototype.isSprite = !0;
    const $l = new sr(),
      Xl = new sr();
    class Yl extends ci {
      constructor() {
        super(),
          (this._currentLevel = 0),
          (this.type = "LOD"),
          Object.defineProperties(this, {
            levels: {
              enumerable: !0,
              value: [],
            },
            isLOD: {
              value: !0,
            },
          }),
          (this.autoUpdate = !0);
      }
      copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e];
          this.addLevel(n.object.clone(), n.distance);
        }
        return (this.autoUpdate = e.autoUpdate), this;
      }
      addLevel(e, t = 0) {
        t = Math.abs(t);
        const n = this.levels;
        let r;
        for (r = 0; r < n.length && !(t < n[r].distance); r++);
        return (
          n.splice(r, 0, {
            distance: t,
            object: e,
          }),
          this.add(e),
          this
        );
      }
      getCurrentLevel() {
        return this._currentLevel;
      }
      getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
          let n, r;
          for (n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
          return t[n - 1].object;
        }
        return null;
      }
      raycast(e, t) {
        if (this.levels.length > 0) {
          $l.setFromMatrixPosition(this.matrixWorld);
          const n = e.ray.origin.distanceTo($l);
          this.getObjectForDistance(n).raycast(e, t);
        }
      }
      update(e) {
        const t = this.levels;
        if (t.length > 1) {
          $l.setFromMatrixPosition(e.matrixWorld),
            Xl.setFromMatrixPosition(this.matrixWorld);
          const n = $l.distanceTo(Xl) / e.zoom;
          let r, i;
          for (
            t[0].object.visible = !0, r = 1, i = t.length;
            r < i && n >= t[r].distance;
            r++
          )
            (t[r - 1].object.visible = !1), (t[r].object.visible = !0);
          for (this._currentLevel = r - 1; r < i; r++) t[r].object.visible = !1;
        }
      }
      toJSON(e) {
        const t = super.toJSON(e);
        !1 === this.autoUpdate && (t.object.autoUpdate = !1),
          (t.object.levels = []);
        const n = this.levels;
        for (let e = 0, r = n.length; e < r; e++) {
          const r = n[e];
          t.object.levels.push({
            object: r.object.uuid,
            distance: r.distance,
          });
        }
        return t;
      }
    }
    const Jl = new sr(),
      Zl = new nr(),
      Kl = new nr(),
      Ql = new sr(),
      ec = new Nr();
    class tc extends xo {
      constructor(e, t) {
        super(e, t),
          (this.type = "SkinnedMesh"),
          (this.bindMode = "attached"),
          (this.bindMatrix = new Nr()),
          (this.bindMatrixInverse = new Nr());
      }
      copy(e) {
        return (
          super.copy(e),
          (this.bindMode = e.bindMode),
          this.bindMatrix.copy(e.bindMatrix),
          this.bindMatrixInverse.copy(e.bindMatrixInverse),
          (this.skeleton = e.skeleton),
          this
        );
      }
      bind(e, t) {
        (this.skeleton = e),
          void 0 === t &&
            (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            (t = this.matrixWorld)),
          this.bindMatrix.copy(t),
          this.bindMatrixInverse.copy(t).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const e = new nr(),
          t = this.geometry.attributes.skinWeight;
        for (let n = 0, r = t.count; n < r; n++) {
          (e.x = t.getX(n)),
            (e.y = t.getY(n)),
            (e.z = t.getZ(n)),
            (e.w = t.getW(n));
          const r = 1 / e.manhattanLength();
          r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w);
        }
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
          "attached" === this.bindMode
            ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
            : "detached" === this.bindMode
            ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
            : console.warn(
                "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
              );
      }
      boneTransform(e, t) {
        const n = this.skeleton,
          r = this.geometry;
        Zl.fromBufferAttribute(r.attributes.skinIndex, e),
          Kl.fromBufferAttribute(r.attributes.skinWeight, e),
          Jl.fromBufferAttribute(r.attributes.position, e).applyMatrix4(
            this.bindMatrix
          ),
          t.set(0, 0, 0);
        for (let e = 0; e < 4; e++) {
          const r = Kl.getComponent(e);
          if (0 !== r) {
            const i = Zl.getComponent(e);
            ec.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
              t.addScaledVector(Ql.copy(Jl).applyMatrix4(ec), r);
          }
        }
        return t.applyMatrix4(this.bindMatrixInverse);
      }
    }
    tc.prototype.isSkinnedMesh = !0;
    class nc extends ci {
      constructor() {
        super(), (this.type = "Bone");
      }
    }
    nc.prototype.isBone = !0;
    class rc extends er {
      constructor(e = null, t = 1, n = 1, r, i, o, a, s, l = fe, c = fe, u, h) {
        super(null, o, a, s, l, c, r, i, u, h),
          (this.image = {
            data: e,
            width: t,
            height: n,
          }),
          (this.magFilter = l),
          (this.minFilter = c),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1),
          (this.needsUpdate = !0);
      }
    }
    rc.prototype.isDataTexture = !0;
    const ic = new Nr(),
      oc = new Nr();
    class ac {
      constructor(e = [], t = []) {
        (this.uuid = Hn()),
          (this.bones = e.slice(0)),
          (this.boneInverses = t),
          (this.boneMatrices = null),
          (this.boneTexture = null),
          (this.boneTextureSize = 0),
          (this.frame = -1),
          this.init();
      }
      init() {
        const e = this.bones,
          t = this.boneInverses;
        if (
          ((this.boneMatrices = new Float32Array(16 * e.length)),
          0 === t.length)
        )
          this.calculateInverses();
        else if (e.length !== t.length) {
          console.warn(
            "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
          ),
            (this.boneInverses = []);
          for (let e = 0, t = this.bones.length; e < t; e++)
            this.boneInverses.push(new Nr());
        }
      }
      calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = new Nr();
          this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(t);
        }
      }
      pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t && t.matrixWorld.copy(this.boneInverses[e]).invert();
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const t = this.bones[e];
          t &&
            (t.parent && t.parent.isBone
              ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                t.matrix.multiply(t.matrixWorld))
              : t.matrix.copy(t.matrixWorld),
            t.matrix.decompose(t.position, t.quaternion, t.scale));
        }
      }
      update() {
        const e = this.bones,
          t = this.boneInverses,
          n = this.boneMatrices,
          r = this.boneTexture;
        for (let r = 0, i = e.length; r < i; r++) {
          const i = e[r] ? e[r].matrixWorld : oc;
          ic.multiplyMatrices(i, t[r]), ic.toArray(n, 16 * r);
        }
        null !== r && (r.needsUpdate = !0);
      }
      clone() {
        return new ac(this.bones, this.boneInverses);
      }
      computeBoneTexture() {
        let e = Math.sqrt(4 * this.bones.length);
        (e = qn(e)), (e = Math.max(e, 4));
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new rc(t, e, e, Ne, Le);
        return (
          (this.boneMatrices = t),
          (this.boneTexture = n),
          (this.boneTextureSize = e),
          this
        );
      }
      getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
          const n = this.bones[t];
          if (n.name === e) return n;
        }
      }
      dispose() {
        null !== this.boneTexture &&
          (this.boneTexture.dispose(), (this.boneTexture = null));
      }
      fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, r = e.bones.length; n < r; n++) {
          const r = e.bones[n];
          let i = t[r];
          void 0 === i &&
            (console.warn("THREE.Skeleton: No bone found with UUID:", r),
            (i = new nc())),
            this.bones.push(i),
            this.boneInverses.push(new Nr().fromArray(e.boneInverses[n]));
        }
        return this.init(), this;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "Skeleton",
            generator: "Skeleton.toJSON",
          },
          bones: [],
          boneInverses: [],
        };
        e.uuid = this.uuid;
        const t = this.bones,
          n = this.boneInverses;
        for (let r = 0, i = t.length; r < i; r++) {
          const i = t[r];
          e.bones.push(i.uuid);
          const o = n[r];
          e.boneInverses.push(o.toArray());
        }
        return e;
      }
    }
    class sc extends ki {
      constructor(e, t, n, r = 1) {
        "number" == typeof n &&
          ((r = n),
          (n = !1),
          console.error(
            "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
          )),
          super(e, t, n),
          (this.meshPerAttribute = r);
      }
      copy(e) {
        return (
          super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.meshPerAttribute = this.meshPerAttribute),
          (e.isInstancedBufferAttribute = !0),
          e
        );
      }
    }
    sc.prototype.isInstancedBufferAttribute = !0;
    const lc = new Nr(),
      cc = new Nr(),
      uc = [],
      hc = new xo();
    class dc extends xo {
      constructor(e, t, n) {
        super(e, t),
          (this.instanceMatrix = new sc(new Float32Array(16 * n), 16)),
          (this.instanceColor = null),
          (this.count = n),
          (this.frustumCulled = !1);
      }
      copy(e) {
        return (
          super.copy(e),
          this.instanceMatrix.copy(e.instanceMatrix),
          null !== e.instanceColor &&
            (this.instanceColor = e.instanceColor.clone()),
          (this.count = e.count),
          this
        );
      }
      getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, 3 * e);
      }
      getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, 16 * e);
      }
      raycast(e, t) {
        const n = this.matrixWorld,
          r = this.count;
        if (
          ((hc.geometry = this.geometry),
          (hc.material = this.material),
          void 0 !== hc.material)
        )
          for (let i = 0; i < r; i++) {
            this.getMatrixAt(i, lc),
              cc.multiplyMatrices(n, lc),
              (hc.matrixWorld = cc),
              hc.raycast(e, uc);
            for (let e = 0, n = uc.length; e < n; e++) {
              const n = uc[e];
              (n.instanceId = i), (n.object = this), t.push(n);
            }
            uc.length = 0;
          }
      }
      setColorAt(e, t) {
        null === this.instanceColor &&
          (this.instanceColor = new sc(
            new Float32Array(3 * this.instanceMatrix.count),
            3
          )),
          t.toArray(this.instanceColor.array, 3 * e);
      }
      setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, 16 * e);
      }
      updateMorphTargets() {}
      dispose() {
        this.dispatchEvent({
          type: "dispose",
        });
      }
    }
    dc.prototype.isInstancedMesh = !0;
    class pc extends _i {
      constructor(e) {
        super(),
          (this.type = "LineBasicMaterial"),
          (this.color = new Pi(16777215)),
          (this.linewidth = 1),
          (this.linecap = "round"),
          (this.linejoin = "round"),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.linewidth = e.linewidth),
          (this.linecap = e.linecap),
          (this.linejoin = e.linejoin),
          this
        );
      }
    }
    pc.prototype.isLineBasicMaterial = !0;
    const fc = new sr(),
      mc = new sr(),
      gc = new Nr(),
      vc = new Fr(),
      yc = new Pr();
    class xc extends ci {
      constructor(e = new eo(), t = new pc()) {
        super(),
          (this.type = "Line"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      computeLineDistances() {
        const e = this.geometry;
        if (e.isBufferGeometry)
          if (null === e.index) {
            const t = e.attributes.position,
              n = [0];
            for (let e = 1, r = t.count; e < r; e++)
              fc.fromBufferAttribute(t, e - 1),
                mc.fromBufferAttribute(t, e),
                (n[e] = n[e - 1]),
                (n[e] += fc.distanceTo(mc));
            e.setAttribute("lineDistance", new Gi(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else
          e.isGeometry &&
            console.error(
              "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        return this;
      }
      raycast(e, t) {
        const n = this.geometry,
          r = this.matrixWorld,
          i = e.params.Line.threshold,
          o = n.drawRange;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          yc.copy(n.boundingSphere),
          yc.applyMatrix4(r),
          (yc.radius += i),
          !1 === e.ray.intersectsSphere(yc))
        )
          return;
        gc.copy(r).invert(), vc.copy(e.ray).applyMatrix4(gc);
        const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          s = a * a,
          l = new sr(),
          c = new sr(),
          u = new sr(),
          h = new sr(),
          d = this.isLineSegments ? 2 : 1;
        if (n.isBufferGeometry) {
          const r = n.index,
            i = n.attributes.position;
          if (null !== r) {
            for (
              let n = Math.max(0, o.start),
                a = Math.min(r.count, o.start + o.count) - 1;
              n < a;
              n += d
            ) {
              const o = r.getX(n),
                a = r.getX(n + 1);
              if (
                (l.fromBufferAttribute(i, o),
                c.fromBufferAttribute(i, a),
                vc.distanceSqToSegment(l, c, h, u) > s)
              )
                continue;
              h.applyMatrix4(this.matrixWorld);
              const d = e.ray.origin.distanceTo(h);
              d < e.near ||
                d > e.far ||
                t.push({
                  distance: d,
                  point: u.clone().applyMatrix4(this.matrixWorld),
                  index: n,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
          } else {
            for (
              let n = Math.max(0, o.start),
                r = Math.min(i.count, o.start + o.count) - 1;
              n < r;
              n += d
            ) {
              if (
                (l.fromBufferAttribute(i, n),
                c.fromBufferAttribute(i, n + 1),
                vc.distanceSqToSegment(l, c, h, u) > s)
              )
                continue;
              h.applyMatrix4(this.matrixWorld);
              const r = e.ray.origin.distanceTo(h);
              r < e.near ||
                r > e.far ||
                t.push({
                  distance: r,
                  point: u.clone().applyMatrix4(this.matrixWorld),
                  index: n,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
          }
        } else
          n.isGeometry &&
            console.error(
              "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
      }
      updateMorphTargets() {
        const e = this.geometry;
        if (e.isBufferGeometry) {
          const t = e.morphAttributes,
            n = Object.keys(t);
          if (n.length > 0) {
            const e = t[n[0]];
            if (void 0 !== e) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
              }
            }
          }
        } else {
          const t = e.morphTargets;
          void 0 !== t &&
            t.length > 0 &&
            console.error(
              "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
    }
    xc.prototype.isLine = !0;
    const bc = new sr(),
      wc = new sr();
    class _c extends xc {
      constructor(e, t) {
        super(e, t), (this.type = "LineSegments");
      }
      computeLineDistances() {
        const e = this.geometry;
        if (e.isBufferGeometry)
          if (null === e.index) {
            const t = e.attributes.position,
              n = [];
            for (let e = 0, r = t.count; e < r; e += 2)
              bc.fromBufferAttribute(t, e),
                wc.fromBufferAttribute(t, e + 1),
                (n[e] = 0 === e ? 0 : n[e - 1]),
                (n[e + 1] = n[e] + bc.distanceTo(wc));
            e.setAttribute("lineDistance", new Gi(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
        else
          e.isGeometry &&
            console.error(
              "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        return this;
      }
    }
    _c.prototype.isLineSegments = !0;
    class Mc extends xc {
      constructor(e, t) {
        super(e, t), (this.type = "LineLoop");
      }
    }
    Mc.prototype.isLineLoop = !0;
    class Sc extends _i {
      constructor(e) {
        super(),
          (this.type = "PointsMaterial"),
          (this.color = new Pi(16777215)),
          (this.map = null),
          (this.alphaMap = null),
          (this.size = 1),
          (this.sizeAttenuation = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.alphaMap = e.alphaMap),
          (this.size = e.size),
          (this.sizeAttenuation = e.sizeAttenuation),
          this
        );
      }
    }
    Sc.prototype.isPointsMaterial = !0;
    const Tc = new Nr(),
      Ec = new Fr(),
      Ac = new Pr(),
      Cc = new sr();
    class Pc extends ci {
      constructor(e = new eo(), t = new Sc()) {
        super(),
          (this.type = "Points"),
          (this.geometry = e),
          (this.material = t),
          this.updateMorphTargets();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.material = e.material),
          (this.geometry = e.geometry),
          this
        );
      }
      raycast(e, t) {
        const n = this.geometry,
          r = this.matrixWorld,
          i = e.params.Points.threshold,
          o = n.drawRange;
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          Ac.copy(n.boundingSphere),
          Ac.applyMatrix4(r),
          (Ac.radius += i),
          !1 === e.ray.intersectsSphere(Ac))
        )
          return;
        Tc.copy(r).invert(), Ec.copy(e.ray).applyMatrix4(Tc);
        const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          s = a * a;
        if (n.isBufferGeometry) {
          const i = n.index,
            a = n.attributes.position;
          if (null !== i) {
            for (
              let n = Math.max(0, o.start),
                l = Math.min(i.count, o.start + o.count);
              n < l;
              n++
            ) {
              const o = i.getX(n);
              Cc.fromBufferAttribute(a, o), Lc(Cc, o, s, r, e, t, this);
            }
          } else {
            for (
              let n = Math.max(0, o.start),
                i = Math.min(a.count, o.start + o.count);
              n < i;
              n++
            )
              Cc.fromBufferAttribute(a, n), Lc(Cc, n, s, r, e, t, this);
          }
        } else
          console.error(
            "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
      }
      updateMorphTargets() {
        const e = this.geometry;
        if (e.isBufferGeometry) {
          const t = e.morphAttributes,
            n = Object.keys(t);
          if (n.length > 0) {
            const e = t[n[0]];
            if (void 0 !== e) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
              }
            }
          }
        } else {
          const t = e.morphTargets;
          void 0 !== t &&
            t.length > 0 &&
            console.error(
              "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
            );
        }
      }
    }

    function Lc(e, t, n, r, i, o, a) {
      const s = Ec.distanceSqToPoint(e);
      if (s < n) {
        const n = new sr();
        Ec.closestPointToPoint(e, n), n.applyMatrix4(r);
        const l = i.ray.origin.distanceTo(n);
        if (l < i.near || l > i.far) return;
        o.push({
          distance: l,
          distanceToRay: Math.sqrt(s),
          point: n,
          index: t,
          face: null,
          object: a,
        });
      }
    }
    Pc.prototype.isPoints = !0;
    class Rc extends er {
      constructor(e, t, n, r, i, o, a, s, l) {
        super(e, t, n, r, i, o, a, s, l),
          (this.format = void 0 !== a ? a : Fe),
          (this.minFilter = void 0 !== o ? o : xe),
          (this.magFilter = void 0 !== i ? i : xe),
          (this.generateMipmaps = !1);
        const c = this;
        "requestVideoFrameCallback" in e &&
          e.requestVideoFrameCallback(function t() {
            (c.needsUpdate = !0), e.requestVideoFrameCallback(t);
          });
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const e = this.image;
        !1 === "requestVideoFrameCallback" in e &&
          e.readyState >= e.HAVE_CURRENT_DATA &&
          (this.needsUpdate = !0);
      }
    }
    Rc.prototype.isVideoTexture = !0;
    class Ic extends er {
      constructor(e, t, n, r, i, o, a, s, l, c, u, h) {
        super(null, o, a, s, l, c, r, i, u, h),
          (this.image = {
            width: t,
            height: n,
          }),
          (this.mipmaps = e),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
    }
    Ic.prototype.isCompressedTexture = !0;
    class kc extends er {
      constructor(e, t, n, r, i, o, a, s, l) {
        super(e, t, n, r, i, o, a, s, l), (this.needsUpdate = !0);
      }
    }
    kc.prototype.isCanvasTexture = !0;
    class Dc extends er {
      constructor(e, t, n, r, i, o, a, s, l, c) {
        if ((c = void 0 !== c ? c : Ge) !== Ge && c !== Ve)
          throw new Error(
            "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
          );
        void 0 === n && c === Ge && (n = Ae),
          void 0 === n && c === Ve && (n = Oe),
          super(null, r, i, o, a, s, c, n, l),
          (this.image = {
            width: e,
            height: t,
          }),
          (this.magFilter = void 0 !== a ? a : fe),
          (this.minFilter = void 0 !== s ? s : fe),
          (this.flipY = !1),
          (this.generateMipmaps = !1);
      }
    }
    Dc.prototype.isDepthTexture = !0;
    class Oc extends eo {
      constructor(e = 1, t = 8, n = 0, r = 2 * Math.PI) {
        super(),
          (this.type = "CircleGeometry"),
          (this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r,
          }),
          (t = Math.max(3, t));
        const i = [],
          o = [],
          a = [],
          s = [],
          l = new sr(),
          c = new Yn();
        o.push(0, 0, 0), a.push(0, 0, 1), s.push(0.5, 0.5);
        for (let i = 0, u = 3; i <= t; i++, u += 3) {
          const h = n + (i / t) * r;
          (l.x = e * Math.cos(h)),
            (l.y = e * Math.sin(h)),
            o.push(l.x, l.y, l.z),
            a.push(0, 0, 1),
            (c.x = (o[u] / e + 1) / 2),
            (c.y = (o[u + 1] / e + 1) / 2),
            s.push(c.x, c.y);
        }
        for (let e = 1; e <= t; e++) i.push(e, e + 1, 0);
        this.setIndex(i),
          this.setAttribute("position", new Gi(o, 3)),
          this.setAttribute("normal", new Gi(a, 3)),
          this.setAttribute("uv", new Gi(s, 2));
      }
      static fromJSON(e) {
        return new Oc(e.radius, e.segments, e.thetaStart, e.thetaLength);
      }
    }
    class Bc extends eo {
      constructor(
        e = 1,
        t = 1,
        n = 1,
        r = 8,
        i = 1,
        o = !1,
        a = 0,
        s = 2 * Math.PI
      ) {
        super(),
          (this.type = "CylinderGeometry"),
          (this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s,
          });
        const l = this;
        (r = Math.floor(r)), (i = Math.floor(i));
        const c = [],
          u = [],
          h = [],
          d = [];
        let p = 0;
        const f = [],
          m = n / 2;
        let g = 0;

        function v(n) {
          const i = p,
            o = new Yn(),
            f = new sr();
          let v = 0;
          const y = !0 === n ? e : t,
            x = !0 === n ? 1 : -1;
          for (let e = 1; e <= r; e++)
            u.push(0, m * x, 0), h.push(0, x, 0), d.push(0.5, 0.5), p++;
          const b = p;
          for (let e = 0; e <= r; e++) {
            const t = (e / r) * s + a,
              n = Math.cos(t),
              i = Math.sin(t);
            (f.x = y * i),
              (f.y = m * x),
              (f.z = y * n),
              u.push(f.x, f.y, f.z),
              h.push(0, x, 0),
              (o.x = 0.5 * n + 0.5),
              (o.y = 0.5 * i * x + 0.5),
              d.push(o.x, o.y),
              p++;
          }
          for (let e = 0; e < r; e++) {
            const t = i + e,
              r = b + e;
            !0 === n ? c.push(r, r + 1, t) : c.push(r + 1, r, t), (v += 3);
          }
          l.addGroup(g, v, !0 === n ? 1 : 2), (g += v);
        }
        !(function () {
          const o = new sr(),
            v = new sr();
          let y = 0;
          const x = (t - e) / n;
          for (let l = 0; l <= i; l++) {
            const c = [],
              g = l / i,
              y = g * (t - e) + e;
            for (let e = 0; e <= r; e++) {
              const t = e / r,
                i = t * s + a,
                l = Math.sin(i),
                f = Math.cos(i);
              (v.x = y * l),
                (v.y = -g * n + m),
                (v.z = y * f),
                u.push(v.x, v.y, v.z),
                o.set(l, x, f).normalize(),
                h.push(o.x, o.y, o.z),
                d.push(t, 1 - g),
                c.push(p++);
            }
            f.push(c);
          }
          for (let e = 0; e < r; e++)
            for (let t = 0; t < i; t++) {
              const n = f[t][e],
                r = f[t + 1][e],
                i = f[t + 1][e + 1],
                o = f[t][e + 1];
              c.push(n, r, o), c.push(r, i, o), (y += 6);
            }
          l.addGroup(g, y, 0), (g += y);
        })(),
          !1 === o && (e > 0 && v(!0), t > 0 && v(!1)),
          this.setIndex(c),
          this.setAttribute("position", new Gi(u, 3)),
          this.setAttribute("normal", new Gi(h, 3)),
          this.setAttribute("uv", new Gi(d, 2));
      }
      static fromJSON(e) {
        return new Bc(
          e.radiusTop,
          e.radiusBottom,
          e.height,
          e.radialSegments,
          e.heightSegments,
          e.openEnded,
          e.thetaStart,
          e.thetaLength
        );
      }
    }
    class Fc extends Bc {
      constructor(e = 1, t = 1, n = 8, r = 1, i = !1, o = 0, a = 2 * Math.PI) {
        super(0, e, t, n, r, i, o, a),
          (this.type = "ConeGeometry"),
          (this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: o,
            thetaLength: a,
          });
      }
      static fromJSON(e) {
        return new Fc(
          e.radius,
          e.height,
          e.radialSegments,
          e.heightSegments,
          e.openEnded,
          e.thetaStart,
          e.thetaLength
        );
      }
    }
    class Nc extends eo {
      constructor(e, t, n = 1, r = 0) {
        super(),
          (this.type = "PolyhedronGeometry"),
          (this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: r,
          });
        const i = [],
          o = [];

        function a(e, t, n, r) {
          const i = r + 1,
            o = [];
          for (let r = 0; r <= i; r++) {
            o[r] = [];
            const a = e.clone().lerp(n, r / i),
              s = t.clone().lerp(n, r / i),
              l = i - r;
            for (let e = 0; e <= l; e++)
              o[r][e] = 0 === e && r === i ? a : a.clone().lerp(s, e / l);
          }
          for (let e = 0; e < i; e++)
            for (let t = 0; t < 2 * (i - e) - 1; t++) {
              const n = Math.floor(t / 2);
              t % 2 == 0
                ? (s(o[e][n + 1]), s(o[e + 1][n]), s(o[e][n]))
                : (s(o[e][n + 1]), s(o[e + 1][n + 1]), s(o[e + 1][n]));
            }
        }

        function s(e) {
          i.push(e.x, e.y, e.z);
        }

        function l(t, n) {
          const r = 3 * t;
          (n.x = e[r + 0]), (n.y = e[r + 1]), (n.z = e[r + 2]);
        }

        function c(e, t, n, r) {
          r < 0 && 1 === e.x && (o[t] = e.x - 1),
            0 === n.x && 0 === n.z && (o[t] = r / 2 / Math.PI + 0.5);
        }

        function u(e) {
          return Math.atan2(e.z, -e.x);
        }
        !(function (e) {
          const n = new sr(),
            r = new sr(),
            i = new sr();
          for (let o = 0; o < t.length; o += 3)
            l(t[o + 0], n), l(t[o + 1], r), l(t[o + 2], i), a(n, r, i, e);
        })(r),
          (function (e) {
            const t = new sr();
            for (let n = 0; n < i.length; n += 3)
              (t.x = i[n + 0]),
                (t.y = i[n + 1]),
                (t.z = i[n + 2]),
                t.normalize().multiplyScalar(e),
                (i[n + 0] = t.x),
                (i[n + 1] = t.y),
                (i[n + 2] = t.z);
          })(n),
          (function () {
            const e = new sr();
            for (let n = 0; n < i.length; n += 3) {
              (e.x = i[n + 0]), (e.y = i[n + 1]), (e.z = i[n + 2]);
              const r = u(e) / 2 / Math.PI + 0.5,
                a =
                  ((t = e),
                  Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI +
                    0.5);
              o.push(r, 1 - a);
            }
            var t;
            (function () {
              const e = new sr(),
                t = new sr(),
                n = new sr(),
                r = new sr(),
                a = new Yn(),
                s = new Yn(),
                l = new Yn();
              for (let h = 0, d = 0; h < i.length; h += 9, d += 6) {
                e.set(i[h + 0], i[h + 1], i[h + 2]),
                  t.set(i[h + 3], i[h + 4], i[h + 5]),
                  n.set(i[h + 6], i[h + 7], i[h + 8]),
                  a.set(o[d + 0], o[d + 1]),
                  s.set(o[d + 2], o[d + 3]),
                  l.set(o[d + 4], o[d + 5]),
                  r.copy(e).add(t).add(n).divideScalar(3);
                const p = u(r);
                c(a, d + 0, e, p), c(s, d + 2, t, p), c(l, d + 4, n, p);
              }
            })(),
              (function () {
                for (let e = 0; e < o.length; e += 6) {
                  const t = o[e + 0],
                    n = o[e + 2],
                    r = o[e + 4],
                    i = Math.max(t, n, r),
                    a = Math.min(t, n, r);
                  i > 0.9 &&
                    a < 0.1 &&
                    (t < 0.2 && (o[e + 0] += 1),
                    n < 0.2 && (o[e + 2] += 1),
                    r < 0.2 && (o[e + 4] += 1));
                }
              })();
          })(),
          this.setAttribute("position", new Gi(i, 3)),
          this.setAttribute("normal", new Gi(i.slice(), 3)),
          this.setAttribute("uv", new Gi(o, 2)),
          0 === r ? this.computeVertexNormals() : this.normalizeNormals();
      }
      static fromJSON(e) {
        return new Nc(e.vertices, e.indices, e.radius, e.details);
      }
    }
    class Uc extends Nc {
      constructor(e = 1, t = 0) {
        const n = (1 + Math.sqrt(5)) / 2,
          r = 1 / n;
        super(
          [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -r,
            -n,
            0,
            -r,
            n,
            0,
            r,
            -n,
            0,
            r,
            n,
            -r,
            -n,
            0,
            -r,
            n,
            0,
            r,
            -n,
            0,
            r,
            n,
            0,
            -n,
            0,
            -r,
            n,
            0,
            -r,
            -n,
            0,
            r,
            n,
            0,
            r,
          ],
          [
            3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
            8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0,
            1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18,
            3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4,
            0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4,
            17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
          ],
          e,
          t
        ),
          (this.type = "DodecahedronGeometry"),
          (this.parameters = {
            radius: e,
            detail: t,
          });
      }
      static fromJSON(e) {
        return new Uc(e.radius, e.detail);
      }
    }
    const zc = new sr(),
      Hc = new sr(),
      Gc = new sr(),
      Vc = new bi();
    class jc extends eo {
      constructor(e, t) {
        if (
          (super(),
          (this.type = "EdgesGeometry"),
          (this.parameters = {
            thresholdAngle: t,
          }),
          (t = void 0 !== t ? t : 1),
          !0 === e.isGeometry)
        )
          return void console.error(
            "THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
        const n = Math.pow(10, 4),
          r = Math.cos(Un * t),
          i = e.getIndex(),
          o = e.getAttribute("position"),
          a = i ? i.count : o.count,
          s = [0, 0, 0],
          l = ["a", "b", "c"],
          c = new Array(3),
          u = {},
          h = [];
        for (let e = 0; e < a; e += 3) {
          i
            ? ((s[0] = i.getX(e)),
              (s[1] = i.getX(e + 1)),
              (s[2] = i.getX(e + 2)))
            : ((s[0] = e), (s[1] = e + 1), (s[2] = e + 2));
          const { a: t, b: a, c: d } = Vc;
          if (
            (t.fromBufferAttribute(o, s[0]),
            a.fromBufferAttribute(o, s[1]),
            d.fromBufferAttribute(o, s[2]),
            Vc.getNormal(Gc),
            (c[0] = `${Math.round(t.x * n)},${Math.round(t.y * n)},${Math.round(
              t.z * n
            )}`),
            (c[1] = `${Math.round(a.x * n)},${Math.round(a.y * n)},${Math.round(
              a.z * n
            )}`),
            (c[2] = `${Math.round(d.x * n)},${Math.round(d.y * n)},${Math.round(
              d.z * n
            )}`),
            c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
          )
            for (let e = 0; e < 3; e++) {
              const t = (e + 1) % 3,
                n = c[e],
                i = c[t],
                o = Vc[l[e]],
                a = Vc[l[t]],
                d = `${n}_${i}`,
                p = `${i}_${n}`;
              p in u && u[p]
                ? (Gc.dot(u[p].normal) <= r &&
                    (h.push(o.x, o.y, o.z), h.push(a.x, a.y, a.z)),
                  (u[p] = null))
                : d in u ||
                  (u[d] = {
                    index0: s[e],
                    index1: s[t],
                    normal: Gc.clone(),
                  });
            }
        }
        for (const e in u)
          if (u[e]) {
            const { index0: t, index1: n } = u[e];
            zc.fromBufferAttribute(o, t),
              Hc.fromBufferAttribute(o, n),
              h.push(zc.x, zc.y, zc.z),
              h.push(Hc.x, Hc.y, Hc.z);
          }
        this.setAttribute("position", new Gi(h, 3));
      }
    }
    class Wc {
      constructor() {
        (this.type = "Curve"), (this.arcLengthDivisions = 200);
      }
      getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }
      getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t);
      }
      getPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return t;
      }
      getSpacedPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
        return t;
      }
      getLength() {
        const e = this.getLengths();
        return e[e.length - 1];
      }
      getLengths(e = this.arcLengthDivisions) {
        if (
          this.cacheArcLengths &&
          this.cacheArcLengths.length === e + 1 &&
          !this.needsUpdate
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n,
          r = this.getPoint(0),
          i = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
          (n = this.getPoint(o / e)),
            (i += n.distanceTo(r)),
            t.push(i),
            (r = n);
        return (this.cacheArcLengths = t), t;
      }
      updateArcLengths() {
        (this.needsUpdate = !0), this.getLengths();
      }
      getUtoTmapping(e, t) {
        const n = this.getLengths();
        let r = 0;
        const i = n.length;
        let o;
        o = t || e * n[i - 1];
        let a,
          s = 0,
          l = i - 1;
        for (; s <= l; )
          if (((r = Math.floor(s + (l - s) / 2)), (a = n[r] - o), a < 0))
            s = r + 1;
          else {
            if (!(a > 0)) {
              l = r;
              break;
            }
            l = r - 1;
          }
        if (((r = l), n[r] === o)) return r / (i - 1);
        const c = n[r];
        return (r + (o - c) / (n[r + 1] - c)) / (i - 1);
      }
      getTangent(e, t) {
        let n = e - 1e-4,
          r = e + 1e-4;
        n < 0 && (n = 0), r > 1 && (r = 1);
        const i = this.getPoint(n),
          o = this.getPoint(r),
          a = t || (i.isVector2 ? new Yn() : new sr());
        return a.copy(o).sub(i).normalize(), a;
      }
      getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t);
      }
      computeFrenetFrames(e, t) {
        const n = new sr(),
          r = [],
          i = [],
          o = [],
          a = new sr(),
          s = new Nr();
        for (let t = 0; t <= e; t++) {
          const n = t / e;
          (r[t] = this.getTangentAt(n, new sr())), r[t].normalize();
        }
        (i[0] = new sr()), (o[0] = new sr());
        let l = Number.MAX_VALUE;
        const c = Math.abs(r[0].x),
          u = Math.abs(r[0].y),
          h = Math.abs(r[0].z);
        c <= l && ((l = c), n.set(1, 0, 0)),
          u <= l && ((l = u), n.set(0, 1, 0)),
          h <= l && n.set(0, 0, 1),
          a.crossVectors(r[0], n).normalize(),
          i[0].crossVectors(r[0], a),
          o[0].crossVectors(r[0], i[0]);
        for (let t = 1; t <= e; t++) {
          if (
            ((i[t] = i[t - 1].clone()),
            (o[t] = o[t - 1].clone()),
            a.crossVectors(r[t - 1], r[t]),
            a.length() > Number.EPSILON)
          ) {
            a.normalize();
            const e = Math.acos(Gn(r[t - 1].dot(r[t]), -1, 1));
            i[t].applyMatrix4(s.makeRotationAxis(a, e));
          }
          o[t].crossVectors(r[t], i[t]);
        }
        if (!0 === t) {
          let t = Math.acos(Gn(i[0].dot(i[e]), -1, 1));
          (t /= e), r[0].dot(a.crossVectors(i[0], i[e])) > 0 && (t = -t);
          for (let n = 1; n <= e; n++)
            i[n].applyMatrix4(s.makeRotationAxis(r[n], t * n)),
              o[n].crossVectors(r[n], i[n]);
        }
        return {
          tangents: r,
          normals: i,
          binormals: o,
        };
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.5,
            type: "Curve",
            generator: "Curve.toJSON",
          },
        };
        return (
          (e.arcLengthDivisions = this.arcLengthDivisions),
          (e.type = this.type),
          e
        );
      }
      fromJSON(e) {
        return (this.arcLengthDivisions = e.arcLengthDivisions), this;
      }
    }
    class qc extends Wc {
      constructor(
        e = 0,
        t = 0,
        n = 1,
        r = 1,
        i = 0,
        o = 2 * Math.PI,
        a = !1,
        s = 0
      ) {
        super(),
          (this.type = "EllipseCurve"),
          (this.aX = e),
          (this.aY = t),
          (this.xRadius = n),
          (this.yRadius = r),
          (this.aStartAngle = i),
          (this.aEndAngle = o),
          (this.aClockwise = a),
          (this.aRotation = s);
      }
      getPoint(e, t) {
        const n = t || new Yn(),
          r = 2 * Math.PI;
        let i = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(i) < Number.EPSILON;
        for (; i < 0; ) i += r;
        for (; i > r; ) i -= r;
        i < Number.EPSILON && (i = o ? 0 : r),
          !0 !== this.aClockwise || o || (i === r ? (i = -r) : (i -= r));
        const a = this.aStartAngle + e * i;
        let s = this.aX + this.xRadius * Math.cos(a),
          l = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
          const e = Math.cos(this.aRotation),
            t = Math.sin(this.aRotation),
            n = s - this.aX,
            r = l - this.aY;
          (s = n * e - r * t + this.aX), (l = n * t + r * e + this.aY);
        }
        return n.set(s, l);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.aX = e.aX),
          (this.aY = e.aY),
          (this.xRadius = e.xRadius),
          (this.yRadius = e.yRadius),
          (this.aStartAngle = e.aStartAngle),
          (this.aEndAngle = e.aEndAngle),
          (this.aClockwise = e.aClockwise),
          (this.aRotation = e.aRotation),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.aX = this.aX),
          (e.aY = this.aY),
          (e.xRadius = this.xRadius),
          (e.yRadius = this.yRadius),
          (e.aStartAngle = this.aStartAngle),
          (e.aEndAngle = this.aEndAngle),
          (e.aClockwise = this.aClockwise),
          (e.aRotation = this.aRotation),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          (this.aX = e.aX),
          (this.aY = e.aY),
          (this.xRadius = e.xRadius),
          (this.yRadius = e.yRadius),
          (this.aStartAngle = e.aStartAngle),
          (this.aEndAngle = e.aEndAngle),
          (this.aClockwise = e.aClockwise),
          (this.aRotation = e.aRotation),
          this
        );
      }
    }
    qc.prototype.isEllipseCurve = !0;
    class $c extends qc {
      constructor(e, t, n, r, i, o) {
        super(e, t, n, n, r, i, o), (this.type = "ArcCurve");
      }
    }

    function Xc() {
      let e = 0,
        t = 0,
        n = 0,
        r = 0;

      function i(i, o, a, s) {
        (e = i),
          (t = a),
          (n = -3 * i + 3 * o - 2 * a - s),
          (r = 2 * i - 2 * o + a + s);
      }
      return {
        initCatmullRom: function (e, t, n, r, o) {
          i(t, n, o * (n - e), o * (r - t));
        },
        initNonuniformCatmullRom: function (e, t, n, r, o, a, s) {
          let l = (t - e) / o - (n - e) / (o + a) + (n - t) / a,
            c = (n - t) / a - (r - t) / (a + s) + (r - n) / s;
          (l *= a), (c *= a), i(t, n, l, c);
        },
        calc: function (i) {
          const o = i * i;
          return e + t * i + n * o + r * (o * i);
        },
      };
    }
    $c.prototype.isArcCurve = !0;
    const Yc = new sr(),
      Jc = new Xc(),
      Zc = new Xc(),
      Kc = new Xc();
    class Qc extends Wc {
      constructor(e = [], t = !1, n = "centripetal", r = 0.5) {
        super(),
          (this.type = "CatmullRomCurve3"),
          (this.points = e),
          (this.closed = t),
          (this.curveType = n),
          (this.tension = r);
      }
      getPoint(e, t = new sr()) {
        const n = t,
          r = this.points,
          i = r.length,
          o = (i - (this.closed ? 0 : 1)) * e;
        let a,
          s,
          l = Math.floor(o),
          c = o - l;
        this.closed
          ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i)
          : 0 === c && l === i - 1 && ((l = i - 2), (c = 1)),
          this.closed || l > 0
            ? (a = r[(l - 1) % i])
            : (Yc.subVectors(r[0], r[1]).add(r[0]), (a = Yc));
        const u = r[l % i],
          h = r[(l + 1) % i];
        if (
          (this.closed || l + 2 < i
            ? (s = r[(l + 2) % i])
            : (Yc.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), (s = Yc)),
          "centripetal" === this.curveType || "chordal" === this.curveType)
        ) {
          const e = "chordal" === this.curveType ? 0.5 : 0.25;
          let t = Math.pow(a.distanceToSquared(u), e),
            n = Math.pow(u.distanceToSquared(h), e),
            r = Math.pow(h.distanceToSquared(s), e);
          n < 1e-4 && (n = 1),
            t < 1e-4 && (t = n),
            r < 1e-4 && (r = n),
            Jc.initNonuniformCatmullRom(a.x, u.x, h.x, s.x, t, n, r),
            Zc.initNonuniformCatmullRom(a.y, u.y, h.y, s.y, t, n, r),
            Kc.initNonuniformCatmullRom(a.z, u.z, h.z, s.z, t, n, r);
        } else
          "catmullrom" === this.curveType &&
            (Jc.initCatmullRom(a.x, u.x, h.x, s.x, this.tension),
            Zc.initCatmullRom(a.y, u.y, h.y, s.y, this.tension),
            Kc.initCatmullRom(a.z, u.z, h.z, s.z, this.tension));
        return n.set(Jc.calc(c), Zc.calc(c), Kc.calc(c)), n;
      }
      copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }
        return (
          (this.closed = e.closed),
          (this.curveType = e.curveType),
          (this.tension = e.tension),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }
        return (
          (e.closed = this.closed),
          (e.curveType = this.curveType),
          (e.tension = this.tension),
          e
        );
      }
      fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(new sr().fromArray(n));
        }
        return (
          (this.closed = e.closed),
          (this.curveType = e.curveType),
          (this.tension = e.tension),
          this
        );
      }
    }

    function eu(e, t, n, r, i) {
      const o = 0.5 * (r - t),
        a = 0.5 * (i - n),
        s = e * e;
      return (
        (2 * n - 2 * r + o + a) * (e * s) +
        (-3 * n + 3 * r - 2 * o - a) * s +
        o * e +
        n
      );
    }

    function tu(e, t, n, r) {
      return (
        (function (e, t) {
          const n = 1 - e;
          return n * n * t;
        })(e, t) +
        (function (e, t) {
          return 2 * (1 - e) * e * t;
        })(e, n) +
        (function (e, t) {
          return e * e * t;
        })(e, r)
      );
    }

    function nu(e, t, n, r, i) {
      return (
        (function (e, t) {
          const n = 1 - e;
          return n * n * n * t;
        })(e, t) +
        (function (e, t) {
          const n = 1 - e;
          return 3 * n * n * e * t;
        })(e, n) +
        (function (e, t) {
          return 3 * (1 - e) * e * e * t;
        })(e, r) +
        (function (e, t) {
          return e * e * e * t;
        })(e, i)
      );
    }
    Qc.prototype.isCatmullRomCurve3 = !0;
    class ru extends Wc {
      constructor(e = new Yn(), t = new Yn(), n = new Yn(), r = new Yn()) {
        super(),
          (this.type = "CubicBezierCurve"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n),
          (this.v3 = r);
      }
      getPoint(e, t = new Yn()) {
        const n = t,
          r = this.v0,
          i = this.v1,
          o = this.v2,
          a = this.v3;
        return n.set(nu(e, r.x, i.x, o.x, a.x), nu(e, r.y, i.y, o.y, a.y)), n;
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this.v3.copy(e.v3),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          (e.v3 = this.v3.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this.v3.fromArray(e.v3),
          this
        );
      }
    }
    ru.prototype.isCubicBezierCurve = !0;
    class iu extends Wc {
      constructor(e = new sr(), t = new sr(), n = new sr(), r = new sr()) {
        super(),
          (this.type = "CubicBezierCurve3"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n),
          (this.v3 = r);
      }
      getPoint(e, t = new sr()) {
        const n = t,
          r = this.v0,
          i = this.v1,
          o = this.v2,
          a = this.v3;
        return (
          n.set(
            nu(e, r.x, i.x, o.x, a.x),
            nu(e, r.y, i.y, o.y, a.y),
            nu(e, r.z, i.z, o.z, a.z)
          ),
          n
        );
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this.v3.copy(e.v3),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          (e.v3 = this.v3.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this.v3.fromArray(e.v3),
          this
        );
      }
    }
    iu.prototype.isCubicBezierCurve3 = !0;
    class ou extends Wc {
      constructor(e = new Yn(), t = new Yn()) {
        super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
      }
      getPoint(e, t = new Yn()) {
        const n = t;
        return (
          1 === e
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
          n
        );
      }
      getPointAt(e, t) {
        return this.getPoint(e, t);
      }
      getTangent(e, t) {
        const n = t || new Yn();
        return n.copy(this.v2).sub(this.v1).normalize(), n;
      }
      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    ou.prototype.isLineCurve = !0;
    class au extends Wc {
      constructor(e = new sr(), t = new sr()) {
        super(),
          (this.type = "LineCurve3"),
          (this.isLineCurve3 = !0),
          (this.v1 = e),
          (this.v2 = t);
      }
      getPoint(e, t = new sr()) {
        const n = t;
        return (
          1 === e
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
          n
        );
      }
      getPointAt(e, t) {
        return this.getPoint(e, t);
      }
      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    class su extends Wc {
      constructor(e = new Yn(), t = new Yn(), n = new Yn()) {
        super(),
          (this.type = "QuadraticBezierCurve"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n);
      }
      getPoint(e, t = new Yn()) {
        const n = t,
          r = this.v0,
          i = this.v1,
          o = this.v2;
        return n.set(tu(e, r.x, i.x, o.x), tu(e, r.y, i.y, o.y)), n;
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    su.prototype.isQuadraticBezierCurve = !0;
    class lu extends Wc {
      constructor(e = new sr(), t = new sr(), n = new sr()) {
        super(),
          (this.type = "QuadraticBezierCurve3"),
          (this.v0 = e),
          (this.v1 = t),
          (this.v2 = n);
      }
      getPoint(e, t = new sr()) {
        const n = t,
          r = this.v0,
          i = this.v1,
          o = this.v2;
        return (
          n.set(
            tu(e, r.x, i.x, o.x),
            tu(e, r.y, i.y, o.y),
            tu(e, r.z, i.z, o.z)
          ),
          n
        );
      }
      copy(e) {
        return (
          super.copy(e),
          this.v0.copy(e.v0),
          this.v1.copy(e.v1),
          this.v2.copy(e.v2),
          this
        );
      }
      toJSON() {
        const e = super.toJSON();
        return (
          (e.v0 = this.v0.toArray()),
          (e.v1 = this.v1.toArray()),
          (e.v2 = this.v2.toArray()),
          e
        );
      }
      fromJSON(e) {
        return (
          super.fromJSON(e),
          this.v0.fromArray(e.v0),
          this.v1.fromArray(e.v1),
          this.v2.fromArray(e.v2),
          this
        );
      }
    }
    lu.prototype.isQuadraticBezierCurve3 = !0;
    class cu extends Wc {
      constructor(e = []) {
        super(), (this.type = "SplineCurve"), (this.points = e);
      }
      getPoint(e, t = new Yn()) {
        const n = t,
          r = this.points,
          i = (r.length - 1) * e,
          o = Math.floor(i),
          a = i - o,
          s = r[0 === o ? o : o - 1],
          l = r[o],
          c = r[o > r.length - 2 ? r.length - 1 : o + 1],
          u = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return n.set(eu(a, s.x, l.x, c.x, u.x), eu(a, s.y, l.y, c.y, u.y)), n;
      }
      copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
          const n = e.points[t];
          this.points.push(new Yn().fromArray(n));
        }
        return this;
      }
    }
    cu.prototype.isSplineCurve = !0;
    var uu = Object.freeze({
      __proto__: null,
      ArcCurve: $c,
      CatmullRomCurve3: Qc,
      CubicBezierCurve: ru,
      CubicBezierCurve3: iu,
      EllipseCurve: qc,
      LineCurve: ou,
      LineCurve3: au,
      QuadraticBezierCurve: su,
      QuadraticBezierCurve3: lu,
      SplineCurve: cu,
    });
    const hu = function (e, t, n = 2) {
      const r = t && t.length,
        i = r ? t[0] * n : e.length;
      let o = du(e, 0, i, n, !0);
      const a = [];
      if (!o || o.next === o.prev) return a;
      let s, l, c, u, h, d, p;
      if (
        (r &&
          (o = (function (e, t, n, r) {
            const i = [];
            let o, a, s, l, c;
            for (o = 0, a = t.length; o < a; o++)
              (s = t[o] * r),
                (l = o < a - 1 ? t[o + 1] * r : e.length),
                (c = du(e, s, l, r, !1)),
                c === c.next && (c.steiner = !0),
                i.push(Mu(c));
            for (i.sort(xu), o = 0; o < i.length; o++)
              bu(i[o], n), (n = pu(n, n.next));
            return n;
          })(e, t, o, n)),
        e.length > 80 * n)
      ) {
        (s = c = e[0]), (l = u = e[1]);
        for (let t = n; t < i; t += n)
          (h = e[t]),
            (d = e[t + 1]),
            h < s && (s = h),
            d < l && (l = d),
            h > c && (c = h),
            d > u && (u = d);
        (p = Math.max(c - s, u - l)), (p = 0 !== p ? 1 / p : 0);
      }
      return fu(o, a, n, s, l, p), a;
    };

    function du(e, t, n, r, i) {
      let o, a;
      if (
        i ===
        (function (e, t, n, r) {
          let i = 0;
          for (let o = t, a = n - r; o < n; o += r)
            (i += (e[a] - e[o]) * (e[o + 1] + e[a + 1])), (a = o);
          return i;
        })(e, t, n, r) >
          0
      )
        for (o = t; o < n; o += r) a = ku(o, e[o], e[o + 1], a);
      else for (o = n - r; o >= t; o -= r) a = ku(o, e[o], e[o + 1], a);
      return a && Au(a, a.next) && (Du(a), (a = a.next)), a;
    }

    function pu(e, t) {
      if (!e) return e;
      t || (t = e);
      let n,
        r = e;
      do {
        if (
          ((n = !1),
          r.steiner || (!Au(r, r.next) && 0 !== Eu(r.prev, r, r.next)))
        )
          r = r.next;
        else {
          if ((Du(r), (r = t = r.prev), r === r.next)) break;
          n = !0;
        }
      } while (n || r !== t);
      return t;
    }

    function fu(e, t, n, r, i, o, a) {
      if (!e) return;
      !a &&
        o &&
        (function (e, t, n, r) {
          let i = e;
          do {
            null === i.z && (i.z = _u(i.x, i.y, t, n, r)),
              (i.prevZ = i.prev),
              (i.nextZ = i.next),
              (i = i.next);
          } while (i !== e);
          (i.prevZ.nextZ = null),
            (i.prevZ = null),
            (function (e) {
              let t,
                n,
                r,
                i,
                o,
                a,
                s,
                l,
                c = 1;
              do {
                for (n = e, e = null, o = null, a = 0; n; ) {
                  for (
                    a++, r = n, s = 0, t = 0;
                    t < c && (s++, (r = r.nextZ), r);
                    t++
                  );
                  for (l = c; s > 0 || (l > 0 && r); )
                    0 !== s && (0 === l || !r || n.z <= r.z)
                      ? ((i = n), (n = n.nextZ), s--)
                      : ((i = r), (r = r.nextZ), l--),
                      o ? (o.nextZ = i) : (e = i),
                      (i.prevZ = o),
                      (o = i);
                  n = r;
                }
                (o.nextZ = null), (c *= 2);
              } while (a > 1);
            })(i);
        })(e, r, i, o);
      let s,
        l,
        c = e;
      for (; e.prev !== e.next; )
        if (((s = e.prev), (l = e.next), o ? gu(e, r, i, o) : mu(e)))
          t.push(s.i / n),
            t.push(e.i / n),
            t.push(l.i / n),
            Du(e),
            (e = l.next),
            (c = l.next);
        else if ((e = l) === c) {
          a
            ? 1 === a
              ? fu((e = vu(pu(e), t, n)), t, n, r, i, o, 2)
              : 2 === a && yu(e, t, n, r, i, o)
            : fu(pu(e), t, n, r, i, o, 1);
          break;
        }
    }

    function mu(e) {
      const t = e.prev,
        n = e,
        r = e.next;
      if (Eu(t, n, r) >= 0) return !1;
      let i = e.next.next;
      for (; i !== e.prev; ) {
        if (
          Su(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
          Eu(i.prev, i, i.next) >= 0
        )
          return !1;
        i = i.next;
      }
      return !0;
    }

    function gu(e, t, n, r) {
      const i = e.prev,
        o = e,
        a = e.next;
      if (Eu(i, o, a) >= 0) return !1;
      const s = i.x < o.x ? (i.x < a.x ? i.x : a.x) : o.x < a.x ? o.x : a.x,
        l = i.y < o.y ? (i.y < a.y ? i.y : a.y) : o.y < a.y ? o.y : a.y,
        c = i.x > o.x ? (i.x > a.x ? i.x : a.x) : o.x > a.x ? o.x : a.x,
        u = i.y > o.y ? (i.y > a.y ? i.y : a.y) : o.y > a.y ? o.y : a.y,
        h = _u(s, l, t, n, r),
        d = _u(c, u, t, n, r);
      let p = e.prevZ,
        f = e.nextZ;
      for (; p && p.z >= h && f && f.z <= d; ) {
        if (
          p !== e.prev &&
          p !== e.next &&
          Su(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) &&
          Eu(p.prev, p, p.next) >= 0
        )
          return !1;
        if (
          ((p = p.prevZ),
          f !== e.prev &&
            f !== e.next &&
            Su(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
            Eu(f.prev, f, f.next) >= 0)
        )
          return !1;
        f = f.nextZ;
      }
      for (; p && p.z >= h; ) {
        if (
          p !== e.prev &&
          p !== e.next &&
          Su(i.x, i.y, o.x, o.y, a.x, a.y, p.x, p.y) &&
          Eu(p.prev, p, p.next) >= 0
        )
          return !1;
        p = p.prevZ;
      }
      for (; f && f.z <= d; ) {
        if (
          f !== e.prev &&
          f !== e.next &&
          Su(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) &&
          Eu(f.prev, f, f.next) >= 0
        )
          return !1;
        f = f.nextZ;
      }
      return !0;
    }

    function vu(e, t, n) {
      let r = e;
      do {
        const i = r.prev,
          o = r.next.next;
        !Au(i, o) &&
          Cu(i, r, r.next, o) &&
          Ru(i, o) &&
          Ru(o, i) &&
          (t.push(i.i / n),
          t.push(r.i / n),
          t.push(o.i / n),
          Du(r),
          Du(r.next),
          (r = e = o)),
          (r = r.next);
      } while (r !== e);
      return pu(r);
    }

    function yu(e, t, n, r, i, o) {
      let a = e;
      do {
        let e = a.next.next;
        for (; e !== a.prev; ) {
          if (a.i !== e.i && Tu(a, e)) {
            let s = Iu(a, e);
            return (
              (a = pu(a, a.next)),
              (s = pu(s, s.next)),
              fu(a, t, n, r, i, o),
              void fu(s, t, n, r, i, o)
            );
          }
          e = e.next;
        }
        a = a.next;
      } while (a !== e);
    }

    function xu(e, t) {
      return e.x - t.x;
    }

    function bu(e, t) {
      if (
        (t = (function (e, t) {
          let n = t;
          const r = e.x,
            i = e.y;
          let o,
            a = -1 / 0;
          do {
            if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
              const e = n.x + ((i - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
              if (e <= r && e > a) {
                if (((a = e), e === r)) {
                  if (i === n.y) return n;
                  if (i === n.next.y) return n.next;
                }
                o = n.x < n.next.x ? n : n.next;
              }
            }
            n = n.next;
          } while (n !== t);
          if (!o) return null;
          if (r === a) return o;
          const s = o,
            l = o.x,
            c = o.y;
          let u,
            h = 1 / 0;
          n = o;
          do {
            r >= n.x &&
              n.x >= l &&
              r !== n.x &&
              Su(i < c ? r : a, i, l, c, i < c ? a : r, i, n.x, n.y) &&
              ((u = Math.abs(i - n.y) / (r - n.x)),
              Ru(n, e) &&
                (u < h ||
                  (u === h && (n.x > o.x || (n.x === o.x && wu(o, n))))) &&
                ((o = n), (h = u))),
              (n = n.next);
          } while (n !== s);
          return o;
        })(e, t))
      ) {
        const n = Iu(t, e);
        pu(t, t.next), pu(n, n.next);
      }
    }

    function wu(e, t) {
      return Eu(e.prev, e, t.prev) < 0 && Eu(t.next, e, e.next) < 0;
    }

    function _u(e, t, n, r, i) {
      return (
        (e =
          1431655765 &
          ((e =
            858993459 &
            ((e =
              252645135 &
              ((e = 16711935 & ((e = 32767 * (e - n) * i) | (e << 8))) |
                (e << 4))) |
              (e << 2))) |
            (e << 1))) |
        ((t =
          1431655765 &
          ((t =
            858993459 &
            ((t =
              252645135 &
              ((t = 16711935 & ((t = 32767 * (t - r) * i) | (t << 8))) |
                (t << 4))) |
              (t << 2))) |
            (t << 1))) <<
          1)
      );
    }

    function Mu(e) {
      let t = e,
        n = e;
      do {
        (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
      } while (t !== e);
      return n;
    }

    function Su(e, t, n, r, i, o, a, s) {
      return (
        (i - a) * (t - s) - (e - a) * (o - s) >= 0 &&
        (e - a) * (r - s) - (n - a) * (t - s) >= 0 &&
        (n - a) * (o - s) - (i - a) * (r - s) >= 0
      );
    }

    function Tu(e, t) {
      return (
        e.next.i !== t.i &&
        e.prev.i !== t.i &&
        !(function (e, t) {
          let n = e;
          do {
            if (
              n.i !== e.i &&
              n.next.i !== e.i &&
              n.i !== t.i &&
              n.next.i !== t.i &&
              Cu(n, n.next, e, t)
            )
              return !0;
            n = n.next;
          } while (n !== e);
          return !1;
        })(e, t) &&
        ((Ru(e, t) &&
          Ru(t, e) &&
          (function (e, t) {
            let n = e,
              r = !1;
            const i = (e.x + t.x) / 2,
              o = (e.y + t.y) / 2;
            do {
              n.y > o != n.next.y > o &&
                n.next.y !== n.y &&
                i < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
                (r = !r),
                (n = n.next);
            } while (n !== e);
            return r;
          })(e, t) &&
          (Eu(e.prev, e, t.prev) || Eu(e, t.prev, t))) ||
          (Au(e, t) && Eu(e.prev, e, e.next) > 0 && Eu(t.prev, t, t.next) > 0))
      );
    }

    function Eu(e, t, n) {
      return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
    }

    function Au(e, t) {
      return e.x === t.x && e.y === t.y;
    }

    function Cu(e, t, n, r) {
      const i = Lu(Eu(e, t, n)),
        o = Lu(Eu(e, t, r)),
        a = Lu(Eu(n, r, e)),
        s = Lu(Eu(n, r, t));
      return (
        (i !== o && a !== s) ||
        !(0 !== i || !Pu(e, n, t)) ||
        !(0 !== o || !Pu(e, r, t)) ||
        !(0 !== a || !Pu(n, e, r)) ||
        !(0 !== s || !Pu(n, t, r))
      );
    }

    function Pu(e, t, n) {
      return (
        t.x <= Math.max(e.x, n.x) &&
        t.x >= Math.min(e.x, n.x) &&
        t.y <= Math.max(e.y, n.y) &&
        t.y >= Math.min(e.y, n.y)
      );
    }

    function Lu(e) {
      return e > 0 ? 1 : e < 0 ? -1 : 0;
    }

    function Ru(e, t) {
      return Eu(e.prev, e, e.next) < 0
        ? Eu(e, t, e.next) >= 0 && Eu(e, e.prev, t) >= 0
        : Eu(e, t, e.prev) < 0 || Eu(e, e.next, t) < 0;
    }

    function Iu(e, t) {
      const n = new Ou(e.i, e.x, e.y),
        r = new Ou(t.i, t.x, t.y),
        i = e.next,
        o = t.prev;
      return (
        (e.next = t),
        (t.prev = e),
        (n.next = i),
        (i.prev = n),
        (r.next = n),
        (n.prev = r),
        (o.next = r),
        (r.prev = o),
        r
      );
    }

    function ku(e, t, n, r) {
      const i = new Ou(e, t, n);
      return (
        r
          ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
          : ((i.prev = i), (i.next = i)),
        i
      );
    }

    function Du(e) {
      (e.next.prev = e.prev),
        (e.prev.next = e.next),
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ);
    }

    function Ou(e, t, n) {
      (this.i = e),
        (this.x = t),
        (this.y = n),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
    }
    class Bu {
      static area(e) {
        const t = e.length;
        let n = 0;
        for (let r = t - 1, i = 0; i < t; r = i++)
          n += e[r].x * e[i].y - e[i].x * e[r].y;
        return 0.5 * n;
      }
      static isClockWise(e) {
        return Bu.area(e) < 0;
      }
      static triangulateShape(e, t) {
        const n = [],
          r = [],
          i = [];
        Fu(e), Nu(n, e);
        let o = e.length;
        t.forEach(Fu);
        for (let e = 0; e < t.length; e++)
          r.push(o), (o += t[e].length), Nu(n, t[e]);
        const a = hu(n, r);
        for (let e = 0; e < a.length; e += 3) i.push(a.slice(e, e + 3));
        return i;
      }
    }

    function Fu(e) {
      const t = e.length;
      t > 2 && e[t - 1].equals(e[0]) && e.pop();
    }

    function Nu(e, t) {
      for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
    }
    class Uu extends eo {
      constructor(e, t) {
        super(),
          (this.type = "ExtrudeGeometry"),
          (this.parameters = {
            shapes: e,
            options: t,
          }),
          (e = Array.isArray(e) ? e : [e]);
        const n = this,
          r = [],
          i = [];
        for (let t = 0, n = e.length; t < n; t++) {
          o(e[t]);
        }

        function o(e) {
          const o = [],
            a = void 0 !== t.curveSegments ? t.curveSegments : 12,
            s = void 0 !== t.steps ? t.steps : 1;
          let l = void 0 !== t.depth ? t.depth : 100,
            c = void 0 === t.bevelEnabled || t.bevelEnabled,
            u = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
            h = void 0 !== t.bevelSize ? t.bevelSize : u - 2,
            d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
            p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
          const f = t.extrudePath,
            m = void 0 !== t.UVGenerator ? t.UVGenerator : zu;
          void 0 !== t.amount &&
            (console.warn(
              "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
            ),
            (l = t.amount));
          let g,
            v,
            y,
            x,
            b,
            w = !1;
          f &&
            ((g = f.getSpacedPoints(s)),
            (w = !0),
            (c = !1),
            (v = f.computeFrenetFrames(s, !1)),
            (y = new sr()),
            (x = new sr()),
            (b = new sr())),
            c || ((p = 0), (u = 0), (h = 0), (d = 0));
          const _ = e.extractPoints(a);
          let M = _.shape;
          const S = _.holes;
          if (!Bu.isClockWise(M)) {
            M = M.reverse();
            for (let e = 0, t = S.length; e < t; e++) {
              const t = S[e];
              Bu.isClockWise(t) && (S[e] = t.reverse());
            }
          }
          const T = Bu.triangulateShape(M, S),
            E = M;
          for (let e = 0, t = S.length; e < t; e++) {
            const t = S[e];
            M = M.concat(t);
          }

          function A(e, t, n) {
            return (
              t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
              t.clone().multiplyScalar(n).add(e)
            );
          }
          const C = M.length,
            P = T.length;

          function L(e, t, n) {
            let r, i, o;
            const a = e.x - t.x,
              s = e.y - t.y,
              l = n.x - e.x,
              c = n.y - e.y,
              u = a * a + s * s,
              h = a * c - s * l;
            if (Math.abs(h) > Number.EPSILON) {
              const h = Math.sqrt(u),
                d = Math.sqrt(l * l + c * c),
                p = t.x - s / h,
                f = t.y + a / h,
                m =
                  ((n.x - c / d - p) * c - (n.y + l / d - f) * l) /
                  (a * c - s * l);
              (r = p + a * m - e.x), (i = f + s * m - e.y);
              const g = r * r + i * i;
              if (g <= 2) return new Yn(r, i);
              o = Math.sqrt(g / 2);
            } else {
              let e = !1;
              a > Number.EPSILON
                ? l > Number.EPSILON && (e = !0)
                : a < -Number.EPSILON
                ? l < -Number.EPSILON && (e = !0)
                : Math.sign(s) === Math.sign(c) && (e = !0),
                e
                  ? ((r = -s), (i = a), (o = Math.sqrt(u)))
                  : ((r = a), (i = s), (o = Math.sqrt(u / 2)));
            }
            return new Yn(r / o, i / o);
          }
          const R = [];
          for (
            let e = 0, t = E.length, n = t - 1, r = e + 1;
            e < t;
            e++, n++, r++
          )
            n === t && (n = 0),
              r === t && (r = 0),
              (R[e] = L(E[e], E[n], E[r]));
          const I = [];
          let k,
            D = R.concat();
          for (let e = 0, t = S.length; e < t; e++) {
            const t = S[e];
            k = [];
            for (
              let e = 0, n = t.length, r = n - 1, i = e + 1;
              e < n;
              e++, r++, i++
            )
              r === n && (r = 0),
                i === n && (i = 0),
                (k[e] = L(t[e], t[r], t[i]));
            I.push(k), (D = D.concat(k));
          }
          for (let e = 0; e < p; e++) {
            const t = e / p,
              n = u * Math.cos((t * Math.PI) / 2),
              r = h * Math.sin((t * Math.PI) / 2) + d;
            for (let e = 0, t = E.length; e < t; e++) {
              const t = A(E[e], R[e], r);
              F(t.x, t.y, -n);
            }
            for (let e = 0, t = S.length; e < t; e++) {
              const t = S[e];
              k = I[e];
              for (let e = 0, i = t.length; e < i; e++) {
                const i = A(t[e], k[e], r);
                F(i.x, i.y, -n);
              }
            }
          }
          const O = h + d;
          for (let e = 0; e < C; e++) {
            const t = c ? A(M[e], D[e], O) : M[e];
            w
              ? (x.copy(v.normals[0]).multiplyScalar(t.x),
                y.copy(v.binormals[0]).multiplyScalar(t.y),
                b.copy(g[0]).add(x).add(y),
                F(b.x, b.y, b.z))
              : F(t.x, t.y, 0);
          }
          for (let e = 1; e <= s; e++)
            for (let t = 0; t < C; t++) {
              const n = c ? A(M[t], D[t], O) : M[t];
              w
                ? (x.copy(v.normals[e]).multiplyScalar(n.x),
                  y.copy(v.binormals[e]).multiplyScalar(n.y),
                  b.copy(g[e]).add(x).add(y),
                  F(b.x, b.y, b.z))
                : F(n.x, n.y, (l / s) * e);
            }
          for (let e = p - 1; e >= 0; e--) {
            const t = e / p,
              n = u * Math.cos((t * Math.PI) / 2),
              r = h * Math.sin((t * Math.PI) / 2) + d;
            for (let e = 0, t = E.length; e < t; e++) {
              const t = A(E[e], R[e], r);
              F(t.x, t.y, l + n);
            }
            for (let e = 0, t = S.length; e < t; e++) {
              const t = S[e];
              k = I[e];
              for (let e = 0, i = t.length; e < i; e++) {
                const i = A(t[e], k[e], r);
                w
                  ? F(i.x, i.y + g[s - 1].y, g[s - 1].x + n)
                  : F(i.x, i.y, l + n);
              }
            }
          }

          function B(e, t) {
            let n = e.length;
            for (; --n >= 0; ) {
              const r = n;
              let i = n - 1;
              i < 0 && (i = e.length - 1);
              for (let e = 0, n = s + 2 * p; e < n; e++) {
                const n = C * e,
                  o = C * (e + 1);
                U(t + r + n, t + i + n, t + i + o, t + r + o);
              }
            }
          }

          function F(e, t, n) {
            o.push(e), o.push(t), o.push(n);
          }

          function N(e, t, i) {
            z(e), z(t), z(i);
            const o = r.length / 3,
              a = m.generateTopUV(n, r, o - 3, o - 2, o - 1);
            H(a[0]), H(a[1]), H(a[2]);
          }

          function U(e, t, i, o) {
            z(e), z(t), z(o), z(t), z(i), z(o);
            const a = r.length / 3,
              s = m.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
            H(s[0]), H(s[1]), H(s[3]), H(s[1]), H(s[2]), H(s[3]);
          }

          function z(e) {
            r.push(o[3 * e + 0]), r.push(o[3 * e + 1]), r.push(o[3 * e + 2]);
          }

          function H(e) {
            i.push(e.x), i.push(e.y);
          }
          !(function () {
            const e = r.length / 3;
            if (c) {
              let e = 0,
                t = C * e;
              for (let e = 0; e < P; e++) {
                const n = T[e];
                N(n[2] + t, n[1] + t, n[0] + t);
              }
              (e = s + 2 * p), (t = C * e);
              for (let e = 0; e < P; e++) {
                const n = T[e];
                N(n[0] + t, n[1] + t, n[2] + t);
              }
            } else {
              for (let e = 0; e < P; e++) {
                const t = T[e];
                N(t[2], t[1], t[0]);
              }
              for (let e = 0; e < P; e++) {
                const t = T[e];
                N(t[0] + C * s, t[1] + C * s, t[2] + C * s);
              }
            }
            n.addGroup(e, r.length / 3 - e, 0);
          })(),
            (function () {
              const e = r.length / 3;
              let t = 0;
              B(E, t), (t += E.length);
              for (let e = 0, n = S.length; e < n; e++) {
                const n = S[e];
                B(n, t), (t += n.length);
              }
              n.addGroup(e, r.length / 3 - e, 1);
            })();
        }
        this.setAttribute("position", new Gi(r, 3)),
          this.setAttribute("uv", new Gi(i, 2)),
          this.computeVertexNormals();
      }
      toJSON() {
        const e = super.toJSON();
        return (function (e, t, n) {
          if (((n.shapes = []), Array.isArray(e)))
            for (let t = 0, r = e.length; t < r; t++) {
              const r = e[t];
              n.shapes.push(r.uuid);
            }
          else n.shapes.push(e.uuid);
          void 0 !== t.extrudePath &&
            (n.options.extrudePath = t.extrudePath.toJSON());
          return n;
        })(this.parameters.shapes, this.parameters.options, e);
      }
      static fromJSON(e, t) {
        const n = [];
        for (let r = 0, i = e.shapes.length; r < i; r++) {
          const i = t[e.shapes[r]];
          n.push(i);
        }
        const r = e.options.extrudePath;
        return (
          void 0 !== r &&
            (e.options.extrudePath = new uu[r.type]().fromJSON(r)),
          new Uu(n, e.options)
        );
      }
    }
    const zu = {
      generateTopUV: function (e, t, n, r, i) {
        const o = t[3 * n],
          a = t[3 * n + 1],
          s = t[3 * r],
          l = t[3 * r + 1],
          c = t[3 * i],
          u = t[3 * i + 1];
        return [new Yn(o, a), new Yn(s, l), new Yn(c, u)];
      },
      generateSideWallUV: function (e, t, n, r, i, o) {
        const a = t[3 * n],
          s = t[3 * n + 1],
          l = t[3 * n + 2],
          c = t[3 * r],
          u = t[3 * r + 1],
          h = t[3 * r + 2],
          d = t[3 * i],
          p = t[3 * i + 1],
          f = t[3 * i + 2],
          m = t[3 * o],
          g = t[3 * o + 1],
          v = t[3 * o + 2];
        return Math.abs(s - u) < Math.abs(a - c)
          ? [
              new Yn(a, 1 - l),
              new Yn(c, 1 - h),
              new Yn(d, 1 - f),
              new Yn(m, 1 - v),
            ]
          : [
              new Yn(s, 1 - l),
              new Yn(u, 1 - h),
              new Yn(p, 1 - f),
              new Yn(g, 1 - v),
            ];
      },
    };
    class Hu extends Nc {
      constructor(e = 1, t = 0) {
        const n = (1 + Math.sqrt(5)) / 2;
        super(
          [
            -1,
            n,
            0,
            1,
            n,
            0,
            -1,
            -n,
            0,
            1,
            -n,
            0,
            0,
            -1,
            n,
            0,
            1,
            n,
            0,
            -1,
            -n,
            0,
            1,
            -n,
            n,
            0,
            -1,
            n,
            0,
            1,
            -n,
            0,
            -1,
            -n,
            0,
            1,
          ],
          [
            0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
            11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
            8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
          ],
          e,
          t
        ),
          (this.type = "IcosahedronGeometry"),
          (this.parameters = {
            radius: e,
            detail: t,
          });
      }
      static fromJSON(e) {
        return new Hu(e.radius, e.detail);
      }
    }
    class Gu extends eo {
      constructor(e, t = 12, n = 0, r = 2 * Math.PI) {
        super(),
          (this.type = "LatheGeometry"),
          (this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r,
          }),
          (t = Math.floor(t)),
          (r = Gn(r, 0, 2 * Math.PI));
        const i = [],
          o = [],
          a = [],
          s = 1 / t,
          l = new sr(),
          c = new Yn();
        for (let i = 0; i <= t; i++) {
          const u = n + i * s * r,
            h = Math.sin(u),
            d = Math.cos(u);
          for (let n = 0; n <= e.length - 1; n++)
            (l.x = e[n].x * h),
              (l.y = e[n].y),
              (l.z = e[n].x * d),
              o.push(l.x, l.y, l.z),
              (c.x = i / t),
              (c.y = n / (e.length - 1)),
              a.push(c.x, c.y);
        }
        for (let n = 0; n < t; n++)
          for (let t = 0; t < e.length - 1; t++) {
            const r = t + n * e.length,
              o = r,
              a = r + e.length,
              s = r + e.length + 1,
              l = r + 1;
            i.push(o, a, l), i.push(a, s, l);
          }
        if (
          (this.setIndex(i),
          this.setAttribute("position", new Gi(o, 3)),
          this.setAttribute("uv", new Gi(a, 2)),
          this.computeVertexNormals(),
          r === 2 * Math.PI)
        ) {
          const n = this.attributes.normal.array,
            r = new sr(),
            i = new sr(),
            o = new sr(),
            a = t * e.length * 3;
          for (let t = 0, s = 0; t < e.length; t++, s += 3)
            (r.x = n[s + 0]),
              (r.y = n[s + 1]),
              (r.z = n[s + 2]),
              (i.x = n[a + s + 0]),
              (i.y = n[a + s + 1]),
              (i.z = n[a + s + 2]),
              o.addVectors(r, i).normalize(),
              (n[s + 0] = n[a + s + 0] = o.x),
              (n[s + 1] = n[a + s + 1] = o.y),
              (n[s + 2] = n[a + s + 2] = o.z);
        }
      }
      static fromJSON(e) {
        return new Gu(e.points, e.segments, e.phiStart, e.phiLength);
      }
    }
    class Vu extends Nc {
      constructor(e = 1, t = 0) {
        super(
          [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
          [
            0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4,
            2,
          ],
          e,
          t
        ),
          (this.type = "OctahedronGeometry"),
          (this.parameters = {
            radius: e,
            detail: t,
          });
      }
      static fromJSON(e) {
        return new Vu(e.radius, e.detail);
      }
    }
    class ju extends eo {
      constructor(e, t, n) {
        super(),
          (this.type = "ParametricGeometry"),
          (this.parameters = {
            func: e,
            slices: t,
            stacks: n,
          });
        const r = [],
          i = [],
          o = [],
          a = [],
          s = 1e-5,
          l = new sr(),
          c = new sr(),
          u = new sr(),
          h = new sr(),
          d = new sr();
        e.length < 3 &&
          console.error(
            "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
          );
        const p = t + 1;
        for (let r = 0; r <= n; r++) {
          const p = r / n;
          for (let n = 0; n <= t; n++) {
            const r = n / t;
            e(r, p, c),
              i.push(c.x, c.y, c.z),
              r - s >= 0
                ? (e(r - s, p, u), h.subVectors(c, u))
                : (e(r + s, p, u), h.subVectors(u, c)),
              p - s >= 0
                ? (e(r, p - s, u), d.subVectors(c, u))
                : (e(r, p + s, u), d.subVectors(u, c)),
              l.crossVectors(h, d).normalize(),
              o.push(l.x, l.y, l.z),
              a.push(r, p);
          }
        }
        for (let e = 0; e < n; e++)
          for (let n = 0; n < t; n++) {
            const t = e * p + n,
              i = e * p + n + 1,
              o = (e + 1) * p + n + 1,
              a = (e + 1) * p + n;
            r.push(t, i, a), r.push(i, o, a);
          }
        this.setIndex(r),
          this.setAttribute("position", new Gi(i, 3)),
          this.setAttribute("normal", new Gi(o, 3)),
          this.setAttribute("uv", new Gi(a, 2));
      }
    }
    class Wu extends eo {
      constructor(e = 0.5, t = 1, n = 8, r = 1, i = 0, o = 2 * Math.PI) {
        super(),
          (this.type = "RingGeometry"),
          (this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: o,
          }),
          (n = Math.max(3, n));
        const a = [],
          s = [],
          l = [],
          c = [];
        let u = e;
        const h = (t - e) / (r = Math.max(1, r)),
          d = new sr(),
          p = new Yn();
        for (let e = 0; e <= r; e++) {
          for (let e = 0; e <= n; e++) {
            const r = i + (e / n) * o;
            (d.x = u * Math.cos(r)),
              (d.y = u * Math.sin(r)),
              s.push(d.x, d.y, d.z),
              l.push(0, 0, 1),
              (p.x = (d.x / t + 1) / 2),
              (p.y = (d.y / t + 1) / 2),
              c.push(p.x, p.y);
          }
          u += h;
        }
        for (let e = 0; e < r; e++) {
          const t = e * (n + 1);
          for (let e = 0; e < n; e++) {
            const r = e + t,
              i = r,
              o = r + n + 1,
              s = r + n + 2,
              l = r + 1;
            a.push(i, o, l), a.push(o, s, l);
          }
        }
        this.setIndex(a),
          this.setAttribute("position", new Gi(s, 3)),
          this.setAttribute("normal", new Gi(l, 3)),
          this.setAttribute("uv", new Gi(c, 2));
      }
      static fromJSON(e) {
        return new Wu(
          e.innerRadius,
          e.outerRadius,
          e.thetaSegments,
          e.phiSegments,
          e.thetaStart,
          e.thetaLength
        );
      }
    }
    class qu extends eo {
      constructor(e, t = 12) {
        super(),
          (this.type = "ShapeGeometry"),
          (this.parameters = {
            shapes: e,
            curveSegments: t,
          });
        const n = [],
          r = [],
          i = [],
          o = [];
        let a = 0,
          s = 0;
        if (!1 === Array.isArray(e)) l(e);
        else
          for (let t = 0; t < e.length; t++)
            l(e[t]), this.addGroup(a, s, t), (a += s), (s = 0);

        function l(e) {
          const a = r.length / 3,
            l = e.extractPoints(t);
          let c = l.shape;
          const u = l.holes;
          !1 === Bu.isClockWise(c) && (c = c.reverse());
          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e];
            !0 === Bu.isClockWise(t) && (u[e] = t.reverse());
          }
          const h = Bu.triangulateShape(c, u);
          for (let e = 0, t = u.length; e < t; e++) {
            const t = u[e];
            c = c.concat(t);
          }
          for (let e = 0, t = c.length; e < t; e++) {
            const t = c[e];
            r.push(t.x, t.y, 0), i.push(0, 0, 1), o.push(t.x, t.y);
          }
          for (let e = 0, t = h.length; e < t; e++) {
            const t = h[e],
              r = t[0] + a,
              i = t[1] + a,
              o = t[2] + a;
            n.push(r, i, o), (s += 3);
          }
        }
        this.setIndex(n),
          this.setAttribute("position", new Gi(r, 3)),
          this.setAttribute("normal", new Gi(i, 3)),
          this.setAttribute("uv", new Gi(o, 2));
      }
      toJSON() {
        const e = super.toJSON();
        return (function (e, t) {
          if (((t.shapes = []), Array.isArray(e)))
            for (let n = 0, r = e.length; n < r; n++) {
              const r = e[n];
              t.shapes.push(r.uuid);
            }
          else t.shapes.push(e.uuid);
          return t;
        })(this.parameters.shapes, e);
      }
      static fromJSON(e, t) {
        const n = [];
        for (let r = 0, i = e.shapes.length; r < i; r++) {
          const i = t[e.shapes[r]];
          n.push(i);
        }
        return new qu(n, e.curveSegments);
      }
    }
    class $u extends eo {
      constructor(
        e = 1,
        t = 32,
        n = 16,
        r = 0,
        i = 2 * Math.PI,
        o = 0,
        a = Math.PI
      ) {
        super(),
          (this.type = "SphereGeometry"),
          (this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a,
          }),
          (t = Math.max(3, Math.floor(t))),
          (n = Math.max(2, Math.floor(n)));
        const s = Math.min(o + a, Math.PI);
        let l = 0;
        const c = [],
          u = new sr(),
          h = new sr(),
          d = [],
          p = [],
          f = [],
          m = [];
        for (let d = 0; d <= n; d++) {
          const g = [],
            v = d / n;
          let y = 0;
          0 == d && 0 == o
            ? (y = 0.5 / t)
            : d == n && s == Math.PI && (y = -0.5 / t);
          for (let n = 0; n <= t; n++) {
            const s = n / t;
            (u.x = -e * Math.cos(r + s * i) * Math.sin(o + v * a)),
              (u.y = e * Math.cos(o + v * a)),
              (u.z = e * Math.sin(r + s * i) * Math.sin(o + v * a)),
              p.push(u.x, u.y, u.z),
              h.copy(u).normalize(),
              f.push(h.x, h.y, h.z),
              m.push(s + y, 1 - v),
              g.push(l++);
          }
          c.push(g);
        }
        for (let e = 0; e < n; e++)
          for (let r = 0; r < t; r++) {
            const t = c[e][r + 1],
              i = c[e][r],
              a = c[e + 1][r],
              l = c[e + 1][r + 1];
            (0 !== e || o > 0) && d.push(t, i, l),
              (e !== n - 1 || s < Math.PI) && d.push(i, a, l);
          }
        this.setIndex(d),
          this.setAttribute("position", new Gi(p, 3)),
          this.setAttribute("normal", new Gi(f, 3)),
          this.setAttribute("uv", new Gi(m, 2));
      }
      static fromJSON(e) {
        return new $u(
          e.radius,
          e.widthSegments,
          e.heightSegments,
          e.phiStart,
          e.phiLength,
          e.thetaStart,
          e.thetaLength
        );
      }
    }
    class Xu extends Nc {
      constructor(e = 1, t = 0) {
        super(
          [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
          [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
          e,
          t
        ),
          (this.type = "TetrahedronGeometry"),
          (this.parameters = {
            radius: e,
            detail: t,
          });
      }
      static fromJSON(e) {
        return new Xu(e.radius, e.detail);
      }
    }
    class Yu extends Uu {
      constructor(e, t = {}) {
        const n = t.font;
        if (!n || !n.isFont)
          return (
            console.error(
              "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
            ),
            new eo()
          );
        const r = n.generateShapes(e, t.size);
        (t.depth = void 0 !== t.height ? t.height : 50),
          void 0 === t.bevelThickness && (t.bevelThickness = 10),
          void 0 === t.bevelSize && (t.bevelSize = 8),
          void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
          super(r, t),
          (this.type = "TextGeometry");
      }
    }
    class Ju extends eo {
      constructor(e = 1, t = 0.4, n = 8, r = 6, i = 2 * Math.PI) {
        super(),
          (this.type = "TorusGeometry"),
          (this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: r,
            arc: i,
          }),
          (n = Math.floor(n)),
          (r = Math.floor(r));
        const o = [],
          a = [],
          s = [],
          l = [],
          c = new sr(),
          u = new sr(),
          h = new sr();
        for (let o = 0; o <= n; o++)
          for (let d = 0; d <= r; d++) {
            const p = (d / r) * i,
              f = (o / n) * Math.PI * 2;
            (u.x = (e + t * Math.cos(f)) * Math.cos(p)),
              (u.y = (e + t * Math.cos(f)) * Math.sin(p)),
              (u.z = t * Math.sin(f)),
              a.push(u.x, u.y, u.z),
              (c.x = e * Math.cos(p)),
              (c.y = e * Math.sin(p)),
              h.subVectors(u, c).normalize(),
              s.push(h.x, h.y, h.z),
              l.push(d / r),
              l.push(o / n);
          }
        for (let e = 1; e <= n; e++)
          for (let t = 1; t <= r; t++) {
            const n = (r + 1) * e + t - 1,
              i = (r + 1) * (e - 1) + t - 1,
              a = (r + 1) * (e - 1) + t,
              s = (r + 1) * e + t;
            o.push(n, i, s), o.push(i, a, s);
          }
        this.setIndex(o),
          this.setAttribute("position", new Gi(a, 3)),
          this.setAttribute("normal", new Gi(s, 3)),
          this.setAttribute("uv", new Gi(l, 2));
      }
      static fromJSON(e) {
        return new Ju(
          e.radius,
          e.tube,
          e.radialSegments,
          e.tubularSegments,
          e.arc
        );
      }
    }
    class Zu extends eo {
      constructor(e = 1, t = 0.4, n = 64, r = 8, i = 2, o = 3) {
        super(),
          (this.type = "TorusKnotGeometry"),
          (this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: o,
          }),
          (n = Math.floor(n)),
          (r = Math.floor(r));
        const a = [],
          s = [],
          l = [],
          c = [],
          u = new sr(),
          h = new sr(),
          d = new sr(),
          p = new sr(),
          f = new sr(),
          m = new sr(),
          g = new sr();
        for (let a = 0; a <= n; ++a) {
          const y = (a / n) * i * Math.PI * 2;
          v(y, i, o, e, d),
            v(y + 0.01, i, o, e, p),
            m.subVectors(p, d),
            g.addVectors(p, d),
            f.crossVectors(m, g),
            g.crossVectors(f, m),
            f.normalize(),
            g.normalize();
          for (let e = 0; e <= r; ++e) {
            const i = (e / r) * Math.PI * 2,
              o = -t * Math.cos(i),
              p = t * Math.sin(i);
            (u.x = d.x + (o * g.x + p * f.x)),
              (u.y = d.y + (o * g.y + p * f.y)),
              (u.z = d.z + (o * g.z + p * f.z)),
              s.push(u.x, u.y, u.z),
              h.subVectors(u, d).normalize(),
              l.push(h.x, h.y, h.z),
              c.push(a / n),
              c.push(e / r);
          }
        }
        for (let e = 1; e <= n; e++)
          for (let t = 1; t <= r; t++) {
            const n = (r + 1) * (e - 1) + (t - 1),
              i = (r + 1) * e + (t - 1),
              o = (r + 1) * e + t,
              s = (r + 1) * (e - 1) + t;
            a.push(n, i, s), a.push(i, o, s);
          }

        function v(e, t, n, r, i) {
          const o = Math.cos(e),
            a = Math.sin(e),
            s = (n / t) * e,
            l = Math.cos(s);
          (i.x = r * (2 + l) * 0.5 * o),
            (i.y = r * (2 + l) * a * 0.5),
            (i.z = r * Math.sin(s) * 0.5);
        }
        this.setIndex(a),
          this.setAttribute("position", new Gi(s, 3)),
          this.setAttribute("normal", new Gi(l, 3)),
          this.setAttribute("uv", new Gi(c, 2));
      }
      static fromJSON(e) {
        return new Zu(
          e.radius,
          e.tube,
          e.tubularSegments,
          e.radialSegments,
          e.p,
          e.q
        );
      }
    }
    class Ku extends eo {
      constructor(e, t = 64, n = 1, r = 8, i = !1) {
        super(),
          (this.type = "TubeGeometry"),
          (this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: r,
            closed: i,
          });
        const o = e.computeFrenetFrames(t, i);
        (this.tangents = o.tangents),
          (this.normals = o.normals),
          (this.binormals = o.binormals);
        const a = new sr(),
          s = new sr(),
          l = new Yn();
        let c = new sr();
        const u = [],
          h = [],
          d = [],
          p = [];

        function f(i) {
          c = e.getPointAt(i / t, c);
          const l = o.normals[i],
            d = o.binormals[i];
          for (let e = 0; e <= r; e++) {
            const t = (e / r) * Math.PI * 2,
              i = Math.sin(t),
              o = -Math.cos(t);
            (s.x = o * l.x + i * d.x),
              (s.y = o * l.y + i * d.y),
              (s.z = o * l.z + i * d.z),
              s.normalize(),
              h.push(s.x, s.y, s.z),
              (a.x = c.x + n * s.x),
              (a.y = c.y + n * s.y),
              (a.z = c.z + n * s.z),
              u.push(a.x, a.y, a.z);
          }
        }
        !(function () {
          for (let e = 0; e < t; e++) f(e);
          f(!1 === i ? t : 0),
            (function () {
              for (let e = 0; e <= t; e++)
                for (let n = 0; n <= r; n++)
                  (l.x = e / t), (l.y = n / r), d.push(l.x, l.y);
            })(),
            (function () {
              for (let e = 1; e <= t; e++)
                for (let t = 1; t <= r; t++) {
                  const n = (r + 1) * (e - 1) + (t - 1),
                    i = (r + 1) * e + (t - 1),
                    o = (r + 1) * e + t,
                    a = (r + 1) * (e - 1) + t;
                  p.push(n, i, a), p.push(i, o, a);
                }
            })();
        })(),
          this.setIndex(p),
          this.setAttribute("position", new Gi(u, 3)),
          this.setAttribute("normal", new Gi(h, 3)),
          this.setAttribute("uv", new Gi(d, 2));
      }
      toJSON() {
        const e = super.toJSON();
        return (e.path = this.parameters.path.toJSON()), e;
      }
      static fromJSON(e) {
        return new Ku(
          new uu[e.path.type]().fromJSON(e.path),
          e.tubularSegments,
          e.radius,
          e.radialSegments,
          e.closed
        );
      }
    }
    class Qu extends eo {
      constructor(e) {
        if ((super(), (this.type = "WireframeGeometry"), !0 === e.isGeometry))
          return void console.error(
            "THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
          );
        const t = [],
          n = new Set(),
          r = new sr(),
          i = new sr();
        if (null !== e.index) {
          const o = e.attributes.position,
            a = e.index;
          let s = e.groups;
          0 === s.length &&
            (s = [
              {
                start: 0,
                count: a.count,
                materialIndex: 0,
              },
            ]);
          for (let e = 0, l = s.length; e < l; ++e) {
            const l = s[e],
              c = l.start;
            for (let e = c, s = c + l.count; e < s; e += 3)
              for (let s = 0; s < 3; s++) {
                const l = a.getX(e + s),
                  c = a.getX(e + ((s + 1) % 3));
                r.fromBufferAttribute(o, l),
                  i.fromBufferAttribute(o, c),
                  !0 === eh(r, i, n) &&
                    (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z));
              }
          }
        } else {
          const o = e.attributes.position;
          for (let e = 0, a = o.count / 3; e < a; e++)
            for (let a = 0; a < 3; a++) {
              const s = 3 * e + a,
                l = 3 * e + ((a + 1) % 3);
              r.fromBufferAttribute(o, s),
                i.fromBufferAttribute(o, l),
                !0 === eh(r, i, n) &&
                  (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z));
            }
        }
        this.setAttribute("position", new Gi(t, 3));
      }
    }

    function eh(e, t, n) {
      const r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
        i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
      return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r, i), !0);
    }
    var th = Object.freeze({
      __proto__: null,
      BoxGeometry: wo,
      BoxBufferGeometry: wo,
      CircleGeometry: Oc,
      CircleBufferGeometry: Oc,
      ConeGeometry: Fc,
      ConeBufferGeometry: Fc,
      CylinderGeometry: Bc,
      CylinderBufferGeometry: Bc,
      DodecahedronGeometry: Uc,
      DodecahedronBufferGeometry: Uc,
      EdgesGeometry: jc,
      ExtrudeGeometry: Uu,
      ExtrudeBufferGeometry: Uu,
      IcosahedronGeometry: Hu,
      IcosahedronBufferGeometry: Hu,
      LatheGeometry: Gu,
      LatheBufferGeometry: Gu,
      OctahedronGeometry: Vu,
      OctahedronBufferGeometry: Vu,
      ParametricGeometry: ju,
      ParametricBufferGeometry: ju,
      PlaneGeometry: zo,
      PlaneBufferGeometry: zo,
      PolyhedronGeometry: Nc,
      PolyhedronBufferGeometry: Nc,
      RingGeometry: Wu,
      RingBufferGeometry: Wu,
      ShapeGeometry: qu,
      ShapeBufferGeometry: qu,
      SphereGeometry: $u,
      SphereBufferGeometry: $u,
      TetrahedronGeometry: Xu,
      TetrahedronBufferGeometry: Xu,
      TextGeometry: Yu,
      TextBufferGeometry: Yu,
      TorusGeometry: Ju,
      TorusBufferGeometry: Ju,
      TorusKnotGeometry: Zu,
      TorusKnotBufferGeometry: Zu,
      TubeGeometry: Ku,
      TubeBufferGeometry: Ku,
      WireframeGeometry: Qu,
    });
    class nh extends _i {
      constructor(e) {
        super(),
          (this.type = "ShadowMaterial"),
          (this.color = new Pi(0)),
          (this.transparent = !0),
          this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.color.copy(e.color), this;
      }
    }
    nh.prototype.isShadowMaterial = !0;
    class rh extends _i {
      constructor(e) {
        super(),
          (this.defines = {
            STANDARD: "",
          }),
          (this.type = "MeshStandardMaterial"),
          (this.color = new Pi(16777215)),
          (this.roughness = 1),
          (this.metalness = 0),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new Pi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = sn),
          (this.normalScale = new Yn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.roughnessMap = null),
          (this.metalnessMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.envMapIntensity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = {
            STANDARD: "",
          }),
          this.color.copy(e.color),
          (this.roughness = e.roughness),
          (this.metalness = e.metalness),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.roughnessMap = e.roughnessMap),
          (this.metalnessMap = e.metalnessMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.envMapIntensity = e.envMapIntensity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }
    rh.prototype.isMeshStandardMaterial = !0;
    class ih extends rh {
      constructor(e) {
        super(),
          (this.defines = {
            STANDARD: "",
            PHYSICAL: "",
          }),
          (this.type = "MeshPhysicalMaterial"),
          (this.clearcoatMap = null),
          (this.clearcoatRoughness = 0),
          (this.clearcoatRoughnessMap = null),
          (this.clearcoatNormalScale = new Yn(1, 1)),
          (this.clearcoatNormalMap = null),
          (this.ior = 1.5),
          Object.defineProperty(this, "reflectivity", {
            get: function () {
              return Gn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
            },
            set: function (e) {
              this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
            },
          }),
          (this.sheenTint = new Pi(0)),
          (this.transmission = 0),
          (this.transmissionMap = null),
          (this.thickness = 0.01),
          (this.thicknessMap = null),
          (this.attenuationDistance = 0),
          (this.attenuationTint = new Pi(1, 1, 1)),
          (this.specularIntensity = 1),
          (this.specularIntensityMap = null),
          (this.specularTint = new Pi(1, 1, 1)),
          (this.specularTintMap = null),
          (this._clearcoat = 0),
          (this._transmission = 0),
          this.setValues(e);
      }
      get clearcoat() {
        return this._clearcoat;
      }
      set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
      }
      get transmission() {
        return this._transmission;
      }
      set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
          (this._transmission = e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = {
            STANDARD: "",
            PHYSICAL: "",
          }),
          (this.clearcoat = e.clearcoat),
          (this.clearcoatMap = e.clearcoatMap),
          (this.clearcoatRoughness = e.clearcoatRoughness),
          (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
          (this.clearcoatNormalMap = e.clearcoatNormalMap),
          this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
          (this.ior = e.ior),
          this.sheenTint.copy(e.sheenTint),
          (this.transmission = e.transmission),
          (this.transmissionMap = e.transmissionMap),
          (this.thickness = e.thickness),
          (this.thicknessMap = e.thicknessMap),
          (this.attenuationDistance = e.attenuationDistance),
          this.attenuationTint.copy(e.attenuationTint),
          (this.specularIntensity = e.specularIntensity),
          (this.specularIntensityMap = e.specularIntensityMap),
          this.specularTint.copy(e.specularTint),
          (this.specularTintMap = e.specularTintMap),
          this
        );
      }
    }
    ih.prototype.isMeshPhysicalMaterial = !0;
    class oh extends _i {
      constructor(e) {
        super(),
          (this.type = "MeshPhongMaterial"),
          (this.color = new Pi(16777215)),
          (this.specular = new Pi(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new Pi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = sn),
          (this.normalScale = new Yn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Y),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          this.specular.copy(e.specular),
          (this.shininess = e.shininess),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }
    oh.prototype.isMeshPhongMaterial = !0;
    class ah extends _i {
      constructor(e) {
        super(),
          (this.defines = {
            TOON: "",
          }),
          (this.type = "MeshToonMaterial"),
          (this.color = new Pi(16777215)),
          (this.map = null),
          (this.gradientMap = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new Pi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = sn),
          (this.normalScale = new Yn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.gradientMap = e.gradientMap),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.alphaMap = e.alphaMap),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          this
        );
      }
    }
    ah.prototype.isMeshToonMaterial = !0;
    class sh extends _i {
      constructor(e) {
        super(),
          (this.type = "MeshNormalMaterial"),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = sn),
          (this.normalScale = new Yn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }
    sh.prototype.isMeshNormalMaterial = !0;
    class lh extends _i {
      constructor(e) {
        super(),
          (this.type = "MeshLambertMaterial"),
          (this.color = new Pi(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new Pi(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = Y),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          this
        );
      }
    }
    lh.prototype.isMeshLambertMaterial = !0;
    class ch extends _i {
      constructor(e) {
        super(),
          (this.defines = {
            MATCAP: "",
          }),
          (this.type = "MeshMatcapMaterial"),
          (this.color = new Pi(16777215)),
          (this.matcap = null),
          (this.map = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = sn),
          (this.normalScale = new Yn(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.alphaMap = null),
          (this.flatShading = !1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.defines = {
            MATCAP: "",
          }),
          this.color.copy(e.color),
          (this.matcap = e.matcap),
          (this.map = e.map),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.alphaMap = e.alphaMap),
          (this.flatShading = e.flatShading),
          this
        );
      }
    }
    ch.prototype.isMeshMatcapMaterial = !0;
    class uh extends pc {
      constructor(e) {
        super(),
          (this.type = "LineDashedMaterial"),
          (this.scale = 1),
          (this.dashSize = 3),
          (this.gapSize = 1),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.scale = e.scale),
          (this.dashSize = e.dashSize),
          (this.gapSize = e.gapSize),
          this
        );
      }
    }
    uh.prototype.isLineDashedMaterial = !0;
    var hh = Object.freeze({
      __proto__: null,
      ShadowMaterial: nh,
      SpriteMaterial: Rl,
      RawShaderMaterial: Zo,
      ShaderMaterial: To,
      PointsMaterial: Sc,
      MeshPhysicalMaterial: ih,
      MeshStandardMaterial: rh,
      MeshPhongMaterial: oh,
      MeshToonMaterial: ah,
      MeshNormalMaterial: sh,
      MeshLambertMaterial: lh,
      MeshDepthMaterial: hl,
      MeshDistanceMaterial: dl,
      MeshBasicMaterial: Li,
      MeshMatcapMaterial: ch,
      LineDashedMaterial: uh,
      LineBasicMaterial: pc,
      Material: _i,
    });
    const dh = {
      arraySlice: function (e, t, n) {
        return dh.isTypedArray(e)
          ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length))
          : e.slice(t, n);
      },
      convertArray: function (e, t, n) {
        return !e || (!n && e.constructor === t)
          ? e
          : "number" == typeof t.BYTES_PER_ELEMENT
          ? new t(e)
          : Array.prototype.slice.call(e);
      },
      isTypedArray: function (e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      },
      getKeyframeOrder: function (e) {
        const t = e.length,
          n = new Array(t);
        for (let e = 0; e !== t; ++e) n[e] = e;
        return (
          n.sort(function (t, n) {
            return e[t] - e[n];
          }),
          n
        );
      },
      sortedArray: function (e, t, n) {
        const r = e.length,
          i = new e.constructor(r);
        for (let o = 0, a = 0; a !== r; ++o) {
          const r = n[o] * t;
          for (let n = 0; n !== t; ++n) i[a++] = e[r + n];
        }
        return i;
      },
      flattenJSON: function (e, t, n, r) {
        let i = 1,
          o = e[0];
        for (; void 0 !== o && void 0 === o[r]; ) o = e[i++];
        if (void 0 === o) return;
        let a = o[r];
        if (void 0 !== a)
          if (Array.isArray(a))
            do {
              (a = o[r]),
                void 0 !== a && (t.push(o.time), n.push.apply(n, a)),
                (o = e[i++]);
            } while (void 0 !== o);
          else if (void 0 !== a.toArray)
            do {
              (a = o[r]),
                void 0 !== a && (t.push(o.time), a.toArray(n, n.length)),
                (o = e[i++]);
            } while (void 0 !== o);
          else
            do {
              (a = o[r]),
                void 0 !== a && (t.push(o.time), n.push(a)),
                (o = e[i++]);
            } while (void 0 !== o);
      },
      subclip: function (e, t, n, r, i = 30) {
        const o = e.clone();
        o.name = t;
        const a = [];
        for (let e = 0; e < o.tracks.length; ++e) {
          const t = o.tracks[e],
            s = t.getValueSize(),
            l = [],
            c = [];
          for (let e = 0; e < t.times.length; ++e) {
            const o = t.times[e] * i;
            if (!(o < n || o >= r)) {
              l.push(t.times[e]);
              for (let n = 0; n < s; ++n) c.push(t.values[e * s + n]);
            }
          }
          0 !== l.length &&
            ((t.times = dh.convertArray(l, t.times.constructor)),
            (t.values = dh.convertArray(c, t.values.constructor)),
            a.push(t));
        }
        o.tracks = a;
        let s = 1 / 0;
        for (let e = 0; e < o.tracks.length; ++e)
          s > o.tracks[e].times[0] && (s = o.tracks[e].times[0]);
        for (let e = 0; e < o.tracks.length; ++e) o.tracks[e].shift(-1 * s);
        return o.resetDuration(), o;
      },
      makeClipAdditive: function (e, t = 0, n = e, r = 30) {
        r <= 0 && (r = 30);
        const i = n.tracks.length,
          o = t / r;
        for (let t = 0; t < i; ++t) {
          const r = n.tracks[t],
            i = r.ValueTypeName;
          if ("bool" === i || "string" === i) continue;
          const a = e.tracks.find(function (e) {
            return e.name === r.name && e.ValueTypeName === i;
          });
          if (void 0 === a) continue;
          let s = 0;
          const l = r.getValueSize();
          r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (s = l / 3);
          let c = 0;
          const u = a.getValueSize();
          a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
            (c = u / 3);
          const h = r.times.length - 1;
          let d;
          if (o <= r.times[0]) {
            const e = s,
              t = l - s;
            d = dh.arraySlice(r.values, e, t);
          } else if (o >= r.times[h]) {
            const e = h * l + s,
              t = e + l - s;
            d = dh.arraySlice(r.values, e, t);
          } else {
            const e = r.createInterpolant(),
              t = s,
              n = l - s;
            e.evaluate(o), (d = dh.arraySlice(e.resultBuffer, t, n));
          }
          if ("quaternion" === i) {
            new ar().fromArray(d).normalize().conjugate().toArray(d);
          }
          const p = a.times.length;
          for (let e = 0; e < p; ++e) {
            const t = e * u + c;
            if ("quaternion" === i)
              ar.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t);
            else {
              const e = u - 2 * c;
              for (let n = 0; n < e; ++n) a.values[t + n] -= d[n];
            }
          }
        }
        return (e.blendMode = qt), e;
      },
    };
    class ph {
      constructor(e, t, n, r) {
        (this.parameterPositions = e),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== r ? r : new t.constructor(n)),
          (this.sampleValues = t),
          (this.valueSize = n),
          (this.settings = null),
          (this.DefaultSettings_ = {});
      }
      evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex,
          r = t[n],
          i = t[n - 1];
        e: {
          t: {
            let o;
            n: {
              r: if (!(e < r)) {
                for (let o = n + 2; ; ) {
                  if (void 0 === r) {
                    if (e < i) break r;
                    return (
                      (n = t.length),
                      (this._cachedIndex = n),
                      this.afterEnd_(n - 1, e, i)
                    );
                  }
                  if (n === o) break;
                  if (((i = r), (r = t[++n]), e < r)) break t;
                }
                o = t.length;
                break n;
              }
              if (e >= i) break e;
              {
                const a = t[1];
                e < a && ((n = 2), (i = a));
                for (let o = n - 2; ; ) {
                  if (void 0 === i)
                    return (this._cachedIndex = 0), this.beforeStart_(0, e, r);
                  if (n === o) break;
                  if (((r = i), (i = t[--n - 1]), e >= i)) break t;
                }
                (o = n), (n = 0);
              }
            }
            for (; n < o; ) {
              const r = (n + o) >>> 1;
              e < t[r] ? (o = r) : (n = r + 1);
            }
            if (((r = t[n]), (i = t[n - 1]), void 0 === i))
              return (this._cachedIndex = 0), this.beforeStart_(0, e, r);
            if (void 0 === r)
              return (
                (n = t.length),
                (this._cachedIndex = n),
                this.afterEnd_(n - 1, i, e)
              );
          }
          (this._cachedIndex = n), this.intervalChanged_(n, i, r);
        }
        return this.interpolate_(n, i, e, r);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(e) {
        const t = this.resultBuffer,
          n = this.sampleValues,
          r = this.valueSize,
          i = e * r;
        for (let e = 0; e !== r; ++e) t[e] = n[i + e];
        return t;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {}
    }
    (ph.prototype.beforeStart_ = ph.prototype.copySampleValue_),
      (ph.prototype.afterEnd_ = ph.prototype.copySampleValue_);
    class fh extends ph {
      constructor(e, t, n, r) {
        super(e, t, n, r),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0),
          (this.DefaultSettings_ = {
            endingStart: Gt,
            endingEnd: Gt,
          });
      }
      intervalChanged_(e, t, n) {
        const r = this.parameterPositions;
        let i = e - 2,
          o = e + 1,
          a = r[i],
          s = r[o];
        if (void 0 === a)
          switch (this.getSettings_().endingStart) {
            case Vt:
              (i = e), (a = 2 * t - n);
              break;
            case jt:
              (i = r.length - 2), (a = t + r[i] - r[i + 1]);
              break;
            default:
              (i = e), (a = n);
          }
        if (void 0 === s)
          switch (this.getSettings_().endingEnd) {
            case Vt:
              (o = e), (s = 2 * n - t);
              break;
            case jt:
              (o = 1), (s = n + r[1] - r[0]);
              break;
            default:
              (o = e - 1), (s = t);
          }
        const l = 0.5 * (n - t),
          c = this.valueSize;
        (this._weightPrev = l / (t - a)),
          (this._weightNext = l / (s - n)),
          (this._offsetPrev = i * c),
          (this._offsetNext = o * c);
      }
      interpolate_(e, t, n, r) {
        const i = this.resultBuffer,
          o = this.sampleValues,
          a = this.valueSize,
          s = e * a,
          l = s - a,
          c = this._offsetPrev,
          u = this._offsetNext,
          h = this._weightPrev,
          d = this._weightNext,
          p = (n - t) / (r - t),
          f = p * p,
          m = f * p,
          g = -h * m + 2 * h * f - h * p,
          v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
          y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
          x = d * m - d * f;
        for (let e = 0; e !== a; ++e)
          i[e] = g * o[c + e] + v * o[l + e] + y * o[s + e] + x * o[u + e];
        return i;
      }
    }
    class mh extends ph {
      constructor(e, t, n, r) {
        super(e, t, n, r);
      }
      interpolate_(e, t, n, r) {
        const i = this.resultBuffer,
          o = this.sampleValues,
          a = this.valueSize,
          s = e * a,
          l = s - a,
          c = (n - t) / (r - t),
          u = 1 - c;
        for (let e = 0; e !== a; ++e) i[e] = o[l + e] * u + o[s + e] * c;
        return i;
      }
    }
    class gh extends ph {
      constructor(e, t, n, r) {
        super(e, t, n, r);
      }
      interpolate_(e) {
        return this.copySampleValue_(e - 1);
      }
    }
    class vh {
      constructor(e, t, n, r) {
        if (void 0 === e)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
          throw new Error(
            "THREE.KeyframeTrack: no keyframes in track named " + e
          );
        (this.name = e),
          (this.times = dh.convertArray(t, this.TimeBufferType)),
          (this.values = dh.convertArray(n, this.ValueBufferType)),
          this.setInterpolation(r || this.DefaultInterpolation);
      }
      static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON) n = t.toJSON(e);
        else {
          n = {
            name: e.name,
            times: dh.convertArray(e.times, Array),
            values: dh.convertArray(e.values, Array),
          };
          const t = e.getInterpolation();
          t !== e.DefaultInterpolation && (n.interpolation = t);
        }
        return (n.type = e.ValueTypeName), n;
      }
      InterpolantFactoryMethodDiscrete(e) {
        return new gh(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodLinear(e) {
        return new mh(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodSmooth(e) {
        return new fh(this.times, this.values, this.getValueSize(), e);
      }
      setInterpolation(e) {
        let t;
        switch (e) {
          case Ut:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
          case zt:
            t = this.InterpolantFactoryMethodLinear;
            break;
          case Ht:
            t = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === t) {
          const t =
            "unsupported interpolation for " +
            this.ValueTypeName +
            " keyframe track named " +
            this.name;
          if (void 0 === this.createInterpolant) {
            if (e === this.DefaultInterpolation) throw new Error(t);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", t), this;
        }
        return (this.createInterpolant = t), this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return Ut;
          case this.InterpolantFactoryMethodLinear:
            return zt;
          case this.InterpolantFactoryMethodSmooth:
            return Ht;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(e) {
        if (0 !== e) {
          const t = this.times;
          for (let n = 0, r = t.length; n !== r; ++n) t[n] += e;
        }
        return this;
      }
      scale(e) {
        if (1 !== e) {
          const t = this.times;
          for (let n = 0, r = t.length; n !== r; ++n) t[n] *= e;
        }
        return this;
      }
      trim(e, t) {
        const n = this.times,
          r = n.length;
        let i = 0,
          o = r - 1;
        for (; i !== r && n[i] < e; ) ++i;
        for (; -1 !== o && n[o] > t; ) --o;
        if ((++o, 0 !== i || o !== r)) {
          i >= o && ((o = Math.max(o, 1)), (i = o - 1));
          const e = this.getValueSize();
          (this.times = dh.arraySlice(n, i, o)),
            (this.values = dh.arraySlice(this.values, i * e, o * e));
        }
        return this;
      }
      validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) != 0 &&
          (console.error(
            "THREE.KeyframeTrack: Invalid value size in track.",
            this
          ),
          (e = !1));
        const n = this.times,
          r = this.values,
          i = n.length;
        0 === i &&
          (console.error("THREE.KeyframeTrack: Track is empty.", this),
          (e = !1));
        let o = null;
        for (let t = 0; t !== i; t++) {
          const r = n[t];
          if ("number" == typeof r && isNaN(r)) {
            console.error(
              "THREE.KeyframeTrack: Time is not a valid number.",
              this,
              t,
              r
            ),
              (e = !1);
            break;
          }
          if (null !== o && o > r) {
            console.error(
              "THREE.KeyframeTrack: Out of order keys.",
              this,
              t,
              r,
              o
            ),
              (e = !1);
            break;
          }
          o = r;
        }
        if (void 0 !== r && dh.isTypedArray(r))
          for (let t = 0, n = r.length; t !== n; ++t) {
            const n = r[t];
            if (isNaN(n)) {
              console.error(
                "THREE.KeyframeTrack: Value is not a valid number.",
                this,
                t,
                n
              ),
                (e = !1);
              break;
            }
          }
        return e;
      }
      optimize() {
        const e = dh.arraySlice(this.times),
          t = dh.arraySlice(this.values),
          n = this.getValueSize(),
          r = this.getInterpolation() === Ht,
          i = e.length - 1;
        let o = 1;
        for (let a = 1; a < i; ++a) {
          let i = !1;
          const s = e[a];
          if (s !== e[a + 1] && (1 !== a || s !== e[0]))
            if (r) i = !0;
            else {
              const e = a * n,
                r = e - n,
                o = e + n;
              for (let a = 0; a !== n; ++a) {
                const n = t[e + a];
                if (n !== t[r + a] || n !== t[o + a]) {
                  i = !0;
                  break;
                }
              }
            }
          if (i) {
            if (a !== o) {
              e[o] = e[a];
              const r = a * n,
                i = o * n;
              for (let e = 0; e !== n; ++e) t[i + e] = t[r + e];
            }
            ++o;
          }
        }
        if (i > 0) {
          e[o] = e[i];
          for (let e = i * n, r = o * n, a = 0; a !== n; ++a)
            t[r + a] = t[e + a];
          ++o;
        }
        return (
          o !== e.length
            ? ((this.times = dh.arraySlice(e, 0, o)),
              (this.values = dh.arraySlice(t, 0, o * n)))
            : ((this.times = e), (this.values = t)),
          this
        );
      }
      clone() {
        const e = dh.arraySlice(this.times, 0),
          t = dh.arraySlice(this.values, 0),
          n = new (0, this.constructor)(this.name, e, t);
        return (n.createInterpolant = this.createInterpolant), n;
      }
    }
    (vh.prototype.TimeBufferType = Float32Array),
      (vh.prototype.ValueBufferType = Float32Array),
      (vh.prototype.DefaultInterpolation = zt);
    class yh extends vh {}
    (yh.prototype.ValueTypeName = "bool"),
      (yh.prototype.ValueBufferType = Array),
      (yh.prototype.DefaultInterpolation = Ut),
      (yh.prototype.InterpolantFactoryMethodLinear = void 0),
      (yh.prototype.InterpolantFactoryMethodSmooth = void 0);
    class xh extends vh {}
    xh.prototype.ValueTypeName = "color";
    class bh extends vh {}
    bh.prototype.ValueTypeName = "number";
    class wh extends ph {
      constructor(e, t, n, r) {
        super(e, t, n, r);
      }
      interpolate_(e, t, n, r) {
        const i = this.resultBuffer,
          o = this.sampleValues,
          a = this.valueSize,
          s = (n - t) / (r - t);
        let l = e * a;
        for (let e = l + a; l !== e; l += 4)
          ar.slerpFlat(i, 0, o, l - a, o, l, s);
        return i;
      }
    }
    class _h extends vh {
      InterpolantFactoryMethodLinear(e) {
        return new wh(this.times, this.values, this.getValueSize(), e);
      }
    }
    (_h.prototype.ValueTypeName = "quaternion"),
      (_h.prototype.DefaultInterpolation = zt),
      (_h.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Mh extends vh {}
    (Mh.prototype.ValueTypeName = "string"),
      (Mh.prototype.ValueBufferType = Array),
      (Mh.prototype.DefaultInterpolation = Ut),
      (Mh.prototype.InterpolantFactoryMethodLinear = void 0),
      (Mh.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Sh extends vh {}
    Sh.prototype.ValueTypeName = "vector";
    class Th {
      constructor(e, t = -1, n, r = Wt) {
        (this.name = e),
          (this.tracks = n),
          (this.duration = t),
          (this.blendMode = r),
          (this.uuid = Hn()),
          this.duration < 0 && this.resetDuration();
      }
      static parse(e) {
        const t = [],
          n = e.tracks,
          r = 1 / (e.fps || 1);
        for (let e = 0, i = n.length; e !== i; ++e) t.push(Eh(n[e]).scale(r));
        const i = new this(e.name, e.duration, t, e.blendMode);
        return (i.uuid = e.uuid), i;
      }
      static toJSON(e) {
        const t = [],
          n = e.tracks,
          r = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode,
          };
        for (let e = 0, r = n.length; e !== r; ++e) t.push(vh.toJSON(n[e]));
        return r;
      }
      static CreateFromMorphTargetSequence(e, t, n, r) {
        const i = t.length,
          o = [];
        for (let e = 0; e < i; e++) {
          let a = [],
            s = [];
          a.push((e + i - 1) % i, e, (e + 1) % i), s.push(0, 1, 0);
          const l = dh.getKeyframeOrder(a);
          (a = dh.sortedArray(a, 1, l)),
            (s = dh.sortedArray(s, 1, l)),
            r || 0 !== a[0] || (a.push(i), s.push(s[0])),
            o.push(
              new bh(".morphTargetInfluences[" + t[e].name + "]", a, s).scale(
                1 / n
              )
            );
        }
        return new this(e, -1, o);
      }
      static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
          const t = e;
          n = (t.geometry && t.geometry.animations) || t.animations;
        }
        for (let e = 0; e < n.length; e++) if (n[e].name === t) return n[e];
        return null;
      }
      static CreateClipsFromMorphTargetSequences(e, t, n) {
        const r = {},
          i = /^([\w-]*?)([\d]+)$/;
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t],
            o = n.name.match(i);
          if (o && o.length > 1) {
            const e = o[1];
            let t = r[e];
            t || (r[e] = t = []), t.push(n);
          }
        }
        const o = [];
        for (const e in r)
          o.push(this.CreateFromMorphTargetSequence(e, r[e], t, n));
        return o;
      }
      static parseAnimation(e, t) {
        if (!e)
          return (
            console.error(
              "THREE.AnimationClip: No animation in JSONLoader data."
            ),
            null
          );
        const n = function (e, t, n, r, i) {
            if (0 !== n.length) {
              const o = [],
                a = [];
              dh.flattenJSON(n, o, a, r),
                0 !== o.length && i.push(new e(t, o, a));
            }
          },
          r = [],
          i = e.name || "default",
          o = e.fps || 30,
          a = e.blendMode;
        let s = e.length || -1;
        const l = e.hierarchy || [];
        for (let e = 0; e < l.length; e++) {
          const i = l[e].keys;
          if (i && 0 !== i.length)
            if (i[0].morphTargets) {
              const e = {};
              let t;
              for (t = 0; t < i.length; t++)
                if (i[t].morphTargets)
                  for (let n = 0; n < i[t].morphTargets.length; n++)
                    e[i[t].morphTargets[n]] = -1;
              for (const n in e) {
                const e = [],
                  o = [];
                for (let r = 0; r !== i[t].morphTargets.length; ++r) {
                  const r = i[t];
                  e.push(r.time), o.push(r.morphTarget === n ? 1 : 0);
                }
                r.push(new bh(".morphTargetInfluence[" + n + "]", e, o));
              }
              s = e.length * (o || 1);
            } else {
              const o = ".bones[" + t[e].name + "]";
              n(Sh, o + ".position", i, "pos", r),
                n(_h, o + ".quaternion", i, "rot", r),
                n(Sh, o + ".scale", i, "scl", r);
            }
        }
        return 0 === r.length ? null : new this(i, s, r, a);
      }
      resetDuration() {
        let e = 0;
        for (let t = 0, n = this.tracks.length; t !== n; ++t) {
          const n = this.tracks[t];
          e = Math.max(e, n.times[n.times.length - 1]);
        }
        return (this.duration = e), this;
      }
      trim() {
        for (let e = 0; e < this.tracks.length; e++)
          this.tracks[e].trim(0, this.duration);
        return this;
      }
      validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
          e = e && this.tracks[t].validate();
        return e;
      }
      optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this;
      }
      clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
          e.push(this.tracks[t].clone());
        return new this.constructor(
          this.name,
          this.duration,
          e,
          this.blendMode
        );
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    }

    function Eh(e) {
      if (void 0 === e.type)
        throw new Error(
          "THREE.KeyframeTrack: track type undefined, can not parse"
        );
      const t = (function (e) {
        switch (e.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return bh;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return Sh;
          case "color":
            return xh;
          case "quaternion":
            return _h;
          case "bool":
          case "boolean":
            return yh;
          case "string":
            return Mh;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
      })(e.type);
      if (void 0 === e.times) {
        const t = [],
          n = [];
        dh.flattenJSON(e.keys, t, n, "value"), (e.times = t), (e.values = n);
      }
      return void 0 !== t.parse
        ? t.parse(e)
        : new t(e.name, e.times, e.values, e.interpolation);
    }
    const Ah = {
      enabled: !1,
      files: {},
      add: function (e, t) {
        !1 !== this.enabled && (this.files[e] = t);
      },
      get: function (e) {
        if (!1 !== this.enabled) return this.files[e];
      },
      remove: function (e) {
        delete this.files[e];
      },
      clear: function () {
        this.files = {};
      },
    };
    class Ch {
      constructor(e, t, n) {
        const r = this;
        let i = !1,
          o = 0,
          a = 0,
          s = void 0;
        const l = [];
        (this.onStart = void 0),
          (this.onLoad = e),
          (this.onProgress = t),
          (this.onError = n),
          (this.itemStart = function (e) {
            a++,
              !1 === i && void 0 !== r.onStart && r.onStart(e, o, a),
              (i = !0);
          }),
          (this.itemEnd = function (e) {
            o++,
              void 0 !== r.onProgress && r.onProgress(e, o, a),
              o === a && ((i = !1), void 0 !== r.onLoad && r.onLoad());
          }),
          (this.itemError = function (e) {
            void 0 !== r.onError && r.onError(e);
          }),
          (this.resolveURL = function (e) {
            return s ? s(e) : e;
          }),
          (this.setURLModifier = function (e) {
            return (s = e), this;
          }),
          (this.addHandler = function (e, t) {
            return l.push(e, t), this;
          }),
          (this.removeHandler = function (e) {
            const t = l.indexOf(e);
            return -1 !== t && l.splice(t, 2), this;
          }),
          (this.getHandler = function (e) {
            for (let t = 0, n = l.length; t < n; t += 2) {
              const n = l[t],
                r = l[t + 1];
              if ((n.global && (n.lastIndex = 0), n.test(e))) return r;
            }
            return null;
          });
      }
    }
    const Ph = new Ch();
    class Lh {
      constructor(e) {
        (this.manager = void 0 !== e ? e : Ph),
          (this.crossOrigin = "anonymous"),
          (this.withCredentials = !1),
          (this.path = ""),
          (this.resourcePath = ""),
          (this.requestHeader = {});
      }
      load() {}
      loadAsync(e, t) {
        const n = this;
        return new Promise(function (r, i) {
          n.load(e, r, t, i);
        });
      }
      parse() {}
      setCrossOrigin(e) {
        return (this.crossOrigin = e), this;
      }
      setWithCredentials(e) {
        return (this.withCredentials = e), this;
      }
      setPath(e) {
        return (this.path = e), this;
      }
      setResourcePath(e) {
        return (this.resourcePath = e), this;
      }
      setRequestHeader(e) {
        return (this.requestHeader = e), this;
      }
    }
    const Rh = {};
    class Ih extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        void 0 === e && (e = ""),
          void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const i = this,
          o = Ah.get(e);
        if (void 0 !== o)
          return (
            i.manager.itemStart(e),
            setTimeout(function () {
              t && t(o), i.manager.itemEnd(e);
            }, 0),
            o
          );
        if (void 0 !== Rh[e])
          return void Rh[e].push({
            onLoad: t,
            onProgress: n,
            onError: r,
          });
        const a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
        let s;
        if (a) {
          const n = a[1],
            o = !!a[2];
          let s = a[3];
          (s = decodeURIComponent(s)), o && (s = atob(s));
          try {
            let r;
            const o = (this.responseType || "").toLowerCase();
            switch (o) {
              case "arraybuffer":
              case "blob":
                const e = new Uint8Array(s.length);
                for (let t = 0; t < s.length; t++) e[t] = s.charCodeAt(t);
                r =
                  "blob" === o
                    ? new Blob([e.buffer], {
                        type: n,
                      })
                    : e.buffer;
                break;
              case "document":
                const t = new DOMParser();
                r = t.parseFromString(s, n);
                break;
              case "json":
                r = JSON.parse(s);
                break;
              default:
                r = s;
            }
            setTimeout(function () {
              t && t(r), i.manager.itemEnd(e);
            }, 0);
          } catch (t) {
            setTimeout(function () {
              r && r(t), i.manager.itemError(e), i.manager.itemEnd(e);
            }, 0);
          }
        } else {
          (Rh[e] = []),
            Rh[e].push({
              onLoad: t,
              onProgress: n,
              onError: r,
            }),
            (s = new XMLHttpRequest()),
            s.open("GET", e, !0),
            s.addEventListener(
              "load",
              function (t) {
                const n = this.response,
                  r = Rh[e];
                if ((delete Rh[e], 200 === this.status || 0 === this.status)) {
                  0 === this.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    Ah.add(e, n);
                  for (let e = 0, t = r.length; e < t; e++) {
                    const t = r[e];
                    t.onLoad && t.onLoad(n);
                  }
                  i.manager.itemEnd(e);
                } else {
                  for (let e = 0, n = r.length; e < n; e++) {
                    const n = r[e];
                    n.onError && n.onError(t);
                  }
                  i.manager.itemError(e), i.manager.itemEnd(e);
                }
              },
              !1
            ),
            s.addEventListener(
              "progress",
              function (t) {
                const n = Rh[e];
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = n[e];
                  r.onProgress && r.onProgress(t);
                }
              },
              !1
            ),
            s.addEventListener(
              "error",
              function (t) {
                const n = Rh[e];
                delete Rh[e];
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = n[e];
                  r.onError && r.onError(t);
                }
                i.manager.itemError(e), i.manager.itemEnd(e);
              },
              !1
            ),
            s.addEventListener(
              "abort",
              function (t) {
                const n = Rh[e];
                delete Rh[e];
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = n[e];
                  r.onError && r.onError(t);
                }
                i.manager.itemError(e), i.manager.itemEnd(e);
              },
              !1
            ),
            void 0 !== this.responseType &&
              (s.responseType = this.responseType),
            void 0 !== this.withCredentials &&
              (s.withCredentials = this.withCredentials),
            s.overrideMimeType &&
              s.overrideMimeType(
                void 0 !== this.mimeType ? this.mimeType : "text/plain"
              );
          for (const e in this.requestHeader)
            s.setRequestHeader(e, this.requestHeader[e]);
          s.send(null);
        }
        return i.manager.itemStart(e), s;
      }
      setResponseType(e) {
        return (this.responseType = e), this;
      }
      setMimeType(e) {
        return (this.mimeType = e), this;
      }
    }
    class kh extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        const i = this,
          o = new Ih(this.manager);
        o.setPath(this.path),
          o.setRequestHeader(this.requestHeader),
          o.setWithCredentials(this.withCredentials),
          o.load(
            e,
            function (n) {
              try {
                t(i.parse(JSON.parse(n)));
              } catch (t) {
                r ? r(t) : console.error(t), i.manager.itemError(e);
              }
            },
            n,
            r
          );
      }
      parse(e) {
        const t = [];
        for (let n = 0; n < e.length; n++) {
          const r = Th.parse(e[n]);
          t.push(r);
        }
        return t;
      }
    }
    class Dh extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        const i = this,
          o = [],
          a = new Ic(),
          s = new Ih(this.manager);
        s.setPath(this.path),
          s.setResponseType("arraybuffer"),
          s.setRequestHeader(this.requestHeader),
          s.setWithCredentials(i.withCredentials);
        let l = 0;

        function c(c) {
          s.load(
            e[c],
            function (e) {
              const n = i.parse(e, !0);
              (o[c] = {
                width: n.width,
                height: n.height,
                format: n.format,
                mipmaps: n.mipmaps,
              }),
                (l += 1),
                6 === l &&
                  (1 === n.mipmapCount && (a.minFilter = xe),
                  (a.image = o),
                  (a.format = n.format),
                  (a.needsUpdate = !0),
                  t && t(a));
            },
            n,
            r
          );
        }
        if (Array.isArray(e)) for (let t = 0, n = e.length; t < n; ++t) c(t);
        else
          s.load(
            e,
            function (e) {
              const n = i.parse(e, !0);
              if (n.isCubemap) {
                const e = n.mipmaps.length / n.mipmapCount;
                for (let t = 0; t < e; t++) {
                  o[t] = {
                    mipmaps: [],
                  };
                  for (let e = 0; e < n.mipmapCount; e++)
                    o[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]),
                      (o[t].format = n.format),
                      (o[t].width = n.width),
                      (o[t].height = n.height);
                }
                a.image = o;
              } else
                (a.image.width = n.width),
                  (a.image.height = n.height),
                  (a.mipmaps = n.mipmaps);
              1 === n.mipmapCount && (a.minFilter = xe),
                (a.format = n.format),
                (a.needsUpdate = !0),
                t && t(a);
            },
            n,
            r
          );
        return a;
      }
    }
    class Oh extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const i = this,
          o = Ah.get(e);
        if (void 0 !== o)
          return (
            i.manager.itemStart(e),
            setTimeout(function () {
              t && t(o), i.manager.itemEnd(e);
            }, 0),
            o
          );
        const a = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "img"
        );

        function s() {
          a.removeEventListener("load", s, !1),
            a.removeEventListener("error", l, !1),
            Ah.add(e, this),
            t && t(this),
            i.manager.itemEnd(e);
        }

        function l(t) {
          a.removeEventListener("load", s, !1),
            a.removeEventListener("error", l, !1),
            r && r(t),
            i.manager.itemError(e),
            i.manager.itemEnd(e);
        }
        return (
          a.addEventListener("load", s, !1),
          a.addEventListener("error", l, !1),
          "data:" !== e.substr(0, 5) &&
            void 0 !== this.crossOrigin &&
            (a.crossOrigin = this.crossOrigin),
          i.manager.itemStart(e),
          (a.src = e),
          a
        );
      }
    }
    class Bh extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        const i = new Po(),
          o = new Oh(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let a = 0;

        function s(n) {
          o.load(
            e[n],
            function (e) {
              (i.images[n] = e),
                a++,
                6 === a && ((i.needsUpdate = !0), t && t(i));
            },
            void 0,
            r
          );
        }
        for (let t = 0; t < e.length; ++t) s(t);
        return i;
      }
    }
    class Fh extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        const i = this,
          o = new rc(),
          a = new Ih(this.manager);
        return (
          a.setResponseType("arraybuffer"),
          a.setRequestHeader(this.requestHeader),
          a.setPath(this.path),
          a.setWithCredentials(i.withCredentials),
          a.load(
            e,
            function (e) {
              const n = i.parse(e);
              n &&
                (void 0 !== n.image
                  ? (o.image = n.image)
                  : void 0 !== n.data &&
                    ((o.image.width = n.width),
                    (o.image.height = n.height),
                    (o.image.data = n.data)),
                (o.wrapS = void 0 !== n.wrapS ? n.wrapS : de),
                (o.wrapT = void 0 !== n.wrapT ? n.wrapT : de),
                (o.magFilter = void 0 !== n.magFilter ? n.magFilter : xe),
                (o.minFilter = void 0 !== n.minFilter ? n.minFilter : xe),
                (o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                void 0 !== n.encoding && (o.encoding = n.encoding),
                void 0 !== n.flipY && (o.flipY = n.flipY),
                void 0 !== n.format && (o.format = n.format),
                void 0 !== n.type && (o.type = n.type),
                void 0 !== n.mipmaps &&
                  ((o.mipmaps = n.mipmaps), (o.minFilter = _e)),
                1 === n.mipmapCount && (o.minFilter = xe),
                void 0 !== n.generateMipmaps &&
                  (o.generateMipmaps = n.generateMipmaps),
                (o.needsUpdate = !0),
                t && t(o, n));
            },
            n,
            r
          ),
          o
        );
      }
    }
    class Nh extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        const i = new er(),
          o = new Oh(this.manager);
        return (
          o.setCrossOrigin(this.crossOrigin),
          o.setPath(this.path),
          o.load(
            e,
            function (n) {
              i.image = n;
              const r =
                e.search(/\.jpe?g($|\?)/i) > 0 ||
                0 === e.search(/^data\:image\/jpeg/);
              (i.format = r ? Fe : Ne),
                (i.needsUpdate = !0),
                void 0 !== t && t(i);
            },
            n,
            r
          ),
          i
        );
      }
    }
    class Uh extends Wc {
      constructor() {
        super(),
          (this.type = "CurvePath"),
          (this.curves = []),
          (this.autoClose = !1);
      }
      add(e) {
        this.curves.push(e);
      }
      closePath() {
        const e = this.curves[0].getPoint(0),
          t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new ou(t, e));
      }
      getPoint(e) {
        const t = e * this.getLength(),
          n = this.getCurveLengths();
        let r = 0;
        for (; r < n.length; ) {
          if (n[r] >= t) {
            const e = n[r] - t,
              i = this.curves[r],
              o = i.getLength(),
              a = 0 === o ? 0 : 1 - e / o;
            return i.getPointAt(a);
          }
          r++;
        }
        return null;
      }
      getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1];
      }
      updateArcLengths() {
        (this.needsUpdate = !0),
          (this.cacheLengths = null),
          this.getCurveLengths();
      }
      getCurveLengths() {
        if (
          this.cacheLengths &&
          this.cacheLengths.length === this.curves.length
        )
          return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let n = 0, r = this.curves.length; n < r; n++)
          (t += this.curves[n].getLength()), e.push(t);
        return (this.cacheLengths = e), e;
      }
      getSpacedPoints(e = 40) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return this.autoClose && t.push(t[0]), t;
      }
      getPoints(e = 12) {
        const t = [];
        let n;
        for (let r = 0, i = this.curves; r < i.length; r++) {
          const o = i[r],
            a =
              o && o.isEllipseCurve
                ? 2 * e
                : o && (o.isLineCurve || o.isLineCurve3)
                ? 1
                : o && o.isSplineCurve
                ? e * o.points.length
                : e,
            s = o.getPoints(a);
          for (let e = 0; e < s.length; e++) {
            const r = s[e];
            (n && n.equals(r)) || (t.push(r), (n = r));
          }
        }
        return (
          this.autoClose &&
            t.length > 1 &&
            !t[t.length - 1].equals(t[0]) &&
            t.push(t[0]),
          t
        );
      }
      copy(e) {
        super.copy(e), (this.curves = []);
        for (let t = 0, n = e.curves.length; t < n; t++) {
          const n = e.curves[t];
          this.curves.push(n.clone());
        }
        return (this.autoClose = e.autoClose), this;
      }
      toJSON() {
        const e = super.toJSON();
        (e.autoClose = this.autoClose), (e.curves = []);
        for (let t = 0, n = this.curves.length; t < n; t++) {
          const n = this.curves[t];
          e.curves.push(n.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
        for (let t = 0, n = e.curves.length; t < n; t++) {
          const n = e.curves[t];
          this.curves.push(new uu[n.type]().fromJSON(n));
        }
        return this;
      }
    }
    class zh extends Uh {
      constructor(e) {
        super(),
          (this.type = "Path"),
          (this.currentPoint = new Yn()),
          e && this.setFromPoints(e);
      }
      setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
        return this;
      }
      moveTo(e, t) {
        return this.currentPoint.set(e, t), this;
      }
      lineTo(e, t) {
        const n = new ou(this.currentPoint.clone(), new Yn(e, t));
        return this.curves.push(n), this.currentPoint.set(e, t), this;
      }
      quadraticCurveTo(e, t, n, r) {
        const i = new su(this.currentPoint.clone(), new Yn(e, t), new Yn(n, r));
        return this.curves.push(i), this.currentPoint.set(n, r), this;
      }
      bezierCurveTo(e, t, n, r, i, o) {
        const a = new ru(
          this.currentPoint.clone(),
          new Yn(e, t),
          new Yn(n, r),
          new Yn(i, o)
        );
        return this.curves.push(a), this.currentPoint.set(i, o), this;
      }
      splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
          n = new cu(t);
        return (
          this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
        );
      }
      arc(e, t, n, r, i, o) {
        const a = this.currentPoint.x,
          s = this.currentPoint.y;
        return this.absarc(e + a, t + s, n, r, i, o), this;
      }
      absarc(e, t, n, r, i, o) {
        return this.absellipse(e, t, n, n, r, i, o), this;
      }
      ellipse(e, t, n, r, i, o, a, s) {
        const l = this.currentPoint.x,
          c = this.currentPoint.y;
        return this.absellipse(e + l, t + c, n, r, i, o, a, s), this;
      }
      absellipse(e, t, n, r, i, o, a, s) {
        const l = new qc(e, t, n, r, i, o, a, s);
        if (this.curves.length > 0) {
          const e = l.getPoint(0);
          e.equals(this.currentPoint) || this.lineTo(e.x, e.y);
        }
        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c), this;
      }
      copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
      }
      toJSON() {
        const e = super.toJSON();
        return (e.currentPoint = this.currentPoint.toArray()), e;
      }
      fromJSON(e) {
        return (
          super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
        );
      }
    }
    class Hh extends zh {
      constructor(e) {
        super(e), (this.uuid = Hn()), (this.type = "Shape"), (this.holes = []);
      }
      getPointsHoles(e) {
        const t = [];
        for (let n = 0, r = this.holes.length; n < r; n++)
          t[n] = this.holes[n].getPoints(e);
        return t;
      }
      extractPoints(e) {
        return {
          shape: this.getPoints(e),
          holes: this.getPointsHoles(e),
        };
      }
      copy(e) {
        super.copy(e), (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        (e.uuid = this.uuid), (e.holes = []);
        for (let t = 0, n = this.holes.length; t < n; t++) {
          const n = this.holes[t];
          e.holes.push(n.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
        for (let t = 0, n = e.holes.length; t < n; t++) {
          const n = e.holes[t];
          this.holes.push(new zh().fromJSON(n));
        }
        return this;
      }
    }
    class Gh extends ci {
      constructor(e, t = 1) {
        super(),
          (this.type = "Light"),
          (this.color = new Pi(e)),
          (this.intensity = t);
      }
      dispose() {}
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          (this.intensity = e.intensity),
          this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.color = this.color.getHex()),
          (t.object.intensity = this.intensity),
          void 0 !== this.groundColor &&
            (t.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (t.object.distance = this.distance),
          void 0 !== this.angle && (t.object.angle = this.angle),
          void 0 !== this.decay && (t.object.decay = this.decay),
          void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
          t
        );
      }
    }
    Gh.prototype.isLight = !0;
    class Vh extends Gh {
      constructor(e, t, n) {
        super(e, n),
          (this.type = "HemisphereLight"),
          this.position.copy(ci.DefaultUp),
          this.updateMatrix(),
          (this.groundColor = new Pi(t));
      }
      copy(e) {
        return (
          Gh.prototype.copy.call(this, e),
          this.groundColor.copy(e.groundColor),
          this
        );
      }
    }
    Vh.prototype.isHemisphereLight = !0;
    const jh = new Nr(),
      Wh = new sr(),
      qh = new sr();
    class $h {
      constructor(e) {
        (this.camera = e),
          (this.bias = 0),
          (this.normalBias = 0),
          (this.radius = 1),
          (this.blurSamples = 8),
          (this.mapSize = new Yn(512, 512)),
          (this.map = null),
          (this.mapPass = null),
          (this.matrix = new Nr()),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this._frustum = new Fo()),
          (this._frameExtents = new Yn(1, 1)),
          (this._viewportCount = 1),
          (this._viewports = [new nr(0, 0, 1, 1)]);
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(e) {
        const t = this.camera,
          n = this.matrix;
        Wh.setFromMatrixPosition(e.matrixWorld),
          t.position.copy(Wh),
          qh.setFromMatrixPosition(e.target.matrixWorld),
          t.lookAt(qh),
          t.updateMatrixWorld(),
          jh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(jh),
          n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
          n.multiply(t.projectionMatrix),
          n.multiply(t.matrixWorldInverse);
      }
      getViewport(e) {
        return this._viewports[e];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }
      copy(e) {
        return (
          (this.camera = e.camera.clone()),
          (this.bias = e.bias),
          (this.radius = e.radius),
          this.mapSize.copy(e.mapSize),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const e = {};
        return (
          0 !== this.bias && (e.bias = this.bias),
          0 !== this.normalBias && (e.normalBias = this.normalBias),
          1 !== this.radius && (e.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) ||
            (e.mapSize = this.mapSize.toArray()),
          (e.camera = this.camera.toJSON(!1).object),
          delete e.camera.matrix,
          e
        );
      }
    }
    class Xh extends $h {
      constructor() {
        super(new Ao(50, 1, 0.5, 500)), (this.focus = 1);
      }
      updateMatrices(e) {
        const t = this.camera,
          n = 2 * zn * e.angle * this.focus,
          r = this.mapSize.width / this.mapSize.height,
          i = e.distance || t.far;
        (n === t.fov && r === t.aspect && i === t.far) ||
          ((t.fov = n),
          (t.aspect = r),
          (t.far = i),
          t.updateProjectionMatrix()),
          super.updateMatrices(e);
      }
      copy(e) {
        return super.copy(e), (this.focus = e.focus), this;
      }
    }
    Xh.prototype.isSpotLightShadow = !0;
    class Yh extends Gh {
      constructor(e, t, n = 0, r = Math.PI / 3, i = 0, o = 1) {
        super(e, t),
          (this.type = "SpotLight"),
          this.position.copy(ci.DefaultUp),
          this.updateMatrix(),
          (this.target = new ci()),
          (this.distance = n),
          (this.angle = r),
          (this.penumbra = i),
          (this.decay = o),
          (this.shadow = new Xh());
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.distance = e.distance),
          (this.angle = e.angle),
          (this.penumbra = e.penumbra),
          (this.decay = e.decay),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    Yh.prototype.isSpotLight = !0;
    const Jh = new Nr(),
      Zh = new sr(),
      Kh = new sr();
    class Qh extends $h {
      constructor() {
        super(new Ao(90, 1, 0.5, 500)),
          (this._frameExtents = new Yn(4, 2)),
          (this._viewportCount = 6),
          (this._viewports = [
            new nr(2, 1, 1, 1),
            new nr(0, 1, 1, 1),
            new nr(3, 1, 1, 1),
            new nr(1, 1, 1, 1),
            new nr(3, 0, 1, 1),
            new nr(1, 0, 1, 1),
          ]),
          (this._cubeDirections = [
            new sr(1, 0, 0),
            new sr(-1, 0, 0),
            new sr(0, 0, 1),
            new sr(0, 0, -1),
            new sr(0, 1, 0),
            new sr(0, -1, 0),
          ]),
          (this._cubeUps = [
            new sr(0, 1, 0),
            new sr(0, 1, 0),
            new sr(0, 1, 0),
            new sr(0, 1, 0),
            new sr(0, 0, 1),
            new sr(0, 0, -1),
          ]);
      }
      updateMatrices(e, t = 0) {
        const n = this.camera,
          r = this.matrix,
          i = e.distance || n.far;
        i !== n.far && ((n.far = i), n.updateProjectionMatrix()),
          Zh.setFromMatrixPosition(e.matrixWorld),
          n.position.copy(Zh),
          Kh.copy(n.position),
          Kh.add(this._cubeDirections[t]),
          n.up.copy(this._cubeUps[t]),
          n.lookAt(Kh),
          n.updateMatrixWorld(),
          r.makeTranslation(-Zh.x, -Zh.y, -Zh.z),
          Jh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(Jh);
      }
    }
    Qh.prototype.isPointLightShadow = !0;
    class ed extends Gh {
      constructor(e, t, n = 0, r = 1) {
        super(e, t),
          (this.type = "PointLight"),
          (this.distance = n),
          (this.decay = r),
          (this.shadow = new Qh());
      }
      get power() {
        return 4 * this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.distance = e.distance),
          (this.decay = e.decay),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    ed.prototype.isPointLight = !0;
    class td extends $h {
      constructor() {
        super(new Jo(-5, 5, 5, -5, 0.5, 500));
      }
    }
    td.prototype.isDirectionalLightShadow = !0;
    class nd extends Gh {
      constructor(e, t) {
        super(e, t),
          (this.type = "DirectionalLight"),
          this.position.copy(ci.DefaultUp),
          this.updateMatrix(),
          (this.target = new ci()),
          (this.shadow = new td());
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return (
          super.copy(e),
          (this.target = e.target.clone()),
          (this.shadow = e.shadow.clone()),
          this
        );
      }
    }
    nd.prototype.isDirectionalLight = !0;
    class rd extends Gh {
      constructor(e, t) {
        super(e, t), (this.type = "AmbientLight");
      }
    }
    rd.prototype.isAmbientLight = !0;
    class id extends Gh {
      constructor(e, t, n = 10, r = 10) {
        super(e, t),
          (this.type = "RectAreaLight"),
          (this.width = n),
          (this.height = r);
      }
      get power() {
        return this.intensity * this.width * this.height * Math.PI;
      }
      set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI);
      }
      copy(e) {
        return (
          super.copy(e), (this.width = e.width), (this.height = e.height), this
        );
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.object.width = this.width), (t.object.height = this.height), t
        );
      }
    }
    id.prototype.isRectAreaLight = !0;
    class od {
      constructor() {
        this.coefficients = [];
        for (let e = 0; e < 9; e++) this.coefficients.push(new sr());
      }
      set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
        return this;
      }
      zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this;
      }
      getAt(e, t) {
        const n = e.x,
          r = e.y,
          i = e.z,
          o = this.coefficients;
        return (
          t.copy(o[0]).multiplyScalar(0.282095),
          t.addScaledVector(o[1], 0.488603 * r),
          t.addScaledVector(o[2], 0.488603 * i),
          t.addScaledVector(o[3], 0.488603 * n),
          t.addScaledVector(o[4], n * r * 1.092548),
          t.addScaledVector(o[5], r * i * 1.092548),
          t.addScaledVector(o[6], 0.315392 * (3 * i * i - 1)),
          t.addScaledVector(o[7], n * i * 1.092548),
          t.addScaledVector(o[8], 0.546274 * (n * n - r * r)),
          t
        );
      }
      getIrradianceAt(e, t) {
        const n = e.x,
          r = e.y,
          i = e.z,
          o = this.coefficients;
        return (
          t.copy(o[0]).multiplyScalar(0.886227),
          t.addScaledVector(o[1], 1.023328 * r),
          t.addScaledVector(o[2], 1.023328 * i),
          t.addScaledVector(o[3], 1.023328 * n),
          t.addScaledVector(o[4], 0.858086 * n * r),
          t.addScaledVector(o[5], 0.858086 * r * i),
          t.addScaledVector(o[6], 0.743125 * i * i - 0.247708),
          t.addScaledVector(o[7], 0.858086 * n * i),
          t.addScaledVector(o[8], 0.429043 * (n * n - r * r)),
          t
        );
      }
      add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
        return this;
      }
      addScaledSH(e, t) {
        for (let n = 0; n < 9; n++)
          this.coefficients[n].addScaledVector(e.coefficients[n], t);
        return this;
      }
      scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
        return this;
      }
      lerp(e, t) {
        for (let n = 0; n < 9; n++)
          this.coefficients[n].lerp(e.coefficients[n], t);
        return this;
      }
      equals(e) {
        for (let t = 0; t < 9; t++)
          if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0;
      }
      copy(e) {
        return this.set(e.coefficients);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      fromArray(e, t = 0) {
        const n = this.coefficients;
        for (let r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
        return this;
      }
      toArray(e = [], t = 0) {
        const n = this.coefficients;
        for (let r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
        return e;
      }
      static getBasisAt(e, t) {
        const n = e.x,
          r = e.y,
          i = e.z;
        (t[0] = 0.282095),
          (t[1] = 0.488603 * r),
          (t[2] = 0.488603 * i),
          (t[3] = 0.488603 * n),
          (t[4] = 1.092548 * n * r),
          (t[5] = 1.092548 * r * i),
          (t[6] = 0.315392 * (3 * i * i - 1)),
          (t[7] = 1.092548 * n * i),
          (t[8] = 0.546274 * (n * n - r * r));
      }
    }
    od.prototype.isSphericalHarmonics3 = !0;
    class ad extends Gh {
      constructor(e = new od(), t = 1) {
        super(void 0, t), (this.sh = e);
      }
      copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this;
      }
      fromJSON(e) {
        return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (t.object.sh = this.sh.toArray()), t;
      }
    }
    ad.prototype.isLightProbe = !0;
    class sd extends Lh {
      constructor(e) {
        super(e), (this.textures = {});
      }
      load(e, t, n, r) {
        const i = this,
          o = new Ih(i.manager);
        o.setPath(i.path),
          o.setRequestHeader(i.requestHeader),
          o.setWithCredentials(i.withCredentials),
          o.load(
            e,
            function (n) {
              try {
                t(i.parse(JSON.parse(n)));
              } catch (t) {
                r ? r(t) : console.error(t), i.manager.itemError(e);
              }
            },
            n,
            r
          );
      }
      parse(e) {
        const t = this.textures;

        function n(e) {
          return (
            void 0 === t[e] &&
              console.warn("THREE.MaterialLoader: Undefined texture", e),
            t[e]
          );
        }
        const r = new hh[e.type]();
        if (
          (void 0 !== e.uuid && (r.uuid = e.uuid),
          void 0 !== e.name && (r.name = e.name),
          void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color),
          void 0 !== e.roughness && (r.roughness = e.roughness),
          void 0 !== e.metalness && (r.metalness = e.metalness),
          void 0 !== e.sheenTint &&
            (r.sheenTint = new Pi().setHex(e.sheenTint)),
          void 0 !== e.emissive &&
            void 0 !== r.emissive &&
            r.emissive.setHex(e.emissive),
          void 0 !== e.specular &&
            void 0 !== r.specular &&
            r.specular.setHex(e.specular),
          void 0 !== e.specularIntensity &&
            (r.specularIntensity = e.specularIntensity),
          void 0 !== e.specularTint &&
            void 0 !== r.specularTint &&
            r.specularTint.setHex(e.specularTint),
          void 0 !== e.shininess && (r.shininess = e.shininess),
          void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat),
          void 0 !== e.clearcoatRoughness &&
            (r.clearcoatRoughness = e.clearcoatRoughness),
          void 0 !== e.transmission && (r.transmission = e.transmission),
          void 0 !== e.thickness && (r.thickness = e.thickness),
          void 0 !== e.attenuationDistance &&
            (r.attenuationDistance = e.attenuationDistance),
          void 0 !== e.attenuationTint &&
            void 0 !== r.attenuationTint &&
            r.attenuationTint.setHex(e.attenuationTint),
          void 0 !== e.fog && (r.fog = e.fog),
          void 0 !== e.flatShading && (r.flatShading = e.flatShading),
          void 0 !== e.blending && (r.blending = e.blending),
          void 0 !== e.combine && (r.combine = e.combine),
          void 0 !== e.side && (r.side = e.side),
          void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide),
          void 0 !== e.opacity && (r.opacity = e.opacity),
          void 0 !== e.format && (r.format = e.format),
          void 0 !== e.transparent && (r.transparent = e.transparent),
          void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest),
          void 0 !== e.depthTest && (r.depthTest = e.depthTest),
          void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite),
          void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite),
          void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite),
          void 0 !== e.stencilWriteMask &&
            (r.stencilWriteMask = e.stencilWriteMask),
          void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc),
          void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef),
          void 0 !== e.stencilFuncMask &&
            (r.stencilFuncMask = e.stencilFuncMask),
          void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail),
          void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail),
          void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass),
          void 0 !== e.wireframe && (r.wireframe = e.wireframe),
          void 0 !== e.wireframeLinewidth &&
            (r.wireframeLinewidth = e.wireframeLinewidth),
          void 0 !== e.wireframeLinecap &&
            (r.wireframeLinecap = e.wireframeLinecap),
          void 0 !== e.wireframeLinejoin &&
            (r.wireframeLinejoin = e.wireframeLinejoin),
          void 0 !== e.rotation && (r.rotation = e.rotation),
          1 !== e.linewidth && (r.linewidth = e.linewidth),
          void 0 !== e.dashSize && (r.dashSize = e.dashSize),
          void 0 !== e.gapSize && (r.gapSize = e.gapSize),
          void 0 !== e.scale && (r.scale = e.scale),
          void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset),
          void 0 !== e.polygonOffsetFactor &&
            (r.polygonOffsetFactor = e.polygonOffsetFactor),
          void 0 !== e.polygonOffsetUnits &&
            (r.polygonOffsetUnits = e.polygonOffsetUnits),
          void 0 !== e.dithering && (r.dithering = e.dithering),
          void 0 !== e.alphaToCoverage &&
            (r.alphaToCoverage = e.alphaToCoverage),
          void 0 !== e.premultipliedAlpha &&
            (r.premultipliedAlpha = e.premultipliedAlpha),
          void 0 !== e.visible && (r.visible = e.visible),
          void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped),
          void 0 !== e.userData && (r.userData = e.userData),
          void 0 !== e.vertexColors &&
            ("number" == typeof e.vertexColors
              ? (r.vertexColors = e.vertexColors > 0)
              : (r.vertexColors = e.vertexColors)),
          void 0 !== e.uniforms)
        )
          for (const t in e.uniforms) {
            const i = e.uniforms[t];
            switch (((r.uniforms[t] = {}), i.type)) {
              case "t":
                r.uniforms[t].value = n(i.value);
                break;
              case "c":
                r.uniforms[t].value = new Pi().setHex(i.value);
                break;
              case "v2":
                r.uniforms[t].value = new Yn().fromArray(i.value);
                break;
              case "v3":
                r.uniforms[t].value = new sr().fromArray(i.value);
                break;
              case "v4":
                r.uniforms[t].value = new nr().fromArray(i.value);
                break;
              case "m3":
                r.uniforms[t].value = new Jn().fromArray(i.value);
                break;
              case "m4":
                r.uniforms[t].value = new Nr().fromArray(i.value);
                break;
              default:
                r.uniforms[t].value = i.value;
            }
          }
        if (
          (void 0 !== e.defines && (r.defines = e.defines),
          void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader),
          void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader),
          void 0 !== e.extensions)
        )
          for (const t in e.extensions) r.extensions[t] = e.extensions[t];
        if (
          (void 0 !== e.shading && (r.flatShading = 1 === e.shading),
          void 0 !== e.size && (r.size = e.size),
          void 0 !== e.sizeAttenuation &&
            (r.sizeAttenuation = e.sizeAttenuation),
          void 0 !== e.map && (r.map = n(e.map)),
          void 0 !== e.matcap && (r.matcap = n(e.matcap)),
          void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)),
          void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)),
          void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale),
          void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)),
          void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType),
          void 0 !== e.normalScale)
        ) {
          let t = e.normalScale;
          !1 === Array.isArray(t) && (t = [t, t]),
            (r.normalScale = new Yn().fromArray(t));
        }
        return (
          void 0 !== e.displacementMap &&
            (r.displacementMap = n(e.displacementMap)),
          void 0 !== e.displacementScale &&
            (r.displacementScale = e.displacementScale),
          void 0 !== e.displacementBias &&
            (r.displacementBias = e.displacementBias),
          void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)),
          void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)),
          void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)),
          void 0 !== e.emissiveIntensity &&
            (r.emissiveIntensity = e.emissiveIntensity),
          void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)),
          void 0 !== e.specularIntensityMap &&
            (r.specularIntensityMap = n(e.specularIntensityMap)),
          void 0 !== e.specularTintMap &&
            (r.specularTintMap = n(e.specularTintMap)),
          void 0 !== e.envMap && (r.envMap = n(e.envMap)),
          void 0 !== e.envMapIntensity &&
            (r.envMapIntensity = e.envMapIntensity),
          void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity),
          void 0 !== e.refractionRatio &&
            (r.refractionRatio = e.refractionRatio),
          void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)),
          void 0 !== e.lightMapIntensity &&
            (r.lightMapIntensity = e.lightMapIntensity),
          void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)),
          void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity),
          void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)),
          void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)),
          void 0 !== e.clearcoatRoughnessMap &&
            (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
          void 0 !== e.clearcoatNormalMap &&
            (r.clearcoatNormalMap = n(e.clearcoatNormalMap)),
          void 0 !== e.clearcoatNormalScale &&
            (r.clearcoatNormalScale = new Yn().fromArray(
              e.clearcoatNormalScale
            )),
          void 0 !== e.transmissionMap &&
            (r.transmissionMap = n(e.transmissionMap)),
          void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)),
          r
        );
      }
      setTextures(e) {
        return (this.textures = e), this;
      }
    }
    class ld {
      static decodeText(e) {
        if ("undefined" != typeof TextDecoder)
          return new TextDecoder().decode(e);
        let t = "";
        for (let n = 0, r = e.length; n < r; n++)
          t += String.fromCharCode(e[n]);
        try {
          return decodeURIComponent(escape(t));
        } catch (e) {
          return t;
        }
      }
      static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.substr(0, t + 1);
      }
    }
    class cd extends eo {
      constructor() {
        super(),
          (this.type = "InstancedBufferGeometry"),
          (this.instanceCount = 1 / 0);
      }
      copy(e) {
        return super.copy(e), (this.instanceCount = e.instanceCount), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const e = super.toJSON(this);
        return (
          (e.instanceCount = this.instanceCount),
          (e.isInstancedBufferGeometry = !0),
          e
        );
      }
    }
    cd.prototype.isInstancedBufferGeometry = !0;
    class ud extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        const i = this,
          o = new Ih(i.manager);
        o.setPath(i.path),
          o.setRequestHeader(i.requestHeader),
          o.setWithCredentials(i.withCredentials),
          o.load(
            e,
            function (n) {
              try {
                t(i.parse(JSON.parse(n)));
              } catch (t) {
                r ? r(t) : console.error(t), i.manager.itemError(e);
              }
            },
            n,
            r
          );
      }
      parse(e) {
        const t = {},
          n = {};

        function r(e, r) {
          if (void 0 !== t[r]) return t[r];
          const i = e.interleavedBuffers[r],
            o = (function (e, t) {
              if (void 0 !== n[t]) return n[t];
              const r = e.arrayBuffers[t],
                i = new Uint32Array(r).buffer;
              return (n[t] = i), i;
            })(e, i.buffer),
            a = qi(i.type, o),
            s = new Cl(a, i.stride);
          return (s.uuid = i.uuid), (t[r] = s), s;
        }
        const i = e.isInstancedBufferGeometry ? new cd() : new eo(),
          o = e.data.index;
        if (void 0 !== o) {
          const e = qi(o.type, o.array);
          i.setIndex(new ki(e, 1));
        }
        const a = e.data.attributes;
        for (const t in a) {
          const n = a[t];
          let o;
          if (n.isInterleavedBufferAttribute) {
            const t = r(e.data, n.data);
            o = new Ll(t, n.itemSize, n.offset, n.normalized);
          } else {
            const e = qi(n.type, n.array);
            o = new (n.isInstancedBufferAttribute ? sc : ki)(
              e,
              n.itemSize,
              n.normalized
            );
          }
          void 0 !== n.name && (o.name = n.name),
            void 0 !== n.usage && o.setUsage(n.usage),
            void 0 !== n.updateRange &&
              ((o.updateRange.offset = n.updateRange.offset),
              (o.updateRange.count = n.updateRange.count)),
            i.setAttribute(t, o);
        }
        const s = e.data.morphAttributes;
        if (s)
          for (const t in s) {
            const n = s[t],
              o = [];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              let a;
              if (i.isInterleavedBufferAttribute) {
                const t = r(e.data, i.data);
                a = new Ll(t, i.itemSize, i.offset, i.normalized);
              } else {
                const e = qi(i.type, i.array);
                a = new ki(e, i.itemSize, i.normalized);
              }
              void 0 !== i.name && (a.name = i.name), o.push(a);
            }
            i.morphAttributes[t] = o;
          }
        e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
        const l = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (void 0 !== l)
          for (let e = 0, t = l.length; e !== t; ++e) {
            const t = l[e];
            i.addGroup(t.start, t.count, t.materialIndex);
          }
        const c = e.data.boundingSphere;
        if (void 0 !== c) {
          const e = new sr();
          void 0 !== c.center && e.fromArray(c.center),
            (i.boundingSphere = new Pr(e, c.radius));
        }
        return (
          e.name && (i.name = e.name),
          e.userData && (i.userData = e.userData),
          i
        );
      }
    }
    class hd extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        const i = this,
          o = "" === this.path ? ld.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new Ih(this.manager);
        a.setPath(this.path),
          a.setRequestHeader(this.requestHeader),
          a.setWithCredentials(this.withCredentials),
          a.load(
            e,
            function (n) {
              let o = null;
              try {
                o = JSON.parse(n);
              } catch (t) {
                return (
                  void 0 !== r && r(t),
                  void console.error(
                    "THREE:ObjectLoader: Can't parse " + e + ".",
                    t.message
                  )
                );
              }
              const a = o.metadata;
              void 0 !== a &&
              void 0 !== a.type &&
              "geometry" !== a.type.toLowerCase()
                ? i.parse(o, t)
                : console.error("THREE.ObjectLoader: Can't load " + e);
            },
            n,
            r
          );
      }
      async loadAsync(e, t) {
        const n = "" === this.path ? ld.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || n;
        const r = new Ih(this.manager);
        r.setPath(this.path),
          r.setRequestHeader(this.requestHeader),
          r.setWithCredentials(this.withCredentials);
        const i = await r.loadAsync(e, t),
          o = JSON.parse(i),
          a = o.metadata;
        if (
          void 0 === a ||
          void 0 === a.type ||
          "geometry" === a.type.toLowerCase()
        )
          throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await this.parseAsync(o);
      }
      parse(e, t) {
        const n = this.parseAnimations(e.animations),
          r = this.parseShapes(e.shapes),
          i = this.parseGeometries(e.geometries, r),
          o = this.parseImages(e.images, function () {
            void 0 !== t && t(l);
          }),
          a = this.parseTextures(e.textures, o),
          s = this.parseMaterials(e.materials, a),
          l = this.parseObject(e.object, i, s, a, n),
          c = this.parseSkeletons(e.skeletons, l);
        if ((this.bindSkeletons(l, c), void 0 !== t)) {
          let e = !1;
          for (const t in o)
            if (o[t] instanceof HTMLImageElement) {
              e = !0;
              break;
            }
          !1 === e && t(l);
        }
        return l;
      }
      async parseAsync(e) {
        const t = this.parseAnimations(e.animations),
          n = this.parseShapes(e.shapes),
          r = this.parseGeometries(e.geometries, n),
          i = await this.parseImagesAsync(e.images),
          o = this.parseTextures(e.textures, i),
          a = this.parseMaterials(e.materials, o),
          s = this.parseObject(e.object, r, a, o, t),
          l = this.parseSkeletons(e.skeletons, s);
        return this.bindSkeletons(s, l), s;
      }
      parseShapes(e) {
        const t = {};
        if (void 0 !== e)
          for (let n = 0, r = e.length; n < r; n++) {
            const r = new Hh().fromJSON(e[n]);
            t[r.uuid] = r;
          }
        return t;
      }
      parseSkeletons(e, t) {
        const n = {},
          r = {};
        if (
          (t.traverse(function (e) {
            e.isBone && (r[e.uuid] = e);
          }),
          void 0 !== e)
        )
          for (let t = 0, i = e.length; t < i; t++) {
            const i = new ac().fromJSON(e[t], r);
            n[i.uuid] = i;
          }
        return n;
      }
      parseGeometries(e, t) {
        const n = {};
        if (void 0 !== e) {
          const r = new ud();
          for (let i = 0, o = e.length; i < o; i++) {
            let o;
            const a = e[i];
            switch (a.type) {
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                o = r.parse(a);
                break;
              case "Geometry":
                console.error(
                  "THREE.ObjectLoader: The legacy Geometry type is no longer supported."
                );
                break;
              default:
                a.type in th
                  ? (o = th[a.type].fromJSON(a, t))
                  : console.warn(
                      `THREE.ObjectLoader: Unsupported geometry type "${a.type}"`
                    );
            }
            (o.uuid = a.uuid),
              void 0 !== a.name && (o.name = a.name),
              !0 === o.isBufferGeometry &&
                void 0 !== a.userData &&
                (o.userData = a.userData),
              (n[a.uuid] = o);
          }
        }
        return n;
      }
      parseMaterials(e, t) {
        const n = {},
          r = {};
        if (void 0 !== e) {
          const i = new sd();
          i.setTextures(t);
          for (let t = 0, o = e.length; t < o; t++) {
            const o = e[t];
            if ("MultiMaterial" === o.type) {
              const e = [];
              for (let t = 0; t < o.materials.length; t++) {
                const r = o.materials[t];
                void 0 === n[r.uuid] && (n[r.uuid] = i.parse(r)),
                  e.push(n[r.uuid]);
              }
              r[o.uuid] = e;
            } else
              void 0 === n[o.uuid] && (n[o.uuid] = i.parse(o)),
                (r[o.uuid] = n[o.uuid]);
          }
        }
        return r;
      }
      parseAnimations(e) {
        const t = {};
        if (void 0 !== e)
          for (let n = 0; n < e.length; n++) {
            const r = e[n],
              i = Th.parse(r);
            t[i.uuid] = i;
          }
        return t;
      }
      parseImages(e, t) {
        const n = this,
          r = {};
        let i;

        function o(e) {
          if ("string" == typeof e) {
            const t = e;
            return (function (e) {
              return (
                n.manager.itemStart(e),
                i.load(
                  e,
                  function () {
                    n.manager.itemEnd(e);
                  },
                  void 0,
                  function () {
                    n.manager.itemError(e), n.manager.itemEnd(e);
                  }
                )
              );
            })(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t);
          }
          return e.data
            ? {
                data: qi(e.type, e.data),
                width: e.width,
                height: e.height,
              }
            : null;
        }
        if (void 0 !== e && e.length > 0) {
          const n = new Ch(t);
          (i = new Oh(n)), i.setCrossOrigin(this.crossOrigin);
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t],
              i = n.url;
            if (Array.isArray(i)) {
              r[n.uuid] = [];
              for (let e = 0, t = i.length; e < t; e++) {
                const t = o(i[e]);
                null !== t &&
                  (t instanceof HTMLImageElement
                    ? r[n.uuid].push(t)
                    : r[n.uuid].push(new rc(t.data, t.width, t.height)));
              }
            } else {
              const e = o(n.url);
              null !== e && (r[n.uuid] = e);
            }
          }
        }
        return r;
      }
      async parseImagesAsync(e) {
        const t = this,
          n = {};
        let r;
        async function i(e) {
          if ("string" == typeof e) {
            const n = e,
              i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n;
            return await r.loadAsync(i);
          }
          return e.data
            ? {
                data: qi(e.type, e.data),
                width: e.width,
                height: e.height,
              }
            : null;
        }
        if (void 0 !== e && e.length > 0) {
          (r = new Oh(this.manager)), r.setCrossOrigin(this.crossOrigin);
          for (let t = 0, r = e.length; t < r; t++) {
            const r = e[t],
              o = r.url;
            if (Array.isArray(o)) {
              n[r.uuid] = [];
              for (let e = 0, t = o.length; e < t; e++) {
                const t = o[e],
                  a = await i(t);
                null !== a &&
                  (a instanceof HTMLImageElement
                    ? n[r.uuid].push(a)
                    : n[r.uuid].push(new rc(a.data, a.width, a.height)));
              }
            } else {
              const e = await i(r.url);
              null !== e && (n[r.uuid] = e);
            }
          }
        }
        return n;
      }
      parseTextures(e, t) {
        function n(e, t) {
          return "number" == typeof e
            ? e
            : (console.warn(
                "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                e
              ),
              t[e]);
        }
        const r = {};
        if (void 0 !== e)
          for (let i = 0, o = e.length; i < o; i++) {
            const o = e[i];
            let a;
            void 0 === o.image &&
              console.warn(
                'THREE.ObjectLoader: No "image" specified for',
                o.uuid
              ),
              void 0 === t[o.image] &&
                console.warn("THREE.ObjectLoader: Undefined image", o.image);
            const s = t[o.image];
            Array.isArray(s)
              ? ((a = new Po(s)), 6 === s.length && (a.needsUpdate = !0))
              : ((a =
                  s && s.data ? new rc(s.data, s.width, s.height) : new er(s)),
                s && (a.needsUpdate = !0)),
              (a.uuid = o.uuid),
              void 0 !== o.name && (a.name = o.name),
              void 0 !== o.mapping && (a.mapping = n(o.mapping, dd)),
              void 0 !== o.offset && a.offset.fromArray(o.offset),
              void 0 !== o.repeat && a.repeat.fromArray(o.repeat),
              void 0 !== o.center && a.center.fromArray(o.center),
              void 0 !== o.rotation && (a.rotation = o.rotation),
              void 0 !== o.wrap &&
                ((a.wrapS = n(o.wrap[0], pd)), (a.wrapT = n(o.wrap[1], pd))),
              void 0 !== o.format && (a.format = o.format),
              void 0 !== o.type && (a.type = o.type),
              void 0 !== o.encoding && (a.encoding = o.encoding),
              void 0 !== o.minFilter && (a.minFilter = n(o.minFilter, fd)),
              void 0 !== o.magFilter && (a.magFilter = n(o.magFilter, fd)),
              void 0 !== o.anisotropy && (a.anisotropy = o.anisotropy),
              void 0 !== o.flipY && (a.flipY = o.flipY),
              void 0 !== o.premultiplyAlpha &&
                (a.premultiplyAlpha = o.premultiplyAlpha),
              void 0 !== o.unpackAlignment &&
                (a.unpackAlignment = o.unpackAlignment),
              (r[o.uuid] = a);
          }
        return r;
      }
      parseObject(e, t, n, r, i) {
        let o, a, s;

        function l(e) {
          return (
            void 0 === t[e] &&
              console.warn("THREE.ObjectLoader: Undefined geometry", e),
            t[e]
          );
        }

        function c(e) {
          if (void 0 !== e) {
            if (Array.isArray(e)) {
              const t = [];
              for (let r = 0, i = e.length; r < i; r++) {
                const i = e[r];
                void 0 === n[i] &&
                  console.warn("THREE.ObjectLoader: Undefined material", i),
                  t.push(n[i]);
              }
              return t;
            }
            return (
              void 0 === n[e] &&
                console.warn("THREE.ObjectLoader: Undefined material", e),
              n[e]
            );
          }
        }

        function u(e) {
          return (
            void 0 === r[e] &&
              console.warn("THREE.ObjectLoader: Undefined texture", e),
            r[e]
          );
        }
        switch (e.type) {
          case "Scene":
            (o = new Al()),
              void 0 !== e.background &&
                (Number.isInteger(e.background)
                  ? (o.background = new Pi(e.background))
                  : (o.background = u(e.background))),
              void 0 !== e.environment && (o.environment = u(e.environment)),
              void 0 !== e.fog &&
                ("Fog" === e.fog.type
                  ? (o.fog = new El(e.fog.color, e.fog.near, e.fog.far))
                  : "FogExp2" === e.fog.type &&
                    (o.fog = new Tl(e.fog.color, e.fog.density)));
            break;
          case "PerspectiveCamera":
            (o = new Ao(e.fov, e.aspect, e.near, e.far)),
              void 0 !== e.focus && (o.focus = e.focus),
              void 0 !== e.zoom && (o.zoom = e.zoom),
              void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge),
              void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset),
              void 0 !== e.view && (o.view = Object.assign({}, e.view));
            break;
          case "OrthographicCamera":
            (o = new Jo(e.left, e.right, e.top, e.bottom, e.near, e.far)),
              void 0 !== e.zoom && (o.zoom = e.zoom),
              void 0 !== e.view && (o.view = Object.assign({}, e.view));
            break;
          case "AmbientLight":
            o = new rd(e.color, e.intensity);
            break;
          case "DirectionalLight":
            o = new nd(e.color, e.intensity);
            break;
          case "PointLight":
            o = new ed(e.color, e.intensity, e.distance, e.decay);
            break;
          case "RectAreaLight":
            o = new id(e.color, e.intensity, e.width, e.height);
            break;
          case "SpotLight":
            o = new Yh(
              e.color,
              e.intensity,
              e.distance,
              e.angle,
              e.penumbra,
              e.decay
            );
            break;
          case "HemisphereLight":
            o = new Vh(e.color, e.groundColor, e.intensity);
            break;
          case "LightProbe":
            o = new ad().fromJSON(e);
            break;
          case "SkinnedMesh":
            (a = l(e.geometry)),
              (s = c(e.material)),
              (o = new tc(a, s)),
              void 0 !== e.bindMode && (o.bindMode = e.bindMode),
              void 0 !== e.bindMatrix && o.bindMatrix.fromArray(e.bindMatrix),
              void 0 !== e.skeleton && (o.skeleton = e.skeleton);
            break;
          case "Mesh":
            (a = l(e.geometry)), (s = c(e.material)), (o = new xo(a, s));
            break;
          case "InstancedMesh":
            (a = l(e.geometry)), (s = c(e.material));
            const t = e.count,
              n = e.instanceMatrix,
              r = e.instanceColor;
            (o = new dc(a, s, t)),
              (o.instanceMatrix = new sc(new Float32Array(n.array), 16)),
              void 0 !== r &&
                (o.instanceColor = new sc(
                  new Float32Array(r.array),
                  r.itemSize
                ));
            break;
          case "LOD":
            o = new Yl();
            break;
          case "Line":
            o = new xc(l(e.geometry), c(e.material));
            break;
          case "LineLoop":
            o = new Mc(l(e.geometry), c(e.material));
            break;
          case "LineSegments":
            o = new _c(l(e.geometry), c(e.material));
            break;
          case "PointCloud":
          case "Points":
            o = new Pc(l(e.geometry), c(e.material));
            break;
          case "Sprite":
            o = new Wl(c(e.material));
            break;
          case "Group":
            o = new yl();
            break;
          case "Bone":
            o = new nc();
            break;
          default:
            o = new ci();
        }
        if (
          ((o.uuid = e.uuid),
          void 0 !== e.name && (o.name = e.name),
          void 0 !== e.matrix
            ? (o.matrix.fromArray(e.matrix),
              void 0 !== e.matrixAutoUpdate &&
                (o.matrixAutoUpdate = e.matrixAutoUpdate),
              o.matrixAutoUpdate &&
                o.matrix.decompose(o.position, o.quaternion, o.scale))
            : (void 0 !== e.position && o.position.fromArray(e.position),
              void 0 !== e.rotation && o.rotation.fromArray(e.rotation),
              void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion),
              void 0 !== e.scale && o.scale.fromArray(e.scale)),
          void 0 !== e.castShadow && (o.castShadow = e.castShadow),
          void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow),
          e.shadow &&
            (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias),
            void 0 !== e.shadow.normalBias &&
              (o.shadow.normalBias = e.shadow.normalBias),
            void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius),
            void 0 !== e.shadow.mapSize &&
              o.shadow.mapSize.fromArray(e.shadow.mapSize),
            void 0 !== e.shadow.camera &&
              (o.shadow.camera = this.parseObject(e.shadow.camera))),
          void 0 !== e.visible && (o.visible = e.visible),
          void 0 !== e.frustumCulled && (o.frustumCulled = e.frustumCulled),
          void 0 !== e.renderOrder && (o.renderOrder = e.renderOrder),
          void 0 !== e.userData && (o.userData = e.userData),
          void 0 !== e.layers && (o.layers.mask = e.layers),
          void 0 !== e.children)
        ) {
          const a = e.children;
          for (let e = 0; e < a.length; e++)
            o.add(this.parseObject(a[e], t, n, r, i));
        }
        if (void 0 !== e.animations) {
          const t = e.animations;
          for (let e = 0; e < t.length; e++) {
            const n = t[e];
            o.animations.push(i[n]);
          }
        }
        if ("LOD" === e.type) {
          void 0 !== e.autoUpdate && (o.autoUpdate = e.autoUpdate);
          const t = e.levels;
          for (let e = 0; e < t.length; e++) {
            const n = t[e],
              r = o.getObjectByProperty("uuid", n.object);
            void 0 !== r && o.addLevel(r, n.distance);
          }
        }
        return o;
      }
      bindSkeletons(e, t) {
        0 !== Object.keys(t).length &&
          e.traverse(function (e) {
            if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
              const n = t[e.skeleton];
              void 0 === n
                ? console.warn(
                    "THREE.ObjectLoader: No skeleton found with UUID:",
                    e.skeleton
                  )
                : e.bind(n, e.bindMatrix);
            }
          });
      }
      setTexturePath(e) {
        return (
          console.warn(
            "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
          ),
          this.setResourcePath(e)
        );
      }
    }
    const dd = {
        UVMapping: ie,
        CubeReflectionMapping: oe,
        CubeRefractionMapping: ae,
        EquirectangularReflectionMapping: se,
        EquirectangularRefractionMapping: le,
        CubeUVReflectionMapping: ce,
        CubeUVRefractionMapping: ue,
      },
      pd = {
        RepeatWrapping: he,
        ClampToEdgeWrapping: de,
        MirroredRepeatWrapping: pe,
      },
      fd = {
        NearestFilter: fe,
        NearestMipmapNearestFilter: me,
        NearestMipmapLinearFilter: ve,
        LinearFilter: xe,
        LinearMipmapNearestFilter: be,
        LinearMipmapLinearFilter: _e,
      };
    class md extends Lh {
      constructor(e) {
        super(e),
          "undefined" == typeof createImageBitmap &&
            console.warn(
              "THREE.ImageBitmapLoader: createImageBitmap() not supported."
            ),
          "undefined" == typeof fetch &&
            console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
          (this.options = {
            premultiplyAlpha: "none",
          });
      }
      setOptions(e) {
        return (this.options = e), this;
      }
      load(e, t, n, r) {
        void 0 === e && (e = ""),
          void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        const i = this,
          o = Ah.get(e);
        if (void 0 !== o)
          return (
            i.manager.itemStart(e),
            setTimeout(function () {
              t && t(o), i.manager.itemEnd(e);
            }, 0),
            o
          );
        const a = {};
        (a.credentials =
          "anonymous" === this.crossOrigin ? "same-origin" : "include"),
          (a.headers = this.requestHeader),
          fetch(e, a)
            .then(function (e) {
              return e.blob();
            })
            .then(function (e) {
              return createImageBitmap(
                e,
                Object.assign(i.options, {
                  colorSpaceConversion: "none",
                })
              );
            })
            .then(function (n) {
              Ah.add(e, n), t && t(n), i.manager.itemEnd(e);
            })
            .catch(function (t) {
              r && r(t), i.manager.itemError(e), i.manager.itemEnd(e);
            }),
          i.manager.itemStart(e);
      }
    }
    md.prototype.isImageBitmapLoader = !0;
    class gd {
      constructor() {
        (this.type = "ShapePath"),
          (this.color = new Pi()),
          (this.subPaths = []),
          (this.currentPath = null);
      }
      moveTo(e, t) {
        return (
          (this.currentPath = new zh()),
          this.subPaths.push(this.currentPath),
          this.currentPath.moveTo(e, t),
          this
        );
      }
      lineTo(e, t) {
        return this.currentPath.lineTo(e, t), this;
      }
      quadraticCurveTo(e, t, n, r) {
        return this.currentPath.quadraticCurveTo(e, t, n, r), this;
      }
      bezierCurveTo(e, t, n, r, i, o) {
        return this.currentPath.bezierCurveTo(e, t, n, r, i, o), this;
      }
      splineThru(e) {
        return this.currentPath.splineThru(e), this;
      }
      toShapes(e, t) {
        function n(e) {
          const t = [];
          for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n],
              i = new Hh();
            (i.curves = r.curves), t.push(i);
          }
          return t;
        }

        function r(e, t) {
          const n = t.length;
          let r = !1;
          for (let i = n - 1, o = 0; o < n; i = o++) {
            let n = t[i],
              a = t[o],
              s = a.x - n.x,
              l = a.y - n.y;
            if (Math.abs(l) > Number.EPSILON) {
              if (
                (l < 0 && ((n = t[o]), (s = -s), (a = t[i]), (l = -l)),
                e.y < n.y || e.y > a.y)
              )
                continue;
              if (e.y === n.y) {
                if (e.x === n.x) return !0;
              } else {
                const t = l * (e.x - n.x) - s * (e.y - n.y);
                if (0 === t) return !0;
                if (t < 0) continue;
                r = !r;
              }
            } else {
              if (e.y !== n.y) continue;
              if ((a.x <= e.x && e.x <= n.x) || (n.x <= e.x && e.x <= a.x))
                return !0;
            }
          }
          return r;
        }
        const i = Bu.isClockWise,
          o = this.subPaths;
        if (0 === o.length) return [];
        if (!0 === t) return n(o);
        let a, s, l;
        const c = [];
        if (1 === o.length)
          return (
            (s = o[0]), (l = new Hh()), (l.curves = s.curves), c.push(l), c
          );
        let u = !i(o[0].getPoints());
        u = e ? !u : u;
        const h = [],
          d = [];
        let p,
          f,
          m = [],
          g = 0;
        (d[g] = void 0), (m[g] = []);
        for (let t = 0, n = o.length; t < n; t++)
          (s = o[t]),
            (p = s.getPoints()),
            (a = i(p)),
            (a = e ? !a : a),
            a
              ? (!u && d[g] && g++,
                (d[g] = {
                  s: new Hh(),
                  p: p,
                }),
                (d[g].s.curves = s.curves),
                u && g++,
                (m[g] = []))
              : m[g].push({
                  h: s,
                  p: p[0],
                });
        if (!d[0]) return n(o);
        if (d.length > 1) {
          let e = !1;
          const t = [];
          for (let e = 0, t = d.length; e < t; e++) h[e] = [];
          for (let n = 0, i = d.length; n < i; n++) {
            const i = m[n];
            for (let o = 0; o < i.length; o++) {
              const a = i[o];
              let s = !0;
              for (let i = 0; i < d.length; i++)
                r(a.p, d[i].p) &&
                  (n !== i &&
                    t.push({
                      froms: n,
                      tos: i,
                      hole: o,
                    }),
                  s ? ((s = !1), h[i].push(a)) : (e = !0));
              s && h[n].push(a);
            }
          }
          t.length > 0 && (e || (m = h));
        }
        for (let e = 0, t = d.length; e < t; e++) {
          (l = d[e].s), c.push(l), (f = m[e]);
          for (let e = 0, t = f.length; e < t; e++) l.holes.push(f[e].h);
        }
        return c;
      }
    }
    class vd {
      constructor(e) {
        (this.type = "Font"), (this.data = e);
      }
      generateShapes(e, t = 100) {
        const n = [],
          r = (function (e, t, n) {
            const r = Array.from(e),
              i = t / n.resolution,
              o =
                (n.boundingBox.yMax -
                  n.boundingBox.yMin +
                  n.underlineThickness) *
                i,
              a = [];
            let s = 0,
              l = 0;
            for (let e = 0; e < r.length; e++) {
              const t = r[e];
              if ("\n" === t) (s = 0), (l -= o);
              else {
                const e = yd(t, i, s, l, n);
                (s += e.offsetX), a.push(e.path);
              }
            }
            return a;
          })(e, t, this.data);
        for (let e = 0, t = r.length; e < t; e++)
          Array.prototype.push.apply(n, r[e].toShapes());
        return n;
      }
    }

    function yd(e, t, n, r, i) {
      const o = i.glyphs[e] || i.glyphs["?"];
      if (!o)
        return void console.error(
          'THREE.Font: character "' +
            e +
            '" does not exists in font family ' +
            i.familyName +
            "."
        );
      const a = new gd();
      let s, l, c, u, h, d, p, f;
      if (o.o) {
        const e = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
        for (let i = 0, o = e.length; i < o; ) {
          switch (e[i++]) {
            case "m":
              (s = e[i++] * t + n), (l = e[i++] * t + r), a.moveTo(s, l);
              break;
            case "l":
              (s = e[i++] * t + n), (l = e[i++] * t + r), a.lineTo(s, l);
              break;
            case "q":
              (c = e[i++] * t + n),
                (u = e[i++] * t + r),
                (h = e[i++] * t + n),
                (d = e[i++] * t + r),
                a.quadraticCurveTo(h, d, c, u);
              break;
            case "b":
              (c = e[i++] * t + n),
                (u = e[i++] * t + r),
                (h = e[i++] * t + n),
                (d = e[i++] * t + r),
                (p = e[i++] * t + n),
                (f = e[i++] * t + r),
                a.bezierCurveTo(h, d, p, f, c, u);
          }
        }
      }
      return {
        offsetX: o.ha * t,
        path: a,
      };
    }
    vd.prototype.isFont = !0;
    class xd extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        const i = this,
          o = new Ih(this.manager);
        o.setPath(this.path),
          o.setRequestHeader(this.requestHeader),
          o.setWithCredentials(i.withCredentials),
          o.load(
            e,
            function (e) {
              let n;
              try {
                n = JSON.parse(e);
              } catch (t) {
                console.warn(
                  "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                ),
                  (n = JSON.parse(e.substring(65, e.length - 2)));
              }
              const r = i.parse(n);
              t && t(r);
            },
            n,
            r
          );
      }
      parse(e) {
        return new vd(e);
      }
    }
    let bd;
    const wd = {
      getContext: function () {
        return (
          void 0 === bd &&
            (bd = new (window.AudioContext || window.webkitAudioContext)()),
          bd
        );
      },
      setContext: function (e) {
        bd = e;
      },
    };
    class _d extends Lh {
      constructor(e) {
        super(e);
      }
      load(e, t, n, r) {
        const i = this,
          o = new Ih(this.manager);
        o.setResponseType("arraybuffer"),
          o.setPath(this.path),
          o.setRequestHeader(this.requestHeader),
          o.setWithCredentials(this.withCredentials),
          o.load(
            e,
            function (n) {
              try {
                const e = n.slice(0);
                wd.getContext().decodeAudioData(e, function (e) {
                  t(e);
                });
              } catch (t) {
                r ? r(t) : console.error(t), i.manager.itemError(e);
              }
            },
            n,
            r
          );
      }
    }
    class Md extends ad {
      constructor(e, t, n = 1) {
        super(void 0, n);
        const r = new Pi().set(e),
          i = new Pi().set(t),
          o = new sr(r.r, r.g, r.b),
          a = new sr(i.r, i.g, i.b),
          s = Math.sqrt(Math.PI),
          l = s * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s),
          this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(l);
      }
    }
    Md.prototype.isHemisphereLightProbe = !0;
    class Sd extends ad {
      constructor(e, t = 1) {
        super(void 0, t);
        const n = new Pi().set(e);
        this.sh.coefficients[0]
          .set(n.r, n.g, n.b)
          .multiplyScalar(2 * Math.sqrt(Math.PI));
      }
    }
    Sd.prototype.isAmbientLightProbe = !0;
    const Td = new Nr(),
      Ed = new Nr();
    class Ad {
      constructor() {
        (this.type = "StereoCamera"),
          (this.aspect = 1),
          (this.eyeSep = 0.064),
          (this.cameraL = new Ao()),
          this.cameraL.layers.enable(1),
          (this.cameraL.matrixAutoUpdate = !1),
          (this.cameraR = new Ao()),
          this.cameraR.layers.enable(2),
          (this.cameraR.matrixAutoUpdate = !1),
          (this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null,
          });
      }
      update(e) {
        const t = this._cache;
        if (
          t.focus !== e.focus ||
          t.fov !== e.fov ||
          t.aspect !== e.aspect * this.aspect ||
          t.near !== e.near ||
          t.far !== e.far ||
          t.zoom !== e.zoom ||
          t.eyeSep !== this.eyeSep
        ) {
          (t.focus = e.focus),
            (t.fov = e.fov),
            (t.aspect = e.aspect * this.aspect),
            (t.near = e.near),
            (t.far = e.far),
            (t.zoom = e.zoom),
            (t.eyeSep = this.eyeSep);
          const n = e.projectionMatrix.clone(),
            r = t.eyeSep / 2,
            i = (r * t.near) / t.focus,
            o = (t.near * Math.tan(Un * t.fov * 0.5)) / t.zoom;
          let a, s;
          (Ed.elements[12] = -r),
            (Td.elements[12] = r),
            (a = -o * t.aspect + i),
            (s = o * t.aspect + i),
            (n.elements[0] = (2 * t.near) / (s - a)),
            (n.elements[8] = (s + a) / (s - a)),
            this.cameraL.projectionMatrix.copy(n),
            (a = -o * t.aspect - i),
            (s = o * t.aspect - i),
            (n.elements[0] = (2 * t.near) / (s - a)),
            (n.elements[8] = (s + a) / (s - a)),
            this.cameraR.projectionMatrix.copy(n);
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Ed),
          this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Td);
      }
    }
    class Cd {
      constructor(e = !0) {
        (this.autoStart = e),
          (this.startTime = 0),
          (this.oldTime = 0),
          (this.elapsedTime = 0),
          (this.running = !1);
      }
      start() {
        (this.startTime = Pd()),
          (this.oldTime = this.startTime),
          (this.elapsedTime = 0),
          (this.running = !0);
      }
      stop() {
        this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
      }
      getElapsedTime() {
        return this.getDelta(), this.elapsedTime;
      }
      getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
          const t = Pd();
          (e = (t - this.oldTime) / 1e3),
            (this.oldTime = t),
            (this.elapsedTime += e);
        }
        return e;
      }
    }

    function Pd() {
      return ("undefined" == typeof performance ? Date : performance).now();
    }
    const Ld = new sr(),
      Rd = new ar(),
      Id = new sr(),
      kd = new sr();
    class Dd extends ci {
      constructor() {
        super(),
          (this.type = "AudioListener"),
          (this.context = wd.getContext()),
          (this.gain = this.context.createGain()),
          this.gain.connect(this.context.destination),
          (this.filter = null),
          (this.timeDelta = 0),
          (this._clock = new Cd());
      }
      getInput() {
        return this.gain;
      }
      removeFilter() {
        return (
          null !== this.filter &&
            (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            (this.filter = null)),
          this
        );
      }
      getFilter() {
        return this.filter;
      }
      setFilter(e) {
        return (
          null !== this.filter
            ? (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination))
            : this.gain.disconnect(this.context.destination),
          (this.filter = e),
          this.gain.connect(this.filter),
          this.filter.connect(this.context.destination),
          this
        );
      }
      getMasterVolume() {
        return this.gain.gain.value;
      }
      setMasterVolume(e) {
        return (
          this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
          this
        );
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener,
          n = this.up;
        if (
          ((this.timeDelta = this._clock.getDelta()),
          this.matrixWorld.decompose(Ld, Rd, Id),
          kd.set(0, 0, -1).applyQuaternion(Rd),
          t.positionX)
        ) {
          const e = this.context.currentTime + this.timeDelta;
          t.positionX.linearRampToValueAtTime(Ld.x, e),
            t.positionY.linearRampToValueAtTime(Ld.y, e),
            t.positionZ.linearRampToValueAtTime(Ld.z, e),
            t.forwardX.linearRampToValueAtTime(kd.x, e),
            t.forwardY.linearRampToValueAtTime(kd.y, e),
            t.forwardZ.linearRampToValueAtTime(kd.z, e),
            t.upX.linearRampToValueAtTime(n.x, e),
            t.upY.linearRampToValueAtTime(n.y, e),
            t.upZ.linearRampToValueAtTime(n.z, e);
        } else
          t.setPosition(Ld.x, Ld.y, Ld.z),
            t.setOrientation(kd.x, kd.y, kd.z, n.x, n.y, n.z);
      }
    }
    class Od extends ci {
      constructor(e) {
        super(),
          (this.type = "Audio"),
          (this.listener = e),
          (this.context = e.context),
          (this.gain = this.context.createGain()),
          this.gain.connect(e.getInput()),
          (this.autoplay = !1),
          (this.buffer = null),
          (this.detune = 0),
          (this.loop = !1),
          (this.loopStart = 0),
          (this.loopEnd = 0),
          (this.offset = 0),
          (this.duration = void 0),
          (this.playbackRate = 1),
          (this.isPlaying = !1),
          (this.hasPlaybackControl = !0),
          (this.source = null),
          (this.sourceType = "empty"),
          (this._startedAt = 0),
          (this._progress = 0),
          (this._connected = !1),
          (this.filters = []);
      }
      getOutput() {
        return this.gain;
      }
      setNodeSource(e) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "audioNode"),
          (this.source = e),
          this.connect(),
          this
        );
      }
      setMediaElementSource(e) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "mediaNode"),
          (this.source = this.context.createMediaElementSource(e)),
          this.connect(),
          this
        );
      }
      setMediaStreamSource(e) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "mediaStreamNode"),
          (this.source = this.context.createMediaStreamSource(e)),
          this.connect(),
          this
        );
      }
      setBuffer(e) {
        return (
          (this.buffer = e),
          (this.sourceType = "buffer"),
          this.autoplay && this.play(),
          this
        );
      }
      play(e = 0) {
        if (!0 === this.isPlaying)
          return void console.warn("THREE.Audio: Audio is already playing.");
        if (!1 === this.hasPlaybackControl)
          return void console.warn(
            "THREE.Audio: this Audio has no playback control."
          );
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return (
          (t.buffer = this.buffer),
          (t.loop = this.loop),
          (t.loopStart = this.loopStart),
          (t.loopEnd = this.loopEnd),
          (t.onended = this.onEnded.bind(this)),
          t.start(this._startedAt, this._progress + this.offset, this.duration),
          (this.isPlaying = !0),
          (this.source = t),
          this.setDetune(this.detune),
          this.setPlaybackRate(this.playbackRate),
          this.connect()
        );
      }
      pause() {
        if (!1 !== this.hasPlaybackControl)
          return (
            !0 === this.isPlaying &&
              ((this._progress +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              !0 === this.loop &&
                (this._progress =
                  this._progress % (this.duration || this.buffer.duration)),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      stop() {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this._progress = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let e = 1, t = this.filters.length; e < t; e++)
            this.filters[e - 1].connect(this.filters[e]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return (this._connected = !0), this;
      }
      disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let e = 1, t = this.filters.length; e < t; e++)
            this.filters[e - 1].disconnect(this.filters[e]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return (this._connected = !1), this;
      }
      getFilters() {
        return this.filters;
      }
      setFilters(e) {
        return (
          e || (e = []),
          !0 === this._connected
            ? (this.disconnect(), (this.filters = e.slice()), this.connect())
            : (this.filters = e.slice()),
          this
        );
      }
      setDetune(e) {
        if (((this.detune = e), void 0 !== this.source.detune))
          return (
            !0 === this.isPlaying &&
              this.source.detune.setTargetAtTime(
                this.detune,
                this.context.currentTime,
                0.01
              ),
            this
          );
      }
      getDetune() {
        return this.detune;
      }
      getFilter() {
        return this.getFilters()[0];
      }
      setFilter(e) {
        return this.setFilters(e ? [e] : []);
      }
      setPlaybackRate(e) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.playbackRate = e),
            !0 === this.isPlaying &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01
              ),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      getPlaybackRate() {
        return this.playbackRate;
      }
      onEnded() {
        this.isPlaying = !1;
      }
      getLoop() {
        return !1 === this.hasPlaybackControl
          ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1)
          : this.loop;
      }
      setLoop(e) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.loop = e),
            !0 === this.isPlaying && (this.source.loop = this.loop),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      }
      setLoopStart(e) {
        return (this.loopStart = e), this;
      }
      setLoopEnd(e) {
        return (this.loopEnd = e), this;
      }
      getVolume() {
        return this.gain.gain.value;
      }
      setVolume(e) {
        return (
          this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
          this
        );
      }
    }
    const Bd = new sr(),
      Fd = new ar(),
      Nd = new sr(),
      Ud = new sr();
    class zd extends Od {
      constructor(e) {
        super(e),
          (this.panner = this.context.createPanner()),
          (this.panner.panningModel = "HRTF"),
          this.panner.connect(this.gain);
      }
      getOutput() {
        return this.panner;
      }
      getRefDistance() {
        return this.panner.refDistance;
      }
      setRefDistance(e) {
        return (this.panner.refDistance = e), this;
      }
      getRolloffFactor() {
        return this.panner.rolloffFactor;
      }
      setRolloffFactor(e) {
        return (this.panner.rolloffFactor = e), this;
      }
      getDistanceModel() {
        return this.panner.distanceModel;
      }
      setDistanceModel(e) {
        return (this.panner.distanceModel = e), this;
      }
      getMaxDistance() {
        return this.panner.maxDistance;
      }
      setMaxDistance(e) {
        return (this.panner.maxDistance = e), this;
      }
      setDirectionalCone(e, t, n) {
        return (
          (this.panner.coneInnerAngle = e),
          (this.panner.coneOuterAngle = t),
          (this.panner.coneOuterGain = n),
          this
        );
      }
      updateMatrixWorld(e) {
        if (
          (super.updateMatrixWorld(e),
          !0 === this.hasPlaybackControl && !1 === this.isPlaying)
        )
          return;
        this.matrixWorld.decompose(Bd, Fd, Nd),
          Ud.set(0, 0, 1).applyQuaternion(Fd);
        const t = this.panner;
        if (t.positionX) {
          const e = this.context.currentTime + this.listener.timeDelta;
          t.positionX.linearRampToValueAtTime(Bd.x, e),
            t.positionY.linearRampToValueAtTime(Bd.y, e),
            t.positionZ.linearRampToValueAtTime(Bd.z, e),
            t.orientationX.linearRampToValueAtTime(Ud.x, e),
            t.orientationY.linearRampToValueAtTime(Ud.y, e),
            t.orientationZ.linearRampToValueAtTime(Ud.z, e);
        } else
          t.setPosition(Bd.x, Bd.y, Bd.z), t.setOrientation(Ud.x, Ud.y, Ud.z);
      }
    }
    class Hd {
      constructor(e, t = 2048) {
        (this.analyser = e.context.createAnalyser()),
          (this.analyser.fftSize = t),
          (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
          e.getOutput().connect(this.analyser);
      }
      getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data;
      }
      getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let n = 0; n < t.length; n++) e += t[n];
        return e / t.length;
      }
    }
    class Gd {
      constructor(e, t, n) {
        let r, i, o;
        switch (((this.binding = e), (this.valueSize = n), t)) {
          case "quaternion":
            (r = this._slerp),
              (i = this._slerpAdditive),
              (o = this._setAdditiveIdentityQuaternion),
              (this.buffer = new Float64Array(6 * n)),
              (this._workIndex = 5);
            break;
          case "string":
          case "bool":
            (r = this._select),
              (i = this._select),
              (o = this._setAdditiveIdentityOther),
              (this.buffer = new Array(5 * n));
            break;
          default:
            (r = this._lerp),
              (i = this._lerpAdditive),
              (o = this._setAdditiveIdentityNumeric),
              (this.buffer = new Float64Array(5 * n));
        }
        (this._mixBufferRegion = r),
          (this._mixBufferRegionAdditive = i),
          (this._setIdentity = o),
          (this._origIndex = 3),
          (this._addIndex = 4),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          (this.useCount = 0),
          (this.referenceCount = 0);
      }
      accumulate(e, t) {
        const n = this.buffer,
          r = this.valueSize,
          i = e * r + r;
        let o = this.cumulativeWeight;
        if (0 === o) {
          for (let e = 0; e !== r; ++e) n[i + e] = n[e];
          o = t;
        } else {
          o += t;
          const e = t / o;
          this._mixBufferRegion(n, i, 0, e, r);
        }
        this.cumulativeWeight = o;
      }
      accumulateAdditive(e) {
        const t = this.buffer,
          n = this.valueSize,
          r = n * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(),
          this._mixBufferRegionAdditive(t, r, 0, e, n),
          (this.cumulativeWeightAdditive += e);
      }
      apply(e) {
        const t = this.valueSize,
          n = this.buffer,
          r = e * t + t,
          i = this.cumulativeWeight,
          o = this.cumulativeWeightAdditive,
          a = this.binding;
        if (
          ((this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0),
          i < 1)
        ) {
          const e = t * this._origIndex;
          this._mixBufferRegion(n, r, e, 1 - i, t);
        }
        o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
        for (let e = t, i = t + t; e !== i; ++e)
          if (n[e] !== n[e + t]) {
            a.setValue(n, r);
            break;
          }
      }
      saveOriginalState() {
        const e = this.binding,
          t = this.buffer,
          n = this.valueSize,
          r = n * this._origIndex;
        e.getValue(t, r);
        for (let e = n, i = r; e !== i; ++e) t[e] = t[r + (e % n)];
        this._setIdentity(),
          (this.cumulativeWeight = 0),
          (this.cumulativeWeightAdditive = 0);
      }
      restoreOriginalState() {
        const e = 3 * this.valueSize;
        this.binding.setValue(this.buffer, e);
      }
      _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
          t = e + this.valueSize;
        for (let n = e; n < t; n++) this.buffer[n] = 0;
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
          (this.buffer[this._addIndex * this.valueSize + 3] = 1);
      }
      _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
          t = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++)
          this.buffer[t + n] = this.buffer[e + n];
      }
      _select(e, t, n, r, i) {
        if (r >= 0.5) for (let r = 0; r !== i; ++r) e[t + r] = e[n + r];
      }
      _slerp(e, t, n, r) {
        ar.slerpFlat(e, t, e, t, e, n, r);
      }
      _slerpAdditive(e, t, n, r, i) {
        const o = this._workIndex * i;
        ar.multiplyQuaternionsFlat(e, o, e, t, e, n),
          ar.slerpFlat(e, t, e, t, e, o, r);
      }
      _lerp(e, t, n, r, i) {
        const o = 1 - r;
        for (let a = 0; a !== i; ++a) {
          const i = t + a;
          e[i] = e[i] * o + e[n + a] * r;
        }
      }
      _lerpAdditive(e, t, n, r, i) {
        for (let o = 0; o !== i; ++o) {
          const i = t + o;
          e[i] = e[i] + e[n + o] * r;
        }
      }
    }
    const Vd = new RegExp("[\\[\\]\\.:\\/]", "g"),
      jd = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      Wd = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      qd = /(WCOD+)?/.source.replace("WCOD", jd),
      $d = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      Xd = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      Yd = new RegExp("^" + Wd + qd + $d + Xd + "$"),
      Jd = ["material", "materials", "bones"];
    class Zd {
      constructor(e, t, n) {
        (this.path = t),
          (this.parsedPath = n || Zd.parseTrackName(t)),
          (this.node = Zd.findNode(e, this.parsedPath.nodeName) || e),
          (this.rootNode = e),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
      static create(e, t, n) {
        return e && e.isAnimationObjectGroup
          ? new Zd.Composite(e, t, n)
          : new Zd(e, t, n);
      }
      static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(Vd, "");
      }
      static parseTrackName(e) {
        const t = Yd.exec(e);
        if (!t)
          throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6],
          },
          r = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== r && -1 !== r) {
          const e = n.nodeName.substring(r + 1);
          -1 !== Jd.indexOf(e) &&
            ((n.nodeName = n.nodeName.substring(0, r)), (n.objectName = e));
        }
        if (null === n.propertyName || 0 === n.propertyName.length)
          throw new Error(
            "PropertyBinding: can not parse propertyName from trackName: " + e
          );
        return n;
      }
      static findNode(e, t) {
        if (
          !t ||
          "" === t ||
          "." === t ||
          -1 === t ||
          t === e.name ||
          t === e.uuid
        )
          return e;
        if (e.skeleton) {
          const n = e.skeleton.getBoneByName(t);
          if (void 0 !== n) return n;
        }
        if (e.children) {
          const n = function (e) {
              for (let r = 0; r < e.length; r++) {
                const i = e[r];
                if (i.name === t || i.uuid === t) return i;
                const o = n(i.children);
                if (o) return o;
              }
              return null;
            },
            r = n(e.children);
          if (r) return r;
        }
        return null;
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName];
      }
      _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let r = 0, i = n.length; r !== i; ++r) e[t++] = n[r];
      }
      _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
      }
      _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
      }
      _setValue_direct_setNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        (this.targetObject[this.propertyName] = e[t]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
      }
      _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
        this.targetObject.needsUpdate = !0;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
      _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
      }
      _setValue_arrayElement_setNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        (this.resolvedProperty[this.propertyIndex] = e[t]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
      }
      _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
      }
      _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
      }
      bind() {
        let e = this.node;
        const t = this.parsedPath,
          n = t.objectName,
          r = t.propertyName;
        let i = t.propertyIndex;
        if (
          (e ||
            ((e = Zd.findNode(this.rootNode, t.nodeName) || this.rootNode),
            (this.node = e)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          !e)
        )
          return void console.error(
            "THREE.PropertyBinding: Trying to update node for track: " +
              this.path +
              " but it wasn't found."
          );
        if (n) {
          let r = t.objectIndex;
          switch (n) {
            case "materials":
              if (!e.material)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
              if (!e.material.materials)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
              e = e.material.materials;
              break;
            case "bones":
              if (!e.skeleton)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
              e = e.skeleton.bones;
              for (let t = 0; t < e.length; t++)
                if (e[t].name === r) {
                  r = t;
                  break;
                }
              break;
            default:
              if (void 0 === e[n])
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
              e = e[n];
          }
          if (void 0 !== r) {
            if (void 0 === e[r])
              return void console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                e
              );
            e = e[r];
          }
        }
        const o = e[r];
        if (void 0 === o) {
          const n = t.nodeName;
          return void console.error(
            "THREE.PropertyBinding: Trying to update property for track: " +
              n +
              "." +
              r +
              " but it wasn't found.",
            e
          );
        }
        let a = this.Versioning.None;
        (this.targetObject = e),
          void 0 !== e.needsUpdate
            ? (a = this.Versioning.NeedsUpdate)
            : void 0 !== e.matrixWorldNeedsUpdate &&
              (a = this.Versioning.MatrixWorldNeedsUpdate);
        let s = this.BindingType.Direct;
        if (void 0 !== i) {
          if ("morphTargetInfluences" === r) {
            if (!e.geometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                this
              );
            if (!e.geometry.isBufferGeometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                this
              );
            if (!e.geometry.morphAttributes)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                this
              );
            void 0 !== e.morphTargetDictionary[i] &&
              (i = e.morphTargetDictionary[i]);
          }
          (s = this.BindingType.ArrayElement),
            (this.resolvedProperty = o),
            (this.propertyIndex = i);
        } else
          void 0 !== o.fromArray && void 0 !== o.toArray
            ? ((s = this.BindingType.HasFromToArray),
              (this.resolvedProperty = o))
            : Array.isArray(o)
            ? ((s = this.BindingType.EntireArray), (this.resolvedProperty = o))
            : (this.propertyName = r);
        (this.getValue = this.GetterByBindingType[s]),
          (this.setValue = this.SetterByBindingTypeAndVersioning[s][a]);
      }
      unbind() {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
    }
    (Zd.Composite = class {
      constructor(e, t, n) {
        const r = n || Zd.parseTrackName(t);
        (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
      }
      getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
          r = this._bindings[n];
        void 0 !== r && r.getValue(e, t);
      }
      setValue(e, t) {
        const n = this._bindings;
        for (
          let r = this._targetGroup.nCachedObjects_, i = n.length;
          r !== i;
          ++r
        )
          n[r].setValue(e, t);
      }
      bind() {
        const e = this._bindings;
        for (
          let t = this._targetGroup.nCachedObjects_, n = e.length;
          t !== n;
          ++t
        )
          e[t].bind();
      }
      unbind() {
        const e = this._bindings;
        for (
          let t = this._targetGroup.nCachedObjects_, n = e.length;
          t !== n;
          ++t
        )
          e[t].unbind();
      }
    }),
      (Zd.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      }),
      (Zd.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      }),
      (Zd.prototype.GetterByBindingType = [
        Zd.prototype._getValue_direct,
        Zd.prototype._getValue_array,
        Zd.prototype._getValue_arrayElement,
        Zd.prototype._getValue_toArray,
      ]),
      (Zd.prototype.SetterByBindingTypeAndVersioning = [
        [
          Zd.prototype._setValue_direct,
          Zd.prototype._setValue_direct_setNeedsUpdate,
          Zd.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          Zd.prototype._setValue_array,
          Zd.prototype._setValue_array_setNeedsUpdate,
          Zd.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          Zd.prototype._setValue_arrayElement,
          Zd.prototype._setValue_arrayElement_setNeedsUpdate,
          Zd.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          Zd.prototype._setValue_fromArray,
          Zd.prototype._setValue_fromArray_setNeedsUpdate,
          Zd.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ]);
    class Kd {
      constructor() {
        (this.uuid = Hn()),
          (this._objects = Array.prototype.slice.call(arguments)),
          (this.nCachedObjects_ = 0);
        const e = {};
        this._indicesByUUID = e;
        for (let t = 0, n = arguments.length; t !== n; ++t)
          e[arguments[t].uuid] = t;
        (this._paths = []),
          (this._parsedPaths = []),
          (this._bindings = []),
          (this._bindingsIndicesByPath = {});
        const t = this;
        this.stats = {
          objects: {
            get total() {
              return t._objects.length;
            },
            get inUse() {
              return this.total - t.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return t._bindings.length;
          },
        };
      }
      add() {
        const e = this._objects,
          t = this._indicesByUUID,
          n = this._paths,
          r = this._parsedPaths,
          i = this._bindings,
          o = i.length;
        let a = void 0,
          s = e.length,
          l = this.nCachedObjects_;
        for (let c = 0, u = arguments.length; c !== u; ++c) {
          const u = arguments[c],
            h = u.uuid;
          let d = t[h];
          if (void 0 === d) {
            (d = s++), (t[h] = d), e.push(u);
            for (let e = 0, t = o; e !== t; ++e)
              i[e].push(new Zd(u, n[e], r[e]));
          } else if (d < l) {
            a = e[d];
            const s = --l,
              c = e[s];
            (t[c.uuid] = d), (e[d] = c), (t[h] = s), (e[s] = u);
            for (let e = 0, t = o; e !== t; ++e) {
              const t = i[e],
                o = t[s];
              let a = t[d];
              (t[d] = o),
                void 0 === a && (a = new Zd(u, n[e], r[e])),
                (t[s] = a);
            }
          } else
            e[d] !== a &&
              console.error(
                "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
              );
        }
        this.nCachedObjects_ = l;
      }
      remove() {
        const e = this._objects,
          t = this._indicesByUUID,
          n = this._bindings,
          r = n.length;
        let i = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
          const a = arguments[o],
            s = a.uuid,
            l = t[s];
          if (void 0 !== l && l >= i) {
            const o = i++,
              c = e[o];
            (t[c.uuid] = l), (e[l] = c), (t[s] = o), (e[o] = a);
            for (let e = 0, t = r; e !== t; ++e) {
              const t = n[e],
                r = t[o],
                i = t[l];
              (t[l] = r), (t[o] = i);
            }
          }
        }
        this.nCachedObjects_ = i;
      }
      uncache() {
        const e = this._objects,
          t = this._indicesByUUID,
          n = this._bindings,
          r = n.length;
        let i = this.nCachedObjects_,
          o = e.length;
        for (let a = 0, s = arguments.length; a !== s; ++a) {
          const s = arguments[a].uuid,
            l = t[s];
          if (void 0 !== l)
            if ((delete t[s], l < i)) {
              const a = --i,
                s = e[a],
                c = --o,
                u = e[c];
              (t[s.uuid] = l), (e[l] = s), (t[u.uuid] = a), (e[a] = u), e.pop();
              for (let e = 0, t = r; e !== t; ++e) {
                const t = n[e],
                  r = t[a],
                  i = t[c];
                (t[l] = r), (t[a] = i), t.pop();
              }
            } else {
              const i = --o,
                a = e[i];
              i > 0 && (t[a.uuid] = l), (e[l] = a), e.pop();
              for (let e = 0, t = r; e !== t; ++e) {
                const t = n[e];
                (t[l] = t[i]), t.pop();
              }
            }
        }
        this.nCachedObjects_ = i;
      }
      subscribe_(e, t) {
        const n = this._bindingsIndicesByPath;
        let r = n[e];
        const i = this._bindings;
        if (void 0 !== r) return i[r];
        const o = this._paths,
          a = this._parsedPaths,
          s = this._objects,
          l = s.length,
          c = this.nCachedObjects_,
          u = new Array(l);
        (r = i.length), (n[e] = r), o.push(e), a.push(t), i.push(u);
        for (let n = c, r = s.length; n !== r; ++n) {
          const r = s[n];
          u[n] = new Zd(r, e, t);
        }
        return u;
      }
      unsubscribe_(e) {
        const t = this._bindingsIndicesByPath,
          n = t[e];
        if (void 0 !== n) {
          const r = this._paths,
            i = this._parsedPaths,
            o = this._bindings,
            a = o.length - 1,
            s = o[a];
          (t[e[a]] = n),
            (o[n] = s),
            o.pop(),
            (i[n] = i[a]),
            i.pop(),
            (r[n] = r[a]),
            r.pop();
        }
      }
    }
    Kd.prototype.isAnimationObjectGroup = !0;
    class Qd {
      constructor(e, t, n = null, r = t.blendMode) {
        (this._mixer = e),
          (this._clip = t),
          (this._localRoot = n),
          (this.blendMode = r);
        const i = t.tracks,
          o = i.length,
          a = new Array(o),
          s = {
            endingStart: Gt,
            endingEnd: Gt,
          };
        for (let e = 0; e !== o; ++e) {
          const t = i[e].createInterpolant(null);
          (a[e] = t), (t.settings = s);
        }
        (this._interpolantSettings = s),
          (this._interpolants = a),
          (this._propertyBindings = new Array(o)),
          (this._cacheIndex = null),
          (this._byClipCacheIndex = null),
          (this._timeScaleInterpolant = null),
          (this._weightInterpolant = null),
          (this.loop = Ft),
          (this._loopCount = -1),
          (this._startTime = null),
          (this.time = 0),
          (this.timeScale = 1),
          (this._effectiveTimeScale = 1),
          (this.weight = 1),
          (this._effectiveWeight = 1),
          (this.repetitions = 1 / 0),
          (this.paused = !1),
          (this.enabled = !0),
          (this.clampWhenFinished = !1),
          (this.zeroSlopeAtStart = !0),
          (this.zeroSlopeAtEnd = !0);
      }
      play() {
        return this._mixer._activateAction(this), this;
      }
      stop() {
        return this._mixer._deactivateAction(this), this.reset();
      }
      reset() {
        return (
          (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null),
          this.stopFading().stopWarping()
        );
      }
      isRunning() {
        return (
          this.enabled &&
          !this.paused &&
          0 !== this.timeScale &&
          null === this._startTime &&
          this._mixer._isActiveAction(this)
        );
      }
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(e) {
        return (this._startTime = e), this;
      }
      setLoop(e, t) {
        return (this.loop = e), (this.repetitions = t), this;
      }
      setEffectiveWeight(e) {
        return (
          (this.weight = e),
          (this._effectiveWeight = this.enabled ? e : 0),
          this.stopFading()
        );
      }
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(e) {
        return this._scheduleFading(e, 0, 1);
      }
      fadeOut(e) {
        return this._scheduleFading(e, 1, 0);
      }
      crossFadeFrom(e, t, n) {
        if ((e.fadeOut(t), this.fadeIn(t), n)) {
          const n = this._clip.duration,
            r = e._clip.duration,
            i = r / n,
            o = n / r;
          e.warp(1, i, t), this.warp(o, 1, t);
        }
        return this;
      }
      crossFadeTo(e, t, n) {
        return e.crossFadeFrom(this, t, n);
      }
      stopFading() {
        const e = this._weightInterpolant;
        return (
          null !== e &&
            ((this._weightInterpolant = null),
            this._mixer._takeBackControlInterpolant(e)),
          this
        );
      }
      setEffectiveTimeScale(e) {
        return (
          (this.timeScale = e),
          (this._effectiveTimeScale = this.paused ? 0 : e),
          this.stopWarping()
        );
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(e) {
        return (this.timeScale = this._clip.duration / e), this.stopWarping();
      }
      syncWith(e) {
        return (
          (this.time = e.time),
          (this.timeScale = e.timeScale),
          this.stopWarping()
        );
      }
      halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e);
      }
      warp(e, t, n) {
        const r = this._mixer,
          i = r.time,
          o = this.timeScale;
        let a = this._timeScaleInterpolant;
        null === a &&
          ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a));
        const s = a.parameterPositions,
          l = a.sampleValues;
        return (s[0] = i), (s[1] = i + n), (l[0] = e / o), (l[1] = t / o), this;
      }
      stopWarping() {
        const e = this._timeScaleInterpolant;
        return (
          null !== e &&
            ((this._timeScaleInterpolant = null),
            this._mixer._takeBackControlInterpolant(e)),
          this
        );
      }
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      _update(e, t, n, r) {
        if (!this.enabled) return void this._updateWeight(e);
        const i = this._startTime;
        if (null !== i) {
          const r = (e - i) * n;
          if (r < 0 || 0 === n) return;
          (this._startTime = null), (t = n * r);
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t),
          a = this._updateWeight(e);
        if (a > 0) {
          const e = this._interpolants,
            t = this._propertyBindings;
          switch (this.blendMode) {
            case qt:
              for (let n = 0, r = e.length; n !== r; ++n)
                e[n].evaluate(o), t[n].accumulateAdditive(a);
              break;
            case Wt:
            default:
              for (let n = 0, i = e.length; n !== i; ++n)
                e[n].evaluate(o), t[n].accumulate(r, a);
          }
        }
      }
      _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
          t = this.weight;
          const n = this._weightInterpolant;
          if (null !== n) {
            const r = n.evaluate(e)[0];
            (t *= r),
              e > n.parameterPositions[1] &&
                (this.stopFading(), 0 === r && (this.enabled = !1));
          }
        }
        return (this._effectiveWeight = t), t;
      }
      _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
          t = this.timeScale;
          const n = this._timeScaleInterpolant;
          if (null !== n) {
            (t *= n.evaluate(e)[0]),
              e > n.parameterPositions[1] &&
                (this.stopWarping(),
                0 === t ? (this.paused = !0) : (this.timeScale = t));
          }
        }
        return (this._effectiveTimeScale = t), t;
      }
      _updateTime(e) {
        const t = this._clip.duration,
          n = this.loop;
        let r = this.time + e,
          i = this._loopCount;
        const o = n === Nt;
        if (0 === e) return -1 === i ? r : o && 1 == (1 & i) ? t - r : r;
        if (n === Bt) {
          -1 === i && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          e: {
            if (r >= t) r = t;
            else {
              if (!(r < 0)) {
                this.time = r;
                break e;
              }
              r = 0;
            }
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (this.time = r),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e < 0 ? -1 : 1,
              });
          }
        } else {
          if (
            (-1 === i &&
              (e >= 0
                ? ((i = 0), this._setEndings(!0, 0 === this.repetitions, o))
                : this._setEndings(0 === this.repetitions, !0, o)),
            r >= t || r < 0)
          ) {
            const n = Math.floor(r / t);
            (r -= t * n), (i += Math.abs(n));
            const a = this.repetitions - i;
            if (a <= 0)
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (r = e > 0 ? t : 0),
                (this.time = r),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e > 0 ? 1 : -1,
                });
            else {
              if (1 === a) {
                const t = e < 0;
                this._setEndings(t, !t, o);
              } else this._setEndings(!1, !1, o);
              (this._loopCount = i),
                (this.time = r),
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: n,
                });
            }
          } else this.time = r;
          if (o && 1 == (1 & i)) return t - r;
        }
        return r;
      }
      _setEndings(e, t, n) {
        const r = this._interpolantSettings;
        n
          ? ((r.endingStart = Vt), (r.endingEnd = Vt))
          : ((r.endingStart = e ? (this.zeroSlopeAtStart ? Vt : Gt) : jt),
            (r.endingEnd = t ? (this.zeroSlopeAtEnd ? Vt : Gt) : jt));
      }
      _scheduleFading(e, t, n) {
        const r = this._mixer,
          i = r.time;
        let o = this._weightInterpolant;
        null === o &&
          ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
        const a = o.parameterPositions,
          s = o.sampleValues;
        return (a[0] = i), (s[0] = t), (a[1] = i + e), (s[1] = n), this;
      }
    }
    class ep extends Bn {
      constructor(e) {
        super(),
          (this._root = e),
          this._initMemoryManager(),
          (this._accuIndex = 0),
          (this.time = 0),
          (this.timeScale = 1);
      }
      _bindAction(e, t) {
        const n = e._localRoot || this._root,
          r = e._clip.tracks,
          i = r.length,
          o = e._propertyBindings,
          a = e._interpolants,
          s = n.uuid,
          l = this._bindingsByRootAndName;
        let c = l[s];
        void 0 === c && ((c = {}), (l[s] = c));
        for (let e = 0; e !== i; ++e) {
          const i = r[e],
            l = i.name;
          let u = c[l];
          if (void 0 !== u) o[e] = u;
          else {
            if (((u = o[e]), void 0 !== u)) {
              null === u._cacheIndex &&
                (++u.referenceCount, this._addInactiveBinding(u, s, l));
              continue;
            }
            const r = t && t._propertyBindings[e].binding.parsedPath;
            (u = new Gd(Zd.create(n, l, r), i.ValueTypeName, i.getValueSize())),
              ++u.referenceCount,
              this._addInactiveBinding(u, s, l),
              (o[e] = u);
          }
          a[e].resultBuffer = u.buffer;
        }
      }
      _activateAction(e) {
        if (!this._isActiveAction(e)) {
          if (null === e._cacheIndex) {
            const t = (e._localRoot || this._root).uuid,
              n = e._clip.uuid,
              r = this._actionsByClip[n];
            this._bindAction(e, r && r.knownActions[0]),
              this._addInactiveAction(e, n, t);
          }
          const t = e._propertyBindings;
          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
          }
          this._lendAction(e);
        }
      }
      _deactivateAction(e) {
        if (this._isActiveAction(e)) {
          const t = e._propertyBindings;
          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == --n.useCount &&
              (n.restoreOriginalState(), this._takeBackBinding(n));
          }
          this._takeBackAction(e);
        }
      }
      _initMemoryManager() {
        (this._actions = []),
          (this._nActiveActions = 0),
          (this._actionsByClip = {}),
          (this._bindings = []),
          (this._nActiveBindings = 0),
          (this._bindingsByRootAndName = {}),
          (this._controlInterpolants = []),
          (this._nActiveControlInterpolants = 0);
        const e = this;
        this.stats = {
          actions: {
            get total() {
              return e._actions.length;
            },
            get inUse() {
              return e._nActiveActions;
            },
          },
          bindings: {
            get total() {
              return e._bindings.length;
            },
            get inUse() {
              return e._nActiveBindings;
            },
          },
          controlInterpolants: {
            get total() {
              return e._controlInterpolants.length;
            },
            get inUse() {
              return e._nActiveControlInterpolants;
            },
          },
        };
      }
      _isActiveAction(e) {
        const t = e._cacheIndex;
        return null !== t && t < this._nActiveActions;
      }
      _addInactiveAction(e, t, n) {
        const r = this._actions,
          i = this._actionsByClip;
        let o = i[t];
        if (void 0 === o)
          (o = {
            knownActions: [e],
            actionByRoot: {},
          }),
            (e._byClipCacheIndex = 0),
            (i[t] = o);
        else {
          const t = o.knownActions;
          (e._byClipCacheIndex = t.length), t.push(e);
        }
        (e._cacheIndex = r.length), r.push(e), (o.actionByRoot[n] = e);
      }
      _removeInactiveAction(e) {
        const t = this._actions,
          n = t[t.length - 1],
          r = e._cacheIndex;
        (n._cacheIndex = r), (t[r] = n), t.pop(), (e._cacheIndex = null);
        const i = e._clip.uuid,
          o = this._actionsByClip,
          a = o[i],
          s = a.knownActions,
          l = s[s.length - 1],
          c = e._byClipCacheIndex;
        (l._byClipCacheIndex = c),
          (s[c] = l),
          s.pop(),
          (e._byClipCacheIndex = null),
          delete a.actionByRoot[(e._localRoot || this._root).uuid],
          0 === s.length && delete o[i],
          this._removeInactiveBindingsForAction(e);
      }
      _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let e = 0, n = t.length; e !== n; ++e) {
          const n = t[e];
          0 == --n.referenceCount && this._removeInactiveBinding(n);
        }
      }
      _lendAction(e) {
        const t = this._actions,
          n = e._cacheIndex,
          r = this._nActiveActions++,
          i = t[r];
        (e._cacheIndex = r), (t[r] = e), (i._cacheIndex = n), (t[n] = i);
      }
      _takeBackAction(e) {
        const t = this._actions,
          n = e._cacheIndex,
          r = --this._nActiveActions,
          i = t[r];
        (e._cacheIndex = r), (t[r] = e), (i._cacheIndex = n), (t[n] = i);
      }
      _addInactiveBinding(e, t, n) {
        const r = this._bindingsByRootAndName,
          i = this._bindings;
        let o = r[t];
        void 0 === o && ((o = {}), (r[t] = o)),
          (o[n] = e),
          (e._cacheIndex = i.length),
          i.push(e);
      }
      _removeInactiveBinding(e) {
        const t = this._bindings,
          n = e.binding,
          r = n.rootNode.uuid,
          i = n.path,
          o = this._bindingsByRootAndName,
          a = o[r],
          s = t[t.length - 1],
          l = e._cacheIndex;
        (s._cacheIndex = l),
          (t[l] = s),
          t.pop(),
          delete a[i],
          0 === Object.keys(a).length && delete o[r];
      }
      _lendBinding(e) {
        const t = this._bindings,
          n = e._cacheIndex,
          r = this._nActiveBindings++,
          i = t[r];
        (e._cacheIndex = r), (t[r] = e), (i._cacheIndex = n), (t[n] = i);
      }
      _takeBackBinding(e) {
        const t = this._bindings,
          n = e._cacheIndex,
          r = --this._nActiveBindings,
          i = t[r];
        (e._cacheIndex = r), (t[r] = e), (i._cacheIndex = n), (t[n] = i);
      }
      _lendControlInterpolant() {
        const e = this._controlInterpolants,
          t = this._nActiveControlInterpolants++;
        let n = e[t];
        return (
          void 0 === n &&
            ((n = new mh(
              new Float32Array(2),
              new Float32Array(2),
              1,
              this._controlInterpolantsResultBuffer
            )),
            (n.__cacheIndex = t),
            (e[t] = n)),
          n
        );
      }
      _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants,
          n = e.__cacheIndex,
          r = --this._nActiveControlInterpolants,
          i = t[r];
        (e.__cacheIndex = r), (t[r] = e), (i.__cacheIndex = n), (t[n] = i);
      }
      clipAction(e, t, n) {
        const r = t || this._root,
          i = r.uuid;
        let o = "string" == typeof e ? Th.findByName(r, e) : e;
        const a = null !== o ? o.uuid : e,
          s = this._actionsByClip[a];
        let l = null;
        if (
          (void 0 === n && (n = null !== o ? o.blendMode : Wt), void 0 !== s)
        ) {
          const e = s.actionByRoot[i];
          if (void 0 !== e && e.blendMode === n) return e;
          (l = s.knownActions[0]), null === o && (o = l._clip);
        }
        if (null === o) return null;
        const c = new Qd(this, o, t, n);
        return this._bindAction(c, l), this._addInactiveAction(c, a, i), c;
      }
      existingAction(e, t) {
        const n = t || this._root,
          r = n.uuid,
          i = "string" == typeof e ? Th.findByName(n, e) : e,
          o = i ? i.uuid : e,
          a = this._actionsByClip[o];
        return (void 0 !== a && a.actionByRoot[r]) || null;
      }
      stopAllAction() {
        const e = this._actions;
        for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
        return this;
      }
      update(e) {
        e *= this.timeScale;
        const t = this._actions,
          n = this._nActiveActions,
          r = (this.time += e),
          i = Math.sign(e),
          o = (this._accuIndex ^= 1);
        for (let a = 0; a !== n; ++a) {
          t[a]._update(r, e, i, o);
        }
        const a = this._bindings,
          s = this._nActiveBindings;
        for (let e = 0; e !== s; ++e) a[e].apply(o);
        return this;
      }
      setTime(e) {
        this.time = 0;
        for (let e = 0; e < this._actions.length; e++)
          this._actions[e].time = 0;
        return this.update(e);
      }
      getRoot() {
        return this._root;
      }
      uncacheClip(e) {
        const t = this._actions,
          n = e.uuid,
          r = this._actionsByClip,
          i = r[n];
        if (void 0 !== i) {
          const e = i.knownActions;
          for (let n = 0, r = e.length; n !== r; ++n) {
            const r = e[n];
            this._deactivateAction(r);
            const i = r._cacheIndex,
              o = t[t.length - 1];
            (r._cacheIndex = null),
              (r._byClipCacheIndex = null),
              (o._cacheIndex = i),
              (t[i] = o),
              t.pop(),
              this._removeInactiveBindingsForAction(r);
          }
          delete r[n];
        }
      }
      uncacheRoot(e) {
        const t = e.uuid,
          n = this._actionsByClip;
        for (const e in n) {
          const r = n[e].actionByRoot[t];
          void 0 !== r &&
            (this._deactivateAction(r), this._removeInactiveAction(r));
        }
        const r = this._bindingsByRootAndName[t];
        if (void 0 !== r)
          for (const e in r) {
            const t = r[e];
            t.restoreOriginalState(), this._removeInactiveBinding(t);
          }
      }
      uncacheAction(e, t) {
        const n = this.existingAction(e, t);
        null !== n &&
          (this._deactivateAction(n), this._removeInactiveAction(n));
      }
    }
    ep.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
    class tp {
      constructor(e) {
        "string" == typeof e &&
          (console.warn("THREE.Uniform: Type parameter is no longer needed."),
          (e = arguments[1])),
          (this.value = e);
      }
      clone() {
        return new tp(
          void 0 === this.value.clone ? this.value : this.value.clone()
        );
      }
    }
    class np extends Cl {
      constructor(e, t, n = 1) {
        super(e, t), (this.meshPerAttribute = n);
      }
      copy(e) {
        return (
          super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
        );
      }
      clone(e) {
        const t = super.clone(e);
        return (t.meshPerAttribute = this.meshPerAttribute), t;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return (
          (t.isInstancedInterleavedBuffer = !0),
          (t.meshPerAttribute = this.meshPerAttribute),
          t
        );
      }
    }
    np.prototype.isInstancedInterleavedBuffer = !0;
    class rp {
      constructor(e, t, n, r, i) {
        (this.buffer = e),
          (this.type = t),
          (this.itemSize = n),
          (this.elementSize = r),
          (this.count = i),
          (this.version = 0);
      }
      set needsUpdate(e) {
        !0 === e && this.version++;
      }
      setBuffer(e) {
        return (this.buffer = e), this;
      }
      setType(e, t) {
        return (this.type = e), (this.elementSize = t), this;
      }
      setItemSize(e) {
        return (this.itemSize = e), this;
      }
      setCount(e) {
        return (this.count = e), this;
      }
    }
    rp.prototype.isGLBufferAttribute = !0;
    class ip {
      constructor(e, t, n = 0, r = 1 / 0) {
        (this.ray = new Fr(e, t)),
          (this.near = n),
          (this.far = r),
          (this.camera = null),
          (this.layers = new Yr()),
          (this.params = {
            Mesh: {},
            Line: {
              threshold: 1,
            },
            LOD: {},
            Points: {
              threshold: 1,
            },
            Sprite: {},
          });
      }
      set(e, t) {
        this.ray.set(e, t);
      }
      setFromCamera(e, t) {
        t && t.isPerspectiveCamera
          ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction
              .set(e.x, e.y, 0.5)
              .unproject(t)
              .sub(this.ray.origin)
              .normalize(),
            (this.camera = t))
          : t && t.isOrthographicCamera
          ? (this.ray.origin
              .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
              .unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
            (this.camera = t))
          : console.error(
              "THREE.Raycaster: Unsupported camera type: " + t.type
            );
      }
      intersectObject(e, t = !1, n = []) {
        return ap(e, this, n, t), n.sort(op), n;
      }
      intersectObjects(e, t = !1, n = []) {
        for (let r = 0, i = e.length; r < i; r++) ap(e[r], this, n, t);
        return n.sort(op), n;
      }
    }

    function op(e, t) {
      return e.distance - t.distance;
    }

    function ap(e, t, n, r) {
      if ((e.layers.test(t.layers) && e.raycast(t, n), !0 === r)) {
        const r = e.children;
        for (let e = 0, i = r.length; e < i; e++) ap(r[e], t, n, !0);
      }
    }
    class sp {
      constructor(e = 1, t = 0, n = 0) {
        return (this.radius = e), (this.phi = t), (this.theta = n), this;
      }
      set(e, t, n) {
        return (this.radius = e), (this.phi = t), (this.theta = n), this;
      }
      copy(e) {
        return (
          (this.radius = e.radius),
          (this.phi = e.phi),
          (this.theta = e.theta),
          this
        );
      }
      makeSafe() {
        return (
          (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
        );
      }
      setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
      }
      setFromCartesianCoords(e, t, n) {
        return (
          (this.radius = Math.sqrt(e * e + t * t + n * n)),
          0 === this.radius
            ? ((this.theta = 0), (this.phi = 0))
            : ((this.theta = Math.atan2(e, n)),
              (this.phi = Math.acos(Gn(t / this.radius, -1, 1)))),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class lp {
      constructor(e = 1, t = 0, n = 0) {
        return (this.radius = e), (this.theta = t), (this.y = n), this;
      }
      set(e, t, n) {
        return (this.radius = e), (this.theta = t), (this.y = n), this;
      }
      copy(e) {
        return (
          (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
        );
      }
      setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z);
      }
      setFromCartesianCoords(e, t, n) {
        return (
          (this.radius = Math.sqrt(e * e + n * n)),
          (this.theta = Math.atan2(e, n)),
          (this.y = t),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const cp = new Yn();
    class up {
      constructor(e = new Yn(1 / 0, 1 / 0), t = new Yn(-1 / 0, -1 / 0)) {
        (this.min = e), (this.max = t);
      }
      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }
      setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this;
      }
      setFromCenterAndSize(e, t) {
        const n = cp.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = 1 / 0),
          (this.max.x = this.max.y = -1 / 0),
          this
        );
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
      getCenter(e) {
        return this.isEmpty()
          ? e.set(0, 0)
          : e.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
      }
      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }
      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }
      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }
      containsPoint(e) {
        return !(
          e.x < this.min.x ||
          e.x > this.max.x ||
          e.y < this.min.y ||
          e.y > this.max.y
        );
      }
      containsBox(e) {
        return (
          this.min.x <= e.min.x &&
          e.max.x <= this.max.x &&
          this.min.y <= e.min.y &&
          e.max.y <= this.max.y
        );
      }
      getParameter(e, t) {
        return t.set(
          (e.x - this.min.x) / (this.max.x - this.min.x),
          (e.y - this.min.y) / (this.max.y - this.min.y)
        );
      }
      intersectsBox(e) {
        return !(
          e.max.x < this.min.x ||
          e.min.x > this.max.x ||
          e.max.y < this.min.y ||
          e.min.y > this.max.y
        );
      }
      clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
      }
      distanceToPoint(e) {
        return cp.copy(e).clamp(this.min, this.max).sub(e).length();
      }
      intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this;
      }
      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }
      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }
      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }
    }
    up.prototype.isBox2 = !0;
    const hp = new sr(),
      dp = new sr();
    class pp {
      constructor(e = new sr(), t = new sr()) {
        (this.start = e), (this.end = t);
      }
      set(e, t) {
        return this.start.copy(e), this.end.copy(t), this;
      }
      copy(e) {
        return this.start.copy(e.start), this.end.copy(e.end), this;
      }
      getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(0.5);
      }
      delta(e) {
        return e.subVectors(this.end, this.start);
      }
      distanceSq() {
        return this.start.distanceToSquared(this.end);
      }
      distance() {
        return this.start.distanceTo(this.end);
      }
      at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start);
      }
      closestPointToPointParameter(e, t) {
        hp.subVectors(e, this.start), dp.subVectors(this.end, this.start);
        const n = dp.dot(dp);
        let r = dp.dot(hp) / n;
        return t && (r = Gn(r, 0, 1)), r;
      }
      closestPointToPoint(e, t, n) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(n).multiplyScalar(r).add(this.start);
      }
      applyMatrix4(e) {
        return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
      }
      equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class fp extends ci {
      constructor(e) {
        super(),
          (this.material = e),
          (this.render = function () {}),
          (this.hasPositions = !1),
          (this.hasNormals = !1),
          (this.hasColors = !1),
          (this.hasUvs = !1),
          (this.positionArray = null),
          (this.normalArray = null),
          (this.colorArray = null),
          (this.uvArray = null),
          (this.count = 0);
      }
    }
    fp.prototype.isImmediateRenderObject = !0;
    const mp = new sr();
    class gp extends ci {
      constructor(e, t) {
        super(),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = t);
        const n = new eo(),
          r = [
            0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
            1, 1, 0, 0, 0, 0, -1, 1,
          ];
        for (let e = 0, t = 1, n = 32; e < n; e++, t++) {
          const i = (e / n) * Math.PI * 2,
            o = (t / n) * Math.PI * 2;
          r.push(Math.cos(i), Math.sin(i), 1, Math.cos(o), Math.sin(o), 1);
        }
        n.setAttribute("position", new Gi(r, 3));
        const i = new pc({
          fog: !1,
          toneMapped: !1,
        });
        (this.cone = new _c(n, i)), this.add(this.cone), this.update();
      }
      dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
      }
      update() {
        this.light.updateMatrixWorld();
        const e = this.light.distance ? this.light.distance : 1e3,
          t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
          mp.setFromMatrixPosition(this.light.target.matrixWorld),
          this.cone.lookAt(mp),
          void 0 !== this.color
            ? this.cone.material.color.set(this.color)
            : this.cone.material.color.copy(this.light.color);
      }
    }
    const vp = new sr(),
      yp = new Nr(),
      xp = new Nr();
    class bp extends _c {
      constructor(e) {
        const t = (function e(t) {
            const n = [];
            t && t.isBone && n.push(t);
            for (let r = 0; r < t.children.length; r++)
              n.push.apply(n, e(t.children[r]));
            return n;
          })(e),
          n = new eo(),
          r = [],
          i = [],
          o = new Pi(0, 0, 1),
          a = new Pi(0, 1, 0);
        for (let e = 0; e < t.length; e++) {
          const n = t[e];
          n.parent &&
            n.parent.isBone &&
            (r.push(0, 0, 0),
            r.push(0, 0, 0),
            i.push(o.r, o.g, o.b),
            i.push(a.r, a.g, a.b));
        }
        n.setAttribute("position", new Gi(r, 3)),
          n.setAttribute("color", new Gi(i, 3)),
          super(
            n,
            new pc({
              vertexColors: !0,
              depthTest: !1,
              depthWrite: !1,
              toneMapped: !1,
              transparent: !0,
            })
          ),
          (this.type = "SkeletonHelper"),
          (this.isSkeletonHelper = !0),
          (this.root = e),
          (this.bones = t),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1);
      }
      updateMatrixWorld(e) {
        const t = this.bones,
          n = this.geometry,
          r = n.getAttribute("position");
        xp.copy(this.root.matrixWorld).invert();
        for (let e = 0, n = 0; e < t.length; e++) {
          const i = t[e];
          i.parent &&
            i.parent.isBone &&
            (yp.multiplyMatrices(xp, i.matrixWorld),
            vp.setFromMatrixPosition(yp),
            r.setXYZ(n, vp.x, vp.y, vp.z),
            yp.multiplyMatrices(xp, i.parent.matrixWorld),
            vp.setFromMatrixPosition(yp),
            r.setXYZ(n + 1, vp.x, vp.y, vp.z),
            (n += 2));
        }
        (n.getAttribute("position").needsUpdate = !0),
          super.updateMatrixWorld(e);
      }
    }
    class wp extends xo {
      constructor(e, t, n) {
        super(
          new $u(t, 4, 2),
          new Li({
            wireframe: !0,
            fog: !1,
            toneMapped: !1,
          })
        ),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.color = n),
          (this.type = "PointLightHelper"),
          (this.matrix = this.light.matrixWorld),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      dispose() {
        this.geometry.dispose(), this.material.dispose();
      }
      update() {
        void 0 !== this.color
          ? this.material.color.set(this.color)
          : this.material.color.copy(this.light.color);
      }
    }
    const _p = new sr(),
      Mp = new Pi(),
      Sp = new Pi();
    class Tp extends ci {
      constructor(e, t, n) {
        super(),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = n);
        const r = new Vu(t);
        r.rotateY(0.5 * Math.PI),
          (this.material = new Li({
            wireframe: !0,
            fog: !1,
            toneMapped: !1,
          })),
          void 0 === this.color && (this.material.vertexColors = !0);
        const i = r.getAttribute("position"),
          o = new Float32Array(3 * i.count);
        r.setAttribute("color", new ki(o, 3)),
          this.add(new xo(r, this.material)),
          this.update();
      }
      dispose() {
        this.children[0].geometry.dispose(),
          this.children[0].material.dispose();
      }
      update() {
        const e = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
          const t = e.geometry.getAttribute("color");
          Mp.copy(this.light.color), Sp.copy(this.light.groundColor);
          for (let e = 0, n = t.count; e < n; e++) {
            const r = e < n / 2 ? Mp : Sp;
            t.setXYZ(e, r.r, r.g, r.b);
          }
          t.needsUpdate = !0;
        }
        e.lookAt(_p.setFromMatrixPosition(this.light.matrixWorld).negate());
      }
    }
    class Ep extends _c {
      constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
        (n = new Pi(n)), (r = new Pi(r));
        const i = t / 2,
          o = e / t,
          a = e / 2,
          s = [],
          l = [];
        for (let e = 0, c = 0, u = -a; e <= t; e++, u += o) {
          s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
          const t = e === i ? n : r;
          t.toArray(l, c),
            (c += 3),
            t.toArray(l, c),
            (c += 3),
            t.toArray(l, c),
            (c += 3),
            t.toArray(l, c),
            (c += 3);
        }
        const c = new eo();
        c.setAttribute("position", new Gi(s, 3)),
          c.setAttribute("color", new Gi(l, 3)),
          super(
            c,
            new pc({
              vertexColors: !0,
              toneMapped: !1,
            })
          ),
          (this.type = "GridHelper");
      }
    }
    class Ap extends _c {
      constructor(e = 10, t = 16, n = 8, r = 64, i = 4473924, o = 8947848) {
        (i = new Pi(i)), (o = new Pi(o));
        const a = [],
          s = [];
        for (let n = 0; n <= t; n++) {
          const r = (n / t) * (2 * Math.PI),
            l = Math.sin(r) * e,
            c = Math.cos(r) * e;
          a.push(0, 0, 0), a.push(l, 0, c);
          const u = 1 & n ? i : o;
          s.push(u.r, u.g, u.b), s.push(u.r, u.g, u.b);
        }
        for (let t = 0; t <= n; t++) {
          const l = 1 & t ? i : o,
            c = e - (e / n) * t;
          for (let e = 0; e < r; e++) {
            let t = (e / r) * (2 * Math.PI),
              n = Math.sin(t) * c,
              i = Math.cos(t) * c;
            a.push(n, 0, i),
              s.push(l.r, l.g, l.b),
              (t = ((e + 1) / r) * (2 * Math.PI)),
              (n = Math.sin(t) * c),
              (i = Math.cos(t) * c),
              a.push(n, 0, i),
              s.push(l.r, l.g, l.b);
          }
        }
        const l = new eo();
        l.setAttribute("position", new Gi(a, 3)),
          l.setAttribute("color", new Gi(s, 3)),
          super(
            l,
            new pc({
              vertexColors: !0,
              toneMapped: !1,
            })
          ),
          (this.type = "PolarGridHelper");
      }
    }
    const Cp = new sr(),
      Pp = new sr(),
      Lp = new sr();
    class Rp extends ci {
      constructor(e, t, n) {
        super(),
          (this.light = e),
          this.light.updateMatrixWorld(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = n),
          void 0 === t && (t = 1);
        let r = new eo();
        r.setAttribute(
          "position",
          new Gi([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
        );
        const i = new pc({
          fog: !1,
          toneMapped: !1,
        });
        (this.lightPlane = new xc(r, i)),
          this.add(this.lightPlane),
          (r = new eo()),
          r.setAttribute("position", new Gi([0, 0, 0, 0, 0, 1], 3)),
          (this.targetLine = new xc(r, i)),
          this.add(this.targetLine),
          this.update();
      }
      dispose() {
        this.lightPlane.geometry.dispose(),
          this.lightPlane.material.dispose(),
          this.targetLine.geometry.dispose(),
          this.targetLine.material.dispose();
      }
      update() {
        Cp.setFromMatrixPosition(this.light.matrixWorld),
          Pp.setFromMatrixPosition(this.light.target.matrixWorld),
          Lp.subVectors(Pp, Cp),
          this.lightPlane.lookAt(Pp),
          void 0 !== this.color
            ? (this.lightPlane.material.color.set(this.color),
              this.targetLine.material.color.set(this.color))
            : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color)),
          this.targetLine.lookAt(Pp),
          (this.targetLine.scale.z = Lp.length());
      }
    }
    const Ip = new sr(),
      kp = new Eo();
    class Dp extends _c {
      constructor(e) {
        const t = new eo(),
          n = new pc({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1,
          }),
          r = [],
          i = [],
          o = {},
          a = new Pi(16755200),
          s = new Pi(16711680),
          l = new Pi(43775),
          c = new Pi(16777215),
          u = new Pi(3355443);

        function h(e, t, n) {
          d(e, n), d(t, n);
        }

        function d(e, t) {
          r.push(0, 0, 0),
            i.push(t.r, t.g, t.b),
            void 0 === o[e] && (o[e] = []),
            o[e].push(r.length / 3 - 1);
        }
        h("n1", "n2", a),
          h("n2", "n4", a),
          h("n4", "n3", a),
          h("n3", "n1", a),
          h("f1", "f2", a),
          h("f2", "f4", a),
          h("f4", "f3", a),
          h("f3", "f1", a),
          h("n1", "f1", a),
          h("n2", "f2", a),
          h("n3", "f3", a),
          h("n4", "f4", a),
          h("p", "n1", s),
          h("p", "n2", s),
          h("p", "n3", s),
          h("p", "n4", s),
          h("u1", "u2", l),
          h("u2", "u3", l),
          h("u3", "u1", l),
          h("c", "t", c),
          h("p", "c", u),
          h("cn1", "cn2", u),
          h("cn3", "cn4", u),
          h("cf1", "cf2", u),
          h("cf3", "cf4", u),
          t.setAttribute("position", new Gi(r, 3)),
          t.setAttribute("color", new Gi(i, 3)),
          super(t, n),
          (this.type = "CameraHelper"),
          (this.camera = e),
          this.camera.updateProjectionMatrix &&
            this.camera.updateProjectionMatrix(),
          (this.matrix = e.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.pointMap = o),
          this.update();
      }
      update() {
        const e = this.geometry,
          t = this.pointMap;
        kp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
          Op("c", t, e, kp, 0, 0, -1),
          Op("t", t, e, kp, 0, 0, 1),
          Op("n1", t, e, kp, -1, -1, -1),
          Op("n2", t, e, kp, 1, -1, -1),
          Op("n3", t, e, kp, -1, 1, -1),
          Op("n4", t, e, kp, 1, 1, -1),
          Op("f1", t, e, kp, -1, -1, 1),
          Op("f2", t, e, kp, 1, -1, 1),
          Op("f3", t, e, kp, -1, 1, 1),
          Op("f4", t, e, kp, 1, 1, 1),
          Op("u1", t, e, kp, 0.7, 1.1, -1),
          Op("u2", t, e, kp, -0.7, 1.1, -1),
          Op("u3", t, e, kp, 0, 2, -1),
          Op("cf1", t, e, kp, -1, 0, 1),
          Op("cf2", t, e, kp, 1, 0, 1),
          Op("cf3", t, e, kp, 0, -1, 1),
          Op("cf4", t, e, kp, 0, 1, 1),
          Op("cn1", t, e, kp, -1, 0, -1),
          Op("cn2", t, e, kp, 1, 0, -1),
          Op("cn3", t, e, kp, 0, -1, -1),
          Op("cn4", t, e, kp, 0, 1, -1),
          (e.getAttribute("position").needsUpdate = !0);
      }
      dispose() {
        this.geometry.dispose(), this.material.dispose();
      }
    }

    function Op(e, t, n, r, i, o, a) {
      Ip.set(i, o, a).unproject(r);
      const s = t[e];
      if (void 0 !== s) {
        const e = n.getAttribute("position");
        for (let t = 0, n = s.length; t < n; t++)
          e.setXYZ(s[t], Ip.x, Ip.y, Ip.z);
      }
    }
    const Bp = new ur();
    class Fp extends _c {
      constructor(e, t = 16776960) {
        const n = new Uint16Array([
            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
            7,
          ]),
          r = new Float32Array(24),
          i = new eo();
        i.setIndex(new ki(n, 1)),
          i.setAttribute("position", new ki(r, 3)),
          super(
            i,
            new pc({
              color: t,
              toneMapped: !1,
            })
          ),
          (this.object = e),
          (this.type = "BoxHelper"),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      update(e) {
        if (
          (void 0 !== e &&
            console.warn("THREE.BoxHelper: .update() has no longer arguments."),
          void 0 !== this.object && Bp.setFromObject(this.object),
          Bp.isEmpty())
        )
          return;
        const t = Bp.min,
          n = Bp.max,
          r = this.geometry.attributes.position,
          i = r.array;
        (i[0] = n.x),
          (i[1] = n.y),
          (i[2] = n.z),
          (i[3] = t.x),
          (i[4] = n.y),
          (i[5] = n.z),
          (i[6] = t.x),
          (i[7] = t.y),
          (i[8] = n.z),
          (i[9] = n.x),
          (i[10] = t.y),
          (i[11] = n.z),
          (i[12] = n.x),
          (i[13] = n.y),
          (i[14] = t.z),
          (i[15] = t.x),
          (i[16] = n.y),
          (i[17] = t.z),
          (i[18] = t.x),
          (i[19] = t.y),
          (i[20] = t.z),
          (i[21] = n.x),
          (i[22] = t.y),
          (i[23] = t.z),
          (r.needsUpdate = !0),
          this.geometry.computeBoundingSphere();
      }
      setFromObject(e) {
        return (this.object = e), this.update(), this;
      }
      copy(e) {
        return _c.prototype.copy.call(this, e), (this.object = e.object), this;
      }
    }
    class Np extends _c {
      constructor(e, t = 16776960) {
        const n = new Uint16Array([
            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
            7,
          ]),
          r = new eo();
        r.setIndex(new ki(n, 1)),
          r.setAttribute(
            "position",
            new Gi(
              [
                1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
                -1, -1, 1, -1, -1,
              ],
              3
            )
          ),
          super(
            r,
            new pc({
              color: t,
              toneMapped: !1,
            })
          ),
          (this.box = e),
          (this.type = "Box3Helper"),
          this.geometry.computeBoundingSphere();
      }
      updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() ||
          (t.getCenter(this.position),
          t.getSize(this.scale),
          this.scale.multiplyScalar(0.5),
          super.updateMatrixWorld(e));
      }
    }
    class Up extends xc {
      constructor(e, t = 1, n = 16776960) {
        const r = n,
          i = new eo();
        i.setAttribute(
          "position",
          new Gi(
            [
              1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1,
              -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
            ],
            3
          )
        ),
          i.computeBoundingSphere(),
          super(
            i,
            new pc({
              color: r,
              toneMapped: !1,
            })
          ),
          (this.type = "PlaneHelper"),
          (this.plane = e),
          (this.size = t);
        const o = new eo();
        o.setAttribute(
          "position",
          new Gi(
            [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
            3
          )
        ),
          o.computeBoundingSphere(),
          this.add(
            new xo(
              o,
              new Li({
                color: r,
                opacity: 0.2,
                transparent: !0,
                depthWrite: !1,
                toneMapped: !1,
              })
            )
          );
      }
      updateMatrixWorld(e) {
        let t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8),
          this.scale.set(0.5 * this.size, 0.5 * this.size, t),
          (this.children[0].material.side = t < 0 ? m : f),
          this.lookAt(this.plane.normal),
          super.updateMatrixWorld(e);
      }
    }
    const zp = new sr();
    let Hp, Gp;
    class Vp extends ci {
      constructor(
        e = new sr(0, 0, 1),
        t = new sr(0, 0, 0),
        n = 1,
        r = 16776960,
        i = 0.2 * n,
        o = 0.2 * i
      ) {
        super(),
          (this.type = "ArrowHelper"),
          void 0 === Hp &&
            ((Hp = new eo()),
            Hp.setAttribute("position", new Gi([0, 0, 0, 0, 1, 0], 3)),
            (Gp = new Bc(0, 0.5, 1, 5, 1)),
            Gp.translate(0, -0.5, 0)),
          this.position.copy(t),
          (this.line = new xc(
            Hp,
            new pc({
              color: r,
              toneMapped: !1,
            })
          )),
          (this.line.matrixAutoUpdate = !1),
          this.add(this.line),
          (this.cone = new xo(
            Gp,
            new Li({
              color: r,
              toneMapped: !1,
            })
          )),
          (this.cone.matrixAutoUpdate = !1),
          this.add(this.cone),
          this.setDirection(e),
          this.setLength(n, i, o);
      }
      setDirection(e) {
        if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
          zp.set(e.z, 0, -e.x).normalize();
          const t = Math.acos(e.y);
          this.quaternion.setFromAxisAngle(zp, t);
        }
      }
      setLength(e, t = 0.2 * e, n = 0.2 * t) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
          this.line.updateMatrix(),
          this.cone.scale.set(n, t, n),
          (this.cone.position.y = e),
          this.cone.updateMatrix();
      }
      setColor(e) {
        this.line.material.color.set(e), this.cone.material.color.set(e);
      }
      copy(e) {
        return (
          super.copy(e, !1),
          this.line.copy(e.line),
          this.cone.copy(e.cone),
          this
        );
      }
    }
    class jp extends _c {
      constructor(e = 1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
          n = new eo();
        n.setAttribute("position", new Gi(t, 3)),
          n.setAttribute(
            "color",
            new Gi(
              [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
              3
            )
          ),
          super(
            n,
            new pc({
              vertexColors: !0,
              toneMapped: !1,
            })
          ),
          (this.type = "AxesHelper");
      }
      setColors(e, t, n) {
        const r = new Pi(),
          i = this.geometry.attributes.color.array;
        return (
          r.set(e),
          r.toArray(i, 0),
          r.toArray(i, 3),
          r.set(t),
          r.toArray(i, 6),
          r.toArray(i, 9),
          r.set(n),
          r.toArray(i, 12),
          r.toArray(i, 15),
          (this.geometry.attributes.color.needsUpdate = !0),
          this
        );
      }
      dispose() {
        this.geometry.dispose(), this.material.dispose();
      }
    }
    const Wp = new Float32Array(1),
      qp = new Int32Array(Wp.buffer);
    class $p {
      static toHalfFloat(e) {
        Wp[0] = e;
        const t = qp[0];
        let n = (t >> 16) & 32768,
          r = (t >> 12) & 2047;
        const i = (t >> 23) & 255;
        return i < 103
          ? n
          : i > 142
          ? ((n |= 31744), (n |= (255 == i ? 0 : 1) && 8388607 & t), n)
          : i < 113
          ? ((r |= 2048), (n |= (r >> (114 - i)) + ((r >> (113 - i)) & 1)), n)
          : ((n |= ((i - 112) << 10) | (r >> 1)), (n += 1 & r), n);
      }
    }
    const Xp = 0,
      Yp = 1,
      Jp = 0,
      Zp = 1,
      Kp = 2;

    function Qp(e) {
      return (
        console.warn(
          "THREE.MeshFaceMaterial has been removed. Use an Array instead."
        ),
        e
      );
    }

    function ef(e = []) {
      return (
        console.warn(
          "THREE.MultiMaterial has been removed. Use an Array instead."
        ),
        (e.isMultiMaterial = !0),
        (e.materials = e),
        (e.clone = function () {
          return e.slice();
        }),
        e
      );
    }

    function tf(e, t) {
      return (
        console.warn("THREE.PointCloud has been renamed to THREE.Points."),
        new Pc(e, t)
      );
    }

    function nf(e) {
      return (
        console.warn("THREE.Particle has been renamed to THREE.Sprite."),
        new Wl(e)
      );
    }

    function rf(e, t) {
      return (
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
        new Pc(e, t)
      );
    }

    function of(e) {
      return (
        console.warn(
          "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
        ),
        new Sc(e)
      );
    }

    function af(e) {
      return (
        console.warn(
          "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
        ),
        new Sc(e)
      );
    }

    function sf(e) {
      return (
        console.warn(
          "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
        ),
        new Sc(e)
      );
    }

    function lf(e, t, n) {
      return (
        console.warn(
          "THREE.Vertex has been removed. Use THREE.Vector3 instead."
        ),
        new sr(e, t, n)
      );
    }

    function cf(e, t) {
      return (
        console.warn(
          "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
        ),
        new ki(e, t).setUsage(En)
      );
    }

    function uf(e, t) {
      return (
        console.warn(
          "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
        ),
        new Di(e, t)
      );
    }

    function hf(e, t) {
      return (
        console.warn(
          "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
        ),
        new Oi(e, t)
      );
    }

    function df(e, t) {
      return (
        console.warn(
          "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
        ),
        new Bi(e, t)
      );
    }

    function pf(e, t) {
      return (
        console.warn(
          "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
        ),
        new Fi(e, t)
      );
    }

    function ff(e, t) {
      return (
        console.warn(
          "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
        ),
        new Ni(e, t)
      );
    }

    function mf(e, t) {
      return (
        console.warn(
          "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
        ),
        new Ui(e, t)
      );
    }

    function gf(e, t) {
      return (
        console.warn(
          "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
        ),
        new zi(e, t)
      );
    }

    function vf(e, t) {
      return (
        console.warn(
          "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
        ),
        new Gi(e, t)
      );
    }

    function yf(e, t) {
      return (
        console.warn(
          "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
        ),
        new Vi(e, t)
      );
    }

    function xf(e) {
      return (
        console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
        new jp(e)
      );
    }

    function bf(e, t) {
      return (
        console.warn(
          "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
        ),
        new Fp(e, t)
      );
    }

    function wf(e, t) {
      return (
        console.warn(
          "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
        ),
        new _c(
          new jc(e.geometry),
          new pc({
            color: void 0 !== t ? t : 16777215,
          })
        )
      );
    }

    function _f(e, t) {
      return (
        console.warn(
          "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
        ),
        new _c(
          new Qu(e.geometry),
          new pc({
            color: void 0 !== t ? t : 16777215,
          })
        )
      );
    }

    function Mf(e) {
      return (
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
        new Ih(e)
      );
    }

    function Sf(e) {
      return (
        console.warn(
          "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
        ),
        new Fh(e)
      );
    }

    function Tf(e, t, n) {
      return (
        console.warn(
          "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
        ),
        new Lo(e, n)
      );
    }

    function Ef() {
      console.error("THREE.CanvasRenderer has been removed");
    }

    function Af() {
      console.error("THREE.JSONLoader has been removed.");
    }
    (Wc.create = function (e, t) {
      return (
        console.log("THREE.Curve.create() has been deprecated"),
        (e.prototype = Object.create(Wc.prototype)),
        (e.prototype.constructor = e),
        (e.prototype.getPoint = t),
        e
      );
    }),
      (zh.prototype.fromPoints = function (e) {
        return (
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
          this.setFromPoints(e)
        );
      }),
      (Ep.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      }),
      (bp.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      }),
      (Lh.prototype.extractUrlBase = function (e) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
          ),
          ld.extractUrlBase(e)
        );
      }),
      (Lh.Handlers = {
        add: function () {
          console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
          );
        },
        get: function () {
          console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
          );
        },
      }),
      (up.prototype.center = function (e) {
        return (
          console.warn(
            "THREE.Box2: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(e)
        );
      }),
      (up.prototype.empty = function () {
        return (
          console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      }),
      (up.prototype.isIntersectionBox = function (e) {
        return (
          console.warn(
            "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      }),
      (up.prototype.size = function (e) {
        return (
          console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
          this.getSize(e)
        );
      }),
      (ur.prototype.center = function (e) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(e)
        );
      }),
      (ur.prototype.empty = function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      }),
      (ur.prototype.isIntersectionBox = function (e) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      }),
      (ur.prototype.isIntersectionSphere = function (e) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(e)
        );
      }),
      (ur.prototype.size = function (e) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(e)
        );
      }),
      (Pr.prototype.empty = function () {
        return (
          console.warn(
            "THREE.Sphere: .empty() has been renamed to .isEmpty()."
          ),
          this.isEmpty()
        );
      }),
      (Fo.prototype.setFromMatrix = function (e) {
        return (
          console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
          ),
          this.setFromProjectionMatrix(e)
        );
      }),
      (pp.prototype.center = function (e) {
        return (
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(e)
        );
      }),
      (Jn.prototype.flattenToArrayOffset = function (e, t) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(e, t)
        );
      }),
      (Jn.prototype.multiplyVector3 = function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
          ),
          e.applyMatrix3(this)
        );
      }),
      (Jn.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed."
        );
      }),
      (Jn.prototype.applyToBufferAttribute = function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
          ),
          e.applyMatrix3(this)
        );
      }),
      (Jn.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed."
        );
      }),
      (Jn.prototype.getInverse = function (e) {
        return (
          console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(e).invert()
        );
      }),
      (Nr.prototype.extractPosition = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
          ),
          this.copyPosition(e)
        );
      }),
      (Nr.prototype.flattenToArrayOffset = function (e, t) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
          ),
          this.toArray(e, t)
        );
      }),
      (Nr.prototype.getPosition = function () {
        return (
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
          ),
          new sr().setFromMatrixColumn(this, 3)
        );
      }),
      (Nr.prototype.setRotationFromQuaternion = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
          ),
          this.makeRotationFromQuaternion(e)
        );
      }),
      (Nr.prototype.multiplyToArray = function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      }),
      (Nr.prototype.multiplyVector3 = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (Nr.prototype.multiplyVector4 = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (Nr.prototype.multiplyVector3Array = function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed."
        );
      }),
      (Nr.prototype.rotateAxis = function (e) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
        ),
          e.transformDirection(this);
      }),
      (Nr.prototype.crossVector = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (Nr.prototype.translate = function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      }),
      (Nr.prototype.rotateX = function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      }),
      (Nr.prototype.rotateY = function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      }),
      (Nr.prototype.rotateZ = function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      }),
      (Nr.prototype.rotateByAxis = function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      }),
      (Nr.prototype.applyToBufferAttribute = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
          ),
          e.applyMatrix4(this)
        );
      }),
      (Nr.prototype.applyToVector3Array = function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed."
        );
      }),
      (Nr.prototype.makeFrustum = function (e, t, n, r, i, o) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
          ),
          this.makePerspective(e, t, r, n, i, o)
        );
      }),
      (Nr.prototype.getInverse = function (e) {
        return (
          console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
          ),
          this.copy(e).invert()
        );
      }),
      (Do.prototype.isIntersectionLine = function (e) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(e)
        );
      }),
      (ar.prototype.multiplyVector3 = function (e) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          e.applyQuaternion(this)
        );
      }),
      (ar.prototype.inverse = function () {
        return (
          console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
          ),
          this.invert()
        );
      }),
      (Fr.prototype.isIntersectionBox = function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
          ),
          this.intersectsBox(e)
        );
      }),
      (Fr.prototype.isIntersectionPlane = function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
          ),
          this.intersectsPlane(e)
        );
      }),
      (Fr.prototype.isIntersectionSphere = function (e) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
          ),
          this.intersectsSphere(e)
        );
      }),
      (bi.prototype.area = function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea()."
          ),
          this.getArea()
        );
      }),
      (bi.prototype.barycoordFromPoint = function (e, t) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          this.getBarycoord(e, t)
        );
      }),
      (bi.prototype.midpoint = function (e) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
          ),
          this.getMidpoint(e)
        );
      }),
      (bi.prototypenormal = function (e) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          this.getNormal(e)
        );
      }),
      (bi.prototype.plane = function (e) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
          ),
          this.getPlane(e)
        );
      }),
      (bi.barycoordFromPoint = function (e, t, n, r, i) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
          ),
          bi.getBarycoord(e, t, n, r, i)
        );
      }),
      (bi.normal = function (e, t, n, r) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
          ),
          bi.getNormal(e, t, n, r)
        );
      }),
      (Hh.prototype.extractAllPoints = function (e) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
          ),
          this.extractPoints(e)
        );
      }),
      (Hh.prototype.extrude = function (e) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
          ),
          new Uu(this, e)
        );
      }),
      (Hh.prototype.makeGeometry = function (e) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
          ),
          new qu(this, e)
        );
      }),
      (Yn.prototype.fromAttribute = function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      }),
      (Yn.prototype.distanceToManhattan = function (e) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(e)
        );
      }),
      (Yn.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (sr.prototype.setEulerFromRotationMatrix = function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
        );
      }),
      (sr.prototype.setEulerFromQuaternion = function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
        );
      }),
      (sr.prototype.getPositionFromMatrix = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
          ),
          this.setFromMatrixPosition(e)
        );
      }),
      (sr.prototype.getScaleFromMatrix = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
          ),
          this.setFromMatrixScale(e)
        );
      }),
      (sr.prototype.getColumnFromMatrix = function (e, t) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
          ),
          this.setFromMatrixColumn(t, e)
        );
      }),
      (sr.prototype.applyProjection = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
          ),
          this.applyMatrix4(e)
        );
      }),
      (sr.prototype.fromAttribute = function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      }),
      (sr.prototype.distanceToManhattan = function (e) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
          ),
          this.manhattanDistanceTo(e)
        );
      }),
      (sr.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (nr.prototype.fromAttribute = function (e, t, n) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
          ),
          this.fromBufferAttribute(e, t, n)
        );
      }),
      (nr.prototype.lengthManhattan = function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
          ),
          this.manhattanLength()
        );
      }),
      (ci.prototype.getChildByName = function (e) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
          ),
          this.getObjectByName(e)
        );
      }),
      (ci.prototype.renderDepth = function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
        );
      }),
      (ci.prototype.translate = function (e, t) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
          ),
          this.translateOnAxis(t, e)
        );
      }),
      (ci.prototype.getWorldRotation = function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
        );
      }),
      (ci.prototype.applyMatrix = function (e) {
        return (
          console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(e)
        );
      }),
      Object.defineProperties(ci.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (e) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = e);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      }),
      (xo.prototype.setDrawMode = function () {
        console.error(
          "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      }),
      Object.defineProperties(xo.prototype, {
        drawMode: {
          get: function () {
            return (
              console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
              ),
              $t
            );
          },
          set: function () {
            console.error(
              "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          },
        },
      }),
      (tc.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }),
      (Ao.prototype.setLens = function (e, t) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          void 0 !== t && (this.filmGauge = t),
          this.setFocalLength(e);
      }),
      Object.defineProperties(Gh.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = e);
          },
        },
        shadowCameraLeft: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = e);
          },
        },
        shadowCameraRight: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = e);
          },
        },
        shadowCameraTop: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = e);
          },
        },
        shadowCameraBottom: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = e);
          },
        },
        shadowCameraNear: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = e);
          },
        },
        shadowCameraFar: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = e);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (e) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = e);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = e);
          },
        },
        shadowMapHeight: {
          set: function (e) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = e);
          },
        },
      }),
      Object.defineProperties(ki.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
        dynamic: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
              ),
              this.usage === En
            );
          },
          set: function () {
            console.warn(
              "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
              this.setUsage(En);
          },
        },
      }),
      (ki.prototype.setDynamic = function (e) {
        return (
          console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === e ? En : Tn),
          this
        );
      }),
      (ki.prototype.copyIndicesArray = function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed."
        );
      }),
      (ki.prototype.setArray = function () {
        console.error(
          "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      }),
      (eo.prototype.addIndex = function (e) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
        ),
          this.setIndex(e);
      }),
      (eo.prototype.addAttribute = function (e, t) {
        return (
          console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
          ),
          (t && t.isBufferAttribute) || (t && t.isInterleavedBufferAttribute)
            ? "index" === e
              ? (console.warn(
                  "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                ),
                this.setIndex(t),
                this)
              : this.setAttribute(e, t)
            : (console.warn(
                "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(e, new ki(arguments[1], arguments[2])))
        );
      }),
      (eo.prototype.addDrawCall = function (e, t, n) {
        void 0 !== n &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
          ),
          this.addGroup(e, t);
      }),
      (eo.prototype.clearDrawCalls = function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
        ),
          this.clearGroups();
      }),
      (eo.prototype.computeOffsets = function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed."
        );
      }),
      (eo.prototype.removeAttribute = function (e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
          ),
          this.deleteAttribute(e)
        );
      }),
      (eo.prototype.applyMatrix = function (e) {
        return (
          console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
          ),
          this.applyMatrix4(e)
        );
      }),
      Object.defineProperties(eo.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      }),
      (Cl.prototype.setDynamic = function (e) {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
          ),
          this.setUsage(!0 === e ? En : Tn),
          this
        );
      }),
      (Cl.prototype.setArray = function () {
        console.error(
          "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
      }),
      (Uu.prototype.getArrays = function () {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      }),
      (Uu.prototype.addShapeList = function () {
        console.error(
          "THREE.ExtrudeGeometry: .addShapeList() has been removed."
        );
      }),
      (Uu.prototype.addShape = function () {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      }),
      (Al.prototype.dispose = function () {
        console.error("THREE.Scene: .dispose() has been removed.");
      }),
      (tp.prototype.onUpdate = function () {
        return (
          console.warn(
            "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
          ),
          this
        );
      }),
      Object.defineProperties(_i.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        overdraw: {
          get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new Pi()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (e) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = e === v);
          },
        },
        stencilMask: {
          get: function () {
            return (
              console.warn(
                "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
              ),
              this.stencilFuncMask
            );
          },
          set: function (e) {
            console.warn(
              "THREE." +
                this.type +
                ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
              (this.stencilFuncMask = e);
          },
        },
        vertexTangents: {
          get: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
          set: function () {
            console.warn(
              "THREE." + this.type + ": .vertexTangents has been removed."
            );
          },
        },
      }),
      Object.defineProperties(To.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (e) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = e);
          },
        },
      }),
      (Ml.prototype.clearTarget = function (e, t, n, r) {
        console.warn(
          "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
        ),
          this.setRenderTarget(e),
          this.clear(t, n, r);
      }),
      (Ml.prototype.animate = function (e) {
        console.warn(
          "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
        ),
          this.setAnimationLoop(e);
      }),
      (Ml.prototype.getCurrentRenderTarget = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
          ),
          this.getRenderTarget()
        );
      }),
      (Ml.prototype.getMaxAnisotropy = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
          ),
          this.capabilities.getMaxAnisotropy()
        );
      }),
      (Ml.prototype.getPrecision = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
          ),
          this.capabilities.precision
        );
      }),
      (Ml.prototype.resetGLState = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
          ),
          this.state.reset()
        );
      }),
      (Ml.prototype.supportsFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get("OES_texture_float")
        );
      }),
      (Ml.prototype.supportsHalfFloatTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get("OES_texture_half_float")
        );
      }),
      (Ml.prototype.supportsStandardDerivatives = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get("OES_standard_derivatives")
        );
      }),
      (Ml.prototype.supportsCompressedTextureS3TC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_s3tc")
        );
      }),
      (Ml.prototype.supportsCompressedTexturePVRTC = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get("WEBGL_compressed_texture_pvrtc")
        );
      }),
      (Ml.prototype.supportsBlendMinMax = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get("EXT_blend_minmax")
        );
      }),
      (Ml.prototype.supportsVertexTextures = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
          ),
          this.capabilities.vertexTextures
        );
      }),
      (Ml.prototype.supportsInstancedArrays = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get("ANGLE_instanced_arrays")
        );
      }),
      (Ml.prototype.enableScissorTest = function (e) {
        console.warn(
          "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
        ),
          this.setScissorTest(e);
      }),
      (Ml.prototype.initMaterial = function () {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      }),
      (Ml.prototype.addPrePlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      }),
      (Ml.prototype.addPostPlugin = function () {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      }),
      (Ml.prototype.updateShadowMap = function () {
        console.warn(
          "THREE.WebGLRenderer: .updateShadowMap() has been removed."
        );
      }),
      (Ml.prototype.setFaceCulling = function () {
        console.warn(
          "THREE.WebGLRenderer: .setFaceCulling() has been removed."
        );
      }),
      (Ml.prototype.allocTextureUnit = function () {
        console.warn(
          "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
        );
      }),
      (Ml.prototype.setTexture = function () {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      }),
      (Ml.prototype.setTexture2D = function () {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      }),
      (Ml.prototype.setTextureCube = function () {
        console.warn(
          "THREE.WebGLRenderer: .setTextureCube() has been removed."
        );
      }),
      (Ml.prototype.getActiveMipMapLevel = function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
          ),
          this.getActiveMipmapLevel()
        );
      }),
      Object.defineProperties(Ml.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = e);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = e);
          },
        },
        shadowMapCullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        context: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
              ),
              this.getContext()
            );
          },
        },
        vr: {
          get: function () {
            return (
              console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
              this.xr
            );
          },
        },
        gammaInput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
          },
        },
        gammaOutput: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
              ),
              !1
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
              (this.outputEncoding = !0 === e ? Zt : Jt);
          },
        },
        toneMappingWhitePoint: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
              ),
              1
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
          },
        },
      }),
      Object.defineProperties(pl.prototype, {
        cullFace: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderReverseSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
        renderSingleSided: {
          get: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
          set: function () {
            console.warn(
              "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
          },
        },
      }),
      Object.defineProperties(rr.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = e);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = e);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = e);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = e);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = e);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = e);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = e);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = e);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = e);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (e) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = e);
          },
        },
      }),
      (Od.prototype.load = function (e) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const t = this;
        return (
          new _d().load(e, function (e) {
            t.setBuffer(e);
          }),
          this
        );
      }),
      (Hd.prototype.getData = function () {
        return (
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          ),
          this.getFrequencyData()
        );
      }),
      (Co.prototype.updateCubeMap = function (e, t) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(e, t)
        );
      }),
      (Co.prototype.clear = function (e, t, n, r) {
        return (
          console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
          ),
          this.renderTarget.clear(e, t, n, r)
        );
      }),
      (Kn.crossOrigin = void 0),
      (Kn.loadTexture = function (e, t, n, r) {
        console.warn(
          "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
        );
        const i = new Nh();
        i.setCrossOrigin(this.crossOrigin);
        const o = i.load(e, n, void 0, r);
        return t && (o.mapping = t), o;
      }),
      (Kn.loadTextureCube = function (e, t, n, r) {
        console.warn(
          "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
        );
        const i = new Bh();
        i.setCrossOrigin(this.crossOrigin);
        const o = i.load(e, n, void 0, r);
        return t && (o.mapping = t), o;
      }),
      (Kn.loadCompressedTexture = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
        );
      }),
      (Kn.loadCompressedTextureCube = function () {
        console.error(
          "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
        );
      });
    const Cf = {
      createMultiMaterialObject: function () {
        console.error(
          "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
        );
      },
      detach: function () {
        console.error(
          "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
        );
      },
      attach: function () {
        console.error(
          "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
        );
      },
    };

    function Pf() {
      console.error(
        "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
      );
    }
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", {
          detail: {
            revision: r,
          },
        })
      ),
      "undefined" != typeof window &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = r));
  },
  function (e, t, n) {
    "use strict";
    /*!
     * Vue.js v1.0.28
     * (c) 2016 Evan You
     * Released under the MIT License.
     */
    function r(e, t, n) {
      if (a(e, t)) e[t] = n;
      else if (e._isVue) r(e._data, t, n);
      else {
        var i = e.__ob__;
        if (i) {
          if ((i.convert(t, n), i.dep.notify(), i.vms))
            for (var o = i.vms.length; o--; ) {
              var s = i.vms[o];
              s._proxy(t), s._digest();
            }
          return n;
        }
        e[t] = n;
      }
    }

    function i(e, t) {
      if (a(e, t)) {
        delete e[t];
        var n = e.__ob__;
        if (n) {
          if ((n.dep.notify(), n.vms))
            for (var r = n.vms.length; r--; ) {
              var i = n.vms[r];
              i._unproxy(t), i._digest();
            }
        } else e._isVue && (delete e._data[t], e._digest());
      }
    }
    var o = Object.prototype.hasOwnProperty;

    function a(e, t) {
      return o.call(e, t);
    }
    var s = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;

    function l(e) {
      return s.test(e);
    }

    function c(e) {
      var t = (e + "").charCodeAt(0);
      return 36 === t || 95 === t;
    }

    function u(e) {
      return null == e ? "" : e.toString();
    }

    function h(e) {
      if ("string" != typeof e) return e;
      var t = Number(e);
      return isNaN(t) ? e : t;
    }

    function d(e) {
      return "true" === e || ("false" !== e && e);
    }

    function p(e) {
      var t = e.charCodeAt(0);
      return t !== e.charCodeAt(e.length - 1) || (34 !== t && 39 !== t)
        ? e
        : e.slice(1, -1);
    }
    var f = /-(\w)/g;

    function m(e) {
      return e.replace(f, g);
    }

    function g(e, t) {
      return t ? t.toUpperCase() : "";
    }
    var v = /([^-])([A-Z])/g;

    function y(e) {
      return e.replace(v, "$1-$2").replace(v, "$1-$2").toLowerCase();
    }
    var x = /(?:^|[-_\/])(\w)/g;

    function b(e) {
      return e.replace(x, g);
    }

    function w(e, t) {
      return function (n) {
        var r = arguments.length;
        return r ? (r > 1 ? e.apply(t, arguments) : e.call(t, n)) : e.call(t);
      };
    }

    function _(e, t) {
      t = t || 0;
      for (var n = e.length - t, r = new Array(n); n--; ) r[n] = e[n + t];
      return r;
    }

    function M(e, t) {
      for (var n = Object.keys(t), r = n.length; r--; ) e[n[r]] = t[n[r]];
      return e;
    }

    function S(e) {
      return null !== e && "object" == typeof e;
    }
    var T = Object.prototype.toString;

    function E(e) {
      return "[object Object]" === T.call(e);
    }
    var A = Array.isArray;

    function C(e, t, n, r) {
      Object.defineProperty(e, t, {
        value: n,
        enumerable: !!r,
        writable: !0,
        configurable: !0,
      });
    }

    function P(e, t) {
      var n,
        r,
        i,
        o,
        a,
        s = function s() {
          var l = Date.now() - o;
          l < t && l >= 0
            ? (n = setTimeout(s, t - l))
            : ((n = null), (a = e.apply(i, r)), n || (i = r = null));
        };
      return function () {
        return (
          (i = this),
          (r = arguments),
          (o = Date.now()),
          n || (n = setTimeout(s, t)),
          a
        );
      };
    }

    function L(e, t) {
      for (var n = e.length; n--; ) if (e[n] === t) return n;
      return -1;
    }

    function R(e) {
      var t = function t() {
        if (!t.cancelled) return e.apply(this, arguments);
      };
      return (
        (t.cancel = function () {
          t.cancelled = !0;
        }),
        t
      );
    }

    function I(e, t) {
      return (
        e == t || (!(!S(e) || !S(t)) && JSON.stringify(e) === JSON.stringify(t))
      );
    }
    var k = "__proto__" in {},
      D =
        "undefined" != typeof window &&
        "[object Object]" !== Object.prototype.toString.call(window),
      O = D && window.__VUE_DEVTOOLS_GLOBAL_HOOK__,
      B = D && window.navigator.userAgent.toLowerCase(),
      F = B && B.indexOf("trident") > 0,
      N = B && B.indexOf("msie 9.0") > 0,
      U = B && B.indexOf("android") > 0,
      z = B && /iphone|ipad|ipod|ios/.test(B),
      H = void 0,
      G = void 0,
      V = void 0,
      j = void 0;
    if (D && !N) {
      var W =
          void 0 === window.ontransitionend &&
          void 0 !== window.onwebkittransitionend,
        q =
          void 0 === window.onanimationend &&
          void 0 !== window.onwebkitanimationend;
      (H = W ? "WebkitTransition" : "transition"),
        (G = W ? "webkitTransitionEnd" : "transitionend"),
        (V = q ? "WebkitAnimation" : "animation"),
        (j = q ? "webkitAnimationEnd" : "animationend");
    }

    function $(e) {
      return /native code/.test(e.toString());
    }
    var X = (function () {
        var e = [],
          t = !1,
          n = void 0;

        function r() {
          t = !1;
          var n = e.slice(0);
          e.length = 0;
          for (var r = 0; r < n.length; r++) n[r]();
        }
        if ("undefined" != typeof Promise && $(Promise)) {
          var i = Promise.resolve(),
            o = function () {};
          n = function () {
            i.then(r), z && setTimeout(o);
          };
        } else if ("undefined" != typeof MutationObserver) {
          var a = 1,
            s = new MutationObserver(r),
            l = document.createTextNode(String(a));
          s.observe(l, {
            characterData: !0,
          }),
            (n = function () {
              (a = (a + 1) % 2), (l.data = String(a));
            });
        } else n = setTimeout;
        return function (i, o) {
          var a = o
            ? function () {
                i.call(o);
              }
            : i;
          e.push(a), t || ((t = !0), n(r, 0));
        };
      })(),
      Y = void 0;

    function J(e) {
      (this.size = 0),
        (this.limit = e),
        (this.head = this.tail = void 0),
        (this._keymap = Object.create(null));
    }
    "undefined" != typeof Set && $(Set)
      ? (Y = Set)
      : (((Y = function () {
          this.set = Object.create(null);
        }).prototype.has = function (e) {
          return void 0 !== this.set[e];
        }),
        (Y.prototype.add = function (e) {
          this.set[e] = 1;
        }),
        (Y.prototype.clear = function () {
          this.set = Object.create(null);
        }));
    var Z = J.prototype;
    (Z.put = function (e, t) {
      var n,
        r = this.get(e, !0);
      return (
        r ||
          (this.size === this.limit && (n = this.shift()),
          (r = {
            key: e,
          }),
          (this._keymap[e] = r),
          this.tail
            ? ((this.tail.newer = r), (r.older = this.tail))
            : (this.head = r),
          (this.tail = r),
          this.size++),
        (r.value = t),
        n
      );
    }),
      (Z.shift = function () {
        var e = this.head;
        return (
          e &&
            ((this.head = this.head.newer),
            (this.head.older = void 0),
            (e.newer = e.older = void 0),
            (this._keymap[e.key] = void 0),
            this.size--),
          e
        );
      }),
      (Z.get = function (e, t) {
        var n = this._keymap[e];
        if (void 0 !== n)
          return (
            n === this.tail ||
              (n.newer &&
                (n === this.head && (this.head = n.newer),
                (n.newer.older = n.older)),
              n.older && (n.older.newer = n.newer),
              (n.newer = void 0),
              (n.older = this.tail),
              this.tail && (this.tail.newer = n),
              (this.tail = n)),
            t ? n : n.value
          );
      });
    var K,
      Q,
      ee,
      te,
      ne,
      re,
      ie = new J(1e3),
      oe = /^in$|^-?\d+/,
      ae = {
        91: 1,
        123: 1,
        40: 1,
      },
      se = {
        91: 93,
        123: 125,
        40: 41,
      };

    function le() {
      return K.charCodeAt(te + 1);
    }

    function ce() {
      return K.charCodeAt(++te);
    }

    function ue() {
      return te >= ee;
    }

    function he() {
      for (; 32 === le(); ) ce();
    }

    function de(e) {
      return 34 === e || 39 === e;
    }

    function pe(e) {
      return ae[e];
    }

    function fe(e, t) {
      return se[e] === t;
    }

    function me() {
      for (var e, t = ce(); !ue(); )
        if (92 === (e = ce())) ce();
        else if (e === t) break;
    }

    function ge(e) {
      for (var t = 0, n = e; !ue(); )
        if (de((e = le()))) me();
        else if ((n === e && t++, fe(n, e) && t--, ce(), 0 === t)) break;
    }

    function ve() {
      for (var e = te; !ue(); )
        if (de((ne = le()))) me();
        else if (pe(ne)) ge(ne);
        else if (124 === ne) {
          if ((ce(), 124 !== (ne = le()))) {
            (0 !== re && 3 !== re) || (re = 1);
            break;
          }
          ce();
        } else {
          if (32 === ne && (2 === re || 3 === re)) {
            he();
            break;
          }
          1 === re && (re = 2), ce();
        }
      return K.slice(e + 1, te) || null;
    }

    function ye() {
      var e,
        t = {};
      return (
        (re = 1),
        (t.name = ve().trim()),
        (re = 3),
        (e = (function () {
          var e = [];
          for (; !ue() && 1 !== re; ) {
            var t = ve();
            if (!t) break;
            e.push(xe(t));
          }
          return e;
        })()).length && (t.args = e),
        t
      );
    }

    function xe(e) {
      if (oe.test(e))
        return {
          value: h(e),
          dynamic: !1,
        };
      var t = p(e),
        n = t === e;
      return {
        value: n ? e : t,
        dynamic: n,
      };
    }

    function be(e) {
      var t,
        n = ie.get(e);
      return (
        n ||
        ((Q = {}),
        (ee = (K = e).length),
        (te = -1),
        (ne = ""),
        (re = 0),
        K.indexOf("|") < 0
          ? (Q.expression = K.trim())
          : ((Q.expression = ve().trim()),
            (t = (function () {
              for (var e = []; !ue(); ) e.push(ye());
              return e;
            })()).length && (Q.filters = t)),
        ie.put(e, Q),
        Q)
      );
    }
    var we = Object.freeze({
        parseDirective: be,
      }),
      _e = /[-.*+?^${}()|[\]\/\\]/g,
      Me = void 0,
      Se = void 0,
      Te = void 0;

    function Ee(e) {
      return e.replace(_e, "\\$&");
    }

    function Ae() {
      var e = Ee(Oe.delimiters[0]),
        t = Ee(Oe.delimiters[1]),
        n = Ee(Oe.unsafeDelimiters[0]),
        r = Ee(Oe.unsafeDelimiters[1]);
      (Se = new RegExp(
        n + "((?:.|\\n)+?)" + r + "|" + e + "((?:.|\\n)+?)" + t,
        "g"
      )),
        (Te = new RegExp("^" + n + "((?:.|\\n)+?)" + r + "$")),
        (Me = new J(1e3));
    }

    function Ce(e) {
      Me || Ae();
      var t = Me.get(e);
      if (t) return t;
      if (!Se.test(e)) return null;
      for (
        var n, r, i, o, a, s, l = [], c = (Se.lastIndex = 0);
        (n = Se.exec(e));

      )
        (r = n.index) > c &&
          l.push({
            value: e.slice(c, r),
          }),
          (a = (o = (i = Te.test(n[0])) ? n[1] : n[2]).charCodeAt(0)),
          (o = (s = 42 === a) ? o.slice(1) : o),
          l.push({
            tag: !0,
            value: o.trim(),
            html: i,
            oneTime: s,
          }),
          (c = r + n[0].length);
      return (
        c < e.length &&
          l.push({
            value: e.slice(c),
          }),
        Me.put(e, l),
        l
      );
    }

    function Pe(e, t) {
      return e.length > 1
        ? e
            .map(function (e) {
              return Le(e, t);
            })
            .join("+")
        : Le(e[0], t, !0);
    }

    function Le(e, t, n) {
      return e.tag
        ? e.oneTime && t
          ? '"' + t.$eval(e.value) + '"'
          : (function (e, t) {
              if (Re.test(e)) {
                var n = be(e);
                return n.filters
                  ? "this._applyFilters(" +
                      n.expression +
                      ",null," +
                      JSON.stringify(n.filters) +
                      ",false)"
                  : "(" + e + ")";
              }
              return t ? e : "(" + e + ")";
            })(e.value, n)
        : '"' + e.value + '"';
    }
    var Re = /[^|]\|[^|]/;
    var Ie = Object.freeze({
        compileRegex: Ae,
        parseText: Ce,
        tokensToExp: Pe,
      }),
      ke = ["{{", "}}"],
      De = ["{{{", "}}}"],
      Oe = Object.defineProperties(
        {
          debug: !1,
          silent: !1,
          async: !0,
          warnExpressionErrors: !0,
          devtools: !1,
          _delimitersChanged: !0,
          _assetTypes: [
            "component",
            "directive",
            "elementDirective",
            "filter",
            "transition",
            "partial",
          ],
          _propBindingModes: {
            ONE_WAY: 0,
            TWO_WAY: 1,
            ONE_TIME: 2,
          },
          _maxUpdateCount: 100,
        },
        {
          delimiters: {
            get: function () {
              return ke;
            },
            set: function (e) {
              (ke = e), Ae();
            },
            configurable: !0,
            enumerable: !0,
          },
          unsafeDelimiters: {
            get: function () {
              return De;
            },
            set: function (e) {
              (De = e), Ae();
            },
            configurable: !0,
            enumerable: !0,
          },
        }
      );

    function Be(e, t, n, r) {
      Ue(
        e,
        1,
        function () {
          t.appendChild(e);
        },
        n,
        r
      );
    }

    function Fe(e, t, n, r) {
      Ue(
        e,
        1,
        function () {
          qe(e, t);
        },
        n,
        r
      );
    }

    function Ne(e, t, n) {
      Ue(
        e,
        -1,
        function () {
          Xe(e);
        },
        t,
        n
      );
    }

    function Ue(e, t, n, r, i) {
      var o = e.__v_trans;
      if (
        !o ||
        (!o.hooks && !G) ||
        !r._isCompiled ||
        (r.$parent && !r.$parent._isCompiled)
      )
        return n(), void (i && i());
      o[t > 0 ? "enter" : "leave"](n, i);
    }
    var ze = Object.freeze({
      appendWithTransition: Be,
      beforeWithTransition: Fe,
      removeWithTransition: Ne,
      applyTransition: Ue,
    });

    function He(e) {
      if ("string" == typeof e) {
        e = document.querySelector(e);
      }
      return e;
    }

    function Ge(e) {
      if (!e) return !1;
      var t = e.ownerDocument.documentElement,
        n = e.parentNode;
      return t === e || t === n || !(!n || 1 !== n.nodeType || !t.contains(n));
    }

    function Ve(e, t) {
      var n = e.getAttribute(t);
      return null !== n && e.removeAttribute(t), n;
    }

    function je(e, t) {
      var n = Ve(e, ":" + t);
      return null === n && (n = Ve(e, "v-bind:" + t)), n;
    }

    function We(e, t) {
      return (
        e.hasAttribute(t) ||
        e.hasAttribute(":" + t) ||
        e.hasAttribute("v-bind:" + t)
      );
    }

    function qe(e, t) {
      t.parentNode.insertBefore(e, t);
    }

    function $e(e, t) {
      t.nextSibling ? qe(e, t.nextSibling) : t.parentNode.appendChild(e);
    }

    function Xe(e) {
      e.parentNode.removeChild(e);
    }

    function Ye(e, t) {
      t.firstChild ? qe(e, t.firstChild) : t.appendChild(e);
    }

    function Je(e, t) {
      var n = e.parentNode;
      n && n.replaceChild(t, e);
    }

    function Ze(e, t, n, r) {
      e.addEventListener(t, n, r);
    }

    function Ke(e, t, n) {
      e.removeEventListener(t, n);
    }

    function Qe(e) {
      var t = e.className;
      return "object" == typeof t && (t = t.baseVal || ""), t;
    }

    function et(e, t) {
      N && !/svg$/.test(e.namespaceURI)
        ? (e.className = t)
        : e.setAttribute("class", t);
    }

    function tt(e, t) {
      if (e.classList) e.classList.add(t);
      else {
        var n = " " + Qe(e) + " ";
        n.indexOf(" " + t + " ") < 0 && et(e, (n + t).trim());
      }
    }

    function nt(e, t) {
      if (e.classList) e.classList.remove(t);
      else {
        for (var n = " " + Qe(e) + " ", r = " " + t + " "; n.indexOf(r) >= 0; )
          n = n.replace(r, " ");
        et(e, n.trim());
      }
      e.className || e.removeAttribute("class");
    }

    function rt(e, t) {
      var n, r;
      if ((at(e) && dt(e.content) && (e = e.content), e.hasChildNodes()))
        for (
          it(e),
            r = t
              ? document.createDocumentFragment()
              : document.createElement("div");
          (n = e.firstChild);

        )
          r.appendChild(n);
      return r;
    }

    function it(e) {
      for (var t; ot((t = e.firstChild)); ) e.removeChild(t);
      for (; ot((t = e.lastChild)); ) e.removeChild(t);
    }

    function ot(e) {
      return e && ((3 === e.nodeType && !e.data.trim()) || 8 === e.nodeType);
    }

    function at(e) {
      return e.tagName && "template" === e.tagName.toLowerCase();
    }

    function st(e, t) {
      var n = Oe.debug
        ? document.createComment(e)
        : document.createTextNode(t ? " " : "");
      return (n.__v_anchor = !0), n;
    }
    var lt = /^v-ref:/;

    function ct(e) {
      if (e.hasAttributes())
        for (var t = e.attributes, n = 0, r = t.length; n < r; n++) {
          var i = t[n].name;
          if (lt.test(i)) return m(i.replace(lt, ""));
        }
    }

    function ut(e, t, n) {
      for (var r; e !== t; ) (r = e.nextSibling), n(e), (e = r);
      n(t);
    }

    function ht(e, t, n, r, i) {
      var o = !1,
        a = 0,
        s = [];

      function l() {
        if ((a++, o && a >= s.length)) {
          for (var e = 0; e < s.length; e++) r.appendChild(s[e]);
          i && i();
        }
      }
      ut(e, t, function (e) {
        e === t && (o = !0), s.push(e), Ne(e, n, l);
      });
    }

    function dt(e) {
      return e && 11 === e.nodeType;
    }

    function pt(e) {
      if (e.outerHTML) return e.outerHTML;
      var t = document.createElement("div");
      return t.appendChild(e.cloneNode(!0)), t.innerHTML;
    }
    var ft =
        /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i,
      mt = /^(slot|partial|component)$/i;

    function gt(e, t) {
      var n = e.tagName.toLowerCase(),
        r = e.hasAttributes();
      if (ft.test(n) || mt.test(n)) {
        if (r) return vt(e, t);
      } else {
        if (St(t, "components", n))
          return {
            id: n,
          };
        var i = r && vt(e, t);
        if (i) return i;
      }
    }

    function vt(e, t) {
      var n = e.getAttribute("is");
      if (null != n) {
        if (St(t, "components", n))
          return (
            e.removeAttribute("is"),
            {
              id: n,
            }
          );
      } else if (null != (n = je(e, "is")))
        return {
          id: n,
          dynamic: !0,
        };
    }
    var yt = (Oe.optionMergeStrategies = Object.create(null));

    function xt(e, t) {
      var n, i, o;
      for (n in t)
        (i = e[n]), (o = t[n]), a(e, n) ? S(i) && S(o) && xt(i, o) : r(e, n, o);
      return e;
    }

    function bt(e, t) {
      var n = Object.create(e || null);
      return t ? M(n, _t(t)) : n;
    }
    (yt.data = function (e, t, n) {
      return n
        ? e || t
          ? function () {
              var r = "function" == typeof t ? t.call(n) : t,
                i = "function" == typeof e ? e.call(n) : void 0;
              return r ? xt(r, i) : i;
            }
          : void 0
        : t
        ? "function" != typeof t
          ? e
          : e
          ? function () {
              return xt(t.call(this), e.call(this));
            }
          : t
        : e;
    }),
      (yt.el = function (e, t, n) {
        if (n || !t || "function" == typeof t) {
          var r = t || e;
          return n && "function" == typeof r ? r.call(n) : r;
        }
      }),
      (yt.init =
        yt.created =
        yt.ready =
        yt.attached =
        yt.detached =
        yt.beforeCompile =
        yt.compiled =
        yt.beforeDestroy =
        yt.destroyed =
        yt.activate =
          function (e, t) {
            return t ? (e ? e.concat(t) : A(t) ? t : [t]) : e;
          }),
      Oe._assetTypes.forEach(function (e) {
        yt[e + "s"] = bt;
      }),
      (yt.watch = yt.events =
        function (e, t) {
          if (!t) return e;
          if (!e) return t;
          var n = {};
          for (var r in (M(n, e), t)) {
            var i = n[r],
              o = t[r];
            i && !A(i) && (i = [i]), (n[r] = i ? i.concat(o) : [o]);
          }
          return n;
        }),
      (yt.props =
        yt.methods =
        yt.computed =
          function (e, t) {
            if (!t) return e;
            if (!e) return t;
            var n = Object.create(null);
            return M(n, e), M(n, t), n;
          });
    var wt = function (e, t) {
      return void 0 === t ? e : t;
    };

    function _t(e) {
      if (A(e)) {
        for (var t, n = {}, r = e.length; r--; ) {
          var i =
            "function" == typeof (t = e[r])
              ? (t.options && t.options.name) || t.id
              : t.name || t.id;
          i && (n[i] = t);
        }
        return n;
      }
      return e;
    }

    function Mt(e, t, n) {
      !(function (e) {
        if (e.components)
          for (
            var t,
              n = (e.components = _t(e.components)),
              r = Object.keys(n),
              i = 0,
              o = r.length;
            i < o;
            i++
          ) {
            var a = r[i];
            ft.test(a) ||
              mt.test(a) ||
              (E((t = n[a])) && (n[a] = yi.extend(t)));
          }
      })(t),
        (function (e) {
          var t,
            n,
            r = e.props;
          if (A(r))
            for (e.props = {}, t = r.length; t--; )
              "string" == typeof (n = r[t])
                ? (e.props[n] = null)
                : n.name && (e.props[n.name] = n);
          else if (E(r)) {
            var i = Object.keys(r);
            for (t = i.length; t--; )
              "function" == typeof (n = r[i[t]]) &&
                (r[i[t]] = {
                  type: n,
                });
          }
        })(t);
      var r,
        i = {};
      if (
        (t.extends &&
          (e =
            "function" == typeof t.extends
              ? Mt(e, t.extends.options, n)
              : Mt(e, t.extends, n)),
        t.mixins)
      )
        for (var o = 0, s = t.mixins.length; o < s; o++) {
          var l = t.mixins[o],
            c = l.prototype instanceof yi ? l.options : l;
          e = Mt(e, c, n);
        }
      for (r in e) u(r);
      for (r in t) a(e, r) || u(r);

      function u(r) {
        var o = yt[r] || wt;
        i[r] = o(e[r], t[r], n, r);
      }
      return i;
    }

    function St(e, t, n, r) {
      if ("string" == typeof n) {
        var i,
          o = e[t];
        return (
          o[n] || o[(i = m(n))] || o[i.charAt(0).toUpperCase() + i.slice(1)]
        );
      }
    }
    var Tt = 0;

    function Et() {
      (this.id = Tt++), (this.subs = []);
    }
    (Et.target = null),
      (Et.prototype.addSub = function (e) {
        this.subs.push(e);
      }),
      (Et.prototype.removeSub = function (e) {
        this.subs.$remove(e);
      }),
      (Et.prototype.depend = function () {
        Et.target.addDep(this);
      }),
      (Et.prototype.notify = function () {
        for (var e = _(this.subs), t = 0, n = e.length; t < n; t++)
          e[t].update();
      });
    var At = Array.prototype,
      Ct = Object.create(At);
    ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(
      function (e) {
        var t = At[e];
        C(Ct, e, function () {
          for (var n = arguments.length, r = new Array(n); n--; )
            r[n] = arguments[n];
          var i,
            o = t.apply(this, r),
            a = this.__ob__;
          switch (e) {
            case "push":
            case "unshift":
              i = r;
              break;
            case "splice":
              i = r.slice(2);
          }
          return i && a.observeArray(i), a.dep.notify(), o;
        });
      }
    ),
      C(At, "$set", function (e, t) {
        return (
          e >= this.length && (this.length = Number(e) + 1),
          this.splice(e, 1, t)[0]
        );
      }),
      C(At, "$remove", function (e) {
        if (this.length) {
          var t = L(this, e);
          return t > -1 ? this.splice(t, 1) : void 0;
        }
      });
    var Pt = Object.getOwnPropertyNames(Ct),
      Lt = !0;

    function Rt(e) {
      (Lt = !1), e(), (Lt = !0);
    }

    function It(e) {
      ((this.value = e), (this.dep = new Et()), C(e, "__ob__", this), A(e))
        ? ((k ? kt : Dt)(e, Ct, Pt), this.observeArray(e))
        : this.walk(e);
    }

    function kt(e, t) {
      e.__proto__ = t;
    }

    function Dt(e, t, n) {
      for (var r = 0, i = n.length; r < i; r++) {
        var o = n[r];
        C(e, o, t[o]);
      }
    }

    function Ot(e, t) {
      var n;
      if (e && "object" == typeof e)
        return (
          a(e, "__ob__") && e.__ob__ instanceof It
            ? (n = e.__ob__)
            : Lt &&
              (A(e) || E(e)) &&
              Object.isExtensible(e) &&
              !e._isVue &&
              (n = new It(e)),
          n && t && n.addVm(t),
          n
        );
    }

    function Bt(e, t, n) {
      var r = new Et(),
        i = Object.getOwnPropertyDescriptor(e, t);
      if (!i || !1 !== i.configurable) {
        var o = i && i.get,
          a = i && i.set,
          s = Ot(n);
        Object.defineProperty(e, t, {
          enumerable: !0,
          configurable: !0,
          get: function () {
            var t = o ? o.call(e) : n;
            if (Et.target && (r.depend(), s && s.dep.depend(), A(t)))
              for (var i, a = 0, l = t.length; a < l; a++)
                (i = t[a]) && i.__ob__ && i.__ob__.dep.depend();
            return t;
          },
          set: function (t) {
            t !== (o ? o.call(e) : n) &&
              (a ? a.call(e, t) : (n = t), (s = Ot(t)), r.notify());
          },
        });
      }
    }
    (It.prototype.walk = function (e) {
      for (var t = Object.keys(e), n = 0, r = t.length; n < r; n++)
        this.convert(t[n], e[t[n]]);
    }),
      (It.prototype.observeArray = function (e) {
        for (var t = 0, n = e.length; t < n; t++) Ot(e[t]);
      }),
      (It.prototype.convert = function (e, t) {
        Bt(this.value, e, t);
      }),
      (It.prototype.addVm = function (e) {
        (this.vms || (this.vms = [])).push(e);
      }),
      (It.prototype.removeVm = function (e) {
        this.vms.$remove(e);
      });
    var Ft = Object.freeze({
        defineReactive: Bt,
        set: r,
        del: i,
        hasOwn: a,
        isLiteral: l,
        isReserved: c,
        _toString: u,
        toNumber: h,
        toBoolean: d,
        stripQuotes: p,
        camelize: m,
        hyphenate: y,
        classify: b,
        bind: w,
        toArray: _,
        extend: M,
        isObject: S,
        isPlainObject: E,
        def: C,
        debounce: P,
        indexOf: L,
        cancellable: R,
        looseEqual: I,
        isArray: A,
        hasProto: k,
        inBrowser: D,
        devtools: O,
        isIE: F,
        isIE9: N,
        isAndroid: U,
        isIOS: z,
        get transitionProp() {
          return H;
        },
        get transitionEndEvent() {
          return G;
        },
        get animationProp() {
          return V;
        },
        get animationEndEvent() {
          return j;
        },
        nextTick: X,
        get _Set() {
          return Y;
        },
        query: He,
        inDoc: Ge,
        getAttr: Ve,
        getBindAttr: je,
        hasBindAttr: We,
        before: qe,
        after: $e,
        remove: Xe,
        prepend: Ye,
        replace: Je,
        on: Ze,
        off: Ke,
        setClass: et,
        addClass: tt,
        removeClass: nt,
        extractContent: rt,
        trimNode: it,
        isTemplate: at,
        createAnchor: st,
        findRef: ct,
        mapNodeRange: ut,
        removeNodeRange: ht,
        isFragment: dt,
        getOuterHTML: pt,
        mergeOptions: Mt,
        resolveAsset: St,
        checkComponentAttr: gt,
        commonTagRE: ft,
        reservedTagRE: mt,
        get warn() {},
      }),
      Nt = 0;
    var Ut = new J(1e3),
      zt = [];

    function Ht(e) {
      if (void 0 === e) return "eof";
      var t = e.charCodeAt(0);
      switch (t) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
        case 48:
          return e;
        case 95:
        case 36:
          return "ident";
        case 32:
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
          return "ws";
      }
      return (t >= 97 && t <= 122) || (t >= 65 && t <= 90)
        ? "ident"
        : t >= 49 && t <= 57
        ? "number"
        : "else";
    }

    function Gt(e) {
      var t,
        n,
        r,
        i,
        o,
        a,
        s,
        c = [],
        u = -1,
        h = 0,
        d = 0,
        f = [];

      function m() {
        var t = e[u + 1];
        if ((5 === h && "'" === t) || (6 === h && '"' === t))
          return u++, (n = "\\" + t), f[0](), !0;
      }
      for (
        f[1] = function () {
          void 0 !== r && (c.push(r), (r = void 0));
        },
          f[0] = function () {
            void 0 === r ? (r = n) : (r += n);
          },
          f[2] = function () {
            f[0](), d++;
          },
          f[3] = function () {
            if (d > 0) d--, (h = 4), f[0]();
            else {
              if (
                ((d = 0),
                !1 ===
                  (r = (function (e) {
                    var t = e.trim();
                    return (
                      ("0" !== e.charAt(0) || !isNaN(e)) &&
                      (l(t) ? p(t) : "*" + t)
                    );
                  })(r)))
              )
                return !1;
              f[1]();
            }
          };
        null != h;

      )
        if ((u++, "\\" !== (t = e[u]) || !m())) {
          if (((i = Ht(t)), 8 === (o = (s = zt[h])[i] || s.else || 8))) return;
          if (
            ((h = o[0]),
            (a = f[o[1]]) && ((n = void 0 === (n = o[2]) ? t : n), !1 === a()))
          )
            return;
          if (7 === h) return (c.raw = e), c;
        }
    }

    function Vt(e) {
      var t = Ut.get(e);
      return t || ((t = Gt(e)) && Ut.put(e, t)), t;
    }

    function jt(e, t) {
      return hn(t).get(e);
    }

    function Wt(e, t, n) {
      var i,
        o,
        a = e;
      if (("string" == typeof t && (t = Gt(t)), !t || !S(e))) return !1;
      for (var s = 0, l = t.length; s < l; s++)
        (i = e),
          "*" === (o = t[s]).charAt(0) && (o = hn(o.slice(1)).get.call(a, a)),
          s < l - 1
            ? S((e = e[o])) || r(i, o, (e = {}))
            : A(e)
            ? e.$set(o, n)
            : o in e
            ? (e[o] = n)
            : r(e, o, n);
      return !0;
    }
    (zt[0] = {
      ws: [0],
      ident: [3, 0],
      "[": [4],
      eof: [7],
    }),
      (zt[1] = {
        ws: [1],
        ".": [2],
        "[": [4],
        eof: [7],
      }),
      (zt[2] = {
        ws: [2],
        ident: [3, 0],
      }),
      (zt[3] = {
        ident: [3, 0],
        0: [3, 0],
        number: [3, 0],
        ws: [1, 1],
        ".": [2, 1],
        "[": [4, 1],
        eof: [7, 1],
      }),
      (zt[4] = {
        "'": [5, 0],
        '"': [6, 0],
        "[": [4, 2],
        "]": [1, 3],
        eof: 8,
        else: [4, 0],
      }),
      (zt[5] = {
        "'": [4, 0],
        eof: 8,
        else: [5, 0],
      }),
      (zt[6] = {
        '"': [4, 0],
        eof: 8,
        else: [6, 0],
      });
    var qt = Object.freeze({
        parsePath: Vt,
        getPath: jt,
        setPath: Wt,
      }),
      $t = new J(1e3),
      Xt = new RegExp(
        "^(" +
          "Math,Date,this,true,false,null,undefined,Infinity,NaN,isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,parseInt,parseFloat".replace(
            /,/g,
            "\\b|"
          ) +
          "\\b)"
      ),
      Yt = new RegExp(
        "^(" +
          "break,case,class,catch,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,let,return,super,switch,throw,try,var,while,with,yield,enum,await,implements,package,protected,static,interface,private,public".replace(
            /,/g,
            "\\b|"
          ) +
          "\\b)"
      ),
      Jt = /\s/g,
      Zt = /\n/g,
      Kt =
        /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\"']|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g,
      Qt = /"(\d+)"/g,
      en =
        /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/,
      tn = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g,
      nn = /^(?:true|false|null|undefined|Infinity|NaN)$/;

    function rn() {}
    var on = [];

    function an(e, t) {
      var n = on.length;
      return (on[n] = t ? e.replace(Zt, "\\n") : e), '"' + n + '"';
    }

    function sn(e) {
      var t = e.charAt(0),
        n = e.slice(1);
      return Xt.test(n)
        ? e
        : t + "scope." + (n = n.indexOf('"') > -1 ? n.replace(Qt, ln) : n);
    }

    function ln(e, t) {
      return on[t];
    }

    function cn(e) {
      try {
        return new Function("scope", "return " + e + ";");
      } catch (e) {
        return rn;
      }
    }

    function un(e) {
      var t = Vt(e);
      if (t)
        return function (e, n) {
          Wt(e, t, n);
        };
    }

    function hn(e, t) {
      e = e.trim();
      var n = $t.get(e);
      if (n) return t && !n.set && (n.set = un(n.exp)), n;
      var r = {
        exp: e,
      };
      return (
        (r.get =
          dn(e) && e.indexOf("[") < 0
            ? cn("scope." + e)
            : (function (e) {
                Yt.test(e), (on.length = 0);
                var t = e.replace(Kt, an).replace(Jt, "");
                return cn((t = (" " + t).replace(tn, sn).replace(Qt, ln)));
              })(e)),
        t && (r.set = un(e)),
        $t.put(e, r),
        r
      );
    }

    function dn(e) {
      return en.test(e) && !nn.test(e) && "Math." !== e.slice(0, 5);
    }
    var pn = Object.freeze({
        parseExpression: hn,
        isSimplePath: dn,
      }),
      fn = [],
      mn = [],
      gn = {},
      vn = !1;

    function yn() {
      for (var e = !0; e; )
        (e = !1),
          xn(fn),
          xn(mn),
          fn.length
            ? (e = !0)
            : (O && Oe.devtools && O.emit("flush"),
              (fn.length = 0),
              (mn.length = 0),
              (gn = {}),
              {},
              (vn = !1));
    }

    function xn(e) {
      for (var t = 0; t < e.length; t++) {
        var n = e[t],
          r = n.id;
        (gn[r] = null), n.run();
      }
      e.length = 0;
    }
    var bn = 0;

    function wn(e, t, n, r) {
      r && M(this, r);
      var i = "function" == typeof t;
      if (
        ((this.vm = e),
        e._watchers.push(this),
        (this.expression = t),
        (this.cb = n),
        (this.id = ++bn),
        (this.active = !0),
        (this.dirty = this.lazy),
        (this.deps = []),
        (this.newDeps = []),
        (this.depIds = new Y()),
        (this.newDepIds = new Y()),
        (this.prevError = null),
        i)
      )
        (this.getter = t), (this.setter = void 0);
      else {
        var o = hn(t, this.twoWay);
        (this.getter = o.get), (this.setter = o.set);
      }
      (this.value = this.lazy ? void 0 : this.get()),
        (this.queued = this.shallow = !1);
    }
    (wn.prototype.get = function () {
      this.beforeGet();
      var e,
        t = this.scope || this.vm;
      try {
        e = this.getter.call(t, t);
      } catch (e) {
        0;
      }
      return (
        this.deep &&
          (function e(t, n) {
            var r = void 0,
              i = void 0;
            n || (n = _n).clear();
            var o = A(t),
              a = S(t);
            if ((o || a) && Object.isExtensible(t)) {
              if (t.__ob__) {
                var s = t.__ob__.dep.id;
                if (n.has(s)) return;
                n.add(s);
              }
              if (o) for (r = t.length; r--; ) e(t[r], n);
              else if (a)
                for (i = Object.keys(t), r = i.length; r--; ) e(t[i[r]], n);
            }
          })(e),
        this.preProcess && (e = this.preProcess(e)),
        this.filters && (e = t._applyFilters(e, null, this.filters, !1)),
        this.postProcess && (e = this.postProcess(e)),
        this.afterGet(),
        e
      );
    }),
      (wn.prototype.set = function (e) {
        var t = this.scope || this.vm;
        this.filters && (e = t._applyFilters(e, this.value, this.filters, !0));
        try {
          this.setter.call(t, t, e);
        } catch (e) {
          0;
        }
        var n = t.$forContext;
        if (n && n.alias === this.expression) {
          if (n.filters) return;
          n._withLock(function () {
            t.$key ? (n.rawValue[t.$key] = e) : n.rawValue.$set(t.$index, e);
          });
        }
      }),
      (wn.prototype.beforeGet = function () {
        Et.target = this;
      }),
      (wn.prototype.addDep = function (e) {
        var t = e.id;
        this.newDepIds.has(t) ||
          (this.newDepIds.add(t),
          this.newDeps.push(e),
          this.depIds.has(t) || e.addSub(this));
      }),
      (wn.prototype.afterGet = function () {
        Et.target = null;
        for (var e = this.deps.length; e--; ) {
          var t = this.deps[e];
          this.newDepIds.has(t.id) || t.removeSub(this);
        }
        var n = this.depIds;
        (this.depIds = this.newDepIds),
          (this.newDepIds = n),
          this.newDepIds.clear(),
          (n = this.deps),
          (this.deps = this.newDeps),
          (this.newDeps = n),
          (this.newDeps.length = 0);
      }),
      (wn.prototype.update = function (e) {
        this.lazy
          ? (this.dirty = !0)
          : this.sync || !Oe.async
          ? this.run()
          : ((this.shallow = this.queued ? !!e && this.shallow : !!e),
            (this.queued = !0),
            (function (e) {
              var t = e.id;
              if (null == gn[t]) {
                var n = e.user ? mn : fn;
                (gn[t] = n.length), n.push(e), vn || ((vn = !0), X(yn));
              }
            })(this));
      }),
      (wn.prototype.run = function () {
        if (this.active) {
          var e = this.get();
          if (e !== this.value || ((S(e) || this.deep) && !this.shallow)) {
            var t = this.value;
            this.value = e;
            this.prevError;
            this.cb.call(this.vm, e, t);
          }
          this.queued = this.shallow = !1;
        }
      }),
      (wn.prototype.evaluate = function () {
        var e = Et.target;
        (this.value = this.get()), (this.dirty = !1), (Et.target = e);
      }),
      (wn.prototype.depend = function () {
        for (var e = this.deps.length; e--; ) this.deps[e].depend();
      }),
      (wn.prototype.teardown = function () {
        if (this.active) {
          this.vm._isBeingDestroyed ||
            this.vm._vForRemoving ||
            this.vm._watchers.$remove(this);
          for (var e = this.deps.length; e--; ) this.deps[e].removeSub(this);
          (this.active = !1), (this.vm = this.cb = this.value = null);
        }
      });
    var _n = new Y();
    var Mn = {
        bind: function () {
          this.attr = 3 === this.el.nodeType ? "data" : "textContent";
        },
        update: function (e) {
          this.el[this.attr] = u(e);
        },
      },
      Sn = new J(1e3),
      Tn = new J(1e3),
      En = {
        efault: [0, "", ""],
        legend: [1, "<fieldset>", "</fieldset>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
      };

    function An(e) {
      return at(e) && dt(e.content);
    }
    (En.td = En.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"]),
      (En.option = En.optgroup =
        [1, '<select multiple="multiple">', "</select>"]),
      (En.thead =
        En.tbody =
        En.colgroup =
        En.caption =
        En.tfoot =
          [1, "<table>", "</table>"]),
      (En.g =
        En.defs =
        En.symbol =
        En.use =
        En.image =
        En.text =
        En.circle =
        En.ellipse =
        En.line =
        En.path =
        En.polygon =
        En.polyline =
        En.rect =
          [
            1,
            '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ev="http://www.w3.org/2001/xml-events"version="1.1">',
            "</svg>",
          ]);
    var Cn = /<([\w:-]+)/,
      Pn = /&#?\w+?;/,
      Ln = /<!--/;

    function Rn(e, t) {
      var n = t ? e : e.trim(),
        r = Sn.get(n);
      if (r) return r;
      var i = document.createDocumentFragment(),
        o = e.match(Cn),
        a = Pn.test(e),
        s = Ln.test(e);
      if (o || a || s) {
        var l,
          c = o && o[1],
          u = En[c] || En.efault,
          h = u[0],
          d = u[1],
          p = u[2],
          f = document.createElement("div");
        for (f.innerHTML = d + e + p; h--; ) f = f.lastChild;
        for (; (l = f.firstChild); ) i.appendChild(l);
      } else i.appendChild(document.createTextNode(e));
      return t || it(i), Sn.put(n, i), i;
    }

    function In(e) {
      if (An(e)) return Rn(e.innerHTML);
      if ("SCRIPT" === e.tagName) return Rn(e.textContent);
      for (
        var t, n = On(e), r = document.createDocumentFragment();
        (t = n.firstChild);

      )
        r.appendChild(t);
      return it(r), r;
    }
    var kn = (function () {
        if (D) {
          var e = document.createElement("div");
          return (
            (e.innerHTML = "<template>1</template>"),
            !e.cloneNode(!0).firstChild.innerHTML
          );
        }
        return !1;
      })(),
      Dn = (function () {
        if (D) {
          var e = document.createElement("textarea");
          return (e.placeholder = "t"), "t" === e.cloneNode(!0).value;
        }
        return !1;
      })();

    function On(e) {
      if (!e.querySelectorAll) return e.cloneNode();
      var t,
        n,
        r,
        i = e.cloneNode(!0);
      if (kn) {
        var o = i;
        if (
          (An(e) && ((e = e.content), (o = i.content)),
          (n = e.querySelectorAll("template")).length)
        )
          for (t = (r = o.querySelectorAll("template")).length; t--; )
            r[t].parentNode.replaceChild(On(n[t]), r[t]);
      }
      if (Dn)
        if ("TEXTAREA" === e.tagName) i.value = e.value;
        else if ((n = e.querySelectorAll("textarea")).length)
          for (t = (r = i.querySelectorAll("textarea")).length; t--; )
            r[t].value = n[t].value;
      return i;
    }

    function Bn(e, t, n) {
      var r, i;
      return dt(e)
        ? (it(e), t ? On(e) : e)
        : ("string" == typeof e
            ? n || "#" !== e.charAt(0)
              ? (i = Rn(e, n))
              : (i = Tn.get(e)) ||
                ((r = document.getElementById(e.slice(1))) &&
                  ((i = In(r)), Tn.put(e, i)))
            : e.nodeType && (i = In(e)),
          i && t ? On(i) : i);
    }
    var Fn = Object.freeze({
        cloneNode: On,
        parseTemplate: Bn,
      }),
      Nn = {
        bind: function () {
          8 === this.el.nodeType &&
            ((this.nodes = []),
            (this.anchor = st("v-html")),
            Je(this.el, this.anchor));
        },
        update: function (e) {
          (e = u(e)), this.nodes ? this.swap(e) : (this.el.innerHTML = e);
        },
        swap: function (e) {
          for (var t = this.nodes.length; t--; ) Xe(this.nodes[t]);
          var n = Bn(e, !0, !0);
          (this.nodes = _(n.childNodes)), qe(n, this.anchor);
        },
      };

    function Un(e, t, n, r, i, o) {
      (this.children = []),
        (this.childFrags = []),
        (this.vm = t),
        (this.scope = i),
        (this.inserted = !1),
        (this.parentFrag = o),
        o && o.childFrags.push(this),
        (this.unlink = e(t, n, r, i, this)),
        (this.single = 1 === n.childNodes.length && !n.childNodes[0].__v_anchor)
          ? ((this.node = n.childNodes[0]),
            (this.before = zn),
            (this.remove = Hn))
          : ((this.node = st("fragment-start")),
            (this.end = st("fragment-end")),
            (this.frag = n),
            Ye(this.node, n),
            n.appendChild(this.end),
            (this.before = Gn),
            (this.remove = Vn)),
        (this.node.__v_frag = this);
    }

    function zn(e, t) {
      (this.inserted = !0),
        (!1 !== t ? Fe : qe)(this.node, e, this.vm),
        Ge(this.node) && this.callHook(jn);
    }

    function Hn() {
      this.inserted = !1;
      var e = Ge(this.node),
        t = this;
      this.beforeRemove(),
        Ne(this.node, this.vm, function () {
          e && t.callHook(Wn), t.destroy();
        });
    }

    function Gn(e, t) {
      this.inserted = !0;
      var n = this.vm,
        r = !1 !== t ? Fe : qe;
      ut(this.node, this.end, function (t) {
        r(t, e, n);
      }),
        Ge(this.node) && this.callHook(jn);
    }

    function Vn() {
      this.inserted = !1;
      var e = this,
        t = Ge(this.node);
      this.beforeRemove(),
        ht(this.node, this.end, this.vm, this.frag, function () {
          t && e.callHook(Wn), e.destroy();
        });
    }

    function jn(e) {
      !e._isAttached && Ge(e.$el) && e._callHook("attached");
    }

    function Wn(e) {
      e._isAttached && !Ge(e.$el) && e._callHook("detached");
    }
    (Un.prototype.callHook = function (e) {
      var t, n;
      for (t = 0, n = this.childFrags.length; t < n; t++)
        this.childFrags[t].callHook(e);
      for (t = 0, n = this.children.length; t < n; t++) e(this.children[t]);
    }),
      (Un.prototype.beforeRemove = function () {
        var e, t;
        for (e = 0, t = this.childFrags.length; e < t; e++)
          this.childFrags[e].beforeRemove(!1);
        for (e = 0, t = this.children.length; e < t; e++)
          this.children[e].$destroy(!1, !0);
        var n = this.unlink.dirs;
        for (e = 0, t = n.length; e < t; e++)
          n[e]._watcher && n[e]._watcher.teardown();
      }),
      (Un.prototype.destroy = function () {
        this.parentFrag && this.parentFrag.childFrags.$remove(this),
          (this.node.__v_frag = null),
          this.unlink();
      });
    var qn = new J(5e3);

    function $n(e, t) {
      var n;
      this.vm = e;
      var r,
        i = "string" == typeof t;
      i || (at(t) && !t.hasAttribute("v-if"))
        ? (n = Bn(t, !0))
        : (n = document.createDocumentFragment()).appendChild(t),
        (this.template = n);
      var o = e.constructor.cid;
      if (o > 0) {
        var a = o + (i ? t : pt(t));
        (r = qn.get(a)) || ((r = Xr(n, e.$options, !0)), qn.put(a, r));
      } else r = Xr(n, e.$options, !0);
      this.linker = r;
    }
    $n.prototype.create = function (e, t, n) {
      var r = On(this.template);
      return new Un(this.linker, this.vm, r, e, t, n);
    };
    var Xn = 0,
      Yn = {
        priority: 2200,
        terminal: !0,
        params: ["track-by", "stagger", "enter-stagger", "leave-stagger"],
        bind: function () {
          var e = this.expression.match(/(.*) (?:in|of) (.*)/);
          if (e) {
            var t = e[1].match(/\((.*),(.*)\)/);
            t
              ? ((this.iterator = t[1].trim()), (this.alias = t[2].trim()))
              : (this.alias = e[1].trim()),
              (this.expression = e[2]);
          }
          if (this.alias) {
            this.id = "__v-for__" + ++Xn;
            var n = this.el.tagName;
            (this.isOption =
              ("OPTION" === n || "OPTGROUP" === n) &&
              "SELECT" === this.el.parentNode.tagName),
              (this.start = st("v-for-start")),
              (this.end = st("v-for-end")),
              Je(this.el, this.end),
              qe(this.start, this.end),
              (this.cache = Object.create(null)),
              (this.factory = new $n(this.vm, this.el));
          }
        },
        update: function (e) {
          this.diff(e), this.updateRef(), this.updateModel();
        },
        diff: function (e) {
          var t,
            n,
            r,
            i,
            o,
            s,
            l = e[0],
            c = (this.fromObject = S(l) && a(l, "$key") && a(l, "$value")),
            u = this.params.trackBy,
            h = this.frags,
            d = (this.frags = new Array(e.length)),
            p = this.alias,
            f = this.iterator,
            m = this.start,
            g = this.end,
            v = Ge(m),
            y = !h;
          for (t = 0, n = e.length; t < n; t++)
            (l = e[t]),
              (i = c ? l.$key : null),
              (s = !S((o = c ? l.$value : l))),
              (r = !y && this.getCachedFrag(o, t, i))
                ? ((r.reused = !0),
                  (r.scope.$index = t),
                  i && (r.scope.$key = i),
                  f && (r.scope[f] = null !== i ? i : t),
                  (u || c || s) &&
                    Rt(function () {
                      r.scope[p] = o;
                    }))
                : ((r = this.create(o, p, t, i)).fresh = !y),
              (d[t] = r),
              y && r.before(g);
          if (!y) {
            var x,
              b,
              w,
              _ = 0,
              M = h.length - d.length;
            for (this.vm._vForRemoving = !0, t = 0, n = h.length; t < n; t++)
              (r = h[t]).reused ||
                (this.deleteCachedFrag(r), this.remove(r, _++, M, v));
            (this.vm._vForRemoving = !1),
              _ &&
                (this.vm._watchers = this.vm._watchers.filter(function (e) {
                  return e.active;
                }));
            var T = 0;
            for (t = 0, n = d.length; t < n; t++)
              (r = d[t]),
                (b = (x = d[t - 1])
                  ? x.staggerCb
                    ? x.staggerAnchor
                    : x.end || x.node
                  : m),
                r.reused && !r.staggerCb
                  ? (w = Jn(r, m, this.id)) === x ||
                    (w && Jn(w, m, this.id) === x) ||
                    this.move(r, b)
                  : this.insert(r, T++, b, v),
                (r.reused = r.fresh = !1);
          }
        },
        create: function (e, t, n, r) {
          var i = this._host,
            o = this._scope || this.vm,
            a = Object.create(o);
          (a.$refs = Object.create(o.$refs)),
            (a.$els = Object.create(o.$els)),
            (a.$parent = o),
            (a.$forContext = this),
            Rt(function () {
              Bt(a, t, e);
            }),
            Bt(a, "$index", n),
            r ? Bt(a, "$key", r) : a.$key && C(a, "$key", null),
            this.iterator && Bt(a, this.iterator, null !== r ? r : n);
          var s = this.factory.create(i, a, this._frag);
          return (s.forId = this.id), this.cacheFrag(e, s, n, r), s;
        },
        updateRef: function () {
          var e = this.descriptor.ref;
          if (e) {
            var t,
              n = (this._scope || this.vm).$refs;
            this.fromObject
              ? ((t = {}),
                this.frags.forEach(function (e) {
                  t[e.scope.$key] = Kn(e);
                }))
              : (t = this.frags.map(Kn)),
              (n[e] = t);
          }
        },
        updateModel: function () {
          if (this.isOption) {
            var e = this.start.parentNode,
              t = e && e.__v_model;
            t && t.forceUpdate();
          }
        },
        insert: function (e, t, n, r) {
          e.staggerCb && (e.staggerCb.cancel(), (e.staggerCb = null));
          var i = this.getStagger(e, t, null, "enter");
          if (r && i) {
            var o = e.staggerAnchor;
            o || ((o = e.staggerAnchor = st("stagger-anchor")).__v_frag = e),
              $e(o, n);
            var a = (e.staggerCb = R(function () {
              (e.staggerCb = null), e.before(o), Xe(o);
            }));
            setTimeout(a, i);
          } else {
            var s = n.nextSibling;
            s || ($e(this.end, n), (s = this.end)), e.before(s);
          }
        },
        remove: function (e, t, n, r) {
          if (e.staggerCb)
            return e.staggerCb.cancel(), void (e.staggerCb = null);
          var i = this.getStagger(e, t, n, "leave");
          if (r && i) {
            var o = (e.staggerCb = R(function () {
              (e.staggerCb = null), e.remove();
            }));
            setTimeout(o, i);
          } else e.remove();
        },
        move: function (e, t) {
          t.nextSibling || this.end.parentNode.appendChild(this.end),
            e.before(t.nextSibling, !1);
        },
        cacheFrag: function (e, t, n, r) {
          var i,
            o = this.params.trackBy,
            s = this.cache,
            l = !S(e);
          r || o || l
            ? s[(i = Zn(n, r, e, o))] || (s[i] = t)
            : a(e, (i = this.id))
            ? null === e[i] && (e[i] = t)
            : Object.isExtensible(e) && C(e, i, t),
            (t.raw = e);
        },
        getCachedFrag: function (e, t, n) {
          var r,
            i = this.params.trackBy,
            o = !S(e);
          if (n || i || o) {
            var a = Zn(t, n, e, i);
            r = this.cache[a];
          } else r = e[this.id];
          return r && (r.reused || r.fresh), r;
        },
        deleteCachedFrag: function (e) {
          var t = e.raw,
            n = this.params.trackBy,
            r = e.scope,
            i = r.$index,
            o = a(r, "$key") && r.$key,
            s = !S(t);
          if (n || o || s) {
            var l = Zn(i, o, t, n);
            this.cache[l] = null;
          } else (t[this.id] = null), (e.raw = null);
        },
        getStagger: function (e, t, n, r) {
          r += "Stagger";
          var i = e.node.__v_trans,
            o = i && i.hooks,
            a = o && (o[r] || o.stagger);
          return a
            ? a.call(e, t, n)
            : t * parseInt(this.params[r] || this.params.stagger, 10);
        },
        _preProcess: function (e) {
          return (this.rawValue = e), e;
        },
        _postProcess: function (e) {
          if (A(e)) return e;
          if (E(e)) {
            for (
              var t, n = Object.keys(e), r = n.length, i = new Array(r);
              r--;

            )
              (t = n[r]),
                (i[r] = {
                  $key: t,
                  $value: e[t],
                });
            return i;
          }
          return (
            "number" != typeof e ||
              isNaN(e) ||
              (e = (function (e) {
                var t = -1,
                  n = new Array(Math.floor(e));
                for (; ++t < e; ) n[t] = t;
                return n;
              })(e)),
            e || []
          );
        },
        unbind: function () {
          if (
            (this.descriptor.ref &&
              ((this._scope || this.vm).$refs[this.descriptor.ref] = null),
            this.frags)
          )
            for (var e, t = this.frags.length; t--; )
              (e = this.frags[t]), this.deleteCachedFrag(e), e.destroy();
        },
      };

    function Jn(e, t, n) {
      var r = e.node.previousSibling;
      if (r) {
        for (
          e = r.__v_frag;
          !((e && e.forId === n && e.inserted) || r === t);

        ) {
          if (!(r = r.previousSibling)) return;
          e = r.__v_frag;
        }
        return e;
      }
    }

    function Zn(e, t, n, r) {
      return r
        ? "$index" === r
          ? e
          : r.charAt(0).match(/\w/)
          ? jt(n, r)
          : n[r]
        : t || n;
    }

    function Kn(e) {
      var t = e.node;
      if (e.end)
        for (; !t.__vue__ && t !== e.end && t.nextSibling; ) t = t.nextSibling;
      return t.__vue__;
    }
    var Qn = {
        priority: 2100,
        terminal: !0,
        bind: function () {
          var e = this.el;
          if (e.__vue__) this.invalid = !0;
          else {
            var t = e.nextElementSibling;
            t && null !== Ve(t, "v-else") && (Xe(t), (this.elseEl = t)),
              (this.anchor = st("v-if")),
              Je(e, this.anchor);
          }
        },
        update: function (e) {
          this.invalid || (e ? this.frag || this.insert() : this.remove());
        },
        insert: function () {
          this.elseFrag && (this.elseFrag.remove(), (this.elseFrag = null)),
            this.factory || (this.factory = new $n(this.vm, this.el)),
            (this.frag = this.factory.create(
              this._host,
              this._scope,
              this._frag
            )),
            this.frag.before(this.anchor);
        },
        remove: function () {
          this.frag && (this.frag.remove(), (this.frag = null)),
            this.elseEl &&
              !this.elseFrag &&
              (this.elseFactory ||
                (this.elseFactory = new $n(
                  this.elseEl._context || this.vm,
                  this.elseEl
                )),
              (this.elseFrag = this.elseFactory.create(
                this._host,
                this._scope,
                this._frag
              )),
              this.elseFrag.before(this.anchor));
        },
        unbind: function () {
          this.frag && this.frag.destroy(),
            this.elseFrag && this.elseFrag.destroy();
        },
      },
      er = {
        bind: function () {
          var e = this.el.nextElementSibling;
          e && null !== Ve(e, "v-else") && (this.elseEl = e);
        },
        update: function (e) {
          this.apply(this.el, e), this.elseEl && this.apply(this.elseEl, !e);
        },
        apply: function (e, t) {
          function n() {
            e.style.display = t ? "" : "none";
          }
          Ge(e) ? Ue(e, t ? 1 : -1, n, this.vm) : n();
        },
      };

    function tr(e, t, n) {
      for (var r, i, o = t ? [] : null, a = 0, s = e.options.length; a < s; a++)
        if (((r = e.options[a]), n ? r.hasAttribute("selected") : r.selected)) {
          if (((i = r.hasOwnProperty("_value") ? r._value : r.value), !t))
            return i;
          o.push(i);
        }
      return o;
    }

    function nr(e, t) {
      for (var n = e.length; n--; ) if (I(e[n], t)) return n;
      return -1;
    }
    var rr = {
        text: {
          bind: function () {
            var e = this,
              t = this.el,
              n = "range" === t.type,
              r = this.params.lazy,
              i = this.params.number,
              o = this.params.debounce,
              a = !1;
            if (
              (U ||
                n ||
                (this.on("compositionstart", function () {
                  a = !0;
                }),
                this.on("compositionend", function () {
                  (a = !1), r || e.listener();
                })),
              (this.focused = !1),
              n ||
                r ||
                (this.on("focus", function () {
                  e.focused = !0;
                }),
                this.on("blur", function () {
                  (e.focused = !1),
                    (e._frag && !e._frag.inserted) || e.rawListener();
                })),
              (this.listener = this.rawListener =
                function () {
                  if (!a && e._bound) {
                    var r = i || n ? h(t.value) : t.value;
                    e.set(r),
                      X(function () {
                        e._bound && !e.focused && e.update(e._watcher.value);
                      });
                  }
                }),
              o && (this.listener = P(this.listener, o)),
              (this.hasjQuery = "function" == typeof jQuery),
              this.hasjQuery)
            ) {
              var s = jQuery.fn.on ? "on" : "bind";
              jQuery(t)[s]("change", this.rawListener),
                r || jQuery(t)[s]("input", this.listener);
            } else
              this.on("change", this.rawListener),
                r || this.on("input", this.listener);
            !r &&
              N &&
              (this.on("cut", function () {
                X(e.listener);
              }),
              this.on("keyup", function (t) {
                (46 !== t.keyCode && 8 !== t.keyCode) || e.listener();
              })),
              (t.hasAttribute("value") ||
                ("TEXTAREA" === t.tagName && t.value.trim())) &&
                (this.afterBind = this.listener);
          },
          update: function (e) {
            (e = u(e)) !== this.el.value && (this.el.value = e);
          },
          unbind: function () {
            var e = this.el;
            if (this.hasjQuery) {
              var t = jQuery.fn.off ? "off" : "unbind";
              jQuery(e)[t]("change", this.listener),
                jQuery(e)[t]("input", this.listener);
            }
          },
        },
        radio: {
          bind: function () {
            var e = this,
              t = this.el;
            (this.getValue = function () {
              if (t.hasOwnProperty("_value")) return t._value;
              var n = t.value;
              return e.params.number && (n = h(n)), n;
            }),
              (this.listener = function () {
                e.set(e.getValue());
              }),
              this.on("change", this.listener),
              t.hasAttribute("checked") && (this.afterBind = this.listener);
          },
          update: function (e) {
            this.el.checked = I(e, this.getValue());
          },
        },
        select: {
          bind: function () {
            var e = this,
              t = this,
              n = this.el;
            this.forceUpdate = function () {
              t._watcher && t.update(t._watcher.get());
            };
            var r = (this.multiple = n.hasAttribute("multiple"));
            (this.listener = function () {
              var e = tr(n, r);
              (e = t.params.number ? (A(e) ? e.map(h) : h(e)) : e), t.set(e);
            }),
              this.on("change", this.listener);
            var i = tr(n, r, !0);
            ((r && i.length) || (!r && null !== i)) &&
              (this.afterBind = this.listener),
              this.vm.$on("hook:attached", function () {
                X(e.forceUpdate);
              }),
              Ge(n) || X(this.forceUpdate);
          },
          update: function (e) {
            var t = this.el;
            t.selectedIndex = -1;
            for (
              var n, r, i = this.multiple && A(e), o = t.options, a = o.length;
              a--;

            )
              (r = (n = o[a]).hasOwnProperty("_value") ? n._value : n.value),
                (n.selected = i ? nr(e, r) > -1 : I(e, r));
          },
          unbind: function () {
            this.vm.$off("hook:attached", this.forceUpdate);
          },
        },
        checkbox: {
          bind: function () {
            var e = this,
              t = this.el;
            (this.getValue = function () {
              return t.hasOwnProperty("_value")
                ? t._value
                : e.params.number
                ? h(t.value)
                : t.value;
            }),
              (this.listener = function () {
                var n = e._watcher.get();
                if (A(n)) {
                  var r = e.getValue(),
                    i = L(n, r);
                  t.checked
                    ? i < 0 && e.set(n.concat(r))
                    : i > -1 && e.set(n.slice(0, i).concat(n.slice(i + 1)));
                } else
                  e.set(
                    (function () {
                      var e = t.checked;
                      return e && t.hasOwnProperty("_trueValue")
                        ? t._trueValue
                        : !e && t.hasOwnProperty("_falseValue")
                        ? t._falseValue
                        : e;
                    })()
                  );
              }),
              this.on("change", this.listener),
              t.hasAttribute("checked") && (this.afterBind = this.listener);
          },
          update: function (e) {
            var t = this.el;
            A(e)
              ? (t.checked = L(e, this.getValue()) > -1)
              : t.hasOwnProperty("_trueValue")
              ? (t.checked = I(e, t._trueValue))
              : (t.checked = !!e);
          },
        },
      },
      ir = {
        priority: 800,
        twoWay: !0,
        handlers: rr,
        params: ["lazy", "number", "debounce"],
        bind: function () {
          this.checkFilters(), this.hasRead && this.hasWrite;
          var e,
            t = this.el,
            n = t.tagName;
          if ("INPUT" === n) e = rr[t.type] || rr.text;
          else if ("SELECT" === n) e = rr.select;
          else {
            if ("TEXTAREA" !== n) return;
            e = rr.text;
          }
          (t.__v_model = this),
            e.bind.call(this),
            (this.update = e.update),
            (this._unbind = e.unbind);
        },
        checkFilters: function () {
          var e = this.filters;
          if (e)
            for (var t = e.length; t--; ) {
              var n = St(this.vm.$options, "filters", e[t].name);
              ("function" == typeof n || n.read) && (this.hasRead = !0),
                n.write && (this.hasWrite = !0);
            }
        },
        unbind: function () {
          (this.el.__v_model = null), this._unbind && this._unbind();
        },
      },
      or = {
        esc: 27,
        tab: 9,
        enter: 13,
        space: 32,
        delete: [8, 46],
        up: 38,
        left: 37,
        right: 39,
        down: 40,
      };
    var ar = {
        priority: 700,
        acceptStatement: !0,
        keyCodes: or,
        bind: function () {
          if ("IFRAME" === this.el.tagName && "load" !== this.arg) {
            var e = this;
            (this.iframeBind = function () {
              Ze(e.el.contentWindow, e.arg, e.handler, e.modifiers.capture);
            }),
              this.on("load", this.iframeBind);
          }
        },
        update: function (e) {
          if (
            (this.descriptor.raw || (e = function () {}),
            "function" == typeof e)
          ) {
            this.modifiers.stop &&
              (e = (function (e) {
                return function (t) {
                  return t.stopPropagation(), e.call(this, t);
                };
              })(e)),
              this.modifiers.prevent &&
                (e = (function (e) {
                  return function (t) {
                    return t.preventDefault(), e.call(this, t);
                  };
                })(e)),
              this.modifiers.self &&
                (e = (function (e) {
                  return function (t) {
                    if (t.target === t.currentTarget) return e.call(this, t);
                  };
                })(e));
            var t = Object.keys(this.modifiers).filter(function (e) {
              return (
                "stop" !== e &&
                "prevent" !== e &&
                "self" !== e &&
                "capture" !== e
              );
            });
            t.length &&
              (e = (function (e, t) {
                var n = t.map(function (e) {
                  var t = e.charCodeAt(0);
                  return t > 47 && t < 58
                    ? parseInt(e, 10)
                    : 1 === e.length &&
                      (t = e.toUpperCase().charCodeAt(0)) > 64 &&
                      t < 91
                    ? t
                    : or[e];
                });
                return (
                  (n = [].concat.apply([], n)),
                  function (t) {
                    if (n.indexOf(t.keyCode) > -1) return e.call(this, t);
                  }
                );
              })(e, t)),
              this.reset(),
              (this.handler = e),
              this.iframeBind
                ? this.iframeBind()
                : Ze(this.el, this.arg, this.handler, this.modifiers.capture);
          }
        },
        reset: function () {
          var e = this.iframeBind ? this.el.contentWindow : this.el;
          this.handler && Ke(e, this.arg, this.handler);
        },
        unbind: function () {
          this.reset();
        },
      },
      sr = ["-webkit-", "-moz-", "-ms-"],
      lr = ["Webkit", "Moz", "ms"],
      cr = /!important;?$/,
      ur = Object.create(null),
      hr = null,
      dr = {
        deep: !0,
        update: function (e) {
          "string" == typeof e
            ? (this.el.style.cssText = e)
            : A(e)
            ? this.handleObject(e.reduce(M, {}))
            : this.handleObject(e || {});
        },
        handleObject: function (e) {
          var t,
            n,
            r = this.cache || (this.cache = {});
          for (t in r) t in e || (this.handleSingle(t, null), delete r[t]);
          for (t in e)
            (n = e[t]) !== r[t] && ((r[t] = n), this.handleSingle(t, n));
        },
        handleSingle: function (e, t) {
          if (
            (e = (function (e) {
              if (ur[e]) return ur[e];
              var t = (function (e) {
                var t = m((e = y(e))),
                  n = t.charAt(0).toUpperCase() + t.slice(1);
                hr || (hr = document.createElement("div"));
                var r,
                  i = sr.length;
                if ("filter" !== t && t in hr.style)
                  return {
                    kebab: e,
                    camel: t,
                  };
                for (; i--; )
                  if ((r = lr[i] + n) in hr.style)
                    return {
                      kebab: sr[i] + e,
                      camel: r,
                    };
              })(e);
              return (ur[e] = ur[t] = t), t;
            })(e))
          )
            if ((null != t && (t += ""), t)) {
              var n = cr.test(t) ? "important" : "";
              n
                ? ((t = t.replace(cr, "").trim()),
                  this.el.style.setProperty(e.kebab, t, n))
                : (this.el.style[e.camel] = t);
            } else this.el.style[e.camel] = "";
        },
      };
    var pr = /^xlink:/,
      fr =
        /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/,
      mr = /^(?:value|checked|selected|muted)$/,
      gr = /^(?:draggable|contenteditable|spellcheck)$/,
      vr = {
        value: "_value",
        "true-value": "_trueValue",
        "false-value": "_falseValue",
      },
      yr = {
        priority: 850,
        bind: function () {
          var e = this.arg,
            t = this.el.tagName;
          e || (this.deep = !0);
          var n = this.descriptor,
            r = n.interp;
          r &&
            (n.hasOneTime && (this.expression = Pe(r, this._scope || this.vm)),
            (fr.test(e) ||
              ("name" === e && ("PARTIAL" === t || "SLOT" === t))) &&
              (this.el.removeAttribute(e), (this.invalid = !0)));
        },
        update: function (e) {
          if (!this.invalid) {
            var t = this.arg;
            this.arg ? this.handleSingle(t, e) : this.handleObject(e || {});
          }
        },
        handleObject: dr.handleObject,
        handleSingle: function (e, t) {
          var n = this.el,
            r = this.descriptor.interp;
          if (
            (this.modifiers.camel && (e = m(e)), !r && mr.test(e) && e in n)
          ) {
            var i = "value" === e && null == t ? "" : t;
            n[e] !== i && (n[e] = i);
          }
          var o = vr[e];
          if (!r && o) {
            n[o] = t;
            var a = n.__v_model;
            a && a.listener();
          }
          "value" !== e || "TEXTAREA" !== n.tagName
            ? gr.test(e)
              ? n.setAttribute(e, t ? "true" : "false")
              : null != t && !1 !== t
              ? "class" === e
                ? (n.__v_trans && (t += " " + n.__v_trans.id + "-transition"),
                  et(n, t))
                : pr.test(e)
                ? n.setAttributeNS(
                    "http://www.w3.org/1999/xlink",
                    e,
                    !0 === t ? "" : t
                  )
                : n.setAttribute(e, !0 === t ? "" : t)
              : n.removeAttribute(e)
            : n.removeAttribute(e);
        },
      },
      xr = {
        text: Mn,
        html: Nn,
        for: Yn,
        if: Qn,
        show: er,
        model: ir,
        on: ar,
        bind: yr,
        el: {
          priority: 1500,
          bind: function () {
            if (this.arg) {
              var e = (this.id = m(this.arg)),
                t = (this._scope || this.vm).$els;
              a(t, e) ? (t[e] = this.el) : Bt(t, e, this.el);
            }
          },
          unbind: function () {
            var e = (this._scope || this.vm).$els;
            e[this.id] === this.el && (e[this.id] = null);
          },
        },
        ref: {
          bind: function () {},
        },
        cloak: {
          bind: function () {
            var e = this.el;
            this.vm.$once("pre-hook:compiled", function () {
              e.removeAttribute("v-cloak");
            });
          },
        },
      },
      br = {
        deep: !0,
        update: function (e) {
          e
            ? "string" == typeof e
              ? this.setClass(e.trim().split(/\s+/))
              : this.setClass(
                  (function (e) {
                    var t = [];
                    if (A(e))
                      for (var n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        if (i)
                          if ("string" == typeof i) t.push(i);
                          else for (var o in i) i[o] && t.push(o);
                      }
                    else if (S(e)) for (var a in e) e[a] && t.push(a);
                    return t;
                  })(e)
                )
            : this.cleanup();
        },
        setClass: function (e) {
          this.cleanup(e);
          for (var t = 0, n = e.length; t < n; t++) {
            var r = e[t];
            r && wr(this.el, r, tt);
          }
          this.prevKeys = e;
        },
        cleanup: function (e) {
          var t = this.prevKeys;
          if (t)
            for (var n = t.length; n--; ) {
              var r = t[n];
              (!e || e.indexOf(r) < 0) && wr(this.el, r, nt);
            }
        },
      };

    function wr(e, t, n) {
      if (-1 !== (t = t.trim()).indexOf(" "))
        for (var r = t.split(/\s+/), i = 0, o = r.length; i < o; i++)
          n(e, r[i]);
      else n(e, t);
    }
    var _r = {
      priority: 1500,
      params: ["keep-alive", "transition-mode", "inline-template"],
      bind: function () {
        this.el.__vue__ ||
          ((this.keepAlive = this.params.keepAlive),
          this.keepAlive && (this.cache = {}),
          this.params.inlineTemplate && (this.inlineTemplate = rt(this.el, !0)),
          (this.pendingComponentCb = this.Component = null),
          (this.pendingRemovals = 0),
          (this.pendingRemovalCb = null),
          (this.anchor = st("v-component")),
          Je(this.el, this.anchor),
          this.el.removeAttribute("is"),
          this.el.removeAttribute(":is"),
          this.descriptor.ref &&
            this.el.removeAttribute("v-ref:" + y(this.descriptor.ref)),
          this.literal && this.setComponent(this.expression));
      },
      update: function (e) {
        this.literal || this.setComponent(e);
      },
      setComponent: function (e, t) {
        if ((this.invalidatePending(), e)) {
          var n = this;
          this.resolveComponent(e, function () {
            n.mountComponent(t);
          });
        } else
          this.unbuild(!0), this.remove(this.childVM, t), (this.childVM = null);
      },
      resolveComponent: function (e, t) {
        var n = this;
        (this.pendingComponentCb = R(function (r) {
          (n.ComponentName =
            r.options.name || ("string" == typeof e ? e : null)),
            (n.Component = r),
            t();
        })),
          this.vm._resolveComponent(e, this.pendingComponentCb);
      },
      mountComponent: function (e) {
        this.unbuild(!0);
        var t = this,
          n = this.Component.options.activate,
          r = this.getCached(),
          i = this.build();
        n && !r
          ? ((this.waitingFor = i),
            (function (e, t, n) {
              var r = e.length,
                i = 0;
              e[0].call(t, function o() {
                ++i >= r ? n() : e[i].call(t, o);
              });
            })(n, i, function () {
              t.waitingFor === i && ((t.waitingFor = null), t.transition(i, e));
            }))
          : (r && i._updateRef(), this.transition(i, e));
      },
      invalidatePending: function () {
        this.pendingComponentCb &&
          (this.pendingComponentCb.cancel(), (this.pendingComponentCb = null));
      },
      build: function (e) {
        var t = this.getCached();
        if (t) return t;
        if (this.Component) {
          var n = {
            name: this.ComponentName,
            el: On(this.el),
            template: this.inlineTemplate,
            parent: this._host || this.vm,
            _linkerCachable: !this.inlineTemplate,
            _ref: this.descriptor.ref,
            _asComponent: !0,
            _isRouterView: this._isRouterView,
            _context: this.vm,
            _scope: this._scope,
            _frag: this._frag,
          };
          e && M(n, e);
          var r = new this.Component(n);
          return this.keepAlive && (this.cache[this.Component.cid] = r), r;
        }
      },
      getCached: function () {
        return this.keepAlive && this.cache[this.Component.cid];
      },
      unbuild: function (e) {
        this.waitingFor &&
          (this.keepAlive || this.waitingFor.$destroy(),
          (this.waitingFor = null));
        var t = this.childVM;
        t && !this.keepAlive
          ? t.$destroy(!1, e)
          : t && ((t._inactive = !0), t._updateRef(!0));
      },
      remove: function (e, t) {
        var n = this.keepAlive;
        if (e) {
          this.pendingRemovals++, (this.pendingRemovalCb = t);
          var r = this;
          e.$remove(function () {
            r.pendingRemovals--,
              n || e._cleanup(),
              !r.pendingRemovals &&
                r.pendingRemovalCb &&
                (r.pendingRemovalCb(), (r.pendingRemovalCb = null));
          });
        } else t && t();
      },
      transition: function (e, t) {
        var n = this,
          r = this.childVM;
        switch (
          (r && (r._inactive = !0),
          (e._inactive = !1),
          (this.childVM = e),
          n.params.transitionMode)
        ) {
          case "in-out":
            e.$before(n.anchor, function () {
              n.remove(r, t);
            });
            break;
          case "out-in":
            n.remove(r, function () {
              e.$before(n.anchor, t);
            });
            break;
          default:
            n.remove(r), e.$before(n.anchor, t);
        }
      },
      unbind: function () {
        if ((this.invalidatePending(), this.unbuild(), this.cache)) {
          for (var e in this.cache) this.cache[e].$destroy();
          this.cache = null;
        }
      },
    };
    var Mr = Oe._propBindingModes,
      Sr = {},
      Tr = /^[$_a-zA-Z]+[\w$]*$/;

    function Er(e, t, n) {
      for (
        var r,
          i,
          o,
          s,
          c,
          u,
          f,
          g = [],
          v = n.$options.propsData,
          x = Object.keys(t),
          b = x.length;
        b--;

      )
        if (((r = t[(i = x[b])] || Sr), (c = m(i)), Tr.test(c))) {
          if (
            ((f = {
              name: i,
              path: c,
              options: r,
              mode: Mr.ONE_WAY,
              raw: null,
            }),
            null === (s = je(e, (o = y(i)))) &&
              (null !== (s = je(e, o + ".sync"))
                ? (f.mode = Mr.TWO_WAY)
                : null !== (s = je(e, o + ".once")) && (f.mode = Mr.ONE_TIME)),
            null !== s)
          )
            (f.raw = s),
              (s = (u = be(s)).expression),
              (f.filters = u.filters),
              l(s) && !u.filters ? (f.optimizedLiteral = !0) : (f.dynamic = !0),
              (f.parentPath = s);
          else if (null !== (s = Ve(e, o))) f.raw = s;
          else if (v && null !== (s = v[i] || v[c])) f.raw = s;
          else {
          }
          g.push(f);
        }
      return (function (e) {
        return function (t, n) {
          t._props = {};
          for (var r, i, o, s, l = t.$options.propsData, c = e.length; c--; )
            if (
              ((s = (r = e[c]).raw),
              (i = r.path),
              (o = r.options),
              (t._props[i] = r),
              l && a(l, i) && Cr(t, r, l[i]),
              null === s)
            )
              Cr(t, r, void 0);
            else if (r.dynamic)
              r.mode === Mr.ONE_TIME
                ? Cr(t, r, (n || t._context || t).$get(r.parentPath))
                : t._context
                ? t._bindDir(
                    {
                      name: "prop",
                      def: Rr,
                      prop: r,
                    },
                    null,
                    null,
                    n
                  )
                : Cr(t, r, t.$get(r.parentPath));
            else if (r.optimizedLiteral) {
              var u = p(s);
              Cr(t, r, u === s ? d(h(s)) : u);
            } else
              Cr(
                t,
                r,
                (o.type === Boolean && ("" === s || s === y(r.name))) || s
              );
        };
      })(g);
    }

    function Ar(e, t, n, r) {
      var i = t.dynamic && dn(t.parentPath),
        o = n;
      void 0 === o &&
        (o = (function (e, t) {
          var n = t.options;
          if (!a(n, "default")) return n.type !== Boolean && void 0;
          var r = n.default;
          S(r);
          return "function" == typeof r && n.type !== Function ? r.call(e) : r;
        })(e, t));
      var s =
        (o = (function (e, t, n) {
          var r = e.options.coerce;
          if (!r) return t;
          return "function" == typeof r ? r(t) : t;
        })(t, o)) !== n;
      (function (e, t, n) {
        if (!e.options.required && (null === e.raw || null == t)) return !0;
        var r = e.options,
          i = r.type,
          o = !i,
          a = [];
        if (i) {
          A(i) || (i = [i]);
          for (var s = 0; s < i.length && !o; s++) {
            var l = Pr(t, i[s]);
            a.push(l.expectedType), (o = l.valid);
          }
        }
        if (!o) return !1;
        var c = r.validator;
        if (c && !c(t)) return !1;
        return !0;
      })(t, o) || (o = void 0),
        i && !s
          ? Rt(function () {
              r(o);
            })
          : r(o);
    }

    function Cr(e, t, n) {
      Ar(e, t, n, function (n) {
        Bt(e, t.path, n);
      });
    }

    function Pr(e, t) {
      var n, r;
      return (
        t === String
          ? (n = typeof e === (r = "string"))
          : t === Number
          ? (n = typeof e === (r = "number"))
          : t === Boolean
          ? (n = typeof e === (r = "boolean"))
          : t === Function
          ? (n = typeof e === (r = "function"))
          : t === Object
          ? ((r = "object"), (n = E(e)))
          : t === Array
          ? ((r = "array"), (n = A(e)))
          : (n = e instanceof t),
        {
          valid: n,
          expectedType: r,
        }
      );
    }
    var Lr = Oe._propBindingModes,
      Rr = {
        bind: function () {
          var e = this.vm,
            t = e._context,
            n = this.descriptor.prop,
            r = n.path,
            i = n.parentPath,
            o = n.mode === Lr.TWO_WAY,
            a = (this.parentWatcher = new wn(
              t,
              i,
              function (t) {
                !(function (e, t, n) {
                  Ar(e, t, n, function (n) {
                    e[t.path] = n;
                  });
                })(e, n, t);
              },
              {
                twoWay: o,
                filters: n.filters,
                scope: this._scope,
              }
            ));
          if ((Cr(e, n, a.value), o)) {
            var s = this;
            e.$once("pre-hook:created", function () {
              s.childWatcher = new wn(
                e,
                r,
                function (e) {
                  a.set(e);
                },
                {
                  sync: !0,
                }
              );
            });
          }
        },
        unbind: function () {
          this.parentWatcher.teardown(),
            this.childWatcher && this.childWatcher.teardown();
        },
      },
      Ir = [],
      kr = !1;

    function Dr(e) {
      Ir.push(e), kr || ((kr = !0), X(Or));
    }

    function Or() {
      for (
        var e = document.documentElement.offsetHeight, t = 0;
        t < Ir.length;
        t++
      )
        Ir[t]();
      return (Ir = []), (kr = !1), e;
    }
    var Br = H + "Duration",
      Fr = V + "Duration",
      Nr = D && window.requestAnimationFrame,
      Ur = Nr
        ? function (e) {
            Nr(function () {
              Nr(e);
            });
          }
        : function (e) {
            setTimeout(e, 50);
          };

    function zr(e, t, n, r) {
      (this.id = t),
        (this.el = e),
        (this.enterClass = (n && n.enterClass) || t + "-enter"),
        (this.leaveClass = (n && n.leaveClass) || t + "-leave"),
        (this.hooks = n),
        (this.vm = r),
        (this.pendingCssEvent =
          this.pendingCssCb =
          this.cancel =
          this.pendingJsCb =
          this.op =
          this.cb =
            null),
        (this.justEntered = !1),
        (this.entered = this.left = !1),
        (this.typeCache = {}),
        (this.type = n && n.type);
      var i = this;
      ["enterNextTick", "enterDone", "leaveNextTick", "leaveDone"].forEach(
        function (e) {
          i[e] = w(i[e], i);
        }
      );
    }
    var Hr = zr.prototype;
    (Hr.enter = function (e, t) {
      this.cancelPending(),
        this.callHook("beforeEnter"),
        (this.cb = t),
        tt(this.el, this.enterClass),
        e(),
        (this.entered = !1),
        this.callHookWithCb("enter"),
        this.entered ||
          ((this.cancel = this.hooks && this.hooks.enterCancelled),
          Dr(this.enterNextTick));
    }),
      (Hr.enterNextTick = function () {
        var e = this;
        (this.justEntered = !0),
          Ur(function () {
            e.justEntered = !1;
          });
        var t = this.enterDone,
          n = this.getCssTransitionType(this.enterClass);
        this.pendingJsCb
          ? "transition" === n && nt(this.el, this.enterClass)
          : "transition" === n
          ? (nt(this.el, this.enterClass), this.setupCssCb(G, t))
          : "animation" === n
          ? this.setupCssCb(j, t)
          : t();
      }),
      (Hr.enterDone = function () {
        (this.entered = !0),
          (this.cancel = this.pendingJsCb = null),
          nt(this.el, this.enterClass),
          this.callHook("afterEnter"),
          this.cb && this.cb();
      }),
      (Hr.leave = function (e, t) {
        this.cancelPending(),
          this.callHook("beforeLeave"),
          (this.op = e),
          (this.cb = t),
          tt(this.el, this.leaveClass),
          (this.left = !1),
          this.callHookWithCb("leave"),
          this.left ||
            ((this.cancel = this.hooks && this.hooks.leaveCancelled),
            this.op &&
              !this.pendingJsCb &&
              (this.justEntered ? this.leaveDone() : Dr(this.leaveNextTick)));
      }),
      (Hr.leaveNextTick = function () {
        var e = this.getCssTransitionType(this.leaveClass);
        if (e) {
          var t = "transition" === e ? G : j;
          this.setupCssCb(t, this.leaveDone);
        } else this.leaveDone();
      }),
      (Hr.leaveDone = function () {
        (this.left = !0),
          (this.cancel = this.pendingJsCb = null),
          this.op(),
          nt(this.el, this.leaveClass),
          this.callHook("afterLeave"),
          this.cb && this.cb(),
          (this.op = null);
      }),
      (Hr.cancelPending = function () {
        this.op = this.cb = null;
        var e = !1;
        this.pendingCssCb &&
          ((e = !0),
          Ke(this.el, this.pendingCssEvent, this.pendingCssCb),
          (this.pendingCssEvent = this.pendingCssCb = null)),
          this.pendingJsCb &&
            ((e = !0), this.pendingJsCb.cancel(), (this.pendingJsCb = null)),
          e && (nt(this.el, this.enterClass), nt(this.el, this.leaveClass)),
          this.cancel &&
            (this.cancel.call(this.vm, this.el), (this.cancel = null));
      }),
      (Hr.callHook = function (e) {
        this.hooks && this.hooks[e] && this.hooks[e].call(this.vm, this.el);
      }),
      (Hr.callHookWithCb = function (e) {
        var t = this.hooks && this.hooks[e];
        t &&
          (t.length > 1 && (this.pendingJsCb = R(this[e + "Done"])),
          t.call(this.vm, this.el, this.pendingJsCb));
      }),
      (Hr.getCssTransitionType = function (e) {
        if (
          !(
            !G ||
            document.hidden ||
            (this.hooks && !1 === this.hooks.css) ||
            (function (e) {
              if (/svg$/.test(e.namespaceURI)) {
                var t = e.getBoundingClientRect();
                return !(t.width || t.height);
              }
              return !(
                e.offsetWidth ||
                e.offsetHeight ||
                e.getClientRects().length
              );
            })(this.el)
          )
        ) {
          var t = this.type || this.typeCache[e];
          if (t) return t;
          var n = this.el.style,
            r = window.getComputedStyle(this.el),
            i = n[Br] || r[Br];
          if (i && "0s" !== i) t = "transition";
          else {
            var o = n[Fr] || r[Fr];
            o && "0s" !== o && (t = "animation");
          }
          return t && (this.typeCache[e] = t), t;
        }
      }),
      (Hr.setupCssCb = function (e, t) {
        this.pendingCssEvent = e;
        var n = this,
          r = this.el,
          i = (this.pendingCssCb = function (o) {
            o.target === r &&
              (Ke(r, e, i),
              (n.pendingCssEvent = n.pendingCssCb = null),
              !n.pendingJsCb && t && t());
          });
        Ze(r, e, i);
      });
    var Gr = {
        style: dr,
        class: br,
        component: _r,
        prop: Rr,
        transition: {
          priority: 1100,
          update: function (e, t) {
            var n = this.el,
              r = St(this.vm.$options, "transitions", e);
            (e = e || "v"),
              (t = t || "v"),
              (n.__v_trans = new zr(n, e, r, this.vm)),
              nt(n, t + "-transition"),
              tt(n, e + "-transition");
          },
        },
      },
      Vr = /^v-bind:|^:/,
      jr = /^v-on:|^@/,
      Wr = /^v-([^:]+)(?:$|:(.*)$)/,
      qr = /\.[^\.]+/g,
      $r = /^(v-bind:|:)?transition$/;

    function Xr(e, t, n) {
      var r = n || !t._asComponent ? ei(e, t) : null,
        i =
          (r && r.terminal) || si(e) || !e.hasChildNodes()
            ? null
            : (function e(t, n) {
                for (var r, i, o, a = [], s = 0, l = t.length; s < l; s++)
                  (o = t[s]),
                    (r = ei(o, n)),
                    (i =
                      (r && r.terminal) ||
                      "SCRIPT" === o.tagName ||
                      !o.hasChildNodes()
                        ? null
                        : e(o.childNodes, n)),
                    a.push(r, i);
                return a.length
                  ? (function (e) {
                      return function (t, n, r, i, o) {
                        for (
                          var a, s, l, c = 0, u = 0, h = e.length;
                          c < h;
                          u++
                        ) {
                          (a = n[u]), (s = e[c++]), (l = e[c++]);
                          var d = _(a.childNodes);
                          s && s(t, a, r, i, o), l && l(t, d, r, i, o);
                        }
                      };
                    })(a)
                  : null;
              })(e.childNodes, t);
      return function (e, t, n, o, a) {
        var s = _(t.childNodes),
          l = Yr(function () {
            r && r(e, t, n, o, a), i && i(e, s, n, o, a);
          }, e);
        return Jr(e, l);
      };
    }

    function Yr(e, t) {
      t._directives = [];
      var n = t._directives.length;
      e();
      var r = t._directives.slice(n);
      !(function (e) {
        if (0 === e.length) return;
        var t,
          n,
          r,
          i,
          o = {},
          a = 0,
          s = [];
        for (t = 0, n = e.length; t < n; t++) {
          var l = e[t],
            c = l.descriptor.def.priority || 1e3,
            u = o[c];
          u || ((u = o[c] = []), s.push(c)), u.push(l);
        }
        for (
          s.sort(function (e, t) {
            return e > t ? -1 : e === t ? 0 : 1;
          }),
            t = 0,
            n = s.length;
          t < n;
          t++
        ) {
          var h = o[s[t]];
          for (r = 0, i = h.length; r < i; r++) e[a++] = h[r];
        }
      })(r);
      for (var i = 0, o = r.length; i < o; i++) r[i]._bind();
      return r;
    }

    function Jr(e, t, n, r) {
      function i(i) {
        Zr(e, t, i), n && r && Zr(n, r);
      }
      return (i.dirs = t), i;
    }

    function Zr(e, t, n) {
      for (var r = t.length; r--; ) t[r]._teardown();
    }

    function Kr(e, t, n, r) {
      var i = Er(t, n, e),
        o = Yr(function () {
          i(e, r);
        }, e);
      return Jr(e, o);
    }

    function Qr(e, t, n) {
      var r,
        i,
        o = t._containerAttrs,
        a = t._replacerAttrs;
      11 !== e.nodeType &&
        (t._asComponent
          ? (o && n && (r = oi(o, n)), a && (i = oi(a, t)))
          : (i = oi(e.attributes, t)));
      return (
        (t._containerAttrs = t._replacerAttrs = null),
        function (e, t, n) {
          var o,
            a = e._context;
          a &&
            r &&
            (o = Yr(function () {
              r(a, t, null, n);
            }, a));
          var s = Yr(function () {
            i && i(e, t);
          }, e);
          return Jr(e, s, a, o);
        }
      );
    }

    function ei(e, t) {
      var n = e.nodeType;
      return 1 !== n || si(e)
        ? 3 === n && e.data.trim()
          ? (function (e, t) {
              if (e._skip) return ti;
              var n = Ce(e.wholeText);
              if (!n) return null;
              var r = e.nextSibling;
              for (; r && 3 === r.nodeType; )
                (r._skip = !0), (r = r.nextSibling);
              for (
                var i,
                  o,
                  a = document.createDocumentFragment(),
                  s = 0,
                  l = n.length;
                s < l;
                s++
              )
                (o = n[s]),
                  (i = o.tag ? ni(o, t) : document.createTextNode(o.value)),
                  a.appendChild(i);
              return (function (e, t) {
                return function (n, r, i, o) {
                  for (
                    var a,
                      s,
                      l,
                      c = t.cloneNode(!0),
                      h = _(c.childNodes),
                      d = 0,
                      p = e.length;
                    d < p;
                    d++
                  )
                    (s = (a = e[d]).value),
                      a.tag &&
                        ((l = h[d]),
                        a.oneTime
                          ? ((s = (o || n).$eval(s)),
                            a.html ? Je(l, Bn(s, !0)) : (l.data = u(s)))
                          : n._bindDir(a.descriptor, l, i, o));
                  Je(r, c);
                };
              })(n, a);
            })(e, t)
          : null
        : (function (e, t) {
            if ("TEXTAREA" === e.tagName) {
              if (null !== Ve(e, "v-pre")) return ri;
              var n = Ce(e.value);
              n && (e.setAttribute(":value", Pe(n)), (e.value = ""));
            }
            var r,
              i = e.hasAttributes(),
              o = i && _(e.attributes);
            i &&
              (r = (function (e, t, n) {
                if (null !== Ve(e, "v-pre")) return ri;
                if (e.hasAttribute("v-else")) {
                  var r = e.previousElementSibling;
                  if (r && r.hasAttribute("v-if")) return ri;
                }
                for (
                  var i, o, a, s, l, c, u, h, d, p, f = 0, m = t.length;
                  f < m;
                  f++
                )
                  (i = t[f]),
                    (o = i.name.replace(qr, "")),
                    (l = o.match(Wr)) &&
                      (d = St(n, "directives", l[1])) &&
                      d.terminal &&
                      (!p || (d.priority || 2e3) > p.priority) &&
                      ((p = d),
                      (u = i.name),
                      (s = ai(i.name)),
                      (a = i.value),
                      (c = l[1]),
                      (h = l[2]));
                if (p) return ii(e, c, a, n, p, u, h, s);
              })(e, o, t));
            r ||
              (r = (function (e, t) {
                var n = e.tagName.toLowerCase();
                if (ft.test(n)) return;
                var r = St(t, "elementDirectives", n);
                if (r) return ii(e, n, "", t, r);
              })(e, t));
            r ||
              (r = (function (e, t) {
                var n = gt(e, t);
                if (n) {
                  var r = ct(e),
                    i = {
                      name: "component",
                      ref: r,
                      expression: n.id,
                      def: Gr.component,
                      modifiers: {
                        literal: !n.dynamic,
                      },
                    },
                    o = function (e, t, n, o, a) {
                      r && Bt((o || e).$refs, r, null),
                        e._bindDir(i, t, n, o, a);
                    };
                  return (o.terminal = !0), o;
                }
              })(e, t));
            !r && i && (r = oi(o, t));
            return r;
          })(e, t);
    }

    function ti(e, t) {
      Xe(t);
    }

    function ni(e, t) {
      var n;

      function r(t) {
        if (!e.descriptor) {
          var n = be(e.value);
          e.descriptor = {
            name: t,
            def: xr[t],
            expression: n.expression,
            filters: n.filters,
          };
        }
      }
      return (
        e.oneTime
          ? (n = document.createTextNode(e.value))
          : e.html
          ? ((n = document.createComment("v-html")), r("html"))
          : ((n = document.createTextNode(" ")), r("text")),
        n
      );
    }

    function ri() {}

    function ii(e, t, n, r, i, o, a, s) {
      var l = be(n),
        c = {
          name: t,
          arg: a,
          expression: l.expression,
          filters: l.filters,
          raw: n,
          attr: o,
          modifiers: s,
          def: i,
        };
      ("for" !== t && "router-view" !== t) || (c.ref = ct(e));
      var u = function (e, t, n, r, i) {
        c.ref && Bt((r || e).$refs, c.ref, null), e._bindDir(c, t, n, r, i);
      };
      return (u.terminal = !0), u;
    }

    function oi(e, t) {
      for (var n, r, i, o, a, s, l, c, u, h, d, p = e.length, f = []; p--; )
        if (
          ((n = e[p]),
          (r = o = n.name),
          (h = Ce((i = a = n.value))),
          (l = null),
          (c = ai(r)),
          (r = r.replace(qr, "")),
          h)
        )
          (i = Pe(h)), (l = r), m("bind", xr.bind, h);
        else if ($r.test(r))
          (c.literal = !Vr.test(r)), m("transition", Gr.transition);
        else if (jr.test(r)) (l = r.replace(jr, "")), m("on", xr.on);
        else if (Vr.test(r))
          "style" === (s = r.replace(Vr, "")) || "class" === s
            ? m(s, Gr[s])
            : ((l = s), m("bind", xr.bind));
        else if ((d = r.match(Wr))) {
          if (((s = d[1]), (l = d[2]), "else" === s)) continue;
          (u = St(t, "directives", s)) && m(s, u);
        }

      function m(e, t, n) {
        var r =
            n &&
            (function (e) {
              var t = e.length;
              for (; t--; ) if (e[t].oneTime) return !0;
            })(n),
          s = !r && be(i);
        f.push({
          name: e,
          attr: o,
          raw: a,
          def: t,
          arg: l,
          modifiers: c,
          expression: s && s.expression,
          filters: s && s.filters,
          interp: n,
          hasOneTime: r,
        });
      }
      if (f.length)
        return (function (e) {
          return function (t, n, r, i, o) {
            for (var a = e.length; a--; ) t._bindDir(e[a], n, r, i, o);
          };
        })(f);
    }

    function ai(e) {
      var t = Object.create(null),
        n = e.match(qr);
      if (n) for (var r = n.length; r--; ) t[n[r].slice(1)] = !0;
      return t;
    }

    function si(e) {
      return (
        "SCRIPT" === e.tagName &&
        (!e.hasAttribute("type") ||
          "text/javascript" === e.getAttribute("type"))
      );
    }
    ri.terminal = !0;
    var li = /[^\w\-:\.]/;

    function ci(e, t) {
      return (
        t && (t._containerAttrs = ui(e)),
        at(e) && (e = Bn(e)),
        t &&
          (t._asComponent && !t.template && (t.template = "<slot></slot>"),
          t.template &&
            ((t._content = rt(e)),
            (e = (function (e, t) {
              var n = Bn(t.template, !0);
              if (n) {
                var r = n.firstChild;
                if (!r) return n;
                var i = r.tagName && r.tagName.toLowerCase();
                return t.replace
                  ? (document.body,
                    n.childNodes.length > 1 ||
                    1 !== r.nodeType ||
                    "component" === i ||
                    St(t, "components", i) ||
                    We(r, "is") ||
                    St(t, "elementDirectives", i) ||
                    r.hasAttribute("v-for") ||
                    r.hasAttribute("v-if")
                      ? n
                      : ((t._replacerAttrs = ui(r)),
                        (function (e, t) {
                          var n,
                            r,
                            i = e.attributes,
                            o = i.length;
                          for (; o--; )
                            (n = i[o].name),
                              (r = i[o].value),
                              t.hasAttribute(n) || li.test(n)
                                ? "class" === n &&
                                  !Ce(r) &&
                                  (r = r.trim()) &&
                                  r.split(/\s+/).forEach(function (e) {
                                    tt(t, e);
                                  })
                                : t.setAttribute(n, r);
                        })(e, r),
                        r))
                  : (e.appendChild(n), e);
              }
            })(e, t)))),
        dt(e) && (Ye(st("v-start", !0), e), e.appendChild(st("v-end", !0))),
        e
      );
    }

    function ui(e) {
      if (1 === e.nodeType && e.hasAttributes()) return _(e.attributes);
    }

    function hi(e, t) {
      if (t) {
        for (
          var n,
            r,
            i = (e._slotContents = Object.create(null)),
            o = 0,
            a = t.children.length;
          o < a;
          o++
        )
          (r = (n = t.children[o]).getAttribute("slot")) &&
            (i[r] || (i[r] = [])).push(n);
        for (r in i) i[r] = di(i[r], t);
        if (t.hasChildNodes()) {
          var s = t.childNodes;
          if (1 === s.length && 3 === s[0].nodeType && !s[0].data.trim())
            return;
          i.default = di(t.childNodes, t);
        }
      }
    }

    function di(e, t) {
      for (
        var n = document.createDocumentFragment(), r = 0, i = (e = _(e)).length;
        r < i;
        r++
      ) {
        var o = e[r];
        !at(o) ||
          o.hasAttribute("v-if") ||
          o.hasAttribute("v-for") ||
          (t.removeChild(o), (o = Bn(o, !0))),
          n.appendChild(o);
      }
      return n;
    }
    var pi = Object.freeze({
      compile: Xr,
      compileAndLinkProps: Kr,
      compileRoot: Qr,
      transclude: ci,
      resolveSlots: hi,
    });
    var fi = /^v-on:|^@/;

    function mi() {}

    function gi(e, t, n, r, i, o) {
      (this.vm = t),
        (this.el = n),
        (this.descriptor = e),
        (this.name = e.name),
        (this.expression = e.expression),
        (this.arg = e.arg),
        (this.modifiers = e.modifiers),
        (this.filters = e.filters),
        (this.literal = this.modifiers && this.modifiers.literal),
        (this._locked = !1),
        (this._bound = !1),
        (this._listeners = null),
        (this._host = r),
        (this._scope = i),
        (this._frag = o);
    }
    (gi.prototype._bind = function () {
      var e = this.name,
        t = this.descriptor;
      if (
        ("cloak" !== e || this.vm._isCompiled) &&
        this.el &&
        this.el.removeAttribute
      ) {
        var n = t.attr || "v-" + e;
        this.el.removeAttribute(n);
      }
      var r = t.def;
      if (
        ("function" == typeof r ? (this.update = r) : M(this, r),
        this._setupParams(),
        this.bind && this.bind(),
        (this._bound = !0),
        this.literal)
      )
        this.update && this.update(t.raw);
      else if (
        (this.expression || this.modifiers) &&
        (this.update || this.twoWay) &&
        !this._checkStatement()
      ) {
        var i = this;
        this.update
          ? (this._update = function (e, t) {
              i._locked || i.update(e, t);
            })
          : (this._update = mi);
        var o = this._preProcess ? w(this._preProcess, this) : null,
          a = this._postProcess ? w(this._postProcess, this) : null,
          s = (this._watcher = new wn(this.vm, this.expression, this._update, {
            filters: this.filters,
            twoWay: this.twoWay,
            deep: this.deep,
            preProcess: o,
            postProcess: a,
            scope: this._scope,
          }));
        this.afterBind ? this.afterBind() : this.update && this.update(s.value);
      }
    }),
      (gi.prototype._setupParams = function () {
        if (this.params) {
          var e = this.params;
          this.params = Object.create(null);
          for (var t, n, r, i = e.length; i--; )
            (r = m((t = y(e[i])))),
              null != (n = je(this.el, t))
                ? this._setupParamWatcher(r, n)
                : null != (n = Ve(this.el, t)) &&
                  (this.params[r] = "" === n || n);
        }
      }),
      (gi.prototype._setupParamWatcher = function (e, t) {
        var n = this,
          r = !1,
          i = (this._scope || this.vm).$watch(
            t,
            function (t, i) {
              if (((n.params[e] = t), r)) {
                var o = n.paramWatchers && n.paramWatchers[e];
                o && o.call(n, t, i);
              } else r = !0;
            },
            {
              immediate: !0,
              user: !1,
            }
          );
        (this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(i);
      }),
      (gi.prototype._checkStatement = function () {
        var e = this.expression;
        if (e && this.acceptStatement && !dn(e)) {
          var t = hn(e).get,
            n = this._scope || this.vm,
            r = function (e) {
              (n.$event = e), t.call(n, n), (n.$event = null);
            };
          return (
            this.filters && (r = n._applyFilters(r, null, this.filters)),
            this.update(r),
            !0
          );
        }
      }),
      (gi.prototype.set = function (e) {
        this.twoWay &&
          this._withLock(function () {
            this._watcher.set(e);
          });
      }),
      (gi.prototype._withLock = function (e) {
        var t = this;
        (t._locked = !0),
          e.call(t),
          X(function () {
            t._locked = !1;
          });
      }),
      (gi.prototype.on = function (e, t, n) {
        Ze(this.el, e, t, n),
          (this._listeners || (this._listeners = [])).push([e, t]);
      }),
      (gi.prototype._teardown = function () {
        if (this._bound) {
          (this._bound = !1),
            this.unbind && this.unbind(),
            this._watcher && this._watcher.teardown();
          var e,
            t = this._listeners;
          if (t) for (e = t.length; e--; ) Ke(this.el, t[e][0], t[e][1]);
          var n = this._paramUnwatchFns;
          if (n) for (e = n.length; e--; ) n[e]();
          0, (this.vm = this.el = this._watcher = this._listeners = null);
        }
      });
    var vi = /[^|]\|[^|]/;

    function yi(e) {
      this._init(e);
    }
    !(function (e) {
      e.prototype._init = function (e) {
        (e = e || {}),
          (this.$el = null),
          (this.$parent = e.parent),
          (this.$root = this.$parent ? this.$parent.$root : this),
          (this.$children = []),
          (this.$refs = {}),
          (this.$els = {}),
          (this._watchers = []),
          (this._directives = []),
          (this._uid = Nt++),
          (this._isVue = !0),
          (this._events = {}),
          (this._eventsCount = {}),
          (this._isFragment = !1),
          (this._fragment = this._fragmentStart = this._fragmentEnd = null),
          (this._isCompiled =
            this._isDestroyed =
            this._isReady =
            this._isAttached =
            this._isBeingDestroyed =
            this._vForRemoving =
              !1),
          (this._unlinkFn = null),
          (this._context = e._context || this.$parent),
          (this._scope = e._scope),
          (this._frag = e._frag),
          this._frag && this._frag.children.push(this),
          this.$parent && this.$parent.$children.push(this),
          (e = this.$options = Mt(this.constructor.options, e, this)),
          this._updateRef(),
          (this._data = {}),
          this._callHook("init"),
          this._initState(),
          this._initEvents(),
          this._callHook("created"),
          e.el && this.$mount(e.el);
      };
    })(yi),
      (function (e) {
        function t() {}

        function n(e, t) {
          var n = new wn(t, e, null, {
            lazy: !0,
          });
          return function () {
            return n.dirty && n.evaluate(), Et.target && n.depend(), n.value;
          };
        }
        Object.defineProperty(e.prototype, "$data", {
          get: function () {
            return this._data;
          },
          set: function (e) {
            e !== this._data && this._setData(e);
          },
        }),
          (e.prototype._initState = function () {
            this._initProps(),
              this._initMeta(),
              this._initMethods(),
              this._initData(),
              this._initComputed();
          }),
          (e.prototype._initProps = function () {
            var e = this.$options,
              t = e.el,
              n = e.props;
            (t = e.el = He(t)),
              (this._propsUnlinkFn =
                t && 1 === t.nodeType && n
                  ? Kr(this, t, n, this._scope)
                  : null);
          }),
          (e.prototype._initData = function () {
            var e = this.$options.data,
              t = (this._data = e ? e() : {});
            E(t) || (t = {});
            var n,
              r,
              i = this._props,
              o = Object.keys(t);
            for (n = o.length; n--; )
              (r = o[n]), (i && a(i, r)) || this._proxy(r);
            Ot(t, this);
          }),
          (e.prototype._setData = function (e) {
            e = e || {};
            var t,
              n,
              r,
              i = this._data;
            for (this._data = e, r = (t = Object.keys(i)).length; r--; )
              (n = t[r]) in e || this._unproxy(n);
            for (r = (t = Object.keys(e)).length; r--; )
              a(this, (n = t[r])) || this._proxy(n);
            i.__ob__.removeVm(this), Ot(e, this), this._digest();
          }),
          (e.prototype._proxy = function (e) {
            if (!c(e)) {
              var t = this;
              Object.defineProperty(t, e, {
                configurable: !0,
                enumerable: !0,
                get: function () {
                  return t._data[e];
                },
                set: function (n) {
                  t._data[e] = n;
                },
              });
            }
          }),
          (e.prototype._unproxy = function (e) {
            c(e) || delete this[e];
          }),
          (e.prototype._digest = function () {
            for (var e = 0, t = this._watchers.length; e < t; e++)
              this._watchers[e].update(!0);
          }),
          (e.prototype._initComputed = function () {
            var e = this.$options.computed;
            if (e)
              for (var r in e) {
                var i = e[r],
                  o = {
                    enumerable: !0,
                    configurable: !0,
                  };
                "function" == typeof i
                  ? ((o.get = n(i, this)), (o.set = t))
                  : ((o.get = i.get
                      ? !1 !== i.cache
                        ? n(i.get, this)
                        : w(i.get, this)
                      : t),
                    (o.set = i.set ? w(i.set, this) : t)),
                  Object.defineProperty(this, r, o);
              }
          }),
          (e.prototype._initMethods = function () {
            var e = this.$options.methods;
            if (e) for (var t in e) this[t] = w(e[t], this);
          }),
          (e.prototype._initMeta = function () {
            var e = this.$options._meta;
            if (e) for (var t in e) Bt(this, t, e[t]);
          });
      })(yi),
      (function (e) {
        function t(e, t, r) {
          var i, o, a, s;
          if (r)
            for (o in r)
              if (((i = r[o]), A(i)))
                for (a = 0, s = i.length; a < s; a++) n(e, t, o, i[a]);
              else n(e, t, o, i);
        }

        function n(e, t, r, i, o) {
          var a = typeof i;
          if ("function" === a) e[t](r, i, o);
          else if ("string" === a) {
            var s = e.$options.methods,
              l = s && s[i];
            l && e[t](r, l, o);
          } else i && "object" === a && n(e, t, r, i.handler, i);
        }

        function r() {
          this._isAttached ||
            ((this._isAttached = !0), this.$children.forEach(i));
        }

        function i(e) {
          !e._isAttached && Ge(e.$el) && e._callHook("attached");
        }

        function o() {
          this._isAttached &&
            ((this._isAttached = !1), this.$children.forEach(a));
        }

        function a(e) {
          e._isAttached && !Ge(e.$el) && e._callHook("detached");
        }
        (e.prototype._initEvents = function () {
          var e = this.$options;
          e._asComponent &&
            (function (e, t) {
              for (
                var n, r, i, o = t.attributes, a = 0, s = o.length;
                a < s;
                a++
              )
                (n = o[a].name),
                  fi.test(n) &&
                    ((n = n.replace(fi, "")),
                    dn((r = o[a].value)) && (r += ".apply(this, $arguments)"),
                    ((i = (e._scope || e._context).$eval(r, !0))._fromParent =
                      !0),
                    e.$on(n.replace(fi), i));
            })(this, e.el),
            t(this, "$on", e.events),
            t(this, "$watch", e.watch);
        }),
          (e.prototype._initDOMHooks = function () {
            this.$on("hook:attached", r), this.$on("hook:detached", o);
          }),
          (e.prototype._callHook = function (e) {
            this.$emit("pre-hook:" + e);
            var t = this.$options[e];
            if (t) for (var n = 0, r = t.length; n < r; n++) t[n].call(this);
            this.$emit("hook:" + e);
          });
      })(yi),
      (function (e) {
        (e.prototype._updateRef = function (e) {
          var t = this.$options._ref;
          if (t) {
            var n = (this._scope || this._context).$refs;
            e ? n[t] === this && (n[t] = null) : (n[t] = this);
          }
        }),
          (e.prototype._compile = function (e) {
            var t = this.$options,
              n = e;
            if (
              ((e = ci(e, t)),
              this._initElement(e),
              1 !== e.nodeType || null === Ve(e, "v-pre"))
            ) {
              var r,
                i = Qr(e, t, this._context && this._context.$options);
              hi(this, t._content);
              var o = this.constructor;
              t._linkerCachable &&
                ((r = o.linker) || (r = o.linker = Xr(e, t)));
              var a = i(this, e, this._scope),
                s = r ? r(this, e) : Xr(e, t)(this, e);
              (this._unlinkFn = function () {
                a(), s(!0);
              }),
                t.replace && Je(n, e),
                (this._isCompiled = !0),
                this._callHook("compiled");
            }
          }),
          (e.prototype._initElement = function (e) {
            dt(e)
              ? ((this._isFragment = !0),
                (this.$el = this._fragmentStart = e.firstChild),
                (this._fragmentEnd = e.lastChild),
                3 === this._fragmentStart.nodeType &&
                  (this._fragmentStart.data = this._fragmentEnd.data = ""),
                (this._fragment = e))
              : (this.$el = e),
              (this.$el.__vue__ = this),
              this._callHook("beforeCompile");
          }),
          (e.prototype._bindDir = function (e, t, n, r, i) {
            this._directives.push(new gi(e, this, t, n, r, i));
          }),
          (e.prototype._destroy = function (e, t) {
            if (this._isBeingDestroyed) t || this._cleanup();
            else {
              var n,
                r,
                i,
                o = this,
                a = function () {
                  !n || r || t || o._cleanup();
                };
              e &&
                this.$el &&
                ((r = !0),
                this.$remove(function () {
                  (r = !1), a();
                })),
                this._callHook("beforeDestroy"),
                (this._isBeingDestroyed = !0);
              var s = this.$parent;
              for (
                s &&
                  !s._isBeingDestroyed &&
                  (s.$children.$remove(this), this._updateRef(!0)),
                  i = this.$children.length;
                i--;

              )
                this.$children[i].$destroy();
              for (
                this._propsUnlinkFn && this._propsUnlinkFn(),
                  this._unlinkFn && this._unlinkFn(),
                  i = this._watchers.length;
                i--;

              )
                this._watchers[i].teardown();
              this.$el && (this.$el.__vue__ = null), (n = !0), a();
            }
          }),
          (e.prototype._cleanup = function () {
            this._isDestroyed ||
              (this._frag && this._frag.children.$remove(this),
              this._data &&
                this._data.__ob__ &&
                this._data.__ob__.removeVm(this),
              (this.$el =
                this.$parent =
                this.$root =
                this.$children =
                this._watchers =
                this._context =
                this._scope =
                this._directives =
                  null),
              (this._isDestroyed = !0),
              this._callHook("destroyed"),
              this.$off());
          });
      })(yi),
      (function (e) {
        (e.prototype._applyFilters = function (e, t, n, r) {
          var i, o, a, s, l, c, u, h, d;
          for (c = 0, u = n.length; c < u; c++)
            if (
              ((i = n[r ? u - c - 1 : c]),
              (o = St(this.$options, "filters", i.name)) &&
                "function" == typeof (o = r ? o.write : o.read || o))
            ) {
              if (((a = r ? [e, t] : [e]), (l = r ? 2 : 1), i.args))
                for (h = 0, d = i.args.length; h < d; h++)
                  (s = i.args[h]),
                    (a[h + l] = s.dynamic ? this.$get(s.value) : s.value);
              e = o.apply(this, a);
            }
          return e;
        }),
          (e.prototype._resolveComponent = function (t, n) {
            var r;
            if (
              (r =
                "function" == typeof t ? t : St(this.$options, "components", t))
            )
              if (r.options) n(r);
              else if (r.resolved) n(r.resolved);
              else if (r.requested) r.pendingCallbacks.push(n);
              else {
                r.requested = !0;
                var i = (r.pendingCallbacks = [n]);
                r.call(
                  this,
                  function (t) {
                    E(t) && (t = e.extend(t)), (r.resolved = t);
                    for (var n = 0, o = i.length; n < o; n++) i[n](t);
                  },
                  function (e) {}
                );
              }
          });
      })(yi),
      (function (e) {
        function t(e) {
          return JSON.parse(JSON.stringify(e));
        }
        (e.prototype.$get = function (e, t) {
          var n = hn(e);
          if (n) {
            if (t) {
              var r = this;
              return function () {
                r.$arguments = _(arguments);
                var e = n.get.call(r, r);
                return (r.$arguments = null), e;
              };
            }
            try {
              return n.get.call(this, this);
            } catch (e) {}
          }
        }),
          (e.prototype.$set = function (e, t) {
            var n = hn(e, !0);
            n && n.set && n.set.call(this, this, t);
          }),
          (e.prototype.$delete = function (e) {
            i(this._data, e);
          }),
          (e.prototype.$watch = function (e, t, n) {
            var r;
            "string" == typeof e && (e = (r = be(e)).expression);
            var i = new wn(this, e, t, {
              deep: n && n.deep,
              sync: n && n.sync,
              filters: r && r.filters,
              user: !n || !1 !== n.user,
            });
            return (
              n && n.immediate && t.call(this, i.value),
              function () {
                i.teardown();
              }
            );
          }),
          (e.prototype.$eval = function (e, t) {
            if (vi.test(e)) {
              var n = be(e),
                r = this.$get(n.expression, t);
              return n.filters ? this._applyFilters(r, null, n.filters) : r;
            }
            return this.$get(e, t);
          }),
          (e.prototype.$interpolate = function (e) {
            var t = Ce(e),
              n = this;
            return t
              ? 1 === t.length
                ? n.$eval(t[0].value) + ""
                : t
                    .map(function (e) {
                      return e.tag ? n.$eval(e.value) : e.value;
                    })
                    .join("")
              : e;
          }),
          (e.prototype.$log = function (e) {
            var n = e ? jt(this._data, e) : this._data;
            if ((n && (n = t(n)), !e)) {
              var r;
              for (r in this.$options.computed) n[r] = t(this[r]);
              if (this._props) for (r in this._props) n[r] = t(this[r]);
            }
            console.log(n);
          });
      })(yi),
      (function (e) {
        function t(e, t, r, i, o, a) {
          var s = !Ge((t = n(t))),
            l = !1 === i || s ? o : a,
            c = !s && !e._isAttached && !Ge(e.$el);
          return (
            e._isFragment
              ? (ut(e._fragmentStart, e._fragmentEnd, function (n) {
                  l(n, t, e);
                }),
                r && r())
              : l(e.$el, t, e, r),
            c && e._callHook("attached"),
            e
          );
        }

        function n(e) {
          return "string" == typeof e ? document.querySelector(e) : e;
        }

        function r(e, t, n, r) {
          t.appendChild(e), r && r();
        }

        function i(e, t, n, r) {
          qe(e, t), r && r();
        }

        function o(e, t, n) {
          Xe(e), n && n();
        }
        (e.prototype.$nextTick = function (e) {
          X(e, this);
        }),
          (e.prototype.$appendTo = function (e, n, i) {
            return t(this, e, n, i, r, Be);
          }),
          (e.prototype.$prependTo = function (e, t, r) {
            return (
              (e = n(e)).hasChildNodes()
                ? this.$before(e.firstChild, t, r)
                : this.$appendTo(e, t, r),
              this
            );
          }),
          (e.prototype.$before = function (e, n, r) {
            return t(this, e, n, r, i, Fe);
          }),
          (e.prototype.$after = function (e, t, r) {
            return (
              (e = n(e)).nextSibling
                ? this.$before(e.nextSibling, t, r)
                : this.$appendTo(e.parentNode, t, r),
              this
            );
          }),
          (e.prototype.$remove = function (e, t) {
            if (!this.$el.parentNode) return e && e();
            var n = this._isAttached && Ge(this.$el);
            n || (t = !1);
            var r = this,
              i = function () {
                n && r._callHook("detached"), e && e();
              };
            this._isFragment
              ? ht(
                  this._fragmentStart,
                  this._fragmentEnd,
                  this,
                  this._fragment,
                  i
                )
              : (!1 === t ? o : Ne)(this.$el, this, i);
            return this;
          });
      })(yi),
      (function (e) {
        (e.prototype.$on = function (e, t) {
          return (
            (this._events[e] || (this._events[e] = [])).push(t),
            n(this, e, 1),
            this
          );
        }),
          (e.prototype.$once = function (e, t) {
            var n = this;

            function r() {
              n.$off(e, r), t.apply(this, arguments);
            }
            return (r.fn = t), this.$on(e, r), this;
          }),
          (e.prototype.$off = function (e, t) {
            var r, i;
            if (!arguments.length) {
              if (this.$parent)
                for (e in this._events)
                  (r = this._events[e]) && n(this, e, -r.length);
              return (this._events = {}), this;
            }
            if (!(r = this._events[e])) return this;
            if (1 === arguments.length)
              return n(this, e, -r.length), (this._events[e] = null), this;
            for (var o = r.length; o--; )
              if ((i = r[o]) === t || i.fn === t) {
                n(this, e, -1), r.splice(o, 1);
                break;
              }
            return this;
          }),
          (e.prototype.$emit = function (e) {
            var t = "string" == typeof e;
            e = t ? e : e.name;
            var n = this._events[e],
              r = t || !n;
            if (n) {
              n = n.length > 1 ? _(n) : n;
              var i =
                t &&
                n.some(function (e) {
                  return e._fromParent;
                });
              i && (r = !1);
              for (var o = _(arguments, 1), a = 0, s = n.length; a < s; a++) {
                var l = n[a],
                  c = l.apply(this, o);
                !0 !== c || (i && !l._fromParent) || (r = !0);
              }
            }
            return r;
          }),
          (e.prototype.$broadcast = function (e) {
            var t = "string" == typeof e;
            if (((e = t ? e : e.name), this._eventsCount[e])) {
              var n = this.$children,
                r = _(arguments);
              t &&
                (r[0] = {
                  name: e,
                  source: this,
                });
              for (var i = 0, o = n.length; i < o; i++) {
                var a = n[i],
                  s = a.$emit.apply(a, r);
                s && a.$broadcast.apply(a, r);
              }
              return this;
            }
          }),
          (e.prototype.$dispatch = function (e) {
            var t = this.$emit.apply(this, arguments);
            if (t) {
              var n = this.$parent,
                r = _(arguments);
              for (
                r[0] = {
                  name: e,
                  source: this,
                };
                n;

              )
                (t = n.$emit.apply(n, r)), (n = t ? n.$parent : null);
              return this;
            }
          });
        var t = /^hook:/;

        function n(e, n, r) {
          var i = e.$parent;
          if (i && r && !t.test(n))
            for (; i; )
              (i._eventsCount[n] = (i._eventsCount[n] || 0) + r),
                (i = i.$parent);
        }
      })(yi),
      (function (e) {
        function t() {
          (this._isAttached = !0),
            (this._isReady = !0),
            this._callHook("ready");
        }
        (e.prototype.$mount = function (e) {
          if (!this._isCompiled)
            return (
              (e = He(e)) || (e = document.createElement("div")),
              this._compile(e),
              this._initDOMHooks(),
              Ge(this.$el)
                ? (this._callHook("attached"), t.call(this))
                : this.$once("hook:attached", t),
              this
            );
        }),
          (e.prototype.$destroy = function (e, t) {
            this._destroy(e, t);
          }),
          (e.prototype.$compile = function (e, t, n, r) {
            return Xr(e, this.$options, !0)(this, e, t, n, r);
          });
      })(yi);
    var xi = {
        slot: {
          priority: 2300,
          params: ["name"],
          bind: function () {
            var e = this.params.name || "default",
              t = this.vm._slotContents && this.vm._slotContents[e];
            t && t.hasChildNodes()
              ? this.compile(t.cloneNode(!0), this.vm._context, this.vm)
              : this.fallback();
          },
          compile: function (e, t, n) {
            if (e && t) {
              if (
                this.el.hasChildNodes() &&
                1 === e.childNodes.length &&
                1 === e.childNodes[0].nodeType &&
                e.childNodes[0].hasAttribute("v-if")
              ) {
                var r = document.createElement("template");
                r.setAttribute("v-else", ""),
                  (r.innerHTML = this.el.innerHTML),
                  (r._context = this.vm),
                  e.appendChild(r);
              }
              var i = n ? n._scope : this._scope;
              this.unlink = t.$compile(e, n, i, this._frag);
            }
            e ? Je(this.el, e) : Xe(this.el);
          },
          fallback: function () {
            this.compile(rt(this.el, !0), this.vm);
          },
          unbind: function () {
            this.unlink && this.unlink();
          },
        },
        partial: {
          priority: 1750,
          params: ["name"],
          paramWatchers: {
            name: function (e) {
              Qn.remove.call(this), e && this.insert(e);
            },
          },
          bind: function () {
            (this.anchor = st("v-partial")),
              Je(this.el, this.anchor),
              this.insert(this.params.name);
          },
          insert: function (e) {
            var t = St(this.vm.$options, "partials", e);
            t && ((this.factory = new $n(this.vm, t)), Qn.insert.call(this));
          },
          unbind: function () {
            this.frag && this.frag.destroy();
          },
        },
      },
      bi = Yn._postProcess;

    function wi(e, t) {
      var n;
      if (E(e)) {
        var r = Object.keys(e);
        for (n = r.length; n--; ) if (wi(e[r[n]], t)) return !0;
      } else if (A(e)) {
        for (n = e.length; n--; ) if (wi(e[n], t)) return !0;
      } else if (null != e) return e.toString().toLowerCase().indexOf(t) > -1;
    }
    var _i = /(\d{3})(?=\d)/g,
      Mi = {
        orderBy: function (e) {
          var t = null,
            n = void 0;
          e = bi(e);
          var r = _(arguments, 1),
            i = r[r.length - 1];
          "number" == typeof i
            ? ((i = i < 0 ? -1 : 1), (r = r.length > 1 ? r.slice(0, -1) : r))
            : (i = 1);
          var o = r[0];
          if (!o) return e;

          function a(e, t, r) {
            var o = n[r];
            return (
              o &&
                ("$key" !== o &&
                  (S(e) && "$value" in e && (e = e.$value),
                  S(t) && "$value" in t && (t = t.$value)),
                (e = S(e) ? jt(e, o) : e),
                (t = S(t) ? jt(t, o) : t)),
              e === t ? 0 : e > t ? i : -i
            );
          }
          return (
            "function" == typeof o
              ? (t = function (e, t) {
                  return o(e, t) * i;
                })
              : ((n = Array.prototype.concat.apply([], r)),
                (t = function (e, r, i) {
                  return (i = i || 0) >= n.length - 1
                    ? a(e, r, i)
                    : a(e, r, i) || t(e, r, i + 1);
                })),
            e.slice().sort(t)
          );
        },
        filterBy: function (e, t, n) {
          if (((e = bi(e)), null == t)) return e;
          if ("function" == typeof t) return e.filter(t);
          t = ("" + t).toLowerCase();
          for (
            var r,
              i,
              o,
              a,
              s = "in" === n ? 3 : 2,
              l = Array.prototype.concat.apply([], _(arguments, s)),
              c = [],
              u = 0,
              h = e.length;
            u < h;
            u++
          )
            if (((o = ((r = e[u]) && r.$value) || r), (a = l.length))) {
              for (; a--; )
                if (
                  ("$key" === (i = l[a]) && wi(r.$key, t)) ||
                  wi(jt(o, i), t)
                ) {
                  c.push(r);
                  break;
                }
            } else wi(r, t) && c.push(r);
          return c;
        },
        limitBy: function (e, t, n) {
          return (
            (n = n ? parseInt(n, 10) : 0),
            "number" == typeof (t = h(t)) ? e.slice(n, n + t) : e
          );
        },
        json: {
          read: function (e, t) {
            return "string" == typeof e
              ? e
              : JSON.stringify(e, null, arguments.length > 1 ? t : 2);
          },
          write: function (e) {
            try {
              return JSON.parse(e);
            } catch (t) {
              return e;
            }
          },
        },
        capitalize: function (e) {
          return e || 0 === e
            ? (e = e.toString()).charAt(0).toUpperCase() + e.slice(1)
            : "";
        },
        uppercase: function (e) {
          return e || 0 === e ? e.toString().toUpperCase() : "";
        },
        lowercase: function (e) {
          return e || 0 === e ? e.toString().toLowerCase() : "";
        },
        currency: function (e, t, n) {
          if (((e = parseFloat(e)), !isFinite(e) || (!e && 0 !== e))) return "";
          (t = null != t ? t : "$"), (n = null != n ? n : 2);
          var r = Math.abs(e).toFixed(n),
            i = n ? r.slice(0, -1 - n) : r,
            o = i.length % 3,
            a = o > 0 ? i.slice(0, o) + (i.length > 3 ? "," : "") : "",
            s = n ? r.slice(-1 - n) : "";
          return (e < 0 ? "-" : "") + t + a + i.slice(o).replace(_i, "$1,") + s;
        },
        pluralize: function (e) {
          var t = _(arguments, 1),
            n = t.length;
          if (n > 1) {
            var r = (e % 10) - 1;
            return r in t ? t[r] : t[n - 1];
          }
          return t[0] + (1 === e ? "" : "s");
        },
        debounce: function (e, t) {
          if (e) return t || (t = 300), P(e, t);
        },
      };
    !(function (e) {
      (e.options = {
        directives: xr,
        elementDirectives: xi,
        filters: Mi,
        transitions: {},
        components: {},
        partials: {},
        replace: !0,
      }),
        (e.util = Ft),
        (e.config = Oe),
        (e.set = r),
        (e.delete = i),
        (e.nextTick = X),
        (e.compiler = pi),
        (e.FragmentFactory = $n),
        (e.internalDirectives = Gr),
        (e.parsers = {
          path: qt,
          text: Ie,
          template: Fn,
          directive: we,
          expression: pn,
        }),
        (e.cid = 0);
      var t = 1;
      (e.extend = function (e) {
        e = e || {};
        var n = this,
          r = 0 === n.cid;
        if (r && e._Ctor) return e._Ctor;
        var i = e.name || n.options.name;
        var o = (function (e) {
          return new Function(
            "return function " + b(e) + " (options) { this._init(options) }"
          )();
        })(i || "VueComponent");
        return (
          (o.prototype = Object.create(n.prototype)),
          (o.prototype.constructor = o),
          (o.cid = t++),
          (o.options = Mt(n.options, e)),
          (o.super = n),
          (o.extend = n.extend),
          Oe._assetTypes.forEach(function (e) {
            o[e] = n[e];
          }),
          i && (o.options.components[i] = o),
          r && (e._Ctor = o),
          o
        );
      }),
        (e.use = function (e) {
          if (!e.installed) {
            var t = _(arguments, 1);
            return (
              t.unshift(this),
              "function" == typeof e.install
                ? e.install.apply(e, t)
                : e.apply(null, t),
              (e.installed = !0),
              this
            );
          }
        }),
        (e.mixin = function (t) {
          e.options = Mt(e.options, t);
        }),
        Oe._assetTypes.forEach(function (t) {
          e[t] = function (n, r) {
            return r
              ? ("component" === t &&
                  E(r) &&
                  (r.name || (r.name = n), (r = e.extend(r))),
                (this.options[t + "s"][n] = r),
                r)
              : this.options[t + "s"][n];
          };
        }),
        M(e.transition, ze);
    })(yi),
      (yi.version = "1.0.28"),
      setTimeout(function () {
        Oe.devtools && O && O.emit("init", yi);
      }, 0),
      (e.exports = yi);
  },
  function (e, t, n) {
    "use strict";
    (function (e) {
      function r() {
        var e,
          t = 0,
          n = [],
          i = 0,
          o = 0;
        var a = p(function (e) {
            o || l(1, e);
          }),
          s = p(function (e) {
            o || l(-1, e);
          });

        function l(n, r) {
          o++;
          var i = 0;
          try {
            r === g && f();
            var a = n > 0 && d(r);
            a
              ? a.call(
                  r,
                  p(function (e) {
                    i++, l(1, e);
                  }),
                  p(function (e) {
                    i++, l(-1, e);
                  })
                )
              : ((t = n), (e = r), c());
          } catch (e) {
            t || i || l(-1, e);
          }
        }

        function c() {
          i || (setTimeout(u, 0), (i = 1));
        }

        function u() {
          var e = n;
          (i = 0), (n = []), e.forEach(h);
        }

        function h(e) {
          e();
        }

        function d(e) {
          var t = e && (m(e) || "object" == typeof e) && e.then;
          return m(t) && t;
        }

        function p(e) {
          var t = 0;
          return function () {
            for (var n = [], r = arguments.length; r--; ) n[r] = arguments[r];
            t++ || e.apply(this, n);
          };
        }

        function f() {
          throw new TypeError("Chaining cycle detected");
        }
        var m = function (e) {
            return "function" == typeof e;
          },
          g = {
            then: function (i, o) {
              var a = r();
              return (
                n.push(function () {
                  var n = t > 0 ? i : o;
                  if (m(n))
                    try {
                      var r = n(e);
                      r === a && f();
                      var s = d(r);
                      s ? s.call(r, a.resolve, a.reject) : a.resolve(r);
                    } catch (e) {
                      a.reject(e);
                    }
                  else a[t > 0 ? "resolve" : "reject"](e);
                }),
                t && c(),
                a
              );
            },
            resolve: a,
            reject: s,
          };
        return g;
      }

      function i() {
        var e,
          t,
          n = new Promise(function (n, r) {
            (e = n), (t = r);
          });
        return {
          then: n.then.bind(n),
          resolve: e,
          reject: t,
        };
      }
      n.d(t, "a", function () {
        return o;
      }),
        n.d(t, "b", function () {
          return y;
        }),
        n.d(t, "c", function () {
          return f;
        }),
        n.d(t, "d", function () {
          return m;
        }),
        (r.all = i.all =
          function (e) {
            var t = 0,
              n = [],
              r = o();
            return (
              0 === e.length
                ? r.resolve([])
                : e.forEach(function (i, a) {
                    var s = o();
                    s.resolve(i),
                      s.then(function (i) {
                        t++, (n[a] = i), t === e.length && r.resolve(n);
                      }, r.reject);
                  }),
              r
            );
          });
      var o = "function" == typeof Promise ? i : r;

      function a() {
        var e = Object.create(null);

        function t(e, t) {
          var n = void 0;
          self.troikaDefine = function (e) {
            return (n = e);
          };
          var r = URL.createObjectURL(
            new Blob(
              [
                "/** " +
                  e.replace(/\*/g, "") +
                  " **/\n\ntroikaDefine(\n" +
                  t +
                  "\n)",
              ],
              {
                type: "application/javascript",
              }
            )
          );
          try {
            importScripts(r);
          } catch (e) {
            console.error(e);
          }
          return URL.revokeObjectURL(r), delete self.troikaDefine, n;
        }
        self.addEventListener("message", function (n) {
          var r = n.data,
            i = r.messageId,
            o = r.action,
            a = r.data;
          try {
            "registerModule" === o &&
              (function n(r, i) {
                var o = r.id,
                  a = r.name,
                  s = r.dependencies;
                void 0 === s && (s = []);
                var l = r.init;
                void 0 === l && (l = function () {});
                var c = r.getTransferables;
                if ((void 0 === c && (c = null), !e[o]))
                  try {
                    (s = s.map(function (t) {
                      return (
                        t &&
                          t.isWorkerModule &&
                          (n(t, function (e) {
                            if (e instanceof Error) throw e;
                          }),
                          (t = e[t.id].value)),
                        t
                      );
                    })),
                      (l = t("<" + a + ">.init", l)),
                      c && (c = t("<" + a + ">.getTransferables", c));
                    var u = null;
                    "function" == typeof l
                      ? (u = l.apply(void 0, s))
                      : console.error(
                          "worker module init function failed to rehydrate"
                        ),
                      (e[o] = {
                        id: o,
                        value: u,
                        getTransferables: c,
                      }),
                      i(u);
                  } catch (e) {
                    (e && e.noLog) || console.error(e), i(e);
                  }
              })(a, function (e) {
                e instanceof Error
                  ? postMessage({
                      messageId: i,
                      success: !1,
                      error: e.message,
                    })
                  : postMessage({
                      messageId: i,
                      success: !0,
                      result: {
                        isCallable: "function" == typeof e,
                      },
                    });
              }),
              "callModule" === o &&
                (function (t, n) {
                  var r,
                    i = t.id,
                    o = t.args;
                  (e[i] && "function" == typeof e[i].value) ||
                    n(
                      new Error(
                        "Worker module " +
                          i +
                          ": not found or its 'init' did not return a function"
                      )
                    );
                  try {
                    var a = (r = e[i]).value.apply(r, o);
                    a && "function" == typeof a.then
                      ? a.then(s, function (e) {
                          return n(e instanceof Error ? e : new Error("" + e));
                        })
                      : s(a);
                  } catch (e) {
                    n(e);
                  }

                  function s(t) {
                    try {
                      var r = e[i].getTransferables && e[i].getTransferables(t);
                      (r && Array.isArray(r) && r.length) || (r = void 0),
                        n(t, r);
                    } catch (e) {
                      console.error(e), n(e);
                    }
                  }
                })(a, function (e, t) {
                  e instanceof Error
                    ? postMessage({
                        messageId: i,
                        success: !1,
                        error: e.message,
                      })
                    : postMessage(
                        {
                          messageId: i,
                          success: !0,
                          result: e,
                        },
                        t || void 0
                      );
                });
          } catch (e) {
            postMessage({
              messageId: i,
              success: !1,
              error: e.stack,
            });
          }
        });
      }
      var s = function () {
          var e = !1;
          if ("undefined" != typeof window && void 0 !== window.document)
            try {
              new Worker(
                URL.createObjectURL(
                  new Blob([""], {
                    type: "application/javascript",
                  })
                )
              ).terminate(),
                (e = !0);
            } catch (e) {
              console.log(
                "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
                  e.message +
                  "]"
              );
            }
          return (
            (s = function () {
              return e;
            }),
            e
          );
        },
        l = 0,
        c = 0,
        u = !1,
        h = Object.create(null),
        d = Object.create(null),
        p = Object.create(null);

      function f(e) {
        if (!((e && "function" == typeof e.init) || u))
          throw new Error("requires `options.init` function");
        var t = e.dependencies,
          n = e.init,
          r = e.getTransferables,
          i = e.workerId;
        if (!s())
          return (function (e) {
            var t = function () {
              for (var e = [], n = arguments.length; n--; ) e[n] = arguments[n];
              return t._getInitResult().then(function (t) {
                if ("function" == typeof t) return t.apply(void 0, e);
                throw new Error(
                  "Worker module function was called but `init` did not return a callable function"
                );
              });
            };
            return (
              (t._getInitResult = function () {
                var n = e.dependencies,
                  r = e.init;
                n = Array.isArray(n)
                  ? n.map(function (e) {
                      return e && e._getInitResult ? e._getInitResult() : e;
                    })
                  : [];
                var i = o.all(n).then(function (e) {
                  return r.apply(null, e);
                });
                return (
                  (t._getInitResult = function () {
                    return i;
                  }),
                  i
                );
              }),
              t
            );
          })(e);
        null == i && (i = "#default");
        var a = "workerModule" + ++l,
          c = e.name || a,
          h = null;

        function p() {
          for (var e = [], t = arguments.length; t--; ) e[t] = arguments[t];
          if (!h) {
            h = v(i, "registerModule", p.workerModuleData);
            var n = function () {
              (h = null), d[i].delete(n);
            };
            (d[i] || (d[i] = new Set())).add(n);
          }
          return h.then(function (t) {
            if (t.isCallable)
              return v(i, "callModule", {
                id: a,
                args: e,
              });
            throw new Error(
              "Worker module function was called but `init` did not return a callable function"
            );
          });
        }
        return (
          (t =
            t &&
            t.map(function (e) {
              return (
                "function" != typeof e ||
                  e.workerModuleData ||
                  ((u = !0),
                  (e = f({
                    workerId: i,
                    name: "<" + c + "> function dependency: " + e.name,
                    init: "function(){return (\n" + g(e) + "\n)}",
                  })),
                  (u = !1)),
                e && e.workerModuleData && (e = e.workerModuleData),
                e
              );
            })),
          (p.workerModuleData = {
            isWorkerModule: !0,
            id: a,
            name: c,
            dependencies: t,
            init: g(n),
            getTransferables: r && g(r),
          }),
          p
        );
      }

      function m(e) {
        d[e] &&
          d[e].forEach(function (e) {
            e();
          }),
          h[e] && (h[e].terminate(), delete h[e]);
      }

      function g(e) {
        var t = e.toString();
        return (
          !/^function/.test(t) && /^\w+\s*\(/.test(t) && (t = "function " + t),
          t
        );
      }

      function v(e, t, n) {
        var r = o(),
          i = ++c;
        return (
          (p[i] = function (e) {
            e.success
              ? r.resolve(e.result)
              : r.reject(
                  new Error("Error in worker " + t + " call: " + e.error)
                );
          }),
          (function (e) {
            var t = h[e];
            if (!t) {
              var n = g(a);
              (t = h[e] =
                new Worker(
                  URL.createObjectURL(
                    new Blob(
                      [
                        "/** Worker Module Bootstrap: " +
                          e.replace(/\*/g, "") +
                          " **/\n\n;(" +
                          n +
                          ")()",
                      ],
                      {
                        type: "application/javascript",
                      }
                    )
                  )
                )).onmessage = function (e) {
                var t = e.data,
                  n = t.messageId,
                  r = p[n];
                if (!r)
                  throw new Error(
                    "WorkerModule response with empty or unknown messageId"
                  );
                delete p[n], r(t);
              };
            }
            return t;
          })(e).postMessage({
            messageId: i,
            action: t,
            data: n,
          }),
          r
        );
      }
      var y = f({
        name: "Thenable",
        dependencies: [o],
        init: function (e) {
          return e;
        },
      });
    }.call(this, n(8)));
  },
  function (e, t, n) {
    "use strict";
    n.d(t, "c", function () {
      return kt;
    }),
      n.d(t, "a", function () {
        return Dt;
      }),
      n.d(t, "b", function () {
        return Ot;
      });
    var r = n(0),
      i = (function () {
        function e() {
          (this.glass = new r.MeshStandardMaterial({
            color: 8947916,
            roughness: 0,
            metalness: 1,
            opacity: 0.44,
            transparent: !0,
            envMapIntensity: 1,
            flatShading: !0,
            depthWrite: !0,
          })),
            (this.glass_test = new r.MeshPhysicalMaterial({
              metalness: 0.9,
              roughness: 0.05,
              envMapIntensity: 0.9,
              clearcoat: 1,
              transparent: !0,
              opacity: 0.5,
              reflectivity: 0.2,
              refractionRatio: 0.985,
              ior: 0.9,
              side: r.FrontSide,
            })),
            (this.environmentSphere = new r.MeshBasicMaterial({
              depthWrite: !1,
              depthTest: !1,
              side: r.BackSide,
            })),
            (this.whiteMetal = new r.MeshStandardMaterial({
              color: 16777215,
              roughness: 0.7,
              metalness: 0.4,
              flatShading: !0,
            })),
            (this.whiteChalk = new r.MeshStandardMaterial({
              color: 16777215,
              roughness: 1,
              metalness: 0,
              flatShading: !0,
            })),
            (this.oldEnvironmentTextureUrl = "xyz"),
            (this.blackMetal = this.withColor(this.whiteMetal, 0)),
            (this.grayMetal = this.withColor(this.whiteMetal, 8947848));
          var e = new r.ShadowMaterial();
          (e.opacity = 0.5),
            (this.shadowMaterial = e),
            (e.name = "shadowMaterial"),
            this.enableThrottling();
        }
        return (
          (e.prototype.enableThrottling = function () {}),
          (e.prototype.withColor = function (e, t) {
            return (
              ((e = e.clone()).color = new r.Color(t)), (e.needsUpdate = !0), e
            );
          }),
          (e.prototype.withTexture = function (e, t, n) {
            return (
              (e = e.clone()),
              new r.TextureLoader().load(t, function (t) {
                (e.map = t), (e.needsUpdate = !0), n && n(e);
              }),
              e
            );
          }),
          (e.prototype.setEnvironmentTexture = function (e, t) {
            (this.environmentSphere.map = e),
              t && t(e),
              (this.environmentSphere.needsUpdate = !0),
              (e.mapping = r.EquirectangularReflectionMapping),
              (e.needsUpdate = !0),
              [this.glass, this.whiteMetal, this.blackMetal].map(function (t) {
                (t.envMap = e), (t.needsUpdate = !0);
              });
          }),
          (e.prototype.setEnvironmentTextureFromUrl = function (e, t) {
            e != this.oldEnvironmentTextureUrl &&
              ((this.oldEnvironmentTextureUrl = e),
              new r.TextureLoader().load(
                e,
                function (e) {
                  this.setEnvironmentTexture(e, t);
                }.bind(this)
              ));
          }),
          (e.prototype.setEnvironmentTextureFromFileInput = function (e, t) {
            var n = new FileReader(),
              i = new Image();
            (i.onload = function () {
              var e = new r.Texture(i);
              (e.needsUpdate = !0), this.setEnvironmentTexture(e, t);
            }.bind(this)),
              (n.onload = function (e) {
                i.src = e.target.result;
              }),
              n.readAsDataURL(e.files[0]);
          }),
          (e.prototype.loadFromConfig = function (e) {
            return (
              Object.keys(e).map(
                function (t) {
                  var n = e[t],
                    i = this.whiteChalk.clone();
                  void 0 !== n.color && i.color.setHex(n.color),
                    n.map &&
                      n.map.url &&
                      this.withTexture(
                        this.whiteChalk,
                        kt(n.map.url),
                        function (t) {
                          t.map.wrapS = t.map.wrapT = r.RepeatWrapping;
                          var o = n.map.scale || e.default.map.scale;
                          t.map.repeat.set(o, o),
                            (i.map = t.map),
                            n.bump &&
                              n.bump.url == n.map.url &&
                              ((i.bumpMap = i.map),
                              (i.bumpMapScale =
                                n.bump.bumpScale || e.default.bump.bumpScale)),
                            (i.needsUpdate = !0);
                        }
                      ),
                    n.bump &&
                      n.bump.url &&
                      n.bump.url !== n.map.url &&
                      this.withTexture(
                        this.whiteChalk,
                        kt(n.bump.url),
                        function (t) {
                          t.map.wrapS = t.map.wrapT = r.RepeatWrapping;
                          var o = n.map.scale || e.default.bump.scale;
                          t.map.repeat.set(o, o),
                            (i.bumpMap = t.map),
                            (i.bumpMapScale =
                              n.bump.bumpScale || e.default.bump.bumpScale),
                            (i.needsUpdate = !0);
                        }
                      ),
                    console.log("visibility"),
                    "visible" in n && (i.visible = n.visible),
                    (this[t] = i),
                    (i.needsUpdate = !0);
                }.bind(this)
              ),
              this
            );
          }),
          e
        );
      })();
    const o = /^[og]\s*(.+)?/,
      a = /^mtllib /,
      s = /^usemtl /,
      l = /^usemap /,
      c = new r.Vector3(),
      u = new r.Vector3(),
      h = new r.Vector3(),
      d = new r.Vector3(),
      p = new r.Vector3();

    function f() {
      const e = {
        objects: [],
        object: {},
        vertices: [],
        normals: [],
        colors: [],
        uvs: [],
        materials: {},
        materialLibraries: [],
        startObject: function (e, t) {
          if (this.object && !1 === this.object.fromDeclaration)
            return (
              (this.object.name = e),
              void (this.object.fromDeclaration = !1 !== t)
            );
          const n =
            this.object && "function" == typeof this.object.currentMaterial
              ? this.object.currentMaterial()
              : void 0;
          if (
            (this.object &&
              "function" == typeof this.object._finalize &&
              this.object._finalize(!0),
            (this.object = {
              name: e || "",
              fromDeclaration: !1 !== t,
              geometry: {
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                hasUVIndices: !1,
              },
              materials: [],
              smooth: !0,
              startMaterial: function (e, t) {
                const n = this._finalize(!1);
                n &&
                  (n.inherited || n.groupCount <= 0) &&
                  this.materials.splice(n.index, 1);
                const r = {
                  index: this.materials.length,
                  name: e || "",
                  mtllib:
                    Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                  smooth: void 0 !== n ? n.smooth : this.smooth,
                  groupStart: void 0 !== n ? n.groupEnd : 0,
                  groupEnd: -1,
                  groupCount: -1,
                  inherited: !1,
                  clone: function (e) {
                    const t = {
                      index: "number" == typeof e ? e : this.index,
                      name: this.name,
                      mtllib: this.mtllib,
                      smooth: this.smooth,
                      groupStart: 0,
                      groupEnd: -1,
                      groupCount: -1,
                      inherited: !1,
                    };
                    return (t.clone = this.clone.bind(t)), t;
                  },
                };
                return this.materials.push(r), r;
              },
              currentMaterial: function () {
                if (this.materials.length > 0)
                  return this.materials[this.materials.length - 1];
              },
              _finalize: function (e) {
                const t = this.currentMaterial();
                if (
                  (t &&
                    -1 === t.groupEnd &&
                    ((t.groupEnd = this.geometry.vertices.length / 3),
                    (t.groupCount = t.groupEnd - t.groupStart),
                    (t.inherited = !1)),
                  e && this.materials.length > 1)
                )
                  for (let e = this.materials.length - 1; e >= 0; e--)
                    this.materials[e].groupCount <= 0 &&
                      this.materials.splice(e, 1);
                return (
                  e &&
                    0 === this.materials.length &&
                    this.materials.push({
                      name: "",
                      smooth: this.smooth,
                    }),
                  t
                );
              },
            }),
            n && n.name && "function" == typeof n.clone)
          ) {
            const e = n.clone(0);
            (e.inherited = !0), this.object.materials.push(e);
          }
          this.objects.push(this.object);
        },
        finalize: function () {
          this.object &&
            "function" == typeof this.object._finalize &&
            this.object._finalize(!0);
        },
        parseVertexIndex: function (e, t) {
          const n = parseInt(e, 10);
          return 3 * (n >= 0 ? n - 1 : n + t / 3);
        },
        parseNormalIndex: function (e, t) {
          const n = parseInt(e, 10);
          return 3 * (n >= 0 ? n - 1 : n + t / 3);
        },
        parseUVIndex: function (e, t) {
          const n = parseInt(e, 10);
          return 2 * (n >= 0 ? n - 1 : n + t / 2);
        },
        addVertex: function (e, t, n) {
          const r = this.vertices,
            i = this.object.geometry.vertices;
          i.push(r[e + 0], r[e + 1], r[e + 2]),
            i.push(r[t + 0], r[t + 1], r[t + 2]),
            i.push(r[n + 0], r[n + 1], r[n + 2]);
        },
        addVertexPoint: function (e) {
          const t = this.vertices;
          this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
        },
        addVertexLine: function (e) {
          const t = this.vertices;
          this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
        },
        addNormal: function (e, t, n) {
          const r = this.normals,
            i = this.object.geometry.normals;
          i.push(r[e + 0], r[e + 1], r[e + 2]),
            i.push(r[t + 0], r[t + 1], r[t + 2]),
            i.push(r[n + 0], r[n + 1], r[n + 2]);
        },
        addFaceNormal: function (e, t, n) {
          const r = this.vertices,
            i = this.object.geometry.normals;
          c.fromArray(r, e),
            u.fromArray(r, t),
            h.fromArray(r, n),
            p.subVectors(h, u),
            d.subVectors(c, u),
            p.cross(d),
            p.normalize(),
            i.push(p.x, p.y, p.z),
            i.push(p.x, p.y, p.z),
            i.push(p.x, p.y, p.z);
        },
        addColor: function (e, t, n) {
          const r = this.colors,
            i = this.object.geometry.colors;
          void 0 !== r[e] && i.push(r[e + 0], r[e + 1], r[e + 2]),
            void 0 !== r[t] && i.push(r[t + 0], r[t + 1], r[t + 2]),
            void 0 !== r[n] && i.push(r[n + 0], r[n + 1], r[n + 2]);
        },
        addUV: function (e, t, n) {
          const r = this.uvs,
            i = this.object.geometry.uvs;
          i.push(r[e + 0], r[e + 1]),
            i.push(r[t + 0], r[t + 1]),
            i.push(r[n + 0], r[n + 1]);
        },
        addDefaultUV: function () {
          const e = this.object.geometry.uvs;
          e.push(0, 0), e.push(0, 0), e.push(0, 0);
        },
        addUVLine: function (e) {
          const t = this.uvs;
          this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
        },
        addFace: function (e, t, n, r, i, o, a, s, l) {
          const c = this.vertices.length;
          let u = this.parseVertexIndex(e, c),
            h = this.parseVertexIndex(t, c),
            d = this.parseVertexIndex(n, c);
          if (
            (this.addVertex(u, h, d),
            this.addColor(u, h, d),
            void 0 !== a && "" !== a)
          ) {
            const e = this.normals.length;
            (u = this.parseNormalIndex(a, e)),
              (h = this.parseNormalIndex(s, e)),
              (d = this.parseNormalIndex(l, e)),
              this.addNormal(u, h, d);
          } else this.addFaceNormal(u, h, d);
          if (void 0 !== r && "" !== r) {
            const e = this.uvs.length;
            (u = this.parseUVIndex(r, e)),
              (h = this.parseUVIndex(i, e)),
              (d = this.parseUVIndex(o, e)),
              this.addUV(u, h, d),
              (this.object.geometry.hasUVIndices = !0);
          } else this.addDefaultUV();
        },
        addPointGeometry: function (e) {
          this.object.geometry.type = "Points";
          const t = this.vertices.length;
          for (let n = 0, r = e.length; n < r; n++) {
            const r = this.parseVertexIndex(e[n], t);
            this.addVertexPoint(r), this.addColor(r);
          }
        },
        addLineGeometry: function (e, t) {
          this.object.geometry.type = "Line";
          const n = this.vertices.length,
            r = this.uvs.length;
          for (let t = 0, r = e.length; t < r; t++)
            this.addVertexLine(this.parseVertexIndex(e[t], n));
          for (let e = 0, n = t.length; e < n; e++)
            this.addUVLine(this.parseUVIndex(t[e], r));
        },
      };
      return e.startObject("", !1), e;
    }
    class m extends r.Loader {
      constructor(e) {
        super(e), (this.materials = null);
      }
      load(e, t, n, i) {
        const o = this,
          a = new r.FileLoader(this.manager);
        a.setPath(this.path),
          a.setRequestHeader(this.requestHeader),
          a.setWithCredentials(this.withCredentials),
          a.load(
            e,
            function (n) {
              try {
                t(o.parse(n));
              } catch (t) {
                i ? i(t) : console.error(t), o.manager.itemError(e);
              }
            },
            n,
            i
          );
      }
      setMaterials(e) {
        return (this.materials = e), this;
      }
      parse(e) {
        const t = new f();
        -1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")),
          -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
        const n = e.split("\n");
        let i = "",
          c = "",
          u = 0,
          h = [];
        const d = "function" == typeof "".trimLeft;
        for (let e = 0, r = n.length; e < r; e++)
          if (
            ((i = n[e]),
            (i = d ? i.trimLeft() : i.trim()),
            (u = i.length),
            0 !== u && ((c = i.charAt(0)), "#" !== c))
          )
            if ("v" === c) {
              const e = i.split(/\s+/);
              switch (e[0]) {
                case "v":
                  t.vertices.push(
                    parseFloat(e[1]),
                    parseFloat(e[2]),
                    parseFloat(e[3])
                  ),
                    e.length >= 7
                      ? t.colors.push(
                          parseFloat(e[4]),
                          parseFloat(e[5]),
                          parseFloat(e[6])
                        )
                      : t.colors.push(void 0, void 0, void 0);
                  break;
                case "vn":
                  t.normals.push(
                    parseFloat(e[1]),
                    parseFloat(e[2]),
                    parseFloat(e[3])
                  );
                  break;
                case "vt":
                  t.uvs.push(parseFloat(e[1]), parseFloat(e[2]));
              }
            } else if ("f" === c) {
              const e = i.substr(1).trim().split(/\s+/),
                n = [];
              for (let t = 0, r = e.length; t < r; t++) {
                const r = e[t];
                if (r.length > 0) {
                  const e = r.split("/");
                  n.push(e);
                }
              }
              const r = n[0];
              for (let e = 1, i = n.length - 1; e < i; e++) {
                const i = n[e],
                  o = n[e + 1];
                t.addFace(r[0], i[0], o[0], r[1], i[1], o[1], r[2], i[2], o[2]);
              }
            } else if ("l" === c) {
              const e = i.substring(1).trim().split(" ");
              let n = [];
              const r = [];
              if (-1 === i.indexOf("/")) n = e;
              else
                for (let t = 0, i = e.length; t < i; t++) {
                  const i = e[t].split("/");
                  "" !== i[0] && n.push(i[0]), "" !== i[1] && r.push(i[1]);
                }
              t.addLineGeometry(n, r);
            } else if ("p" === c) {
              const e = i.substr(1).trim().split(" ");
              t.addPointGeometry(e);
            } else if (null !== (h = o.exec(i))) {
              const e = (" " + h[0].substr(1).trim()).substr(1);
              t.startObject(e);
            } else if (s.test(i))
              t.object.startMaterial(
                i.substring(7).trim(),
                t.materialLibraries
              );
            else if (a.test(i)) t.materialLibraries.push(i.substring(7).trim());
            else if (l.test(i))
              console.warn(
                'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'
              );
            else if ("s" === c) {
              if (((h = i.split(" ")), h.length > 1)) {
                const e = h[1].trim().toLowerCase();
                t.object.smooth = "0" !== e && "off" !== e;
              } else t.object.smooth = !0;
              const e = t.object.currentMaterial();
              e && (e.smooth = t.object.smooth);
            } else {
              if ("\0" === i) continue;
              console.warn('THREE.OBJLoader: Unexpected line: "' + i + '"');
            }
        t.finalize();
        const p = new r.Group();
        if (
          ((p.materialLibraries = [].concat(t.materialLibraries)),
          !0 ===
            !(
              1 === t.objects.length &&
              0 === t.objects[0].geometry.vertices.length
            ))
        )
          for (let e = 0, n = t.objects.length; e < n; e++) {
            const n = t.objects[e],
              i = n.geometry,
              o = n.materials,
              a = "Line" === i.type,
              s = "Points" === i.type;
            let l = !1;
            if (0 === i.vertices.length) continue;
            const c = new r.BufferGeometry();
            c.setAttribute(
              "position",
              new r.Float32BufferAttribute(i.vertices, 3)
            ),
              i.normals.length > 0 &&
                c.setAttribute(
                  "normal",
                  new r.Float32BufferAttribute(i.normals, 3)
                ),
              i.colors.length > 0 &&
                ((l = !0),
                c.setAttribute(
                  "color",
                  new r.Float32BufferAttribute(i.colors, 3)
                )),
              !0 === i.hasUVIndices &&
                c.setAttribute("uv", new r.Float32BufferAttribute(i.uvs, 2));
            const u = [];
            for (let e = 0, n = o.length; e < n; e++) {
              const n = o[e],
                i = n.name + "_" + n.smooth + "_" + l;
              let c = t.materials[i];
              if (null !== this.materials)
                if (
                  ((c = this.materials.create(n.name)),
                  !a || !c || c instanceof r.LineBasicMaterial)
                ) {
                  if (s && c && !(c instanceof r.PointsMaterial)) {
                    const e = new r.PointsMaterial({
                      size: 10,
                      sizeAttenuation: !1,
                    });
                    r.Material.prototype.copy.call(e, c),
                      e.color.copy(c.color),
                      (e.map = c.map),
                      (c = e);
                  }
                } else {
                  const e = new r.LineBasicMaterial();
                  r.Material.prototype.copy.call(e, c),
                    e.color.copy(c.color),
                    (c = e);
                }
              void 0 === c &&
                ((c = a
                  ? new r.LineBasicMaterial()
                  : s
                  ? new r.PointsMaterial({
                      size: 1,
                      sizeAttenuation: !1,
                    })
                  : new r.MeshPhongMaterial()),
                (c.name = n.name),
                (c.flatShading = !n.smooth),
                (c.vertexColors = l),
                (t.materials[i] = c)),
                u.push(c);
            }
            let h;
            if (u.length > 1) {
              for (let e = 0, t = o.length; e < t; e++) {
                const t = o[e];
                c.addGroup(t.groupStart, t.groupCount, e);
              }
              h = a
                ? new r.LineSegments(c, u)
                : s
                ? new r.Points(c, u)
                : new r.Mesh(c, u);
            } else
              h = a
                ? new r.LineSegments(c, u[0])
                : s
                ? new r.Points(c, u[0])
                : new r.Mesh(c, u[0]);
            (h.name = n.name), p.add(h);
          }
        else if (t.vertices.length > 0) {
          const e = new r.PointsMaterial({
              size: 1,
              sizeAttenuation: !1,
            }),
            n = new r.BufferGeometry();
          n.setAttribute(
            "position",
            new r.Float32BufferAttribute(t.vertices, 3)
          ),
            t.colors.length > 0 &&
              void 0 !== t.colors[0] &&
              (n.setAttribute(
                "color",
                new r.Float32BufferAttribute(t.colors, 3)
              ),
              (e.vertexColors = !0));
          const i = new r.Points(n, e);
          p.add(i);
        }
        return p;
      }
    }
    class g extends r.DataTextureLoader {
      constructor(e) {
        super(e);
      }
      parse(e) {
        const t = 0,
          n = 1,
          i = 2,
          o = 3,
          a = 9,
          s = 10,
          l = 11,
          c = 48,
          u = 4,
          h = 0,
          d = 1,
          p = 2,
          f = 3;
        e.length < 19 &&
          console.error("THREE.TGALoader: Not enough data to contain header.");
        let m = 0;
        const g = new Uint8Array(e),
          v = {
            id_length: g[m++],
            colormap_type: g[m++],
            image_type: g[m++],
            colormap_index: g[m++] | (g[m++] << 8),
            colormap_length: g[m++] | (g[m++] << 8),
            colormap_size: g[m++],
            origin: [g[m++] | (g[m++] << 8), g[m++] | (g[m++] << 8)],
            width: g[m++] | (g[m++] << 8),
            height: g[m++] | (g[m++] << 8),
            pixel_size: g[m++],
            flags: g[m++],
          };
        !(function (e) {
          switch (e.image_type) {
            case n:
            case a:
              (e.colormap_length > 256 ||
                24 !== e.colormap_size ||
                1 !== e.colormap_type) &&
                console.error(
                  "THREE.TGALoader: Invalid type colormap data for indexed type."
                );
              break;
            case i:
            case o:
            case s:
            case l:
              e.colormap_type &&
                console.error(
                  "THREE.TGALoader: Invalid type colormap data for colormap type."
                );
              break;
            case t:
              console.error("THREE.TGALoader: No data.");
            default:
              console.error(
                'THREE.TGALoader: Invalid type "%s".',
                e.image_type
              );
          }
          (e.width <= 0 || e.height <= 0) &&
            console.error("THREE.TGALoader: Invalid image size."),
            8 !== e.pixel_size &&
              16 !== e.pixel_size &&
              24 !== e.pixel_size &&
              32 !== e.pixel_size &&
              console.error(
                'THREE.TGALoader: Invalid pixel size "%s".',
                e.pixel_size
              );
        })(v),
          v.id_length + m > e.length &&
            console.error("THREE.TGALoader: No data."),
          (m += v.id_length);
        let y = !1,
          x = !1,
          b = !1;
        switch (v.image_type) {
          case a:
            (y = !0), (x = !0);
            break;
          case n:
            x = !0;
            break;
          case s:
            y = !0;
            break;
          case i:
            break;
          case l:
            (y = !0), (b = !0);
            break;
          case o:
            b = !0;
        }
        const w = new Uint8Array(v.width * v.height * 4),
          _ = (function (e, t, n, r, i) {
            let o, a;
            const s = n.pixel_size >> 3,
              l = n.width * n.height * s;
            if (
              (t &&
                (a = i.subarray(
                  r,
                  (r += n.colormap_length * (n.colormap_size >> 3))
                )),
              e)
            ) {
              let e, t, n;
              o = new Uint8Array(l);
              let a = 0;
              const c = new Uint8Array(s);
              for (; a < l; )
                if (((e = i[r++]), (t = 1 + (127 & e)), 128 & e)) {
                  for (n = 0; n < s; ++n) c[n] = i[r++];
                  for (n = 0; n < t; ++n) o.set(c, a + n * s);
                  a += s * t;
                } else {
                  for (t *= s, n = 0; n < t; ++n) o[a + n] = i[r++];
                  a += t;
                }
            } else o = i.subarray(r, (r += t ? n.width * n.height : l));
            return {
              pixel_data: o,
              palettes: a,
            };
          })(y, x, v, m, g);
        return (
          (function (e, t, n, r, i) {
            let o, a, s, l, m, g;
            switch ((v.flags & c) >> u) {
              default:
              case p:
                (o = 0), (s = 1), (m = t), (a = 0), (l = 1), (g = n);
                break;
              case h:
                (o = 0), (s = 1), (m = t), (a = n - 1), (l = -1), (g = -1);
                break;
              case f:
                (o = t - 1), (s = -1), (m = -1), (a = 0), (l = 1), (g = n);
                break;
              case d:
                (o = t - 1),
                  (s = -1),
                  (m = -1),
                  (a = n - 1),
                  (l = -1),
                  (g = -1);
            }
            if (b)
              switch (v.pixel_size) {
                case 8:
                  !(function (e, t, n, r, i, o, a, s) {
                    let l,
                      c,
                      u,
                      h = 0;
                    const d = v.width;
                    for (u = t; u !== r; u += n)
                      for (c = i; c !== a; c += o, h++)
                        (l = s[h]),
                          (e[4 * (c + d * u) + 0] = l),
                          (e[4 * (c + d * u) + 1] = l),
                          (e[4 * (c + d * u) + 2] = l),
                          (e[4 * (c + d * u) + 3] = 255);
                  })(e, a, l, g, o, s, m, r);
                  break;
                case 16:
                  !(function (e, t, n, r, i, o, a, s) {
                    let l,
                      c,
                      u = 0;
                    const h = v.width;
                    for (c = t; c !== r; c += n)
                      for (l = i; l !== a; l += o, u += 2)
                        (e[4 * (l + h * c) + 0] = s[u + 0]),
                          (e[4 * (l + h * c) + 1] = s[u + 0]),
                          (e[4 * (l + h * c) + 2] = s[u + 0]),
                          (e[4 * (l + h * c) + 3] = s[u + 1]);
                  })(e, a, l, g, o, s, m, r);
                  break;
                default:
                  console.error("THREE.TGALoader: Format not supported.");
              }
            else
              switch (v.pixel_size) {
                case 8:
                  !(function (e, t, n, r, i, o, a, s, l) {
                    const c = l;
                    let u,
                      h,
                      d,
                      p = 0;
                    const f = v.width;
                    for (d = t; d !== r; d += n)
                      for (h = i; h !== a; h += o, p++)
                        (u = s[p]),
                          (e[4 * (h + f * d) + 3] = 255),
                          (e[4 * (h + f * d) + 2] = c[3 * u + 0]),
                          (e[4 * (h + f * d) + 1] = c[3 * u + 1]),
                          (e[4 * (h + f * d) + 0] = c[3 * u + 2]);
                  })(e, a, l, g, o, s, m, r, i);
                  break;
                case 16:
                  !(function (e, t, n, r, i, o, a, s) {
                    let l,
                      c,
                      u,
                      h = 0;
                    const d = v.width;
                    for (u = t; u !== r; u += n)
                      for (c = i; c !== a; c += o, h += 2)
                        (l = s[h + 0] + (s[h + 1] << 8)),
                          (e[4 * (c + d * u) + 0] = (31744 & l) >> 7),
                          (e[4 * (c + d * u) + 1] = (992 & l) >> 2),
                          (e[4 * (c + d * u) + 2] = (31 & l) << 3),
                          (e[4 * (c + d * u) + 3] = 32768 & l ? 0 : 255);
                  })(e, a, l, g, o, s, m, r);
                  break;
                case 24:
                  !(function (e, t, n, r, i, o, a, s) {
                    let l,
                      c,
                      u = 0;
                    const h = v.width;
                    for (c = t; c !== r; c += n)
                      for (l = i; l !== a; l += o, u += 3)
                        (e[4 * (l + h * c) + 3] = 255),
                          (e[4 * (l + h * c) + 2] = s[u + 0]),
                          (e[4 * (l + h * c) + 1] = s[u + 1]),
                          (e[4 * (l + h * c) + 0] = s[u + 2]);
                  })(e, a, l, g, o, s, m, r);
                  break;
                case 32:
                  !(function (e, t, n, r, i, o, a, s) {
                    let l,
                      c,
                      u = 0;
                    const h = v.width;
                    for (c = t; c !== r; c += n)
                      for (l = i; l !== a; l += o, u += 4)
                        (e[4 * (l + h * c) + 2] = s[u + 0]),
                          (e[4 * (l + h * c) + 1] = s[u + 1]),
                          (e[4 * (l + h * c) + 0] = s[u + 2]),
                          (e[4 * (l + h * c) + 3] = s[u + 3]);
                  })(e, a, l, g, o, s, m, r);
                  break;
                default:
                  console.error("THREE.TGALoader: Format not supported.");
              }
          })(w, v.width, v.height, _.pixel_data, _.palettes),
          {
            data: w,
            width: v.width,
            height: v.height,
            flipY: !0,
            generateMipmaps: !0,
            minFilter: r.LinearMipmapLinearFilter,
          }
        );
      }
    }
    class v extends r.Loader {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        const o = this,
          a = "" === o.path ? r.LoaderUtils.extractUrlBase(e) : o.path,
          s = new r.FileLoader(o.manager);
        s.setPath(o.path),
          s.setRequestHeader(o.requestHeader),
          s.setWithCredentials(o.withCredentials),
          s.load(
            e,
            function (n) {
              try {
                t(o.parse(n, a));
              } catch (t) {
                i ? i(t) : console.error(t), o.manager.itemError(e);
              }
            },
            n,
            i
          );
      }
      parse(e, t) {
        function n(e, t) {
          const n = [],
            r = e.childNodes;
          for (let e = 0, i = r.length; e < i; e++) {
            const i = r[e];
            i.nodeName === t && n.push(i);
          }
          return n;
        }

        function i(e) {
          if (0 === e.length) return [];
          const t = e.trim().split(/\s+/),
            n = new Array(t.length);
          for (let e = 0, r = t.length; e < r; e++) n[e] = t[e];
          return n;
        }

        function o(e) {
          if (0 === e.length) return [];
          const t = e.trim().split(/\s+/),
            n = new Array(t.length);
          for (let e = 0, r = t.length; e < r; e++) n[e] = parseFloat(t[e]);
          return n;
        }

        function a(e) {
          if (0 === e.length) return [];
          const t = e.trim().split(/\s+/),
            n = new Array(t.length);
          for (let e = 0, r = t.length; e < r; e++) n[e] = parseInt(t[e]);
          return n;
        }

        function s(e) {
          return e.substring(1);
        }

        function l(e) {
          return 0 === Object.keys(e).length;
        }

        function c(e) {
          return void 0 !== e && !0 === e.hasAttribute("meter")
            ? parseFloat(e.getAttribute("meter"))
            : 1;
        }

        function u(e) {
          return void 0 !== e ? e.textContent : "Y_UP";
        }

        function h(e, t, r, i) {
          const o = n(e, t)[0];
          if (void 0 !== o) {
            const e = n(o, r);
            for (let t = 0; t < e.length; t++) i(e[t]);
          }
        }

        function d(e, t) {
          for (const n in e) {
            e[n].build = t(e[n]);
          }
        }

        function p(e, t) {
          return void 0 !== e.build || (e.build = t(e)), e.build;
        }

        function f(e) {
          const t = {
            inputs: {},
          };
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "input":
                  const e = s(r.getAttribute("source")),
                    n = r.getAttribute("semantic");
                  t.inputs[n] = e;
              }
          }
          return t;
        }

        function m(e) {
          const t = {};
          let n = e.getAttribute("target").split("/");
          const r = n.shift();
          let i = n.shift();
          const o = -1 !== i.indexOf("("),
            a = -1 !== i.indexOf(".");
          if (a) (n = i.split(".")), (i = n.shift()), (t.member = n.shift());
          else if (o) {
            const e = i.split("(");
            i = e.shift();
            for (let t = 0; t < e.length; t++)
              e[t] = parseInt(e[t].replace(/\)/, ""));
            t.indices = e;
          }
          return (
            (t.id = r),
            (t.sid = i),
            (t.arraySyntax = o),
            (t.memberSyntax = a),
            (t.sampler = s(e.getAttribute("source"))),
            t
          );
        }

        function v(e) {
          const t = [],
            n = e.channels,
            r = e.samplers,
            i = e.sources;
          for (const e in n)
            if (n.hasOwnProperty(e)) {
              const o = n[e],
                a = r[o.sampler],
                s = a.inputs.INPUT,
                l = a.inputs.OUTPUT;
              M(x(o, i[s], i[l]), t);
            }
          return t;
        }

        function y(e) {
          return p(Ke.animations[e], v);
        }

        function x(e, t, n) {
          const r = Ke.nodes[e.id],
            i = Ne(r.id),
            o = r.transforms[e.sid],
            a = r.matrix.clone().transpose();
          let s, l, c, u, h, d;
          const p = {};
          switch (o) {
            case "matrix":
              for (c = 0, u = t.array.length; c < u; c++)
                if (
                  ((s = t.array[c]),
                  (l = c * n.stride),
                  void 0 === p[s] && (p[s] = {}),
                  !0 === e.arraySyntax)
                ) {
                  const t = n.array[l],
                    r = e.indices[0] + 4 * e.indices[1];
                  p[s][r] = t;
                } else
                  for (h = 0, d = n.stride; h < d; h++)
                    p[s][h] = n.array[l + h];
              break;
            case "translate":
            case "rotate":
            case "scale":
              console.warn(
                'THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',
                o
              );
          }
          const f = (function (e, t) {
            const n = [];
            for (const t in e)
              n.push({
                time: parseFloat(t),
                value: e[t],
              });
            n.sort(function (e, t) {
              return e.time - t.time;
            });
            for (let e = 0; e < 16; e++) S(n, e, t.elements[e]);
            return n;
          })(p, a);
          return {
            name: i.uuid,
            keyframes: f,
          };
        }
        const b = new r.Vector3(),
          w = new r.Vector3(),
          _ = new r.Quaternion();

        function M(e, t) {
          const n = e.keyframes,
            i = e.name,
            o = [],
            a = [],
            s = [],
            l = [];
          for (let e = 0, t = n.length; e < t; e++) {
            const t = n[e],
              r = t.time,
              i = t.value;
            Ae.fromArray(i).transpose(),
              Ae.decompose(b, _, w),
              o.push(r),
              a.push(b.x, b.y, b.z),
              s.push(_.x, _.y, _.z, _.w),
              l.push(w.x, w.y, w.z);
          }
          return (
            a.length > 0 &&
              t.push(new r.VectorKeyframeTrack(i + ".position", o, a)),
            s.length > 0 &&
              t.push(new r.QuaternionKeyframeTrack(i + ".quaternion", o, s)),
            l.length > 0 &&
              t.push(new r.VectorKeyframeTrack(i + ".scale", o, l)),
            t
          );
        }

        function S(e, t, n) {
          let r,
            i,
            o,
            a = !0;
          for (i = 0, o = e.length; i < o; i++)
            (r = e[i]), void 0 === r.value[t] ? (r.value[t] = null) : (a = !1);
          if (!0 === a)
            for (i = 0, o = e.length; i < o; i++) (r = e[i]), (r.value[t] = n);
          else
            !(function (e, t) {
              let n, r;
              for (let i = 0, o = e.length; i < o; i++) {
                const o = e[i];
                if (null === o.value[t]) {
                  if (((n = T(e, i, t)), (r = E(e, i, t)), null === n)) {
                    o.value[t] = r.value[t];
                    continue;
                  }
                  if (null === r) {
                    o.value[t] = n.value[t];
                    continue;
                  }
                  A(o, n, r, t);
                }
              }
            })(e, t);
        }

        function T(e, t, n) {
          for (; t >= 0; ) {
            const r = e[t];
            if (null !== r.value[n]) return r;
            t--;
          }
          return null;
        }

        function E(e, t, n) {
          for (; t < e.length; ) {
            const r = e[t];
            if (null !== r.value[n]) return r;
            t++;
          }
          return null;
        }

        function A(e, t, n, r) {
          n.time - t.time != 0
            ? (e.value[r] =
                ((e.time - t.time) * (n.value[r] - t.value[r])) /
                  (n.time - t.time) +
                t.value[r])
            : (e.value[r] = t.value[r]);
        }

        function C(e) {
          const t = [],
            n = e.name,
            i = e.end - e.start || -1,
            o = e.animations;
          for (let e = 0, n = o.length; e < n; e++) {
            const n = y(o[e]);
            for (let e = 0, r = n.length; e < r; e++) t.push(n[e]);
          }
          return new r.AnimationClip(n, i, t);
        }

        function P(e) {
          return p(Ke.clips[e], C);
        }

        function L(e) {
          const t = {
            sources: {},
          };
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "bind_shape_matrix":
                  t.bindShapeMatrix = o(r.textContent);
                  break;
                case "source":
                  const e = r.getAttribute("id");
                  t.sources[e] = se(r);
                  break;
                case "joints":
                  t.joints = R(r);
                  break;
                case "vertex_weights":
                  t.vertexWeights = I(r);
              }
          }
          return t;
        }

        function R(e) {
          const t = {
            inputs: {},
          };
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "input":
                  const e = r.getAttribute("semantic"),
                    n = s(r.getAttribute("source"));
                  t.inputs[e] = n;
              }
          }
          return t;
        }

        function I(e) {
          const t = {
            inputs: {},
          };
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "input":
                  const e = r.getAttribute("semantic"),
                    n = s(r.getAttribute("source")),
                    i = parseInt(r.getAttribute("offset"));
                  t.inputs[e] = {
                    id: n,
                    offset: i,
                  };
                  break;
                case "vcount":
                  t.vcount = a(r.textContent);
                  break;
                case "v":
                  t.v = a(r.textContent);
              }
          }
          return t;
        }

        function k(e) {
          const t = {
              id: e.id,
            },
            n = Ke.geometries[t.id];
          return (
            void 0 !== e.skin &&
              ((t.skin = (function (e) {
                const t = {
                    joints: [],
                    indices: {
                      array: [],
                      stride: 4,
                    },
                    weights: {
                      array: [],
                      stride: 4,
                    },
                  },
                  n = e.sources,
                  i = e.vertexWeights,
                  o = i.vcount,
                  a = i.v,
                  s = i.inputs.JOINT.offset,
                  l = i.inputs.WEIGHT.offset,
                  c = e.sources[e.joints.inputs.JOINT],
                  u = e.sources[e.joints.inputs.INV_BIND_MATRIX],
                  h = n[i.inputs.WEIGHT.id].array;
                let d,
                  p,
                  f,
                  m = 0;
                for (d = 0, f = o.length; d < f; d++) {
                  const e = o[d],
                    n = [];
                  for (p = 0; p < e; p++) {
                    const e = a[m + s],
                      t = a[m + l],
                      r = h[t];
                    n.push({
                      index: e,
                      weight: r,
                    }),
                      (m += 2);
                  }
                  for (n.sort(g), p = 0; p < 4; p++) {
                    const e = n[p];
                    void 0 !== e
                      ? (t.indices.array.push(e.index),
                        t.weights.array.push(e.weight))
                      : (t.indices.array.push(0), t.weights.array.push(0));
                  }
                }
                e.bindShapeMatrix
                  ? (t.bindMatrix = new r.Matrix4()
                      .fromArray(e.bindShapeMatrix)
                      .transpose())
                  : (t.bindMatrix = new r.Matrix4().identity());
                for (d = 0, f = c.array.length; d < f; d++) {
                  const e = c.array[d],
                    n = new r.Matrix4()
                      .fromArray(u.array, d * u.stride)
                      .transpose();
                  t.joints.push({
                    name: e,
                    boneInverse: n,
                  });
                }
                return t;

                function g(e, t) {
                  return t.weight - e.weight;
                }
              })(e.skin)),
              (n.sources.skinIndices = t.skin.indices),
              (n.sources.skinWeights = t.skin.weights)),
            t
          );
        }

        function D(e) {
          return p(Ke.controllers[e], k);
        }

        function O(e) {
          return void 0 !== e.build ? e.build : e.init_from;
        }

        function B(e) {
          const t = Ke.images[e];
          return void 0 !== t
            ? p(t, O)
            : (console.warn(
                "THREE.ColladaLoader: Couldn't find image with ID:",
                e
              ),
              null);
        }

        function F(e) {
          const t = {
            surfaces: {},
            samplers: {},
          };
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "newparam":
                  N(r, t);
                  break;
                case "technique":
                  t.technique = H(r);
                  break;
                case "extra":
                  t.extra = $(r);
              }
          }
          return t;
        }

        function N(e, t) {
          const n = e.getAttribute("sid");
          for (let r = 0, i = e.childNodes.length; r < i; r++) {
            const i = e.childNodes[r];
            if (1 === i.nodeType)
              switch (i.nodeName) {
                case "surface":
                  t.surfaces[n] = U(i);
                  break;
                case "sampler2D":
                  t.samplers[n] = z(i);
              }
          }
        }

        function U(e) {
          const t = {};
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "init_from":
                  t.init_from = r.textContent;
              }
          }
          return t;
        }

        function z(e) {
          const t = {};
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "source":
                  t.source = r.textContent;
              }
          }
          return t;
        }

        function H(e) {
          const t = {};
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "constant":
                case "lambert":
                case "blinn":
                case "phong":
                  (t.type = r.nodeName), (t.parameters = G(r));
              }
          }
          return t;
        }

        function G(e) {
          const t = {};
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "emission":
                case "diffuse":
                case "specular":
                case "bump":
                case "ambient":
                case "shininess":
                case "transparency":
                  t[r.nodeName] = V(r);
                  break;
                case "transparent":
                  t[r.nodeName] = {
                    opaque: r.getAttribute("opaque"),
                    data: V(r),
                  };
              }
          }
          return t;
        }

        function V(e) {
          const t = {};
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "color":
                  t[r.nodeName] = o(r.textContent);
                  break;
                case "float":
                  t[r.nodeName] = parseFloat(r.textContent);
                  break;
                case "texture":
                  t[r.nodeName] = {
                    id: r.getAttribute("texture"),
                    extra: j(r),
                  };
              }
          }
          return t;
        }

        function j(e) {
          const t = {
            technique: {},
          };
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "extra":
                  W(r, t);
              }
          }
          return t;
        }

        function W(e, t) {
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "technique":
                  q(r, t);
              }
          }
        }

        function q(e, t) {
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "repeatU":
                case "repeatV":
                case "offsetU":
                case "offsetV":
                  t.technique[r.nodeName] = parseFloat(r.textContent);
                  break;
                case "wrapU":
                case "wrapV":
                  "TRUE" === r.textContent.toUpperCase()
                    ? (t.technique[r.nodeName] = 1)
                    : "FALSE" === r.textContent.toUpperCase()
                    ? (t.technique[r.nodeName] = 0)
                    : (t.technique[r.nodeName] = parseInt(r.textContent));
              }
          }
        }

        function $(e) {
          const t = {};
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "technique":
                  t.technique = X(r);
              }
          }
          return t;
        }

        function X(e) {
          const t = {};
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "double_sided":
                  t[r.nodeName] = parseInt(r.textContent);
              }
          }
          return t;
        }

        function Y(e) {
          return e;
        }

        function J(e) {
          const t = (function (e) {
              return p(Ke.effects[e], Y);
            })(e.url),
            n = t.profile.technique,
            i = t.profile.extra;
          let o;
          switch (n.type) {
            case "phong":
            case "blinn":
              o = new r.MeshPhongMaterial();
              break;
            case "lambert":
              o = new r.MeshLambertMaterial();
              break;
            default:
              o = new r.MeshBasicMaterial();
          }

          function a(e) {
            const n = t.profile.samplers[e.id];
            let i = null;
            if (void 0 !== n) {
              i = B(t.profile.surfaces[n.source].init_from);
            } else
              console.warn(
                "THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."
              ),
                (i = B(e.id));
            if (null !== i) {
              const t = (function (e) {
                let t,
                  n = e.slice(2 + ((e.lastIndexOf(".") - 1) >>> 0));
                switch (((n = n.toLowerCase()), n)) {
                  case "tga":
                    t = Xe;
                    break;
                  default:
                    t = $e;
                }
                return t;
              })(i);
              if (void 0 !== t) {
                const n = t.load(i),
                  o = e.extra;
                if (
                  void 0 !== o &&
                  void 0 !== o.technique &&
                  !1 === l(o.technique)
                ) {
                  const e = o.technique;
                  (n.wrapS = e.wrapU
                    ? r.RepeatWrapping
                    : r.ClampToEdgeWrapping),
                    (n.wrapT = e.wrapV
                      ? r.RepeatWrapping
                      : r.ClampToEdgeWrapping),
                    n.offset.set(e.offsetU || 0, e.offsetV || 0),
                    n.repeat.set(e.repeatU || 1, e.repeatV || 1);
                } else
                  (n.wrapS = r.RepeatWrapping), (n.wrapT = r.RepeatWrapping);
                return n;
              }
              return (
                console.warn(
                  "THREE.ColladaLoader: Loader for texture %s not found.",
                  i
                ),
                null
              );
            }
            return (
              console.warn(
                "THREE.ColladaLoader: Couldn't create texture with ID:",
                e.id
              ),
              null
            );
          }
          o.name = e.name || "";
          const s = n.parameters;
          for (const e in s) {
            const t = s[e];
            switch (e) {
              case "diffuse":
                t.color && o.color.fromArray(t.color),
                  t.texture && (o.map = a(t.texture));
                break;
              case "specular":
                t.color && o.specular && o.specular.fromArray(t.color),
                  t.texture && (o.specularMap = a(t.texture));
                break;
              case "bump":
                t.texture && (o.normalMap = a(t.texture));
                break;
              case "ambient":
                t.texture && (o.lightMap = a(t.texture));
                break;
              case "shininess":
                t.float && o.shininess && (o.shininess = t.float);
                break;
              case "emission":
                t.color && o.emissive && o.emissive.fromArray(t.color),
                  t.texture && (o.emissiveMap = a(t.texture));
            }
          }
          let c = s.transparent,
            u = s.transparency;
          if (
            (void 0 === u &&
              c &&
              (u = {
                float: 1,
              }),
            void 0 === c &&
              u &&
              (c = {
                opaque: "A_ONE",
                data: {
                  color: [1, 1, 1, 1],
                },
              }),
            c && u)
          )
            if (c.data.texture) o.transparent = !0;
            else {
              const e = c.data.color;
              switch (c.opaque) {
                case "A_ONE":
                  o.opacity = e[3] * u.float;
                  break;
                case "RGB_ZERO":
                  o.opacity = 1 - e[0] * u.float;
                  break;
                case "A_ZERO":
                  o.opacity = 1 - e[3] * u.float;
                  break;
                case "RGB_ONE":
                  o.opacity = e[0] * u.float;
                  break;
                default:
                  console.warn(
                    'THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.',
                    c.opaque
                  );
              }
              o.opacity < 1 && (o.transparent = !0);
            }
          return (
            void 0 !== i &&
              void 0 !== i.technique &&
              1 === i.technique.double_sided &&
              (o.side = r.DoubleSide),
            o
          );
        }

        function Z(e) {
          return p(Ke.materials[e], J);
        }

        function K(e) {
          for (let t = 0; t < e.childNodes.length; t++) {
            const n = e.childNodes[t];
            switch (n.nodeName) {
              case "technique_common":
                return Q(n);
            }
          }
          return {};
        }

        function Q(e) {
          const t = {};
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            switch (r.nodeName) {
              case "perspective":
              case "orthographic":
                (t.technique = r.nodeName), (t.parameters = ee(r));
            }
          }
          return t;
        }

        function ee(e) {
          const t = {};
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            switch (r.nodeName) {
              case "xfov":
              case "yfov":
              case "xmag":
              case "ymag":
              case "znear":
              case "zfar":
              case "aspect_ratio":
                t[r.nodeName] = parseFloat(r.textContent);
            }
          }
          return t;
        }

        function te(e) {
          let t;
          switch (e.optics.technique) {
            case "perspective":
              t = new r.PerspectiveCamera(
                e.optics.parameters.yfov,
                e.optics.parameters.aspect_ratio,
                e.optics.parameters.znear,
                e.optics.parameters.zfar
              );
              break;
            case "orthographic":
              let n = e.optics.parameters.ymag,
                i = e.optics.parameters.xmag;
              const o = e.optics.parameters.aspect_ratio;
              (i = void 0 === i ? n * o : i),
                (n = void 0 === n ? i / o : n),
                (i *= 0.5),
                (n *= 0.5),
                (t = new r.OrthographicCamera(
                  -i,
                  i,
                  n,
                  -n,
                  e.optics.parameters.znear,
                  e.optics.parameters.zfar
                ));
              break;
            default:
              t = new r.PerspectiveCamera();
          }
          return (t.name = e.name || ""), t;
        }

        function ne(e) {
          const t = Ke.cameras[e];
          return void 0 !== t
            ? p(t, te)
            : (console.warn(
                "THREE.ColladaLoader: Couldn't find camera with ID:",
                e
              ),
              null);
        }

        function re(e) {
          const t = {};
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "directional":
                case "point":
                case "spot":
                case "ambient":
                  (t.technique = r.nodeName), (t.parameters = ie(r));
              }
          }
          return t;
        }

        function ie(e) {
          const t = {};
          for (let n = 0, i = e.childNodes.length; n < i; n++) {
            const i = e.childNodes[n];
            if (1 === i.nodeType)
              switch (i.nodeName) {
                case "color":
                  const e = o(i.textContent);
                  t.color = new r.Color().fromArray(e);
                  break;
                case "falloff_angle":
                  t.falloffAngle = parseFloat(i.textContent);
                  break;
                case "quadratic_attenuation":
                  const n = parseFloat(i.textContent);
                  t.distance = n ? Math.sqrt(1 / n) : 0;
              }
          }
          return t;
        }

        function oe(e) {
          let t;
          switch (e.technique) {
            case "directional":
              t = new r.DirectionalLight();
              break;
            case "point":
              t = new r.PointLight();
              break;
            case "spot":
              t = new r.SpotLight();
              break;
            case "ambient":
              t = new r.AmbientLight();
          }
          return (
            e.parameters.color && t.color.copy(e.parameters.color),
            e.parameters.distance && (t.distance = e.parameters.distance),
            t
          );
        }

        function ae(e) {
          const t = Ke.lights[e];
          return void 0 !== t
            ? p(t, oe)
            : (console.warn(
                "THREE.ColladaLoader: Couldn't find light with ID:",
                e
              ),
              null);
        }

        function se(e) {
          const t = {
            array: [],
            stride: 3,
          };
          for (let r = 0; r < e.childNodes.length; r++) {
            const a = e.childNodes[r];
            if (1 === a.nodeType)
              switch (a.nodeName) {
                case "float_array":
                  t.array = o(a.textContent);
                  break;
                case "Name_array":
                  t.array = i(a.textContent);
                  break;
                case "technique_common":
                  const e = n(a, "accessor")[0];
                  void 0 !== e &&
                    (t.stride = parseInt(e.getAttribute("stride")));
              }
          }
          return t;
        }

        function le(e) {
          const t = {};
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            1 === r.nodeType &&
              (t[r.getAttribute("semantic")] = s(r.getAttribute("source")));
          }
          return t;
        }

        function ce(e) {
          const t = {
            type: e.nodeName,
            material: e.getAttribute("material"),
            count: parseInt(e.getAttribute("count")),
            inputs: {},
            stride: 0,
            hasUV: !1,
          };
          for (let n = 0, r = e.childNodes.length; n < r; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "input":
                  const e = s(r.getAttribute("source")),
                    n = r.getAttribute("semantic"),
                    i = parseInt(r.getAttribute("offset")),
                    o = parseInt(r.getAttribute("set")),
                    l = o > 0 ? n + o : n;
                  (t.inputs[l] = {
                    id: e,
                    offset: i,
                  }),
                    (t.stride = Math.max(t.stride, i + 1)),
                    "TEXCOORD" === n && (t.hasUV = !0);
                  break;
                case "vcount":
                  t.vcount = a(r.textContent);
                  break;
                case "p":
                  t.p = a(r.textContent);
              }
          }
          return t;
        }

        function ue(e) {
          let t = 0;
          for (let n = 0, r = e.length; n < r; n++) {
            !0 === e[n].hasUV && t++;
          }
          t > 0 && t < e.length && (e.uvsNeedsFix = !0);
        }

        function he(e) {
          const t = {},
            n = e.sources,
            r = e.vertices,
            i = e.primitives;
          if (0 === i.length) return {};
          const o = (function (e) {
            const t = {};
            for (let n = 0; n < e.length; n++) {
              const r = e[n];
              void 0 === t[r.type] && (t[r.type] = []), t[r.type].push(r);
            }
            return t;
          })(i);
          for (const e in o) {
            const i = o[e];
            ue(i), (t[e] = de(i, n, r));
          }
          return t;
        }

        function de(e, t, n) {
          const i = {},
            o = {
              array: [],
              stride: 0,
            },
            a = {
              array: [],
              stride: 0,
            },
            s = {
              array: [],
              stride: 0,
            },
            l = {
              array: [],
              stride: 0,
            },
            c = {
              array: [],
              stride: 0,
            },
            u = [],
            h = 4,
            d = [],
            p = 4,
            f = new r.BufferGeometry(),
            m = [];
          let g = 0;
          for (let r = 0; r < e.length; r++) {
            const i = e[r],
              h = i.inputs;
            let p = 0;
            switch (i.type) {
              case "lines":
              case "linestrips":
                p = 2 * i.count;
                break;
              case "triangles":
                p = 3 * i.count;
                break;
              case "polylist":
                for (let e = 0; e < i.count; e++) {
                  const t = i.vcount[e];
                  switch (t) {
                    case 3:
                      p += 3;
                      break;
                    case 4:
                      p += 6;
                      break;
                    default:
                      p += 3 * (t - 2);
                  }
                }
                break;
              default:
                console.warn(
                  "THREE.ColladaLoader: Unknow primitive type:",
                  i.type
                );
            }
            f.addGroup(g, p, r), (g += p), i.material && m.push(i.material);
            for (const r in h) {
              const p = h[r];
              switch (r) {
                case "VERTEX":
                  for (const r in n) {
                    const h = n[r];
                    switch (r) {
                      case "POSITION":
                        const n = o.array.length;
                        if (
                          (pe(i, t[h], p.offset, o.array),
                          (o.stride = t[h].stride),
                          t.skinWeights &&
                            t.skinIndices &&
                            (pe(i, t.skinIndices, p.offset, u),
                            pe(i, t.skinWeights, p.offset, d)),
                          !1 === i.hasUV && !0 === e.uvsNeedsFix)
                        ) {
                          const e = (o.array.length - n) / o.stride;
                          for (let t = 0; t < e; t++) s.array.push(0, 0);
                        }
                        break;
                      case "NORMAL":
                        pe(i, t[h], p.offset, a.array),
                          (a.stride = t[h].stride);
                        break;
                      case "COLOR":
                        pe(i, t[h], p.offset, c.array),
                          (c.stride = t[h].stride);
                        break;
                      case "TEXCOORD":
                        pe(i, t[h], p.offset, s.array),
                          (s.stride = t[h].stride);
                        break;
                      case "TEXCOORD1":
                        pe(i, t[h], p.offset, l.array),
                          (s.stride = t[h].stride);
                        break;
                      default:
                        console.warn(
                          'THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.',
                          r
                        );
                    }
                  }
                  break;
                case "NORMAL":
                  pe(i, t[p.id], p.offset, a.array),
                    (a.stride = t[p.id].stride);
                  break;
                case "COLOR":
                  pe(i, t[p.id], p.offset, c.array),
                    (c.stride = t[p.id].stride);
                  break;
                case "TEXCOORD":
                  pe(i, t[p.id], p.offset, s.array),
                    (s.stride = t[p.id].stride);
                  break;
                case "TEXCOORD1":
                  pe(i, t[p.id], p.offset, l.array),
                    (l.stride = t[p.id].stride);
              }
            }
          }
          return (
            o.array.length > 0 &&
              f.setAttribute(
                "position",
                new r.Float32BufferAttribute(o.array, o.stride)
              ),
            a.array.length > 0 &&
              f.setAttribute(
                "normal",
                new r.Float32BufferAttribute(a.array, a.stride)
              ),
            c.array.length > 0 &&
              f.setAttribute(
                "color",
                new r.Float32BufferAttribute(c.array, c.stride)
              ),
            s.array.length > 0 &&
              f.setAttribute(
                "uv",
                new r.Float32BufferAttribute(s.array, s.stride)
              ),
            l.array.length > 0 &&
              f.setAttribute(
                "uv2",
                new r.Float32BufferAttribute(l.array, l.stride)
              ),
            u.length > 0 &&
              f.setAttribute("skinIndex", new r.Float32BufferAttribute(u, h)),
            d.length > 0 &&
              f.setAttribute("skinWeight", new r.Float32BufferAttribute(d, p)),
            (i.data = f),
            (i.type = e[0].type),
            (i.materialKeys = m),
            i
          );
        }

        function pe(e, t, n, r) {
          const i = e.p,
            o = e.stride,
            a = e.vcount;

          function s(e) {
            let t = i[e + n] * c;
            const o = t + c;
            for (; t < o; t++) r.push(l[t]);
          }
          const l = t.array,
            c = t.stride;
          if (void 0 !== e.vcount) {
            let e = 0;
            for (let t = 0, n = a.length; t < n; t++) {
              const n = a[t];
              if (4 === n) {
                const t = e + 1 * o,
                  n = e + 2 * o,
                  r = e + 3 * o;
                s(e + 0 * o), s(t), s(r), s(t), s(n), s(r);
              } else if (3 === n) {
                const t = e + 1 * o,
                  n = e + 2 * o;
                s(e + 0 * o), s(t), s(n);
              } else if (n > 4)
                for (let t = 1, r = n - 2; t <= r; t++) {
                  const n = e + o * t,
                    r = e + o * (t + 1);
                  s(e + 0 * o), s(n), s(r);
                }
              e += o * n;
            }
          } else for (let e = 0, t = i.length; e < t; e += o) s(e);
        }

        function fe(e) {
          return p(Ke.geometries[e], he);
        }

        function me(e) {
          return void 0 !== e.build ? e.build : e;
        }

        function ge(e, t) {
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "joint":
                  t.joints[r.getAttribute("sid")] = ve(r);
                  break;
                case "link":
                  t.links.push(xe(r));
              }
          }
        }

        function ve(e) {
          let t;
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "prismatic":
                case "revolute":
                  t = ye(r);
              }
          }
          return t;
        }

        function ye(e) {
          const t = {
            sid: e.getAttribute("sid"),
            name: e.getAttribute("name") || "",
            axis: new r.Vector3(),
            limits: {
              min: 0,
              max: 0,
            },
            type: e.nodeName,
            static: !1,
            zeroPosition: 0,
            middlePosition: 0,
          };
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "axis":
                  const e = o(r.textContent);
                  t.axis.fromArray(e);
                  break;
                case "limits":
                  const n = r.getElementsByTagName("max")[0],
                    i = r.getElementsByTagName("min")[0];
                  (t.limits.max = parseFloat(n.textContent)),
                    (t.limits.min = parseFloat(i.textContent));
              }
          }
          return (
            t.limits.min >= t.limits.max && (t.static = !0),
            (t.middlePosition = (t.limits.min + t.limits.max) / 2),
            t
          );
        }

        function xe(e) {
          const t = {
            sid: e.getAttribute("sid"),
            name: e.getAttribute("name") || "",
            attachments: [],
            transforms: [],
          };
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "attachment_full":
                  t.attachments.push(be(r));
                  break;
                case "matrix":
                case "translate":
                case "rotate":
                  t.transforms.push(we(r));
              }
          }
          return t;
        }

        function be(e) {
          const t = {
            joint: e.getAttribute("joint").split("/").pop(),
            transforms: [],
            links: [],
          };
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "link":
                  t.links.push(xe(r));
                  break;
                case "matrix":
                case "translate":
                case "rotate":
                  t.transforms.push(we(r));
              }
          }
          return t;
        }

        function we(e) {
          const t = {
              type: e.nodeName,
            },
            n = o(e.textContent);
          switch (t.type) {
            case "matrix":
              (t.obj = new r.Matrix4()), t.obj.fromArray(n).transpose();
              break;
            case "translate":
              (t.obj = new r.Vector3()), t.obj.fromArray(n);
              break;
            case "rotate":
              (t.obj = new r.Vector3()),
                t.obj.fromArray(n),
                (t.angle = r.MathUtils.degToRad(n[3]));
          }
          return t;
        }

        function _e(e, t) {
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "technique_common":
                  Me(r, t);
              }
          }
        }

        function Me(e, t) {
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "inertia":
                  t.inertia = o(r.textContent);
                  break;
                case "mass":
                  t.mass = o(r.textContent)[0];
              }
          }
        }

        function Se(e) {
          const t = {
            target: e.getAttribute("target").split("/").pop(),
          };
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            if (1 === r.nodeType)
              switch (r.nodeName) {
                case "axis":
                  const e = r.getElementsByTagName("param")[0];
                  t.axis = e.textContent;
                  const n = t.axis.split("inst_").pop().split("axis")[0];
                  t.jointIndex = n.substr(0, n.length - 1);
              }
          }
          return t;
        }

        function Te(e) {
          return void 0 !== e.build ? e.build : e;
        }

        function Ee(e) {
          const t = [],
            n = Ve.querySelector('[id="' + e.id + '"]');
          for (let e = 0; e < n.childNodes.length; e++) {
            const i = n.childNodes[e];
            if (1 !== i.nodeType) continue;
            let a, s;
            switch (i.nodeName) {
              case "matrix":
                a = o(i.textContent);
                const e = new r.Matrix4().fromArray(a).transpose();
                t.push({
                  sid: i.getAttribute("sid"),
                  type: i.nodeName,
                  obj: e,
                });
                break;
              case "translate":
              case "scale":
                (a = o(i.textContent)),
                  (s = new r.Vector3().fromArray(a)),
                  t.push({
                    sid: i.getAttribute("sid"),
                    type: i.nodeName,
                    obj: s,
                  });
                break;
              case "rotate":
                (a = o(i.textContent)), (s = new r.Vector3().fromArray(a));
                const n = r.MathUtils.degToRad(a[3]);
                t.push({
                  sid: i.getAttribute("sid"),
                  type: i.nodeName,
                  obj: s,
                  angle: n,
                });
            }
          }
          return t;
        }
        const Ae = new r.Matrix4(),
          Ce = new r.Vector3();

        function Pe(e) {
          const t = {
            name: e.getAttribute("name") || "",
            type: e.getAttribute("type"),
            id: e.getAttribute("id"),
            sid: e.getAttribute("sid"),
            matrix: new r.Matrix4(),
            nodes: [],
            instanceCameras: [],
            instanceControllers: [],
            instanceLights: [],
            instanceGeometries: [],
            instanceNodes: [],
            transforms: {},
          };
          for (let n = 0; n < e.childNodes.length; n++) {
            const i = e.childNodes[n];
            if (1 !== i.nodeType) continue;
            let a;
            switch (i.nodeName) {
              case "node":
                t.nodes.push(i.getAttribute("id")), Pe(i);
                break;
              case "instance_camera":
                t.instanceCameras.push(s(i.getAttribute("url")));
                break;
              case "instance_controller":
                t.instanceControllers.push(Le(i));
                break;
              case "instance_light":
                t.instanceLights.push(s(i.getAttribute("url")));
                break;
              case "instance_geometry":
                t.instanceGeometries.push(Le(i));
                break;
              case "instance_node":
                t.instanceNodes.push(s(i.getAttribute("url")));
                break;
              case "matrix":
                (a = o(i.textContent)),
                  t.matrix.multiply(Ae.fromArray(a).transpose()),
                  (t.transforms[i.getAttribute("sid")] = i.nodeName);
                break;
              case "translate":
                (a = o(i.textContent)),
                  Ce.fromArray(a),
                  t.matrix.multiply(Ae.makeTranslation(Ce.x, Ce.y, Ce.z)),
                  (t.transforms[i.getAttribute("sid")] = i.nodeName);
                break;
              case "rotate":
                a = o(i.textContent);
                const e = r.MathUtils.degToRad(a[3]);
                t.matrix.multiply(Ae.makeRotationAxis(Ce.fromArray(a), e)),
                  (t.transforms[i.getAttribute("sid")] = i.nodeName);
                break;
              case "scale":
                (a = o(i.textContent)),
                  t.matrix.scale(Ce.fromArray(a)),
                  (t.transforms[i.getAttribute("sid")] = i.nodeName);
                break;
              case "extra":
                break;
              default:
                console.log(i);
            }
          }
          return (
            Fe(t.id)
              ? console.warn(
                  "THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.",
                  t.id
                )
              : (Ke.nodes[t.id] = t),
            t
          );
        }

        function Le(e) {
          const t = {
            id: s(e.getAttribute("url")),
            materials: {},
            skeletons: [],
          };
          for (let n = 0; n < e.childNodes.length; n++) {
            const r = e.childNodes[n];
            switch (r.nodeName) {
              case "bind_material":
                const e = r.getElementsByTagName("instance_material");
                for (let n = 0; n < e.length; n++) {
                  const r = e[n],
                    i = r.getAttribute("symbol"),
                    o = r.getAttribute("target");
                  t.materials[i] = s(o);
                }
                break;
              case "skeleton":
                t.skeletons.push(s(r.textContent));
            }
          }
          return t;
        }

        function Re(e, t) {
          const n = [],
            i = [];
          let o, a, s;
          for (o = 0; o < e.length; o++) {
            const r = e[o];
            let i;
            if (Fe(r)) (i = Ne(r)), Ie(i, t, n);
            else if (ze(r)) {
              const e = Ke.visualScenes[r].children;
              for (let r = 0; r < e.length; r++) {
                const i = e[r];
                if ("JOINT" === i.type) {
                  Ie(Ne(i.id), t, n);
                }
              }
            } else
              console.error(
                "THREE.ColladaLoader: Unable to find root bone of skeleton with ID:",
                r
              );
          }
          for (o = 0; o < t.length; o++)
            for (a = 0; a < n.length; a++)
              if (((s = n[a]), s.bone.name === t[o].name)) {
                (i[o] = s), (s.processed = !0);
                break;
              }
          for (o = 0; o < n.length; o++)
            (s = n[o]), !1 === s.processed && (i.push(s), (s.processed = !0));
          const l = [],
            c = [];
          for (o = 0; o < i.length; o++)
            (s = i[o]), l.push(s.bone), c.push(s.boneInverse);
          return new r.Skeleton(l, c);
        }

        function Ie(e, t, n) {
          e.traverse(function (e) {
            if (!0 === e.isBone) {
              let i;
              for (let n = 0; n < t.length; n++) {
                const r = t[n];
                if (r.name === e.name) {
                  i = r.boneInverse;
                  break;
                }
              }
              void 0 === i && (i = new r.Matrix4()),
                n.push({
                  bone: e,
                  boneInverse: i,
                  processed: !1,
                });
            }
          });
        }

        function ke(e) {
          const t = [],
            n = e.matrix,
            i = e.nodes,
            o = e.type,
            a = e.instanceCameras,
            s = e.instanceControllers,
            l = e.instanceLights,
            c = e.instanceGeometries,
            u = e.instanceNodes;
          for (let e = 0, n = i.length; e < n; e++) t.push(Ne(i[e]));
          for (let e = 0, n = a.length; e < n; e++) {
            const n = ne(a[e]);
            null !== n && t.push(n.clone());
          }
          for (let e = 0, n = s.length; e < n; e++) {
            const n = s[e],
              r = D(n.id),
              i = Be(fe(r.id), n.materials),
              o = Re(n.skeletons, r.skin.joints);
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              n.isSkinnedMesh &&
                (n.bind(o, r.skin.bindMatrix), n.normalizeSkinWeights()),
                t.push(n);
            }
          }
          for (let e = 0, n = l.length; e < n; e++) {
            const n = ae(l[e]);
            null !== n && t.push(n.clone());
          }
          for (let e = 0, n = c.length; e < n; e++) {
            const n = c[e],
              r = Be(fe(n.id), n.materials);
            for (let e = 0, n = r.length; e < n; e++) t.push(r[e]);
          }
          for (let e = 0, n = u.length; e < n; e++) t.push(Ne(u[e]).clone());
          let h;
          if (0 === i.length && 1 === t.length) h = t[0];
          else {
            h = "JOINT" === o ? new r.Bone() : new r.Group();
            for (let e = 0; e < t.length; e++) h.add(t[e]);
          }
          return (
            (h.name = "JOINT" === o ? e.sid : e.name),
            h.matrix.copy(n),
            h.matrix.decompose(h.position, h.quaternion, h.scale),
            h
          );
        }
        const De = new r.MeshBasicMaterial({
          color: 16711935,
        });

        function Oe(e, t) {
          const n = [];
          for (let r = 0, i = e.length; r < i; r++) {
            const i = t[e[r]];
            void 0 === i
              ? (console.warn(
                  "THREE.ColladaLoader: Material with key %s not found. Apply fallback material.",
                  e[r]
                ),
                n.push(De))
              : n.push(Z(i));
          }
          return n;
        }

        function Be(e, t) {
          const n = [];
          for (const i in e) {
            const o = e[i],
              a = Oe(o.materialKeys, t);
            0 === a.length &&
              ("lines" === i || "linestrips" === i
                ? a.push(new r.LineBasicMaterial())
                : a.push(new r.MeshPhongMaterial()));
            const s = void 0 !== o.data.attributes.skinIndex,
              l = 1 === a.length ? a[0] : a;
            let c;
            switch (i) {
              case "lines":
                c = new r.LineSegments(o.data, l);
                break;
              case "linestrips":
                c = new r.Line(o.data, l);
                break;
              case "triangles":
              case "polylist":
                c = s ? new r.SkinnedMesh(o.data, l) : new r.Mesh(o.data, l);
            }
            n.push(c);
          }
          return n;
        }

        function Fe(e) {
          return void 0 !== Ke.nodes[e];
        }

        function Ne(e) {
          return p(Ke.nodes[e], ke);
        }

        function Ue(e) {
          const t = new r.Group();
          t.name = e.name;
          const n = e.children;
          for (let e = 0; e < n.length; e++) {
            const r = n[e];
            t.add(Ne(r.id));
          }
          return t;
        }

        function ze(e) {
          return void 0 !== Ke.visualScenes[e];
        }

        function He(e) {
          return p(Ke.visualScenes[e], Ue);
        }
        if (0 === e.length)
          return {
            scene: new r.Scene(),
          };
        const Ge = new DOMParser().parseFromString(e, "application/xml"),
          Ve = n(Ge, "COLLADA")[0],
          je = Ge.getElementsByTagName("parsererror")[0];
        if (void 0 !== je) {
          const e = n(je, "div")[0];
          let t;
          return (
            (t = e
              ? e.textContent
              : (function (e) {
                  let t = "";
                  const n = [e];
                  for (; n.length; ) {
                    const e = n.shift();
                    e.nodeType === Node.TEXT_NODE
                      ? (t += e.textContent)
                      : ((t += "\n"), n.push.apply(n, e.childNodes));
                  }
                  return t.trim();
                })(je)),
            console.error(
              "THREE.ColladaLoader: Failed to parse collada file.\n",
              t
            ),
            null
          );
        }
        const We = Ve.getAttribute("version");
        console.log("THREE.ColladaLoader: File version", We);
        const qe = (function (e) {
            return {
              unit: c(n(e, "unit")[0]),
              upAxis: u(n(e, "up_axis")[0]),
            };
          })(n(Ve, "asset")[0]),
          $e = new r.TextureLoader(this.manager);
        let Xe;
        $e.setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin),
          g && ((Xe = new g(this.manager)), Xe.setPath(this.resourcePath || t));
        const Ye = [];
        let Je = {},
          Ze = 0;
        const Ke = {
          animations: {},
          clips: {},
          controllers: {},
          images: {},
          effects: {},
          materials: {},
          cameras: {},
          lights: {},
          geometries: {},
          nodes: {},
          visualScenes: {},
          kinematicsModels: {},
          physicsModels: {},
          kinematicsScenes: {},
        };
        h(Ve, "library_animations", "animation", function e(t) {
          const n = {
            sources: {},
            samplers: {},
            channels: {},
          };
          let i = !1;
          for (let r = 0, o = t.childNodes.length; r < o; r++) {
            const o = t.childNodes[r];
            if (1 !== o.nodeType) continue;
            let a;
            switch (o.nodeName) {
              case "source":
                (a = o.getAttribute("id")), (n.sources[a] = se(o));
                break;
              case "sampler":
                (a = o.getAttribute("id")), (n.samplers[a] = f(o));
                break;
              case "channel":
                (a = o.getAttribute("target")), (n.channels[a] = m(o));
                break;
              case "animation":
                e(o), (i = !0);
                break;
              default:
                console.log(o);
            }
          }
          !1 === i &&
            (Ke.animations[t.getAttribute("id") || r.MathUtils.generateUUID()] =
              n);
        }),
          h(Ve, "library_animation_clips", "animation_clip", function (e) {
            const t = {
              name: e.getAttribute("id") || "default",
              start: parseFloat(e.getAttribute("start") || 0),
              end: parseFloat(e.getAttribute("end") || 0),
              animations: [],
            };
            for (let n = 0, r = e.childNodes.length; n < r; n++) {
              const r = e.childNodes[n];
              if (1 === r.nodeType)
                switch (r.nodeName) {
                  case "instance_animation":
                    t.animations.push(s(r.getAttribute("url")));
                }
            }
            Ke.clips[e.getAttribute("id")] = t;
          }),
          h(Ve, "library_controllers", "controller", function (e) {
            const t = {};
            for (let n = 0, r = e.childNodes.length; n < r; n++) {
              const r = e.childNodes[n];
              if (1 === r.nodeType)
                switch (r.nodeName) {
                  case "skin":
                    (t.id = s(r.getAttribute("source"))), (t.skin = L(r));
                    break;
                  case "morph":
                    (t.id = s(r.getAttribute("source"))),
                      console.warn(
                        "THREE.ColladaLoader: Morph target animation not supported yet."
                      );
                }
            }
            Ke.controllers[e.getAttribute("id")] = t;
          }),
          h(Ve, "library_images", "image", function (e) {
            const t = {
              init_from: n(e, "init_from")[0].textContent,
            };
            Ke.images[e.getAttribute("id")] = t;
          }),
          h(Ve, "library_effects", "effect", function (e) {
            const t = {};
            for (let n = 0, r = e.childNodes.length; n < r; n++) {
              const r = e.childNodes[n];
              if (1 === r.nodeType)
                switch (r.nodeName) {
                  case "profile_COMMON":
                    t.profile = F(r);
                }
            }
            Ke.effects[e.getAttribute("id")] = t;
          }),
          h(Ve, "library_materials", "material", function (e) {
            const t = {
              name: e.getAttribute("name"),
            };
            for (let n = 0, r = e.childNodes.length; n < r; n++) {
              const r = e.childNodes[n];
              if (1 === r.nodeType)
                switch (r.nodeName) {
                  case "instance_effect":
                    t.url = s(r.getAttribute("url"));
                }
            }
            Ke.materials[e.getAttribute("id")] = t;
          }),
          h(Ve, "library_cameras", "camera", function (e) {
            const t = {
              name: e.getAttribute("name"),
            };
            for (let n = 0, r = e.childNodes.length; n < r; n++) {
              const r = e.childNodes[n];
              if (1 === r.nodeType)
                switch (r.nodeName) {
                  case "optics":
                    t.optics = K(r);
                }
            }
            Ke.cameras[e.getAttribute("id")] = t;
          }),
          h(Ve, "library_lights", "light", function (e) {
            let t = {};
            for (let n = 0, r = e.childNodes.length; n < r; n++) {
              const r = e.childNodes[n];
              if (1 === r.nodeType)
                switch (r.nodeName) {
                  case "technique_common":
                    t = re(r);
                }
            }
            Ke.lights[e.getAttribute("id")] = t;
          }),
          h(Ve, "library_geometries", "geometry", function (e) {
            const t = {
                name: e.getAttribute("name"),
                sources: {},
                vertices: {},
                primitives: [],
              },
              r = n(e, "mesh")[0];
            if (void 0 !== r) {
              for (let e = 0; e < r.childNodes.length; e++) {
                const n = r.childNodes[e];
                if (1 !== n.nodeType) continue;
                const i = n.getAttribute("id");
                switch (n.nodeName) {
                  case "source":
                    t.sources[i] = se(n);
                    break;
                  case "vertices":
                    t.vertices = le(n);
                    break;
                  case "polygons":
                    console.warn(
                      "THREE.ColladaLoader: Unsupported primitive type: ",
                      n.nodeName
                    );
                    break;
                  case "lines":
                  case "linestrips":
                  case "polylist":
                  case "triangles":
                    t.primitives.push(ce(n));
                    break;
                  default:
                    console.log(n);
                }
              }
              Ke.geometries[e.getAttribute("id")] = t;
            }
          }),
          h(Ve, "library_nodes", "node", Pe),
          h(Ve, "library_visual_scenes", "visual_scene", function (e) {
            const t = {
              name: e.getAttribute("name"),
              children: [],
            };
            !(function (e) {
              const t = e.getElementsByTagName("node");
              for (let e = 0; e < t.length; e++) {
                const n = t[e];
                !1 === n.hasAttribute("id") &&
                  n.setAttribute("id", "three_default_" + Ze++);
              }
            })(e);
            const r = n(e, "node");
            for (let e = 0; e < r.length; e++) t.children.push(Pe(r[e]));
            Ke.visualScenes[e.getAttribute("id")] = t;
          }),
          h(Ve, "library_kinematics_models", "kinematics_model", function (e) {
            const t = {
              name: e.getAttribute("name") || "",
              joints: {},
              links: [],
            };
            for (let n = 0; n < e.childNodes.length; n++) {
              const r = e.childNodes[n];
              if (1 === r.nodeType)
                switch (r.nodeName) {
                  case "technique_common":
                    ge(r, t);
                }
            }
            Ke.kinematicsModels[e.getAttribute("id")] = t;
          }),
          h(Ve, "library_physics_models", "physics_model", function (e) {
            const t = {
              name: e.getAttribute("name") || "",
              rigidBodies: {},
            };
            for (let n = 0; n < e.childNodes.length; n++) {
              const r = e.childNodes[n];
              if (1 === r.nodeType)
                switch (r.nodeName) {
                  case "rigid_body":
                    (t.rigidBodies[r.getAttribute("name")] = {}),
                      _e(r, t.rigidBodies[r.getAttribute("name")]);
                }
            }
            Ke.physicsModels[e.getAttribute("id")] = t;
          }),
          h(Ve, "scene", "instance_kinematics_scene", function (e) {
            const t = {
              bindJointAxis: [],
            };
            for (let n = 0; n < e.childNodes.length; n++) {
              const r = e.childNodes[n];
              if (1 === r.nodeType)
                switch (r.nodeName) {
                  case "bind_joint_axis":
                    t.bindJointAxis.push(Se(r));
                }
            }
            Ke.kinematicsScenes[s(e.getAttribute("url"))] = t;
          }),
          d(Ke.animations, v),
          d(Ke.clips, C),
          d(Ke.controllers, k),
          d(Ke.images, O),
          d(Ke.effects, Y),
          d(Ke.materials, J),
          d(Ke.cameras, te),
          d(Ke.lights, oe),
          d(Ke.geometries, he),
          d(Ke.visualScenes, Ue),
          (function () {
            const e = Ke.clips;
            if (!0 === l(e)) {
              if (!1 === l(Ke.animations)) {
                const e = [];
                for (const t in Ke.animations) {
                  const n = y(t);
                  for (let t = 0, r = n.length; t < r; t++) e.push(n[t]);
                }
                Ye.push(new r.AnimationClip("default", -1, e));
              }
            } else for (const t in e) Ye.push(P(t));
          })(),
          (function () {
            const e = Object.keys(Ke.kinematicsModels)[0],
              t = Object.keys(Ke.kinematicsScenes)[0],
              n = Object.keys(Ke.visualScenes)[0];
            if (void 0 === e || void 0 === t) return;
            const i = (function (e) {
                return p(Ke.kinematicsModels[e], me);
              })(e),
              o = (function (e) {
                return p(Ke.kinematicsScenes[e], Te);
              })(t),
              a = He(n),
              s = o.bindJointAxis,
              l = {};
            for (let e = 0, t = s.length; e < t; e++) {
              const t = s[e],
                n = Ve.querySelector('[sid="' + t.target + '"]');
              if (n) {
                const e = n.parentElement;
                c(t.jointIndex, e);
              }
            }

            function c(e, t) {
              const n = t.getAttribute("name"),
                r = i.joints[e];
              a.traverse(function (i) {
                i.name === n &&
                  (l[e] = {
                    object: i,
                    transforms: Ee(t),
                    joint: r,
                    position: r.zeroPosition,
                  });
              });
            }
            const u = new r.Matrix4();
            Je = {
              joints: i && i.joints,
              getJointValue: function (e) {
                const t = l[e];
                if (t) return t.position;
                console.warn(
                  "THREE.ColladaLoader: Joint " + e + " doesn't exist."
                );
              },
              setJointValue: function (e, t) {
                const n = l[e];
                if (n) {
                  const i = n.joint;
                  if (t > i.limits.max || t < i.limits.min)
                    console.warn(
                      "THREE.ColladaLoader: Joint " +
                        e +
                        " value " +
                        t +
                        " outside of limits (min: " +
                        i.limits.min +
                        ", max: " +
                        i.limits.max +
                        ")."
                    );
                  else if (i.static)
                    console.warn(
                      "THREE.ColladaLoader: Joint " + e + " is static."
                    );
                  else {
                    const o = n.object,
                      a = i.axis,
                      s = n.transforms;
                    Ae.identity();
                    for (let n = 0; n < s.length; n++) {
                      const o = s[n];
                      if (o.sid && -1 !== o.sid.indexOf(e))
                        switch (i.type) {
                          case "revolute":
                            Ae.multiply(
                              u.makeRotationAxis(a, r.MathUtils.degToRad(t))
                            );
                            break;
                          case "prismatic":
                            Ae.multiply(
                              u.makeTranslation(a.x * t, a.y * t, a.z * t)
                            );
                            break;
                          default:
                            console.warn(
                              "THREE.ColladaLoader: Unknown joint type: " +
                                i.type
                            );
                        }
                      else
                        switch (o.type) {
                          case "matrix":
                            Ae.multiply(o.obj);
                            break;
                          case "translate":
                            Ae.multiply(
                              u.makeTranslation(o.obj.x, o.obj.y, o.obj.z)
                            );
                            break;
                          case "scale":
                            Ae.scale(o.obj);
                            break;
                          case "rotate":
                            Ae.multiply(u.makeRotationAxis(o.obj, o.angle));
                        }
                    }
                    o.matrix.copy(Ae),
                      o.matrix.decompose(o.position, o.quaternion, o.scale),
                      (l[e].position = t);
                  }
                } else
                  console.log("THREE.ColladaLoader: " + e + " does not exist.");
              },
            };
          })();
        const Qe = (function (e) {
          return He(s(n(e, "instance_visual_scene")[0].getAttribute("url")));
        })(n(Ve, "scene")[0]);
        return (
          (Qe.animations = Ye),
          "Z_UP" === qe.upAxis &&
            Qe.quaternion.setFromEuler(new r.Euler(-Math.PI / 2, 0, 0)),
          Qe.scale.multiplyScalar(qe.unit),
          {
            get animations() {
              return (
                console.warn(
                  "THREE.ColladaLoader: Please access animations over scene.animations now."
                ),
                Ye
              );
            },
            kinematics: Je,
            library: Ke,
            scene: Qe,
          }
        );
      }
    }
    class y extends r.Loader {
      constructor(e) {
        super(e);
      }
      load(e, t, n, i) {
        const o = this,
          a = "" === this.path ? r.LoaderUtils.extractUrlBase(e) : this.path,
          s = new r.FileLoader(this.manager);
        s.setPath(this.path),
          s.setRequestHeader(this.requestHeader),
          s.setWithCredentials(this.withCredentials),
          s.load(
            e,
            function (n) {
              try {
                t(o.parse(n, a));
              } catch (t) {
                i ? i(t) : console.error(t), o.manager.itemError(e);
              }
            },
            n,
            i
          );
      }
      setMaterialOptions(e) {
        return (this.materialOptions = e), this;
      }
      parse(e, t) {
        const n = e.split("\n");
        let r = {};
        const i = /\s+/,
          o = {};
        for (let e = 0; e < n.length; e++) {
          let t = n[e];
          if (((t = t.trim()), 0 === t.length || "#" === t.charAt(0))) continue;
          const a = t.indexOf(" ");
          let s = a >= 0 ? t.substring(0, a) : t;
          s = s.toLowerCase();
          let l = a >= 0 ? t.substring(a + 1) : "";
          if (((l = l.trim()), "newmtl" === s))
            (r = {
              name: l,
            }),
              (o[l] = r);
          else if ("ka" === s || "kd" === s || "ks" === s || "ke" === s) {
            const e = l.split(i, 3);
            r[s] = [parseFloat(e[0]), parseFloat(e[1]), parseFloat(e[2])];
          } else r[s] = l;
        }
        const a = new x(this.resourcePath || t, this.materialOptions);
        return (
          a.setCrossOrigin(this.crossOrigin),
          a.setManager(this.manager),
          a.setMaterials(o),
          a
        );
      }
    }
    class x {
      constructor(e = "", t = {}) {
        (this.baseUrl = e),
          (this.options = t),
          (this.materialsInfo = {}),
          (this.materials = {}),
          (this.materialsArray = []),
          (this.nameLookup = {}),
          (this.crossOrigin = "anonymous"),
          (this.side =
            void 0 !== this.options.side ? this.options.side : r.FrontSide),
          (this.wrap =
            void 0 !== this.options.wrap
              ? this.options.wrap
              : r.RepeatWrapping);
      }
      setCrossOrigin(e) {
        return (this.crossOrigin = e), this;
      }
      setManager(e) {
        this.manager = e;
      }
      setMaterials(e) {
        (this.materialsInfo = this.convert(e)),
          (this.materials = {}),
          (this.materialsArray = []),
          (this.nameLookup = {});
      }
      convert(e) {
        if (!this.options) return e;
        const t = {};
        for (const n in e) {
          const r = e[n],
            i = {};
          t[n] = i;
          for (const e in r) {
            let t = !0,
              n = r[e];
            const o = e.toLowerCase();
            switch (o) {
              case "kd":
              case "ka":
              case "ks":
                this.options &&
                  this.options.normalizeRGB &&
                  (n = [n[0] / 255, n[1] / 255, n[2] / 255]),
                  this.options &&
                    this.options.ignoreZeroRGBs &&
                    0 === n[0] &&
                    0 === n[1] &&
                    0 === n[2] &&
                    (t = !1);
            }
            t && (i[o] = n);
          }
        }
        return t;
      }
      preload() {
        for (const e in this.materialsInfo) this.create(e);
      }
      getIndex(e) {
        return this.nameLookup[e];
      }
      getAsArray() {
        let e = 0;
        for (const t in this.materialsInfo)
          (this.materialsArray[e] = this.create(t)),
            (this.nameLookup[t] = e),
            e++;
        return this.materialsArray;
      }
      create(e) {
        return (
          void 0 === this.materials[e] && this.createMaterial_(e),
          this.materials[e]
        );
      }
      createMaterial_(e) {
        const t = this,
          n = this.materialsInfo[e],
          i = {
            name: e,
            side: this.side,
          };

        function o(e, n) {
          if (i[e]) return;
          const r = t.getTextureParams(n, i),
            o = t.loadTexture(
              ((a = t.baseUrl),
              "string" != typeof (s = r.url) || "" === s
                ? ""
                : /^https?:\/\//i.test(s)
                ? s
                : a + s)
            );
          var a, s;
          o.repeat.copy(r.scale),
            o.offset.copy(r.offset),
            (o.wrapS = t.wrap),
            (o.wrapT = t.wrap),
            (i[e] = o);
        }
        for (const e in n) {
          const t = n[e];
          let a;
          if ("" !== t)
            switch (e.toLowerCase()) {
              case "kd":
                i.color = new r.Color().fromArray(t);
                break;
              case "ks":
                i.specular = new r.Color().fromArray(t);
                break;
              case "ke":
                i.emissive = new r.Color().fromArray(t);
                break;
              case "map_kd":
                o("map", t);
                break;
              case "map_ks":
                o("specularMap", t);
                break;
              case "map_ke":
                o("emissiveMap", t);
                break;
              case "norm":
                o("normalMap", t);
                break;
              case "map_bump":
              case "bump":
                o("bumpMap", t);
                break;
              case "map_d":
                o("alphaMap", t), (i.transparent = !0);
                break;
              case "ns":
                i.shininess = parseFloat(t);
                break;
              case "d":
                (a = parseFloat(t)),
                  a < 1 && ((i.opacity = a), (i.transparent = !0));
                break;
              case "tr":
                (a = parseFloat(t)),
                  this.options && this.options.invertTrProperty && (a = 1 - a),
                  a > 0 && ((i.opacity = 1 - a), (i.transparent = !0));
            }
        }
        return (
          (this.materials[e] = new r.MeshPhongMaterial(i)), this.materials[e]
        );
      }
      getTextureParams(e, t) {
        const n = {
            scale: new r.Vector2(1, 1),
            offset: new r.Vector2(0, 0),
          },
          i = e.split(/\s+/);
        let o;
        return (
          (o = i.indexOf("-bm")),
          o >= 0 && ((t.bumpScale = parseFloat(i[o + 1])), i.splice(o, 2)),
          (o = i.indexOf("-s")),
          o >= 0 &&
            (n.scale.set(parseFloat(i[o + 1]), parseFloat(i[o + 2])),
            i.splice(o, 4)),
          (o = i.indexOf("-o")),
          o >= 0 &&
            (n.offset.set(parseFloat(i[o + 1]), parseFloat(i[o + 2])),
            i.splice(o, 4)),
          (n.url = i.join(" ").trim()),
          n
        );
      }
      loadTexture(e, t, n, i, o) {
        const a =
          void 0 !== this.manager ? this.manager : r.DefaultLoadingManager;
        let s = a.getHandler(e);
        null === s && (s = new r.TextureLoader(a)),
          s.setCrossOrigin && s.setCrossOrigin(this.crossOrigin);
        const l = s.load(e, n, i, o);
        return void 0 !== t && (l.mapping = t), l;
      }
    }
    class b extends r.Loader {
      constructor(e) {
        super(e),
          (this.dracoLoader = null),
          (this.ktx2Loader = null),
          (this.meshoptDecoder = null),
          (this.pluginCallbacks = []),
          this.register(function (e) {
            return new T(e);
          }),
          this.register(function (e) {
            return new L(e);
          }),
          this.register(function (e) {
            return new R(e);
          }),
          this.register(function (e) {
            return new E(e);
          }),
          this.register(function (e) {
            return new A(e);
          }),
          this.register(function (e) {
            return new C(e);
          }),
          this.register(function (e) {
            return new P(e);
          }),
          this.register(function (e) {
            return new M(e);
          }),
          this.register(function (e) {
            return new I(e);
          });
      }
      load(e, t, n, i) {
        const o = this;
        let a;
        (a =
          "" !== this.resourcePath
            ? this.resourcePath
            : "" !== this.path
            ? this.path
            : r.LoaderUtils.extractUrlBase(e)),
          this.manager.itemStart(e);
        const s = function (t) {
            i ? i(t) : console.error(t),
              o.manager.itemError(e),
              o.manager.itemEnd(e);
          },
          l = new r.FileLoader(this.manager);
        l.setPath(this.path),
          l.setResponseType("arraybuffer"),
          l.setRequestHeader(this.requestHeader),
          l.setWithCredentials(this.withCredentials),
          l.load(
            e,
            function (n) {
              try {
                o.parse(
                  n,
                  a,
                  function (n) {
                    t(n), o.manager.itemEnd(e);
                  },
                  s
                );
              } catch (e) {
                s(e);
              }
            },
            n,
            s
          );
      }
      setDRACOLoader(e) {
        return (this.dracoLoader = e), this;
      }
      setDDSLoader() {
        throw new Error(
          'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
        );
      }
      setKTX2Loader(e) {
        return (this.ktx2Loader = e), this;
      }
      setMeshoptDecoder(e) {
        return (this.meshoptDecoder = e), this;
      }
      register(e) {
        return (
          -1 === this.pluginCallbacks.indexOf(e) &&
            this.pluginCallbacks.push(e),
          this
        );
      }
      unregister(e) {
        return (
          -1 !== this.pluginCallbacks.indexOf(e) &&
            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
          this
        );
      }
      parse(e, t, n, i) {
        let o;
        const a = {},
          s = {};
        if ("string" == typeof e) o = e;
        else {
          if (r.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === k) {
            try {
              a[_.KHR_BINARY_GLTF] = new B(e);
            } catch (e) {
              return void (i && i(e));
            }
            o = a[_.KHR_BINARY_GLTF].content;
          } else o = r.LoaderUtils.decodeText(new Uint8Array(e));
        }
        const l = JSON.parse(o);
        if (void 0 === l.asset || l.asset.version[0] < 2)
          return void (
            i &&
            i(
              new Error(
                "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
              )
            )
          );
        const c = new me(l, {
          path: t || this.resourcePath || "",
          crossOrigin: this.crossOrigin,
          requestHeader: this.requestHeader,
          manager: this.manager,
          ktx2Loader: this.ktx2Loader,
          meshoptDecoder: this.meshoptDecoder,
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let e = 0; e < this.pluginCallbacks.length; e++) {
          const t = this.pluginCallbacks[e](c);
          (s[t.name] = t), (a[t.name] = !0);
        }
        if (l.extensionsUsed)
          for (let e = 0; e < l.extensionsUsed.length; ++e) {
            const t = l.extensionsUsed[e],
              n = l.extensionsRequired || [];
            switch (t) {
              case _.KHR_MATERIALS_UNLIT:
                a[t] = new S();
                break;
              case _.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                a[t] = new z();
                break;
              case _.KHR_DRACO_MESH_COMPRESSION:
                a[t] = new F(l, this.dracoLoader);
                break;
              case _.KHR_TEXTURE_TRANSFORM:
                a[t] = new N();
                break;
              case _.KHR_MESH_QUANTIZATION:
                a[t] = new H();
                break;
              default:
                n.indexOf(t) >= 0 &&
                  void 0 === s[t] &&
                  console.warn(
                    'THREE.GLTFLoader: Unknown extension "' + t + '".'
                  );
            }
          }
        c.setExtensions(a), c.setPlugins(s), c.parse(n, i);
      }
    }

    function w() {
      let e = {};
      return {
        get: function (t) {
          return e[t];
        },
        add: function (t, n) {
          e[t] = n;
        },
        remove: function (t) {
          delete e[t];
        },
        removeAll: function () {
          e = {};
        },
      };
    }
    const _ = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
      KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
      KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
      KHR_MATERIALS_IOR: "KHR_materials_ior",
      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
        "KHR_materials_pbrSpecularGlossiness",
      KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
      KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
      KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
      KHR_MATERIALS_VOLUME: "KHR_materials_volume",
      KHR_TEXTURE_BASISU: "KHR_texture_basisu",
      KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
      KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
      EXT_TEXTURE_WEBP: "EXT_texture_webp",
      EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    };
    class M {
      constructor(e) {
        (this.parser = e),
          (this.name = _.KHR_LIGHTS_PUNCTUAL),
          (this.cache = {
            refs: {},
            uses: {},
          });
      }
      _markDefs() {
        const e = this.parser,
          t = this.parser.json.nodes || [];
        for (let n = 0, r = t.length; n < r; n++) {
          const r = t[n];
          r.extensions &&
            r.extensions[this.name] &&
            void 0 !== r.extensions[this.name].light &&
            e._addNodeRef(this.cache, r.extensions[this.name].light);
        }
      }
      _loadLight(e) {
        const t = this.parser,
          n = "light:" + e;
        let i = t.cache.get(n);
        if (i) return i;
        const o = t.json,
          a = (((o.extensions && o.extensions[this.name]) || {}).lights || [])[
            e
          ];
        let s;
        const l = new r.Color(16777215);
        void 0 !== a.color && l.fromArray(a.color);
        const c = void 0 !== a.range ? a.range : 0;
        switch (a.type) {
          case "directional":
            (s = new r.DirectionalLight(l)),
              s.target.position.set(0, 0, -1),
              s.add(s.target);
            break;
          case "point":
            (s = new r.PointLight(l)), (s.distance = c);
            break;
          case "spot":
            (s = new r.SpotLight(l)),
              (s.distance = c),
              (a.spot = a.spot || {}),
              (a.spot.innerConeAngle =
                void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0),
              (a.spot.outerConeAngle =
                void 0 !== a.spot.outerConeAngle
                  ? a.spot.outerConeAngle
                  : Math.PI / 4),
              (s.angle = a.spot.outerConeAngle),
              (s.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle),
              s.target.position.set(0, 0, -1),
              s.add(s.target);
            break;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unexpected light type: " + a.type
            );
        }
        return (
          s.position.set(0, 0, 0),
          (s.decay = 2),
          void 0 !== a.intensity && (s.intensity = a.intensity),
          (s.name = t.createUniqueName(a.name || "light_" + e)),
          (i = Promise.resolve(s)),
          t.cache.add(n, i),
          i
        );
      }
      createNodeAttachment(e) {
        const t = this,
          n = this.parser,
          r = n.json.nodes[e],
          i = ((r.extensions && r.extensions[this.name]) || {}).light;
        return void 0 === i
          ? null
          : this._loadLight(i).then(function (e) {
              return n._getNodeRef(t.cache, i, e);
            });
      }
    }
    class S {
      constructor() {
        this.name = _.KHR_MATERIALS_UNLIT;
      }
      getMaterialType() {
        return r.MeshBasicMaterial;
      }
      extendParams(e, t, n) {
        const i = [];
        (e.color = new r.Color(1, 1, 1)), (e.opacity = 1);
        const o = t.pbrMetallicRoughness;
        if (o) {
          if (Array.isArray(o.baseColorFactor)) {
            const t = o.baseColorFactor;
            e.color.fromArray(t), (e.opacity = t[3]);
          }
          void 0 !== o.baseColorTexture &&
            i.push(n.assignTexture(e, "map", o.baseColorTexture));
        }
        return Promise.all(i);
      }
    }
    class T {
      constructor(e) {
        (this.parser = e), (this.name = _.KHR_MATERIALS_CLEARCOAT);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name]
          ? r.MeshPhysicalMaterial
          : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const o = [],
          a = i.extensions[this.name];
        if (
          (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor),
          void 0 !== a.clearcoatTexture &&
            o.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
          void 0 !== a.clearcoatRoughnessFactor &&
            (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
          void 0 !== a.clearcoatRoughnessTexture &&
            o.push(
              n.assignTexture(
                t,
                "clearcoatRoughnessMap",
                a.clearcoatRoughnessTexture
              )
            ),
          void 0 !== a.clearcoatNormalTexture &&
            (o.push(
              n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)
            ),
            void 0 !== a.clearcoatNormalTexture.scale))
        ) {
          const e = a.clearcoatNormalTexture.scale;
          t.clearcoatNormalScale = new r.Vector2(e, -e);
        }
        return Promise.all(o);
      }
    }
    class E {
      constructor(e) {
        (this.parser = e), (this.name = _.KHR_MATERIALS_TRANSMISSION);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name]
          ? r.MeshPhysicalMaterial
          : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          r = n.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        const i = [],
          o = r.extensions[this.name];
        return (
          void 0 !== o.transmissionFactor &&
            (t.transmission = o.transmissionFactor),
          void 0 !== o.transmissionTexture &&
            i.push(
              n.assignTexture(t, "transmissionMap", o.transmissionTexture)
            ),
          Promise.all(i)
        );
      }
    }
    class A {
      constructor(e) {
        (this.parser = e), (this.name = _.KHR_MATERIALS_VOLUME);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name]
          ? r.MeshPhysicalMaterial
          : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const o = [],
          a = i.extensions[this.name];
        (t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0),
          void 0 !== a.thicknessTexture &&
            o.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
          (t.attenuationDistance = a.attenuationDistance || 0);
        const s = a.attenuationColor || [1, 1, 1];
        return (
          (t.attenuationTint = new r.Color(s[0], s[1], s[2])), Promise.all(o)
        );
      }
    }
    class C {
      constructor(e) {
        (this.parser = e), (this.name = _.KHR_MATERIALS_IOR);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name]
          ? r.MeshPhysicalMaterial
          : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const r = n.extensions[this.name];
        return (t.ior = void 0 !== r.ior ? r.ior : 1.5), Promise.resolve();
      }
    }
    class P {
      constructor(e) {
        (this.parser = e), (this.name = _.KHR_MATERIALS_SPECULAR);
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name]
          ? r.MeshPhysicalMaterial
          : null;
      }
      extendMaterialParams(e, t) {
        const n = this.parser,
          i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const o = [],
          a = i.extensions[this.name];
        (t.specularIntensity =
          void 0 !== a.specularFactor ? a.specularFactor : 1),
          void 0 !== a.specularTexture &&
            o.push(
              n.assignTexture(t, "specularIntensityMap", a.specularTexture)
            );
        const s = a.specularColorFactor || [1, 1, 1];
        return (
          (t.specularTint = new r.Color(s[0], s[1], s[2])),
          void 0 !== a.specularColorTexture &&
            o.push(
              n
                .assignTexture(t, "specularTintMap", a.specularColorTexture)
                .then(function (e) {
                  e.encoding = r.sRGBEncoding;
                })
            ),
          Promise.all(o)
        );
      }
    }
    class L {
      constructor(e) {
        (this.parser = e), (this.name = _.KHR_TEXTURE_BASISU);
      }
      loadTexture(e) {
        const t = this.parser,
          n = t.json,
          r = n.textures[e];
        if (!r.extensions || !r.extensions[this.name]) return null;
        const i = r.extensions[this.name],
          o = n.images[i.source],
          a = t.options.ktx2Loader;
        if (!a) {
          if (
            n.extensionsRequired &&
            n.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
            );
          return null;
        }
        return t.loadTextureImage(e, o, a);
      }
    }
    class R {
      constructor(e) {
        (this.parser = e),
          (this.name = _.EXT_TEXTURE_WEBP),
          (this.isSupported = null);
      }
      loadTexture(e) {
        const t = this.name,
          n = this.parser,
          r = n.json,
          i = r.textures[e];
        if (!i.extensions || !i.extensions[t]) return null;
        const o = i.extensions[t],
          a = r.images[o.source];
        let s = n.textureLoader;
        if (a.uri) {
          const e = n.options.manager.getHandler(a.uri);
          null !== e && (s = e);
        }
        return this.detectSupport().then(function (i) {
          if (i) return n.loadTextureImage(e, a, s);
          if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
            throw new Error(
              "THREE.GLTFLoader: WebP required by asset but unsupported."
            );
          return n.loadTexture(e);
        });
      }
      detectSupport() {
        return (
          this.isSupported ||
            (this.isSupported = new Promise(function (e) {
              const t = new Image();
              (t.src =
                "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                (t.onload = t.onerror =
                  function () {
                    e(1 === t.height);
                  });
            })),
          this.isSupported
        );
      }
    }
    class I {
      constructor(e) {
        (this.name = _.EXT_MESHOPT_COMPRESSION), (this.parser = e);
      }
      loadBufferView(e) {
        const t = this.parser.json,
          n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
          const e = n.extensions[this.name],
            r = this.parser.getDependency("buffer", e.buffer),
            i = this.parser.options.meshoptDecoder;
          if (!i || !i.supported) {
            if (
              t.extensionsRequired &&
              t.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
              );
            return null;
          }
          return Promise.all([r, i.ready]).then(function (t) {
            const n = e.byteOffset || 0,
              r = e.byteLength || 0,
              o = e.count,
              a = e.byteStride,
              s = new ArrayBuffer(o * a),
              l = new Uint8Array(t[0], n, r);
            return (
              i.decodeGltfBuffer(new Uint8Array(s), o, a, l, e.mode, e.filter),
              s
            );
          });
        }
        return null;
      }
    }
    const k = "glTF",
      D = 1313821514,
      O = 5130562;
    class B {
      constructor(e) {
        (this.name = _.KHR_BINARY_GLTF),
          (this.content = null),
          (this.body = null);
        const t = new DataView(e, 0, 12);
        if (
          ((this.header = {
            magic: r.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0),
          }),
          this.header.magic !== k)
        )
          throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
          throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n = this.header.length - 12,
          i = new DataView(e, 12);
        let o = 0;
        for (; o < n; ) {
          const t = i.getUint32(o, !0);
          o += 4;
          const n = i.getUint32(o, !0);
          if (((o += 4), n === D)) {
            const n = new Uint8Array(e, 12 + o, t);
            this.content = r.LoaderUtils.decodeText(n);
          } else if (n === O) {
            const n = 12 + o;
            this.body = e.slice(n, n + t);
          }
          o += t;
        }
        if (null === this.content)
          throw new Error("THREE.GLTFLoader: JSON content not found.");
      }
    }
    class F {
      constructor(e, t) {
        if (!t)
          throw new Error(
            "THREE.GLTFLoader: No DRACOLoader instance provided."
          );
        (this.name = _.KHR_DRACO_MESH_COMPRESSION),
          (this.json = e),
          (this.dracoLoader = t),
          this.dracoLoader.preload();
      }
      decodePrimitive(e, t) {
        const n = this.json,
          r = this.dracoLoader,
          i = e.extensions[this.name].bufferView,
          o = e.extensions[this.name].attributes,
          a = {},
          s = {},
          l = {};
        for (const e in o) {
          const t = ne[e] || e.toLowerCase();
          a[t] = o[e];
        }
        for (const t in e.attributes) {
          const r = ne[t] || t.toLowerCase();
          if (void 0 !== o[t]) {
            const i = n.accessors[e.attributes[t]],
              o = K[i.componentType];
            (l[r] = o), (s[r] = !0 === i.normalized);
          }
        }
        return t.getDependency("bufferView", i).then(function (e) {
          return new Promise(function (t) {
            r.decodeDracoFile(
              e,
              function (e) {
                for (const t in e.attributes) {
                  const n = e.attributes[t],
                    r = s[t];
                  void 0 !== r && (n.normalized = r);
                }
                t(e);
              },
              a,
              l
            );
          });
        });
      }
    }
    class N {
      constructor() {
        this.name = _.KHR_TEXTURE_TRANSFORM;
      }
      extendTexture(e, t) {
        return (
          void 0 !== t.texCoord &&
            console.warn(
              'THREE.GLTFLoader: Custom UV sets in "' +
                this.name +
                '" extension not yet supported.'
            ),
          (void 0 === t.offset &&
            void 0 === t.rotation &&
            void 0 === t.scale) ||
            ((e = e.clone()),
            void 0 !== t.offset && e.offset.fromArray(t.offset),
            void 0 !== t.rotation && (e.rotation = t.rotation),
            void 0 !== t.scale && e.repeat.fromArray(t.scale),
            (e.needsUpdate = !0)),
          e
        );
      }
    }
    class U extends r.MeshStandardMaterial {
      constructor(e) {
        super(), (this.isGLTFSpecularGlossinessMaterial = !0);
        const t = [
            "#ifdef USE_SPECULARMAP",
            "\tuniform sampler2D specularMap;",
            "#endif",
          ].join("\n"),
          n = [
            "#ifdef USE_GLOSSINESSMAP",
            "\tuniform sampler2D glossinessMap;",
            "#endif",
          ].join("\n"),
          i = [
            "vec3 specularFactor = specular;",
            "#ifdef USE_SPECULARMAP",
            "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
            "\ttexelSpecular = sRGBToLinear( texelSpecular );",
            "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "\tspecularFactor *= texelSpecular.rgb;",
            "#endif",
          ].join("\n"),
          o = [
            "float glossinessFactor = glossiness;",
            "#ifdef USE_GLOSSINESSMAP",
            "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
            "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "\tglossinessFactor *= texelGlossiness.a;",
            "#endif",
          ].join("\n"),
          a = [
            "PhysicalMaterial material;",
            "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
            "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
            "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
            "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
            "material.roughness += geometryRoughness;",
            "material.roughness = min( material.roughness, 1.0 );",
            "material.specularColor = specularFactor;",
          ].join("\n"),
          s = {
            specular: {
              value: new r.Color().setHex(16777215),
            },
            glossiness: {
              value: 1,
            },
            specularMap: {
              value: null,
            },
            glossinessMap: {
              value: null,
            },
          };
        (this._extraUniforms = s),
          (this.onBeforeCompile = function (e) {
            for (const t in s) e.uniforms[t] = s[t];
            e.fragmentShader = e.fragmentShader
              .replace("uniform float roughness;", "uniform vec3 specular;")
              .replace("uniform float metalness;", "uniform float glossiness;")
              .replace("#include <roughnessmap_pars_fragment>", t)
              .replace("#include <metalnessmap_pars_fragment>", n)
              .replace("#include <roughnessmap_fragment>", i)
              .replace("#include <metalnessmap_fragment>", o)
              .replace("#include <lights_physical_fragment>", a);
          }),
          Object.defineProperties(this, {
            specular: {
              get: function () {
                return s.specular.value;
              },
              set: function (e) {
                s.specular.value = e;
              },
            },
            specularMap: {
              get: function () {
                return s.specularMap.value;
              },
              set: function (e) {
                (s.specularMap.value = e),
                  e
                    ? (this.defines.USE_SPECULARMAP = "")
                    : delete this.defines.USE_SPECULARMAP;
              },
            },
            glossiness: {
              get: function () {
                return s.glossiness.value;
              },
              set: function (e) {
                s.glossiness.value = e;
              },
            },
            glossinessMap: {
              get: function () {
                return s.glossinessMap.value;
              },
              set: function (e) {
                (s.glossinessMap.value = e),
                  e
                    ? ((this.defines.USE_GLOSSINESSMAP = ""),
                      (this.defines.USE_UV = ""))
                    : (delete this.defines.USE_GLOSSINESSMAP,
                      delete this.defines.USE_UV);
              },
            },
          }),
          delete this.metalness,
          delete this.roughness,
          delete this.metalnessMap,
          delete this.roughnessMap,
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          (this.specularMap = e.specularMap),
          this.specular.copy(e.specular),
          (this.glossinessMap = e.glossinessMap),
          (this.glossiness = e.glossiness),
          delete this.metalness,
          delete this.roughness,
          delete this.metalnessMap,
          delete this.roughnessMap,
          this
        );
      }
    }
    class z {
      constructor() {
        (this.name = _.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
          (this.specularGlossinessParams = [
            "color",
            "map",
            "lightMap",
            "lightMapIntensity",
            "aoMap",
            "aoMapIntensity",
            "emissive",
            "emissiveIntensity",
            "emissiveMap",
            "bumpMap",
            "bumpScale",
            "normalMap",
            "normalMapType",
            "displacementMap",
            "displacementScale",
            "displacementBias",
            "specularMap",
            "specular",
            "glossinessMap",
            "glossiness",
            "alphaMap",
            "envMap",
            "envMapIntensity",
            "refractionRatio",
          ]);
      }
      getMaterialType() {
        return U;
      }
      extendParams(e, t, n) {
        const i = t.extensions[this.name];
        (e.color = new r.Color(1, 1, 1)), (e.opacity = 1);
        const o = [];
        if (Array.isArray(i.diffuseFactor)) {
          const t = i.diffuseFactor;
          e.color.fromArray(t), (e.opacity = t[3]);
        }
        if (
          (void 0 !== i.diffuseTexture &&
            o.push(n.assignTexture(e, "map", i.diffuseTexture)),
          (e.emissive = new r.Color(0, 0, 0)),
          (e.glossiness =
            void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
          (e.specular = new r.Color(1, 1, 1)),
          Array.isArray(i.specularFactor) &&
            e.specular.fromArray(i.specularFactor),
          void 0 !== i.specularGlossinessTexture)
        ) {
          const t = i.specularGlossinessTexture;
          o.push(n.assignTexture(e, "glossinessMap", t)),
            o.push(n.assignTexture(e, "specularMap", t));
        }
        return Promise.all(o);
      }
      createMaterial(e) {
        const t = new U(e);
        return (
          (t.fog = !0),
          (t.color = e.color),
          (t.map = void 0 === e.map ? null : e.map),
          (t.lightMap = null),
          (t.lightMapIntensity = 1),
          (t.aoMap = void 0 === e.aoMap ? null : e.aoMap),
          (t.aoMapIntensity = 1),
          (t.emissive = e.emissive),
          (t.emissiveIntensity = 1),
          (t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap),
          (t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
          (t.bumpScale = 1),
          (t.normalMap = void 0 === e.normalMap ? null : e.normalMap),
          (t.normalMapType = r.TangentSpaceNormalMap),
          e.normalScale && (t.normalScale = e.normalScale),
          (t.displacementMap = null),
          (t.displacementScale = 1),
          (t.displacementBias = 0),
          (t.specularMap = void 0 === e.specularMap ? null : e.specularMap),
          (t.specular = e.specular),
          (t.glossinessMap =
            void 0 === e.glossinessMap ? null : e.glossinessMap),
          (t.glossiness = e.glossiness),
          (t.alphaMap = null),
          (t.envMap = void 0 === e.envMap ? null : e.envMap),
          (t.envMapIntensity = 1),
          (t.refractionRatio = 0.98),
          t
        );
      }
    }
    class H {
      constructor() {
        this.name = _.KHR_MESH_QUANTIZATION;
      }
    }
    class G extends r.Interpolant {
      constructor(e, t, n, r) {
        super(e, t, n, r);
      }
      copySampleValue_(e) {
        const t = this.resultBuffer,
          n = this.sampleValues,
          r = this.valueSize,
          i = e * r * 3 + r;
        for (let e = 0; e !== r; e++) t[e] = n[i + e];
        return t;
      }
    }
    (G.prototype.beforeStart_ = G.prototype.copySampleValue_),
      (G.prototype.afterEnd_ = G.prototype.copySampleValue_),
      (G.prototype.interpolate_ = function (e, t, n, r) {
        const i = this.resultBuffer,
          o = this.sampleValues,
          a = this.valueSize,
          s = 2 * a,
          l = 3 * a,
          c = r - t,
          u = (n - t) / c,
          h = u * u,
          d = h * u,
          p = e * l,
          f = p - l,
          m = -2 * d + 3 * h,
          g = d - h,
          v = 1 - m,
          y = g - h + u;
        for (let e = 0; e !== a; e++) {
          const t = o[f + e + a],
            n = o[f + e + s] * c,
            r = o[p + e + a],
            l = o[p + e] * c;
          i[e] = v * t + y * n + m * r + g * l;
        }
        return i;
      });
    const V = new r.Quaternion();
    class j extends G {
      interpolate_(e, t, n, r) {
        const i = super.interpolate_(e, t, n, r);
        return V.fromArray(i).normalize().toArray(i), i;
      }
    }
    const W = 0,
      q = 1,
      $ = 2,
      X = 3,
      Y = 4,
      J = 5,
      Z = 6,
      K = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array,
      },
      Q = {
        9728: r.NearestFilter,
        9729: r.LinearFilter,
        9984: r.NearestMipmapNearestFilter,
        9985: r.LinearMipmapNearestFilter,
        9986: r.NearestMipmapLinearFilter,
        9987: r.LinearMipmapLinearFilter,
      },
      ee = {
        33071: r.ClampToEdgeWrapping,
        33648: r.MirroredRepeatWrapping,
        10497: r.RepeatWrapping,
      },
      te = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16,
      },
      ne = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex",
      },
      re = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences",
      },
      ie = {
        CUBICSPLINE: void 0,
        LINEAR: r.InterpolateLinear,
        STEP: r.InterpolateDiscrete,
      },
      oe = "OPAQUE",
      ae = "MASK",
      se = "BLEND";

    function le(e, t) {
      return "string" != typeof e || "" === e
        ? ""
        : (/^https?:\/\//i.test(t) &&
            /^\//.test(e) &&
            (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(e) ||
          /^data:.*,.*$/i.test(e) ||
          /^blob:.*$/i.test(e)
            ? e
            : t + e);
    }

    function ce(e, t, n) {
      for (const r in n.extensions)
        void 0 === e[r] &&
          ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
          (t.userData.gltfExtensions[r] = n.extensions[r]));
    }

    function ue(e, t) {
      void 0 !== t.extras &&
        ("object" == typeof t.extras
          ? Object.assign(e.userData, t.extras)
          : console.warn(
              "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
            ));
    }

    function he(e, t) {
      if ((e.updateMorphTargets(), void 0 !== t.weights))
        for (let n = 0, r = t.weights.length; n < r; n++)
          e.morphTargetInfluences[n] = t.weights[n];
      if (t.extras && Array.isArray(t.extras.targetNames)) {
        const n = t.extras.targetNames;
        if (e.morphTargetInfluences.length === n.length) {
          e.morphTargetDictionary = {};
          for (let t = 0, r = n.length; t < r; t++)
            e.morphTargetDictionary[n[t]] = t;
        } else
          console.warn(
            "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
          );
      }
    }

    function de(e) {
      const t = e.extensions && e.extensions[_.KHR_DRACO_MESH_COMPRESSION];
      let n;
      return (
        (n = t
          ? "draco:" + t.bufferView + ":" + t.indices + ":" + pe(t.attributes)
          : e.indices + ":" + pe(e.attributes) + ":" + e.mode),
        n
      );
    }

    function pe(e) {
      let t = "";
      const n = Object.keys(e).sort();
      for (let r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";
      return t;
    }

    function fe(e) {
      switch (e) {
        case Int8Array:
          return 1 / 127;
        case Uint8Array:
          return 1 / 255;
        case Int16Array:
          return 1 / 32767;
        case Uint16Array:
          return 1 / 65535;
        default:
          throw new Error(
            "THREE.GLTFLoader: Unsupported normalized accessor component type."
          );
      }
    }
    class me {
      constructor(e = {}, t = {}) {
        (this.json = e),
          (this.extensions = {}),
          (this.plugins = {}),
          (this.options = t),
          (this.cache = new w()),
          (this.associations = new Map()),
          (this.primitiveCache = {}),
          (this.meshCache = {
            refs: {},
            uses: {},
          }),
          (this.cameraCache = {
            refs: {},
            uses: {},
          }),
          (this.lightCache = {
            refs: {},
            uses: {},
          }),
          (this.textureCache = {}),
          (this.nodeNamesUsed = {}),
          "undefined" != typeof createImageBitmap &&
          !1 === /Firefox/.test(navigator.userAgent)
            ? (this.textureLoader = new r.ImageBitmapLoader(
                this.options.manager
              ))
            : (this.textureLoader = new r.TextureLoader(this.options.manager)),
          this.textureLoader.setCrossOrigin(this.options.crossOrigin),
          this.textureLoader.setRequestHeader(this.options.requestHeader),
          (this.fileLoader = new r.FileLoader(this.options.manager)),
          this.fileLoader.setResponseType("arraybuffer"),
          "use-credentials" === this.options.crossOrigin &&
            this.fileLoader.setWithCredentials(!0);
      }
      setExtensions(e) {
        this.extensions = e;
      }
      setPlugins(e) {
        this.plugins = e;
      }
      parse(e, t) {
        const n = this,
          r = this.json,
          i = this.extensions;
        this.cache.removeAll(),
          this._invokeAll(function (e) {
            return e._markDefs && e._markDefs();
          }),
          Promise.all(
            this._invokeAll(function (e) {
              return e.beforeRoot && e.beforeRoot();
            })
          )
            .then(function () {
              return Promise.all([
                n.getDependencies("scene"),
                n.getDependencies("animation"),
                n.getDependencies("camera"),
              ]);
            })
            .then(function (t) {
              const o = {
                scene: t[0][r.scene || 0],
                scenes: t[0],
                animations: t[1],
                cameras: t[2],
                asset: r.asset,
                parser: n,
                userData: {},
              };
              ce(i, o, r),
                ue(o, r),
                Promise.all(
                  n._invokeAll(function (e) {
                    return e.afterRoot && e.afterRoot(o);
                  })
                ).then(function () {
                  e(o);
                });
            })
            .catch(t);
      }
      _markDefs() {
        const e = this.json.nodes || [],
          t = this.json.skins || [],
          n = this.json.meshes || [];
        for (let n = 0, r = t.length; n < r; n++) {
          const r = t[n].joints;
          for (let t = 0, n = r.length; t < n; t++) e[r[t]].isBone = !0;
        }
        for (let t = 0, r = e.length; t < r; t++) {
          const r = e[t];
          void 0 !== r.mesh &&
            (this._addNodeRef(this.meshCache, r.mesh),
            void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)),
            void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera);
        }
      }
      _addNodeRef(e, t) {
        void 0 !== t &&
          (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
      }
      _getNodeRef(e, t, n) {
        if (e.refs[t] <= 1) return n;
        const r = n.clone();
        return (r.name += "_instance_" + e.uses[t]++), r;
      }
      _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
          const r = e(t[n]);
          if (r) return r;
        }
        return null;
      }
      _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let r = 0; r < t.length; r++) {
          const i = e(t[r]);
          i && n.push(i);
        }
        return n;
      }
      getDependency(e, t) {
        const n = e + ":" + t;
        let r = this.cache.get(n);
        if (!r) {
          switch (e) {
            case "scene":
              r = this.loadScene(t);
              break;
            case "node":
              r = this.loadNode(t);
              break;
            case "mesh":
              r = this._invokeOne(function (e) {
                return e.loadMesh && e.loadMesh(t);
              });
              break;
            case "accessor":
              r = this.loadAccessor(t);
              break;
            case "bufferView":
              r = this._invokeOne(function (e) {
                return e.loadBufferView && e.loadBufferView(t);
              });
              break;
            case "buffer":
              r = this.loadBuffer(t);
              break;
            case "material":
              r = this._invokeOne(function (e) {
                return e.loadMaterial && e.loadMaterial(t);
              });
              break;
            case "texture":
              r = this._invokeOne(function (e) {
                return e.loadTexture && e.loadTexture(t);
              });
              break;
            case "skin":
              r = this.loadSkin(t);
              break;
            case "animation":
              r = this.loadAnimation(t);
              break;
            case "camera":
              r = this.loadCamera(t);
              break;
            default:
              throw new Error("Unknown type: " + e);
          }
          this.cache.add(n, r);
        }
        return r;
      }
      getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
          const n = this,
            r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
          (t = Promise.all(
            r.map(function (t, r) {
              return n.getDependency(e, r);
            })
          )),
            this.cache.add(e, t);
        }
        return t;
      }
      loadBuffer(e) {
        const t = this.json.buffers[e],
          n = this.fileLoader;
        if (t.type && "arraybuffer" !== t.type)
          throw new Error(
            "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
          );
        if (void 0 === t.uri && 0 === e)
          return Promise.resolve(this.extensions[_.KHR_BINARY_GLTF].body);
        const r = this.options;
        return new Promise(function (e, i) {
          n.load(le(t.uri, r.path), e, void 0, function () {
            i(
              new Error(
                'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
              )
            );
          });
        });
      }
      loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function (e) {
          const n = t.byteLength || 0,
            r = t.byteOffset || 0;
          return e.slice(r, r + n);
        });
      }
      loadAccessor(e) {
        const t = this,
          n = this.json,
          i = this.json.accessors[e];
        if (void 0 === i.bufferView && void 0 === i.sparse)
          return Promise.resolve(null);
        const o = [];
        return (
          void 0 !== i.bufferView
            ? o.push(this.getDependency("bufferView", i.bufferView))
            : o.push(null),
          void 0 !== i.sparse &&
            (o.push(
              this.getDependency("bufferView", i.sparse.indices.bufferView)
            ),
            o.push(
              this.getDependency("bufferView", i.sparse.values.bufferView)
            )),
          Promise.all(o).then(function (e) {
            const o = e[0],
              a = te[i.type],
              s = K[i.componentType],
              l = s.BYTES_PER_ELEMENT,
              c = l * a,
              u = i.byteOffset || 0,
              h =
                void 0 !== i.bufferView
                  ? n.bufferViews[i.bufferView].byteStride
                  : void 0,
              d = !0 === i.normalized;
            let p, f;
            if (h && h !== c) {
              const e = Math.floor(u / h),
                n =
                  "InterleavedBuffer:" +
                  i.bufferView +
                  ":" +
                  i.componentType +
                  ":" +
                  e +
                  ":" +
                  i.count;
              let c = t.cache.get(n);
              c ||
                ((p = new s(o, e * h, (i.count * h) / l)),
                (c = new r.InterleavedBuffer(p, h / l)),
                t.cache.add(n, c)),
                (f = new r.InterleavedBufferAttribute(c, a, (u % h) / l, d));
            } else (p = null === o ? new s(i.count * a) : new s(o, u, i.count * a)), (f = new r.BufferAttribute(p, a, d));
            if (void 0 !== i.sparse) {
              const t = te.SCALAR,
                n = K[i.sparse.indices.componentType],
                l = i.sparse.indices.byteOffset || 0,
                c = i.sparse.values.byteOffset || 0,
                u = new n(e[1], l, i.sparse.count * t),
                h = new s(e[2], c, i.sparse.count * a);
              null !== o &&
                (f = new r.BufferAttribute(
                  f.array.slice(),
                  f.itemSize,
                  f.normalized
                ));
              for (let e = 0, t = u.length; e < t; e++) {
                const t = u[e];
                if (
                  (f.setX(t, h[e * a]),
                  a >= 2 && f.setY(t, h[e * a + 1]),
                  a >= 3 && f.setZ(t, h[e * a + 2]),
                  a >= 4 && f.setW(t, h[e * a + 3]),
                  a >= 5)
                )
                  throw new Error(
                    "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                  );
              }
            }
            return f;
          })
        );
      }
      loadTexture(e) {
        const t = this.json,
          n = this.options,
          r = t.textures[e],
          i = t.images[r.source];
        let o = this.textureLoader;
        if (i.uri) {
          const e = n.manager.getHandler(i.uri);
          null !== e && (o = e);
        }
        return this.loadTextureImage(e, i, o);
      }
      loadTextureImage(e, t, n) {
        const i = this,
          o = this.json,
          a = this.options,
          s = o.textures[e],
          l = (t.uri || t.bufferView) + ":" + s.sampler;
        if (this.textureCache[l]) return this.textureCache[l];
        const c = self.URL || self.webkitURL;
        let u = t.uri || "",
          h = !1,
          d = !0;
        const p =
          u.search(/\.jpe?g($|\?)/i) > 0 ||
          0 === u.search(/^data\:image\/jpeg/);
        if (
          (("image/jpeg" === t.mimeType || p) && (d = !1),
          void 0 !== t.bufferView)
        )
          u = i.getDependency("bufferView", t.bufferView).then(function (e) {
            if ("image/png" === t.mimeType) {
              const t = new DataView(e, 25, 1).getUint8(0, !1);
              d = 6 === t || 4 === t || 3 === t;
            }
            h = !0;
            const n = new Blob([e], {
              type: t.mimeType,
            });
            return (u = c.createObjectURL(n)), u;
          });
        else if (void 0 === t.uri)
          throw new Error(
            "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
          );
        const f = Promise.resolve(u)
          .then(function (e) {
            return new Promise(function (t, i) {
              let o = t;
              !0 === n.isImageBitmapLoader &&
                (o = function (e) {
                  const n = new r.Texture(e);
                  (n.needsUpdate = !0), t(n);
                }),
                n.load(le(e, a.path), o, void 0, i);
            });
          })
          .then(function (t) {
            !0 === h && c.revokeObjectURL(u),
              (t.flipY = !1),
              s.name && (t.name = s.name),
              d || (t.format = r.RGBFormat);
            const n = (o.samplers || {})[s.sampler] || {};
            return (
              (t.magFilter = Q[n.magFilter] || r.LinearFilter),
              (t.minFilter = Q[n.minFilter] || r.LinearMipmapLinearFilter),
              (t.wrapS = ee[n.wrapS] || r.RepeatWrapping),
              (t.wrapT = ee[n.wrapT] || r.RepeatWrapping),
              i.associations.set(t, {
                type: "textures",
                index: e,
              }),
              t
            );
          })
          .catch(function () {
            return (
              console.error("THREE.GLTFLoader: Couldn't load texture", u), null
            );
          });
        return (this.textureCache[l] = f), f;
      }
      assignTexture(e, t, n) {
        const r = this;
        return this.getDependency("texture", n.index).then(function (i) {
          if (
            (void 0 === n.texCoord ||
              0 == n.texCoord ||
              ("aoMap" === t && 1 == n.texCoord) ||
              console.warn(
                "THREE.GLTFLoader: Custom UV set " +
                  n.texCoord +
                  " for texture " +
                  t +
                  " not yet supported."
              ),
            r.extensions[_.KHR_TEXTURE_TRANSFORM])
          ) {
            const e =
              void 0 !== n.extensions
                ? n.extensions[_.KHR_TEXTURE_TRANSFORM]
                : void 0;
            if (e) {
              const t = r.associations.get(i);
              (i = r.extensions[_.KHR_TEXTURE_TRANSFORM].extendTexture(i, e)),
                r.associations.set(i, t);
            }
          }
          return (e[t] = i), i;
        });
      }
      assignFinalMaterial(e) {
        const t = e.geometry;
        let n = e.material;
        const i = void 0 !== t.attributes.tangent,
          o = void 0 !== t.attributes.color,
          a = void 0 === t.attributes.normal;
        if (e.isPoints) {
          const e = "PointsMaterial:" + n.uuid;
          let t = this.cache.get(e);
          t ||
            ((t = new r.PointsMaterial()),
            r.Material.prototype.copy.call(t, n),
            t.color.copy(n.color),
            (t.map = n.map),
            (t.sizeAttenuation = !1),
            this.cache.add(e, t)),
            (n = t);
        } else if (e.isLine) {
          const e = "LineBasicMaterial:" + n.uuid;
          let t = this.cache.get(e);
          t ||
            ((t = new r.LineBasicMaterial()),
            r.Material.prototype.copy.call(t, n),
            t.color.copy(n.color),
            this.cache.add(e, t)),
            (n = t);
        }
        if (i || o || a) {
          let e = "ClonedMaterial:" + n.uuid + ":";
          n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"),
            i && (e += "vertex-tangents:"),
            o && (e += "vertex-colors:"),
            a && (e += "flat-shading:");
          let t = this.cache.get(e);
          t ||
            ((t = n.clone()),
            o && (t.vertexColors = !0),
            a && (t.flatShading = !0),
            i &&
              (t.normalScale && (t.normalScale.y *= -1),
              t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
            this.cache.add(e, t),
            this.associations.set(t, this.associations.get(n))),
            (n = t);
        }
        n.aoMap &&
          void 0 === t.attributes.uv2 &&
          void 0 !== t.attributes.uv &&
          t.setAttribute("uv2", t.attributes.uv),
          (e.material = n);
      }
      getMaterialType() {
        return r.MeshStandardMaterial;
      }
      loadMaterial(e) {
        const t = this,
          n = this.json,
          i = this.extensions,
          o = n.materials[e];
        let a;
        const s = {},
          l = o.extensions || {},
          c = [];
        if (l[_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
          const e = i[_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
          (a = e.getMaterialType()), c.push(e.extendParams(s, o, t));
        } else if (l[_.KHR_MATERIALS_UNLIT]) {
          const e = i[_.KHR_MATERIALS_UNLIT];
          (a = e.getMaterialType()), c.push(e.extendParams(s, o, t));
        } else {
          const n = o.pbrMetallicRoughness || {};
          if (
            ((s.color = new r.Color(1, 1, 1)),
            (s.opacity = 1),
            Array.isArray(n.baseColorFactor))
          ) {
            const e = n.baseColorFactor;
            s.color.fromArray(e), (s.opacity = e[3]);
          }
          void 0 !== n.baseColorTexture &&
            c.push(t.assignTexture(s, "map", n.baseColorTexture)),
            (s.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
            (s.roughness =
              void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
            void 0 !== n.metallicRoughnessTexture &&
              (c.push(
                t.assignTexture(s, "metalnessMap", n.metallicRoughnessTexture)
              ),
              c.push(
                t.assignTexture(s, "roughnessMap", n.metallicRoughnessTexture)
              )),
            (a = this._invokeOne(function (t) {
              return t.getMaterialType && t.getMaterialType(e);
            })),
            c.push(
              Promise.all(
                this._invokeAll(function (t) {
                  return t.extendMaterialParams && t.extendMaterialParams(e, s);
                })
              )
            );
        }
        !0 === o.doubleSided && (s.side = r.DoubleSide);
        const u = o.alphaMode || oe;
        return (
          u === se
            ? ((s.transparent = !0), (s.depthWrite = !1))
            : ((s.format = r.RGBFormat),
              (s.transparent = !1),
              u === ae &&
                (s.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : 0.5)),
          void 0 !== o.normalTexture &&
            a !== r.MeshBasicMaterial &&
            (c.push(t.assignTexture(s, "normalMap", o.normalTexture)),
            (s.normalScale = new r.Vector2(1, -1)),
            void 0 !== o.normalTexture.scale &&
              s.normalScale.set(o.normalTexture.scale, -o.normalTexture.scale)),
          void 0 !== o.occlusionTexture &&
            a !== r.MeshBasicMaterial &&
            (c.push(t.assignTexture(s, "aoMap", o.occlusionTexture)),
            void 0 !== o.occlusionTexture.strength &&
              (s.aoMapIntensity = o.occlusionTexture.strength)),
          void 0 !== o.emissiveFactor &&
            a !== r.MeshBasicMaterial &&
            (s.emissive = new r.Color().fromArray(o.emissiveFactor)),
          void 0 !== o.emissiveTexture &&
            a !== r.MeshBasicMaterial &&
            c.push(t.assignTexture(s, "emissiveMap", o.emissiveTexture)),
          Promise.all(c).then(function () {
            let n;
            return (
              (n =
                a === U
                  ? i[_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s)
                  : new a(s)),
              o.name && (n.name = o.name),
              n.map && (n.map.encoding = r.sRGBEncoding),
              n.emissiveMap && (n.emissiveMap.encoding = r.sRGBEncoding),
              ue(n, o),
              t.associations.set(n, {
                type: "materials",
                index: e,
              }),
              o.extensions && ce(i, n, o),
              n
            );
          })
        );
      }
      createUniqueName(e) {
        const t = r.PropertyBinding.sanitizeNodeName(e || "");
        let n = t;
        for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;
        return (this.nodeNamesUsed[n] = !0), n;
      }
      loadGeometries(e) {
        const t = this,
          n = this.extensions,
          i = this.primitiveCache;

        function o(e) {
          return n[_.KHR_DRACO_MESH_COMPRESSION]
            .decodePrimitive(e, t)
            .then(function (n) {
              return ve(n, e, t);
            });
        }
        const a = [];
        for (let n = 0, s = e.length; n < s; n++) {
          const s = e[n],
            l = de(s),
            c = i[l];
          if (c) a.push(c.promise);
          else {
            let e;
            (e =
              s.extensions && s.extensions[_.KHR_DRACO_MESH_COMPRESSION]
                ? o(s)
                : ve(new r.BufferGeometry(), s, t)),
              (i[l] = {
                primitive: s,
                promise: e,
              }),
              a.push(e);
          }
        }
        return Promise.all(a);
      }
      loadMesh(e) {
        const t = this,
          n = this.json,
          i = this.extensions,
          o = n.meshes[e],
          a = o.primitives,
          s = [];
        for (let e = 0, t = a.length; e < t; e++) {
          const t =
            void 0 === a[e].material
              ? (void 0 === (l = this.cache).DefaultMaterial &&
                  (l.DefaultMaterial = new r.MeshStandardMaterial({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: r.FrontSide,
                  })),
                l.DefaultMaterial)
              : this.getDependency("material", a[e].material);
          s.push(t);
        }
        var l;
        return (
          s.push(t.loadGeometries(a)),
          Promise.all(s).then(function (n) {
            const s = n.slice(0, n.length - 1),
              l = n[n.length - 1],
              c = [];
            for (let n = 0, u = l.length; n < u; n++) {
              const u = l[n],
                h = a[n];
              let d;
              const p = s[n];
              if (
                h.mode === Y ||
                h.mode === J ||
                h.mode === Z ||
                void 0 === h.mode
              )
                (d =
                  !0 === o.isSkinnedMesh
                    ? new r.SkinnedMesh(u, p)
                    : new r.Mesh(u, p)),
                  !0 !== d.isSkinnedMesh ||
                    d.geometry.attributes.skinWeight.normalized ||
                    d.normalizeSkinWeights(),
                  h.mode === J
                    ? (d.geometry = ye(d.geometry, r.TriangleStripDrawMode))
                    : h.mode === Z &&
                      (d.geometry = ye(d.geometry, r.TriangleFanDrawMode));
              else if (h.mode === q) d = new r.LineSegments(u, p);
              else if (h.mode === X) d = new r.Line(u, p);
              else if (h.mode === $) d = new r.LineLoop(u, p);
              else {
                if (h.mode !== W)
                  throw new Error(
                    "THREE.GLTFLoader: Primitive mode unsupported: " + h.mode
                  );
                d = new r.Points(u, p);
              }
              Object.keys(d.geometry.morphAttributes).length > 0 && he(d, o),
                (d.name = t.createUniqueName(o.name || "mesh_" + e)),
                ue(d, o),
                h.extensions && ce(i, d, h),
                t.assignFinalMaterial(d),
                c.push(d);
            }
            if (1 === c.length) return c[0];
            const u = new r.Group();
            for (let e = 0, t = c.length; e < t; e++) u.add(c[e]);
            return u;
          })
        );
      }
      loadCamera(e) {
        let t;
        const n = this.json.cameras[e],
          i = n[n.type];
        if (i)
          return (
            "perspective" === n.type
              ? (t = new r.PerspectiveCamera(
                  r.MathUtils.radToDeg(i.yfov),
                  i.aspectRatio || 1,
                  i.znear || 1,
                  i.zfar || 2e6
                ))
              : "orthographic" === n.type &&
                (t = new r.OrthographicCamera(
                  -i.xmag,
                  i.xmag,
                  i.ymag,
                  -i.ymag,
                  i.znear,
                  i.zfar
                )),
            n.name && (t.name = this.createUniqueName(n.name)),
            ue(t, n),
            Promise.resolve(t)
          );
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
      }
      loadSkin(e) {
        const t = this.json.skins[e],
          n = {
            joints: t.joints,
          };
        return void 0 === t.inverseBindMatrices
          ? Promise.resolve(n)
          : this.getDependency("accessor", t.inverseBindMatrices).then(
              function (e) {
                return (n.inverseBindMatrices = e), n;
              }
            );
      }
      loadAnimation(e) {
        const t = this.json.animations[e],
          n = [],
          i = [],
          o = [],
          a = [],
          s = [];
        for (let e = 0, r = t.channels.length; e < r; e++) {
          const r = t.channels[e],
            l = t.samplers[r.sampler],
            c = r.target,
            u = void 0 !== c.node ? c.node : c.id,
            h = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
            d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
          n.push(this.getDependency("node", u)),
            i.push(this.getDependency("accessor", h)),
            o.push(this.getDependency("accessor", d)),
            a.push(l),
            s.push(c);
        }
        return Promise.all([
          Promise.all(n),
          Promise.all(i),
          Promise.all(o),
          Promise.all(a),
          Promise.all(s),
        ]).then(function (n) {
          const i = n[0],
            o = n[1],
            a = n[2],
            s = n[3],
            l = n[4],
            c = [];
          for (let e = 0, t = i.length; e < t; e++) {
            const t = i[e],
              n = o[e],
              u = a[e],
              h = s[e],
              d = l[e];
            if (void 0 === t) continue;
            let p;
            switch ((t.updateMatrix(), (t.matrixAutoUpdate = !0), re[d.path])) {
              case re.weights:
                p = r.NumberKeyframeTrack;
                break;
              case re.rotation:
                p = r.QuaternionKeyframeTrack;
                break;
              case re.position:
              case re.scale:
              default:
                p = r.VectorKeyframeTrack;
            }
            const f = t.name ? t.name : t.uuid,
              m =
                void 0 !== h.interpolation
                  ? ie[h.interpolation]
                  : r.InterpolateLinear,
              g = [];
            re[d.path] === re.weights
              ? t.traverse(function (e) {
                  !0 === e.isMesh &&
                    e.morphTargetInfluences &&
                    g.push(e.name ? e.name : e.uuid);
                })
              : g.push(f);
            let v = u.array;
            if (u.normalized) {
              const e = fe(v.constructor),
                t = new Float32Array(v.length);
              for (let n = 0, r = v.length; n < r; n++) t[n] = v[n] * e;
              v = t;
            }
            for (let e = 0, t = g.length; e < t; e++) {
              const t = new p(g[e] + "." + re[d.path], n.array, v, m);
              "CUBICSPLINE" === h.interpolation &&
                ((t.createInterpolant = function (e) {
                  return new (
                    this instanceof r.QuaternionKeyframeTrack ? j : G
                  )(this.times, this.values, this.getValueSize() / 3, e);
                }),
                (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                  !0)),
                c.push(t);
            }
          }
          const u = t.name ? t.name : "animation_" + e;
          return new r.AnimationClip(u, void 0, c);
        });
      }
      createNodeMesh(e) {
        const t = this.json,
          n = this,
          r = t.nodes[e];
        return void 0 === r.mesh
          ? null
          : n.getDependency("mesh", r.mesh).then(function (e) {
              const t = n._getNodeRef(n.meshCache, r.mesh, e);
              return (
                void 0 !== r.weights &&
                  t.traverse(function (e) {
                    if (e.isMesh)
                      for (let t = 0, n = r.weights.length; t < n; t++)
                        e.morphTargetInfluences[t] = r.weights[t];
                  }),
                t
              );
            });
      }
      loadNode(e) {
        const t = this.json,
          n = this.extensions,
          i = this,
          o = t.nodes[e],
          a = o.name ? i.createUniqueName(o.name) : "";
        return (function () {
          const t = [],
            n = i._invokeOne(function (t) {
              return t.createNodeMesh && t.createNodeMesh(e);
            });
          return (
            n && t.push(n),
            void 0 !== o.camera &&
              t.push(
                i.getDependency("camera", o.camera).then(function (e) {
                  return i._getNodeRef(i.cameraCache, o.camera, e);
                })
              ),
            i
              ._invokeAll(function (t) {
                return t.createNodeAttachment && t.createNodeAttachment(e);
              })
              .forEach(function (e) {
                t.push(e);
              }),
            Promise.all(t)
          );
        })().then(function (t) {
          let s;
          if (
            ((s =
              !0 === o.isBone
                ? new r.Bone()
                : t.length > 1
                ? new r.Group()
                : 1 === t.length
                ? t[0]
                : new r.Object3D()),
            s !== t[0])
          )
            for (let e = 0, n = t.length; e < n; e++) s.add(t[e]);
          if (
            (o.name && ((s.userData.name = o.name), (s.name = a)),
            ue(s, o),
            o.extensions && ce(n, s, o),
            void 0 !== o.matrix)
          ) {
            const e = new r.Matrix4();
            e.fromArray(o.matrix), s.applyMatrix4(e);
          } else void 0 !== o.translation && s.position.fromArray(o.translation), void 0 !== o.rotation && s.quaternion.fromArray(o.rotation), void 0 !== o.scale && s.scale.fromArray(o.scale);
          return (
            i.associations.set(s, {
              type: "nodes",
              index: e,
            }),
            s
          );
        });
      }
      loadScene(e) {
        const t = this.json,
          n = this.extensions,
          i = this.json.scenes[e],
          o = this,
          a = new r.Group();
        i.name && (a.name = o.createUniqueName(i.name)),
          ue(a, i),
          i.extensions && ce(n, a, i);
        const s = i.nodes || [],
          l = [];
        for (let e = 0, n = s.length; e < n; e++) l.push(ge(s[e], a, t, o));
        return Promise.all(l).then(function () {
          return a;
        });
      }
    }

    function ge(e, t, n, i) {
      const o = n.nodes[e];
      return i
        .getDependency("node", e)
        .then(function (e) {
          if (void 0 === o.skin) return e;
          let t;
          return i
            .getDependency("skin", o.skin)
            .then(function (e) {
              t = e;
              const n = [];
              for (let e = 0, r = t.joints.length; e < r; e++)
                n.push(i.getDependency("node", t.joints[e]));
              return Promise.all(n);
            })
            .then(function (n) {
              return (
                e.traverse(function (e) {
                  if (!e.isMesh) return;
                  const i = [],
                    o = [];
                  for (let e = 0, a = n.length; e < a; e++) {
                    const a = n[e];
                    if (a) {
                      i.push(a);
                      const n = new r.Matrix4();
                      void 0 !== t.inverseBindMatrices &&
                        n.fromArray(t.inverseBindMatrices.array, 16 * e),
                        o.push(n);
                    } else
                      console.warn(
                        'THREE.GLTFLoader: Joint "%s" could not be found.',
                        t.joints[e]
                      );
                  }
                  e.bind(new r.Skeleton(i, o), e.matrixWorld);
                }),
                e
              );
            });
        })
        .then(function (e) {
          t.add(e);
          const r = [];
          if (o.children) {
            const t = o.children;
            for (let o = 0, a = t.length; o < a; o++) {
              const a = t[o];
              r.push(ge(a, e, n, i));
            }
          }
          return Promise.all(r);
        });
    }

    function ve(e, t, n) {
      const i = t.attributes,
        o = [];

      function a(t, r) {
        return n.getDependency("accessor", t).then(function (t) {
          e.setAttribute(r, t);
        });
      }
      for (const t in i) {
        const n = ne[t] || t.toLowerCase();
        n in e.attributes || o.push(a(i[t], n));
      }
      if (void 0 !== t.indices && !e.index) {
        const r = n.getDependency("accessor", t.indices).then(function (t) {
          e.setIndex(t);
        });
        o.push(r);
      }
      return (
        ue(e, t),
        (function (e, t, n) {
          const i = t.attributes,
            o = new r.Box3();
          if (void 0 === i.POSITION) return;
          {
            const e = n.json.accessors[i.POSITION],
              t = e.min,
              a = e.max;
            if (void 0 === t || void 0 === a)
              return void console.warn(
                "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
              );
            if (
              (o.set(
                new r.Vector3(t[0], t[1], t[2]),
                new r.Vector3(a[0], a[1], a[2])
              ),
              e.normalized)
            ) {
              const t = fe(K[e.componentType]);
              o.min.multiplyScalar(t), o.max.multiplyScalar(t);
            }
          }
          const a = t.targets;
          if (void 0 !== a) {
            const e = new r.Vector3(),
              t = new r.Vector3();
            for (let r = 0, i = a.length; r < i; r++) {
              const i = a[r];
              if (void 0 !== i.POSITION) {
                const r = n.json.accessors[i.POSITION],
                  o = r.min,
                  a = r.max;
                if (void 0 !== o && void 0 !== a) {
                  if (
                    (t.setX(Math.max(Math.abs(o[0]), Math.abs(a[0]))),
                    t.setY(Math.max(Math.abs(o[1]), Math.abs(a[1]))),
                    t.setZ(Math.max(Math.abs(o[2]), Math.abs(a[2]))),
                    r.normalized)
                  ) {
                    const e = fe(K[r.componentType]);
                    t.multiplyScalar(e);
                  }
                  e.max(t);
                } else
                  console.warn(
                    "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                  );
              }
            }
            o.expandByVector(e);
          }
          e.boundingBox = o;
          const s = new r.Sphere();
          o.getCenter(s.center),
            (s.radius = o.min.distanceTo(o.max) / 2),
            (e.boundingSphere = s);
        })(e, t, n),
        Promise.all(o).then(function () {
          return void 0 !== t.targets
            ? (function (e, t, n) {
                let r = !1,
                  i = !1;
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e];
                  if (
                    (void 0 !== n.POSITION && (r = !0),
                    void 0 !== n.NORMAL && (i = !0),
                    r && i)
                  )
                    break;
                }
                if (!r && !i) return Promise.resolve(e);
                const o = [],
                  a = [];
                for (let s = 0, l = t.length; s < l; s++) {
                  const l = t[s];
                  if (r) {
                    const t =
                      void 0 !== l.POSITION
                        ? n.getDependency("accessor", l.POSITION)
                        : e.attributes.position;
                    o.push(t);
                  }
                  if (i) {
                    const t =
                      void 0 !== l.NORMAL
                        ? n.getDependency("accessor", l.NORMAL)
                        : e.attributes.normal;
                    a.push(t);
                  }
                }
                return Promise.all([Promise.all(o), Promise.all(a)]).then(
                  function (t) {
                    const n = t[0],
                      o = t[1];
                    return (
                      r && (e.morphAttributes.position = n),
                      i && (e.morphAttributes.normal = o),
                      (e.morphTargetsRelative = !0),
                      e
                    );
                  }
                );
              })(e, t.targets, n)
            : e;
        })
      );
    }

    function ye(e, t) {
      let n = e.getIndex();
      if (null === n) {
        const t = [],
          r = e.getAttribute("position");
        if (void 0 === r)
          return (
            console.error(
              "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
            ),
            e
          );
        for (let e = 0; e < r.count; e++) t.push(e);
        e.setIndex(t), (n = e.getIndex());
      }
      const i = n.count - 2,
        o = [];
      if (t === r.TriangleFanDrawMode)
        for (let e = 1; e <= i; e++)
          o.push(n.getX(0)), o.push(n.getX(e)), o.push(n.getX(e + 1));
      else
        for (let e = 0; e < i; e++)
          e % 2 == 0
            ? (o.push(n.getX(e)), o.push(n.getX(e + 1)), o.push(n.getX(e + 2)))
            : (o.push(n.getX(e + 2)), o.push(n.getX(e + 1)), o.push(n.getX(e)));
      o.length / 3 !== i &&
        console.error(
          "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
        );
      const a = e.clone();
      return a.setIndex(o), a;
    }

    function xe(e) {
      let t,
        n,
        i,
        o = 0;
      for (let r = 0; r < e.length; ++r) {
        const a = e[r];
        if (a.isInterleavedBufferAttribute)
          return (
            console.error(
              "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."
            ),
            null
          );
        if (
          (void 0 === t && (t = a.array.constructor), t !== a.array.constructor)
        )
          return (
            console.error(
              "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."
            ),
            null
          );
        if ((void 0 === n && (n = a.itemSize), n !== a.itemSize))
          return (
            console.error(
              "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."
            ),
            null
          );
        if ((void 0 === i && (i = a.normalized), i !== a.normalized))
          return (
            console.error(
              "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."
            ),
            null
          );
        o += a.array.length;
      }
      const a = new t(o);
      let s = 0;
      for (let t = 0; t < e.length; ++t)
        a.set(e[t].array, s), (s += e[t].array.length);
      return new r.BufferAttribute(a, n, i);
    }
    var be;
    !(function (e) {
      var t = (function () {
        function e(e) {
          this.forRange =
            e ||
            function (e, t) {
              return [e, t];
            };
        }
        return (
          (e.prototype.withCount = function (t) {
            return new e(function (e, n) {
              var r = [],
                i = n - e;
              r.push(e);
              for (var o = 1; o < t - 1; o++) r.push((o * i) / (t - 1) + e);
              return r.push(n), r;
            });
          }),
          (e.prototype.withFunction = function (t) {
            return new e(t);
          }),
          (e.prototype.withMaxWidth = function (t) {
            var n = this;
            return new e(function (e, r) {
              if (e > r) return n.forRange(r, e).reverse();
              for (
                var i = r - e, o = Math.ceil(i / t), a = i / o, s = [e];
                o-- > 0;

              )
                s.push(r - a * o);
              return s;
            });
          }),
          (e.prototype.withoutBorders = function () {
            var t = this;
            return new e(function (e, n) {
              var r = t.forRange(e, n);
              return r.shift(), r.pop(), r;
            });
          }),
          e
        );
      })();
      e.IntervalBuilder = t;
      var n = (function () {
        function e(e, n) {
          (this.thickness = 8),
            (this.default = {
              beamShape: [
                new r.Vector3(-8, -8, 0),
                new r.Vector3(-6, -10, 0),
                new r.Vector3(6, -10, 0),
                new r.Vector3(8, -8, 0),
                new r.Vector3(8, 6, 0),
                new r.Vector3(6, 8, 0),
                new r.Vector3(-6, 8, 0),
                new r.Vector3(-8, 6, 0),
                new r.Vector3(-8, -8, 0),
              ].map(function (e) {
                return e.divideScalar(1.5);
              }),
              windowBeamShape: [
                new r.Vector3(-6, 0, 0),
                new r.Vector3(-7, 1, 0),
                new r.Vector3(-7, 4, 0),
                new r.Vector3(-6, 5, 0),
                new r.Vector3(0, 5, 0),
                new r.Vector3(0, 0, 0),
                new r.Vector3(-6, 0, 0),
              ].reverse(),
              beamIntervalBuilder: new t().withMaxWidth(60).withoutBorders(),
            }),
            (this.thickness = e || 8),
            (this.materials = n);
        }
        return (
          (e.prototype.xyVerticesFromArray = function (e) {
            for (var t = [], n = 0; n < e.length; n += 2)
              t.push(new r.Vector3(e[n], e[n + 1], 0));
            return t;
          }),
          (e.prototype.xyzVerticesFromArray = function (e) {
            for (var t = [], n = 0; n < e.length; n += 3)
              t.push(new r.Vector3().fromArray(e, n));
            return t;
          }),
          (e.prototype.xyRectVerts = function (e, t, n, r) {
            void 0 === n && (n = 0), void 0 === r && (r = !1);
            var i = e / 2,
              o = t / 2;
            n = n || 0;
            var a = this.xyzVerticesFromArray([
              -i,
              -o,
              n,
              i,
              -o,
              n,
              i,
              o,
              n,
              -i,
              o,
              n,
            ]);
            return r && a.push(a[0]), a;
          }),
          (e.prototype.bevelXYVectorArray = function (e, t) {
            if (e.length < 1) return e;
            var n = e[0],
              r = e[e.length - 1],
              i = n.x === r.x && n.y === r.y && n.z === r.z,
              o = e.slice(0);
            o.push(e[0]);
            var a = e.reduce(function (n, r, i) {
              if (i === e.length - 1) return n;
              var a = o[i + 1],
                s = a.clone().sub(r).normalize().multiplyScalar(t);
              return n.concat([r.clone().add(s), a.clone().sub(s)]);
            }, []);
            return i && a.push(a[0]), a;
          }),
          (e.prototype.xyFrame = function (e, t, n, r, i) {
            var o = this.xyRectVerts(n, r);
            return this.beamsAroundPoly(e, t, o, i);
          }),
          (e.prototype.xyPanel = function (e, t, n, i) {
            var o = this.xyRectVerts(n, i),
              a = this.polygonGeometry(o),
              s = new r.Mesh(a, t);
            return (s.name = e), s;
          }),
          (e.prototype.xyFramedPanel = function (e, t, n, r, i, o) {
            return this.compose(e, [
              [this.xyFrame("frame " + e, t, r, i, o)],
              [this.xyPanel("panel " + e, n, r, i)],
            ]);
          }),
          (e.prototype.placeholder = function (e) {
            var t = new r.Object3D();
            return (t.name = e), t;
          }),
          (e.prototype.loadSprite = function (e, t, n, i, o) {
            var a = new r.TextureLoader(),
              s = this.placeholder("placeholder " + e);
            a.setCrossOrigin("");
            var l = new r.SpriteMaterial({
              map: a.load(t, function (t) {
                var a = t.image.width,
                  c = t.image.height,
                  u = n / a,
                  h = i / c;
                h < u && (u = h), (a *= u), (c *= u);
                var d = new r.Sprite(l);
                d.scale.set(a, c, 1), (d.name = e), s.add(d), o && o(s);
              }),
              transparent: !0,
            });
            return s;
          }),
          (e.prototype.loadImagePlane = function (e, t, n, i, o, a) {
            var s = new r.TextureLoader(),
              l = this.placeholder("placeholder " + e),
              c = new r.Group();
            l.add(c), s.setCrossOrigin("");
            var u = new r.MeshPhysicalMaterial({
              map: s.load(t, function (t) {
                var s = t.image.width,
                  l = t.image.height,
                  h = Math.max(n || s, Math.min(o || s, s)) / s,
                  d = Math.max(i || l, Math.min(a || l, l)) / l,
                  p = Math.max(h, d);
                console.log(p);
                var f = new r.PlaneGeometry(1, 1),
                  m = new r.Mesh(f, u);
                (m.name = e), c.add(m), m.scale.set(p * s, p * l, 1);
              }),
              transparent: !0,
              side: r.DoubleSide,
            });
            return c;
          }),
          (e.prototype.loadMesh = function (e, t, n) {
            var r = this.placeholder(e),
              i = (t = kt(t)).match(/(^.*\/)([^\.]+)\.(\w+)$/),
              o = (i[0], i[1]),
              a = i[2];
            switch (i[3]) {
              case "glb":
              case "gltf":
                new b().load(
                  t,
                  function (e) {
                    (e.scene = e.scene), r.add(e.scene), n && n(e.scene, e);
                  }.bind(this)
                );
                break;
              case "dae":
                new v().load(
                  t,
                  function (e) {
                    (e.scene = e.scene), r.add(e.scene), n && n(e.scene, e);
                  }.bind(this)
                );
                break;
              case "obj":
                new m().load(
                  t,
                  function (e) {
                    r.add(e), n && n(e, e);
                  }.bind(this)
                );
                break;
              case "mtl":
                var s = new y();
                s.setPath(o),
                  s.load(
                    a + ".mtl",
                    function (e) {
                      e.preload();
                      var t = new m();
                      t.setMaterials(e),
                        t.setPath(o),
                        t.load(a + ".obj", function (e) {
                          r.add(e), n && n(e, e);
                        });
                    },
                    function () {},
                    function (e) {
                      throw e;
                    }
                  );
                break;
              default:
                throw "No loader implemented for '" + t + "'.";
            }
            return r;
          }),
          (e.prototype.horizontalPlane = function (e, t, n, i) {
            var o = new r.PlaneBufferGeometry(n, i),
              a = new r.Mesh(o, t);
            a.rotation.x = Math.PI / 2;
            var s = a.clone();
            return (
              (s.rotation.x = -Math.PI / 2),
              this.compose(e, [
                [a, 0, 0, 0],
                [s, 0, 0, 0],
              ])
            );
          }),
          (e.prototype.sphere = function (e, t, n) {
            n = n || 1e3;
            var i = new r.SphereBufferGeometry(n, 50, 50),
              o = new r.Mesh(i, t);
            return o.position.set(0, 0, 0), (o.name = e), o;
          }),
          (e.prototype.box = function (e, t, n, i, o) {
            if (isNaN(n) || isNaN(i) || isNaN(o))
              throw "Invalid parameters for box";
            var a = this.boxWithRoundedEdges(n, i, o, 0.3, 2),
              s = new r.Mesh(a, t);
            return s.position.set(0, 0, 0), (s.name = e), s;
          }),
          (e.prototype.boxWithRoundedEdges = function (e, t, n, i, o) {
            var a = new r.Shape(),
              s = 1e-5,
              l = i - s;
            a.absarc(s, s, s, -Math.PI / 2, -Math.PI, !0),
              a.absarc(s, t - 2 * l, s, Math.PI, Math.PI / 2, !0),
              a.absarc(e - 2 * l, t - 2 * l, s, Math.PI / 2, 0, !0),
              a.absarc(e - 2 * l, s, s, 0, -Math.PI / 2, !0);
            var c = new r.ExtrudeBufferGeometry(a, {
              depth: n - 2 * i,
              bevelEnabled: !0,
              bevelSegments: 2 * o,
              steps: 1,
              bevelSize: l,
              bevelThickness: i,
              curveSegments: o,
            });
            return c.center(), c;
          }),
          (e.prototype.frontBackBox = function (e, t, n, r, i, o) {
            var a = this.box(e + " front", t, r, i, o / 2),
              s = a.clone();
            return (
              (s.name = e + " back"),
              (s.material = n),
              this.compose(e, [
                [a, 0, 0, o / 2],
                [s, 0, 0, -o / 2],
              ])
            );
          }),
          (e.prototype.beamInWidth = function (e, t, n) {
            return this.box(e, t, n, this.thickness, this.thickness);
          }),
          (e.prototype.beamInHeight = function (e, t, n) {
            return this.box(e, t, this.thickness, n, this.thickness);
          }),
          (e.prototype.beamInDepth = function (e, t, n) {
            return this.box(e, t, this.thickness, this.thickness, n);
          }),
          (e.prototype.polygonMatrixforYPlane = function (e, t) {
            var n = e.map(function (t, n) {
                return {
                  v1: t,
                  v2: e[(n + 1) % e.length],
                };
              })[t],
              i = n.v2.clone().sub(n.v1).normalize(),
              o = (function () {
                var t = e[1].clone(),
                  n = e[0].clone().sub(t).normalize(),
                  r = e[2].clone().sub(t).normalize().negate();
                return n.cross(r);
              })(),
              a = i.clone().cross(o).normalize(),
              s = e[t],
              l = new r.Matrix4().makeBasis(a, i, o).setPosition(s),
              c = new r.Matrix4().makeRotationFromEuler(
                new r.Euler(0, Math.PI / 2, Math.PI / 2)
              );
            return l.multiply(c);
          }),
          (e.prototype.beamsAroundPoly = function (e, t, n, i) {
            var o = this.polygonMatrixforYPlane(n, 0),
              a = new r.Matrix4().copy(o).invert(),
              s = n.map(function (e) {
                return e.clone().applyMatrix4(a);
              }),
              l = this.extrudeShapeOnYPlane(e, t, i, s, !1);
            l.applyMatrix4(o);
            var c = new r.Object3D();
            return c.add(l), (c.name = "rotated " + e), c;
          }),
          (e.prototype.polygonGeometry = function (e, t) {
            if (
              (e = e.filter(function (t, n) {
                return 0 === n || !t.equals(e[n - 1]);
              })).length < 3
            )
              return t || new r.BufferGeometry();
            var n = this.polygonMatrixforYPlane(e, 0),
              i = new r.Euler(-Math.PI / 2, 0, 0),
              o = new r.Matrix4().makeRotationFromEuler(i);
            if ((n.multiply(o), 0 === n.determinant()))
              return t || new r.BufferGeometry();
            var a = new r.Matrix4().copy(n).invert(),
              s = e.map(function (e) {
                var t = e.clone().applyMatrix4(a);
                return new r.Vector2(t.x, t.y);
              });
            if (!(s = this.simplifyVerts(s)).length)
              return t || new r.BufferGeometry();
            var l = new r.Shape(s),
              c = new r.ShapeBufferGeometry(l);
            return c.applyMatrix4(n), (t = this.mergeGeometries(c, t));
          }),
          (e.prototype.mergeGeometries = function (e, t) {
            return e && e.hasAttribute("position")
              ? t && t.hasAttribute("position")
                ? (e.index && (e = e.toNonIndexed()),
                  t.index && (t = t.toNonIndexed()),
                  e.hasAttribute("normal") && !t.hasAttribute("normal")
                    ? (t = this.computeFaceNormals(t))
                    : !e.hasAttribute("normal") &&
                      t.hasAttribute("normal") &&
                      (e = this.computeFaceNormals(e)),
                  (function (e, t = !1) {
                    const n = null !== e[0].index,
                      i = new Set(Object.keys(e[0].attributes)),
                      o = new Set(Object.keys(e[0].morphAttributes)),
                      a = {},
                      s = {},
                      l = e[0].morphTargetsRelative,
                      c = new r.BufferGeometry();
                    let u = 0;
                    for (let r = 0; r < e.length; ++r) {
                      const h = e[r];
                      let d = 0;
                      if (n !== (null !== h.index))
                        return (
                          console.error(
                            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                              r +
                              ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."
                          ),
                          null
                        );
                      for (const e in h.attributes) {
                        if (!i.has(e))
                          return (
                            console.error(
                              "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                                r +
                                '. All geometries must have compatible attributes; make sure "' +
                                e +
                                '" attribute exists among all geometries, or in none of them.'
                            ),
                            null
                          );
                        void 0 === a[e] && (a[e] = []),
                          a[e].push(h.attributes[e]),
                          d++;
                      }
                      if (d !== i.size)
                        return (
                          console.error(
                            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                              r +
                              ". Make sure all geometries have the same number of attributes."
                          ),
                          null
                        );
                      if (l !== h.morphTargetsRelative)
                        return (
                          console.error(
                            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                              r +
                              ". .morphTargetsRelative must be consistent throughout all geometries."
                          ),
                          null
                        );
                      for (const e in h.morphAttributes) {
                        if (!o.has(e))
                          return (
                            console.error(
                              "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                                r +
                                ".  .morphAttributes must be consistent throughout all geometries."
                            ),
                            null
                          );
                        void 0 === s[e] && (s[e] = []),
                          s[e].push(h.morphAttributes[e]);
                      }
                      if (
                        ((c.userData.mergedUserData =
                          c.userData.mergedUserData || []),
                        c.userData.mergedUserData.push(h.userData),
                        t)
                      ) {
                        let e;
                        if (n) e = h.index.count;
                        else {
                          if (void 0 === h.attributes.position)
                            return (
                              console.error(
                                "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                                  r +
                                  ". The geometry must have either an index or a position attribute"
                              ),
                              null
                            );
                          e = h.attributes.position.count;
                        }
                        c.addGroup(u, e, r), (u += e);
                      }
                    }
                    if (n) {
                      let t = 0;
                      const n = [];
                      for (let r = 0; r < e.length; ++r) {
                        const i = e[r].index;
                        for (let e = 0; e < i.count; ++e) n.push(i.getX(e) + t);
                        t += e[r].attributes.position.count;
                      }
                      c.setIndex(n);
                    }
                    for (const e in a) {
                      const t = xe(a[e]);
                      if (!t)
                        return (
                          console.error(
                            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
                              e +
                              " attribute."
                          ),
                          null
                        );
                      c.setAttribute(e, t);
                    }
                    for (const e in s) {
                      const t = s[e][0].length;
                      if (0 === t) break;
                      (c.morphAttributes = c.morphAttributes || {}),
                        (c.morphAttributes[e] = []);
                      for (let n = 0; n < t; ++n) {
                        const t = [];
                        for (let r = 0; r < s[e].length; ++r)
                          t.push(s[e][r][n]);
                        const r = xe(t);
                        if (!r)
                          return (
                            console.error(
                              "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
                                e +
                                " morphAttribute."
                            ),
                            null
                          );
                        c.morphAttributes[e].push(r);
                      }
                    }
                    return c;
                  })([t, e]))
                : e
              : t;
          }),
          (e.prototype.beamsToLastPointOverTriangle = function (
            e,
            t,
            n,
            i,
            o,
            a,
            s
          ) {
            var l = i.clone().sub(n),
              c = l.length();
            l.normalize();
            var u = new r.Vector3(0, 1, 0),
              h = a.forRange(0, c).map(function (e) {
                var t = l.clone().multiplyScalar(e).add(n),
                  r = o.clone().sub(t).normalize(),
                  i = r.clone().cross(u).cross(r);
                return {
                  v1: t,
                  v2: o,
                  v1Normal: i,
                  v2Normal: i,
                };
              });
            return this.extrudeEdges(e, t, h, s);
          }),
          (e.prototype.parallelBeamsOverPoly = function (e, t, n, i, o, a) {
            var s = this.polygonMatrixforYPlane(n, i),
              l = new r.Matrix4().copy(s).invert(),
              c = n.map(function (e) {
                return e.clone().applyMatrix4(l);
              }),
              u = c.reduce(
                function (e, t, n) {
                  var r = c[e.left].x < t.x ? e.left : n,
                    i = c[e.right].x > t.x ? e.right : n;
                  return {
                    left: r,
                    right: i,
                    leftX: c[r].x,
                    rightX: c[i].x,
                  };
                },
                {
                  left: 0,
                  right: 0,
                  leftX: 0,
                  rightX: 0,
                }
              );

            function h(e, t) {
              return (e + t + c.length) % c.length;
            }
            for (
              var d = u.left,
                p = u.left,
                f = [],
                m = o.forRange(0, u.rightX - u.leftX),
                g = function (e, t, n) {
                  var r = h(e, t);
                  if (c[e].x > c[r].x) return g(e, -t, n);
                  for (
                    var i = c.length;
                    i-- > 0 && (c[e].x > n || c[r].x < n);

                  )
                    r = h((e = r), t);
                  var o = c[e],
                    a = c[r],
                    s = n - o.x,
                    l = a.x - o.x;
                  return (
                    (l = 0 !== l ? l : 1),
                    {
                      index: e,
                      v: o.clone().lerp(a, s / l),
                    }
                  );
                };
              m.length;

            ) {
              var v = m.pop() + u.leftX,
                y = g(d, 1, v),
                x = g(p, -1, v),
                b = y.v.z,
                w = x.v.z;
              f.push({
                x: v,
                tz: b,
                bz: w,
              }),
                (d = y.index),
                (p = x.index);
            }
            var _ = this,
              M = f.map(function (e) {
                var n = [
                    new r.Vector3(e.x, 0, e.bz),
                    new r.Vector3(e.x, 0, e.tz),
                  ],
                  i = _.extrudeShapeOnYPlane("beam", t, a, n, !0),
                  o = new r.Object3D();
                return (o.name = "beam wrapper"), o.add(i), [o, 0, 0, 0];
              }),
              S = this.compose(e, M);
            S.applyMatrix4(s);
            var T = this.placeholder("rotated " + e);
            return T.add(S), T;
          }),
          (e.prototype.compose = function (e, t) {
            var n = new r.Object3D();
            return (
              n.position.set(0, 0, 0),
              (n.name = e),
              t.map(function (e) {
                var t = e[0];
                if (t && t.children) {
                  var r = e[1],
                    i = e[2],
                    o = e[3];
                  (r = isNaN(r) ? 0 : r),
                    (i = isNaN(i) ? 0 : i),
                    (o = isNaN(o) ? 0 : o);
                  var a = t.clone();
                  a.position.set(r, i, o), n.add(a);
                }
              }),
              n
            );
          }),
          (e.prototype.setCastsShadow = function (e, t) {
            e.traverse(function (e) {
              e instanceof r.Mesh &&
                ((e.castShadow = t(e)), (e.receiveShadow = t(e)));
            });
          }),
          (e.prototype.remapUV = function (e, t, n) {
            return (
              e.updateMatrixWorld(!1),
              e.traverse(function (e) {
                if (e instanceof r.Mesh) {
                  var i = e.geometry;
                  if (!i.isBufferGeometry) throw "non-buffer-geo";
                  if (!i.hasAttribute("position")) return;
                  if (
                    (i.boundingSphere || i.computeBoundingSphere(),
                    isNaN(i.boundingSphere.radius))
                  )
                    return;
                  i.boundingBox || i.computeBoundingBox();
                  var o = i.boundingBox.min;
                  n && ((o.x += n.x), (o.y += n.y)),
                    i.index && (i = i.toNonIndexed());
                  for (
                    var a,
                      s = i.getAttribute("position"),
                      l = new Float32Array(2 * s.count),
                      c = [
                        function (e) {
                          return new r.Vector2(e.z, e.y);
                        },
                        function (e) {
                          return new r.Vector2(e.x, e.z);
                        },
                        function (e) {
                          return new r.Vector2(e.x, e.y);
                        },
                      ],
                      u = function (n) {
                        var i = [0, 1, 2].map(function (t) {
                            var i = new r.Vector3().fromBufferAttribute(
                              s,
                              n + t
                            );
                            return (i = e.localToWorld(i).sub(o));
                          }),
                          u = i[0],
                          h = i[1],
                          d = i[2],
                          p = h
                            .clone()
                            .sub(u)
                            .cross(d.clone().sub(u))
                            .toArray()
                            .map(Math.abs),
                          f = Math.max.apply(Math, p);
                        (a = p.indexOf(f)),
                          console.assert(a > -1),
                          [u, h, d].map(function (e, i) {
                            var o = c[a](e);
                            t && (o = new r.Vector2(o.y, o.x)),
                              (l[2 * (n + i)] = o.x),
                              (l[2 * (n + i) + 1] = o.y);
                          });
                      },
                      h = 0;
                    h < s.count;
                    h += 3
                  )
                    u(h);
                  var d = new r.Float32BufferAttribute(l, 2);
                  i.setAttribute("uv", d);
                }
              }),
              e
            );
          }),
          (e.prototype.remapUV2 = function (e, t, n) {
            return this.remapUV(e, t, n);
          }),
          (e.prototype.matrixForPathPoint = function (e, t, n) {
            var i,
              o,
              a,
              s = e[t % e.length],
              l = e[(t + e.length - 1) % e.length],
              c = e[(t + 1) % e.length];
            (l = l.clone().sub(s).normalize()),
              (c = c.clone().sub(s).normalize()),
              e.length <= 2
                ? ((a = e[0].clone().sub(e[1]).normalize()),
                  (i = new r.Vector3(0, 1, 0).cross(a)),
                  (o = a.clone().cross(i)))
                : ((i = l.clone().cross(c)),
                  n && 0 === t
                    ? ((a = c), (o = i.clone().cross(a).normalize()))
                    : n && t === e.length - 1
                    ? ((a = l.clone().negate()),
                      (o = i.clone().cross(a).normalize()))
                    : ((o = l.clone().add(c).normalize().negate()),
                      (a = i.clone().cross(o).normalize()))),
              i.z > 0 && (i.negate(), o.negate(), a.negate()),
              i.normalize();
            var u = Math.sqrt(Math.sin(Math.acos(o.dot(a))));
            return (
              a.divideScalar(u),
              o.divideScalar(u),
              new r.Matrix4().makeBasis(o, i, a).setPosition(s)
            );
          }),
          (e.prototype.expandPathOnYPlane = function (e, t, n) {
            void 0 === n && (n = !1);
            var r = e.map(function (e, t, r) {
              return this.matrixForPathPoint(r, t, n);
            }, this);
            return (
              n || ((e = e.slice(0)).push(e[0]), r.push(r[0])),
              e.map(function (e, n) {
                return t.clone().applyMatrix4(r[n]);
              })
            );
          }),
          (e.prototype.extrudeShapeOnYPlane = function (e, t, n, i, o) {
            var a = i.map(function (e, t, n) {
              return this.matrixForPathPoint(n, t, o);
            }, this);
            o || ((i = i.slice(0)).push(i[0]), a.push(a[0]));
            for (
              var s = n.length - 1,
                l = [],
                c = 0,
                u = 0,
                h = [],
                d = [],
                p = [],
                f = 0;
              f < i.length;
              f++
            ) {
              var m = a[f];
              f > 0 && ((u = i[f].distanceTo(i[f - 1])), (c += u));
              var g = 0,
                v = n.map(function (e, t) {
                  return (
                    t > 0 && (g += n[t].distanceTo(n[t - 1])),
                    (e = e.clone().applyMatrix4(m)),
                    h.push(e.x, e.y, e.z),
                    d.push(g, c),
                    e
                  );
                });
              for (
                o &&
                (0 === f
                  ? l.push(v.reverse())
                  : f === i.length - 1 && l.push(v));
                s < h.length / 3 - 1;

              ) {
                var y = s - n.length,
                  x = s,
                  b = y + 1,
                  w = x + 1;
                p.push(b, x, y), p.push(w, x, b), s++;
              }
              s++;
            }
            var _ = new r.BufferGeometry();
            _.setAttribute("position", new r.Float32BufferAttribute(h, 3)),
              _.setAttribute("uv", new r.Float32BufferAttribute(d, 2)),
              _.setIndex(p),
              (_ = this.computeFaceNormals(_)),
              l.map(
                function (e) {
                  _ = this.polygonGeometry(e, _);
                }.bind(this)
              ),
              _.computeBoundingBox(),
              _.computeBoundingSphere();
            var M = new r.Mesh(_, t);
            return (M.name = e), M;
          }),
          (e.prototype.extrudeEdges = function (e, t, n, i) {
            var o = new r.BufferGeometry();
            (o.name = e),
              n.map(
                function (e) {
                  o = this.extrudeEdge(
                    e.v1,
                    e.v2,
                    e.v1Normal,
                    e.v2Normal,
                    i,
                    o
                  );
                }.bind(this)
              ),
              (o = this.computeFaceNormals(o));
            var a = new r.Mesh(o, t);
            return (a.name = e), a;
          }),
          (e.prototype.computeFaceNormals = function (e) {
            e.index && (e = e.toNonIndexed());
            var t = e.getAttribute("position");
            if (!t) return e;
            for (
              var n = new Float32Array(3 * t.count * 3),
                i = 0,
                o = function (e) {
                  var o = [0, 1, 2].map(function (n) {
                      return new r.Vector3().fromBufferAttribute(t, e + n);
                    }),
                    a = o[0],
                    s = o[1],
                    l = o[2].sub(s).cross(a.sub(s)).normalize();
                  [0, 1, 2].map(function (e) {
                    (n[i++] = l.x), (n[i++] = l.y), (n[i++] = l.z);
                  });
                },
                a = 0;
              a < t.count;
              a += 3
            )
              o(a);
            return (
              e.setAttribute("normal", new r.BufferAttribute(n, 3)),
              (e.attributes.normal.needsUpdate = !0),
              e
            );
          }),
          (e.prototype.extrudeEdge = function (e, t, n, i, o, a) {
            var s = [
                {
                  v: e,
                  n: (n = n || new r.Vector3(0, 1, 0)),
                  m: null,
                },
                {
                  v: t,
                  n: (i = i || new r.Vector3(0, 1, 0)),
                  m: null,
                },
              ],
              l = e.clone().sub(t).normalize();
            s.map(function (e) {
              var t = e.n.clone().cross(l);
              e.m = new r.Matrix4().makeBasis(e.n, t, l).setPosition(e.v);
            });
            var c,
              u = 0,
              h = [],
              d = [],
              p = [],
              f = [];
            c = e.distanceTo(t);
            for (var m = 0; m < s.length; m++) {
              var g = s[m].m;
              m > 0 && (u += c);
              var v = 0,
                y = o.map(function (e, t) {
                  return (
                    t > 0 && (v += o[t].distanceTo(o[t - 1])),
                    (e = e.clone().applyMatrix4(g)),
                    p.push(e.x, e.y, e.z),
                    d.push(v, u),
                    e
                  );
                });
              if ((0 === m ? h.push(y.reverse()) : 1 === m && h.push(y), m > 0))
                for (var x = 1; x < o.length; x++) {
                  var b = m * o.length + x - 1,
                    w = b - o.length,
                    _ = b + 1,
                    M = w + 1;
                  f.push(b, w, _), f.push(_, w, M);
                }
            }
            var S = new r.BufferGeometry();
            return (
              S.setAttribute("position", new r.Float32BufferAttribute(p, 3)),
              S.setAttribute("uv", new r.Float32BufferAttribute(d, 2)),
              S.setIndex(f),
              (S = this.computeFaceNormals(S)),
              h.map(
                function (e) {
                  S = this.polygonGeometry(e, S);
                }.bind(this)
              ),
              (S = this.mergeGeometries(a, S))
            );
          }),
          (e.prototype.tableLegs = function (e, t, n, r, i) {
            var o = this.beamInHeight("leg", t, r),
              a = (n - this.thickness) / 2,
              s = (i - this.thickness) / 2;
            return this.compose(e, [
              [o, -a, 0, s],
              [o, -a, 0, -s],
              [o, a, 0, -s],
              [o, a, 0, s],
            ]);
          }),
          (e.prototype.horizontalFrame = function (e, t, n, r, i) {
            var o = (n - this.thickness) / 2,
              a = (i - this.thickness) / 2,
              s = this.box("depthBeam", t, this.thickness, r, i),
              l = this.box("widthBeam", t, n, r, this.thickness);
            return this.compose(e, [
              [s, -o, 0, 0],
              [s, o, 0, 0],
              [l, 0, 0, -a],
              [l, 0, 0, a],
            ]);
          }),
          (e.prototype.horizontalShutters = function (
            e,
            t,
            n,
            r,
            i,
            o,
            a,
            s,
            l,
            c,
            u
          ) {
            if (o < a) {
              var h = this.fixedShutters(e, t, n, r, i, a, o, s, l, c, u);
              return (h.rotation.y += Math.PI / 2), h;
            }
            return this.fixedShutters(e, t, n, r, i, o, a, s, l, c, u);
          }),
          (e.prototype.fixedShutters = function (
            e,
            t,
            n,
            r,
            i,
            o,
            a,
            s,
            l,
            c,
            u
          ) {
            var h = Math.floor(o / n),
              d = o / h,
              p = [],
              f = this.box("shutter", t, d - u, r, a);
            f.rotation.z = (Math.PI / 2) * l + i * (1 - l);
            var m = [],
              g = f.clone();
            if (s) {
              for (
                var v = Math.floor(o / c),
                  y = Math.floor(c / d) * d,
                  x = (o - v * y) / 2 + y / 2,
                  b = 0;
                b < v;
                b++, x += y
              )
                x < o && m.push(Math.ceil(x / d));
              var w = this.box("light", this.materials[s], 2, 1, a);
              w.position.setY(r / 2 + u), g.add(w);
            }
            var _ = -(o - d) / 2 - (l * n) / 2;
            d = (d - r) * (1 - l) + r;
            for (var M = 0; M < h; M++, _ += d)
              p.push([m.indexOf(M + 1) < 0 ? f : g, _, 0, 0]);
            return this.compose(e, p);
          }),
          (e.prototype.curvedShutters = function (e, t, n, r, i, o, a, s, l) {
            var c;
            return s
              ? (((c = this.fixedcurvedShutters(
                  e,
                  t,
                  n,
                  r,
                  o,
                  i,
                  a,
                  l
                )).rotation.z = -Math.PI / 2),
                c)
              : i < o
              ? (((c = this.fixedcurvedShutters(
                  e,
                  t,
                  n,
                  r,
                  o,
                  i,
                  a,
                  l
                )).rotation.z += Math.PI / 2),
                c)
              : this.fixedcurvedShutters(e, t, n, r, i, o, a, l);
          }),
          (e.prototype.fixedcurvedShutters = function (e, t, n, i, o, a, s, l) {
            var c = function (e, t, n) {
                return (t - e) * n + e;
              },
              u = Math.floor(o / (3 + n)),
              h = o / u - 3,
              d = new r.Shape(),
              p = c(0.1, 0.7, s) * h,
              f = c(1, 0.01, s) * h,
              m = c(-0.5, 0.2, s) * h,
              g = i;
            d.moveTo(0, 0),
              d.bezierCurveTo(-m, -p, m + f, -p, f, 0),
              d.moveTo(f - g, 0),
              d.bezierCurveTo(m + f - g, -p + g, -m + g, -p + g, g, 0);
            var v = {
                depth: a,
                bevelEnabled: !1,
                bevelSegments: 2,
                steps: 2,
                bevelSize: 1,
                bevelThickness: 1,
              },
              y = new r.ExtrudeBufferGeometry(d, v),
              x = [],
              b = new r.Mesh(y, t);
            b.rotation.x = -Math.PI / 2;
            var w = new r.Mesh(new r.BoxBufferGeometry(3, 3, a), t),
              _ = new r.CylinderBufferGeometry(
                1.5,
                1.5,
                a,
                32,
                1,
                !1,
                0,
                Math.PI
              );
            _.rotateY(-Math.PI / 2);
            var M = new r.Mesh(_, t);
            M.rotation.x = Math.PI / 2;
            var S = w.clone();
            S.position.set(-1.5, -0.9, a / 2), b.add(S);
            var T = M.clone();
            T.position.set(-1.5, -2.4, a / 2), b.add(T);
            var E = w.clone();
            E.position.set(f + 1.5, -0.9, a / 2), b.add(E);
            var A = M.clone();
            A.position.set(f + 1.5, -2.4, a / 2), b.add(A);
            var C = b.clone();
            if (l) {
              var P = new r.Mesh(new r.BoxBufferGeometry(13, 3, a), t),
                L = new r.CylinderBufferGeometry(
                  6.5,
                  6.5,
                  a,
                  32,
                  1,
                  !1,
                  0,
                  Math.PI
                );
              L.rotateY(-Math.PI / 2);
              var R = new r.Mesh(L, t);
              R.rotation.x = Math.PI / 2;
              var I = P.clone();
              I.position.set(f + 6.5, -0.9, a / 2), C.add(I);
              var k = R.clone();
              k.position.set(f + 6.5, -2.4, a / 2), C.add(k);
            }
            for (var D = -o / 2, O = 0; O < u; O += 1, D += f + 3)
              l && O === u - 1
                ? x.push([C, D, -a / 2, 0])
                : x.push([b, D, -a / 2, 0]);
            return this.compose(e, x);
          }),
          (e.prototype.verticalSideFacingPanel = function (e, t, n, r, i) {
            return this.box(e, t, i, r, n);
          }),
          (e.prototype.verticalFrontFacingPanel = function (e, t, n, r, i) {
            return this.box(e, t, n, r, i);
          }),
          (e.prototype.glassSlidersLeftFrontToRightBack = function (
            e,
            t,
            n,
            r,
            i,
            o,
            a
          ) {
            var s = Math.ceil(n / o);
            if (s > i) {
              var l = i * o,
                c = (n - l) / 2,
                u = this.glassSlidersLeftFrontToRightBack(
                  "doors",
                  t,
                  l,
                  r,
                  i,
                  o,
                  a
                ),
                h = this.verticalFrontFacingPanel(
                  "sidepanel",
                  t.glass,
                  c,
                  r,
                  1
                );
              return this.compose(e, [
                [u, 0, 0, 0],
                [h, (l + c) / 2, 0, 0],
                [h, -(l + c) / 2, 0, 0],
              ]);
            }
            for (
              var d = n / s,
                p = r - 10,
                f = this.verticalFrontFacingPanel(
                  "glass",
                  t.glass,
                  d + 2,
                  p,
                  1
                ),
                m = this.verticalFrontFacingPanel(
                  "bottom",
                  t.blackMetal,
                  d + 2,
                  10,
                  1
                ),
                g = this.compose("doorpanel", [
                  [f, 0, 5, 0],
                  [m, 0, (10 - r) / 2, 0],
                ]),
                v = [],
                y = 0;
              y < s;
              y++
            ) {
              var x = y - s / 2 + 0.5,
                b = [g, d * x + (-y * d * a) / 100, 0, 1.1 * x];
              v.push(b);
            }
            return this.compose(e, v);
          }),
          (e.prototype.patioFrame = function (e, t, n, r, i, o) {
            var a = r / 2 + o / 2,
              s = this.tableLegs("legs", t, n, r, i),
              l = this.horizontalFrame("topframe", t, n, o, i);
            return this.compose(e, [
              [s, 0, 0, 0],
              [l, 0, a, 0],
            ]);
          }),
          (e.prototype.roofDome = function (e, n, r, i, o, a, s) {
            if ("none" !== n) {
              if (i > r) {
                var l = this.roofDome(e, n, i, r, o, a, s);
                return (
                  ((l = this.compose("rotated " + e, [
                    [l, 0, 0, 0],
                  ])).rotation.y += Math.PI / 2),
                  l
                );
              }
              (a = a || 60), (s = s || a);
              var c = {
                name: e,
                width: r,
                depth: i,
                beamShape: this.default.beamShape,
                beamIntervalBuilder: new t().withMaxWidth(a).withoutBorders(),
                beamIntervalBuilder2: new t().withMaxWidth(s).withoutBorders(),
                glassMaterial: this.materials.glass,
                beamMaterial: o || this.materials.whiteMetal,
                angle: 0,
                sideCount: 0,
              };
              switch (n) {
                case "flat":
                  return (c.angle = 5), this.__angularDome(c);
                case "saddle":
                  return (
                    (c.angle = 30), (c.sideCount = 2), this.__nSidedDome(c)
                  );
                case "pyramid":
                case "pyramid":
                  return (
                    (c.angle = 30), (c.sideCount = 4), this.__nSidedDome(c)
                  );
              }
            }
          }),
          (e.prototype.windowFrame = function (e, t) {
            var n = this.expandPathOnYPlane(t, new r.Vector3(-2, 3, 0)),
              i = this.polygonGeometry(n),
              o = new r.Mesh(i, this.materials.glass);
            o.name = e + " glass";
            var a = this.beamsAroundPoly(
              e + " border",
              this.materials.whiteMetal,
              t,
              this.default.windowBeamShape
            );
            return this.compose(e, [
              [o, 0, 0, 0],
              [a, 0, 0, 0],
            ]);
          }),
          (e.prototype.sidePolygons = function (e, t) {
            var n = new r.Vector3(0, t / 2, 0);
            return e.slice(1).map(function (t, r) {
              var i = e[r];
              return [
                i.clone().sub(n),
                t.clone().sub(n),
                t.clone().add(n),
                i.clone().add(n),
              ];
            });
          }),
          (e.prototype.__nSidedDome = function (e) {
            var t = Math.tan((e.angle * Math.PI) / 180),
              n = (e.depth / 2) * t;
            1 === e.sideCount && (n *= 2);
            var i = new r.Vector3(0, 1, 0),
              o = new r.Vector3(-e.width / 2, 0, -e.depth / 2),
              a = new r.Vector3(e.width / 2, 0, -e.depth / 2),
              s = new r.Vector3(-e.width / 2, 0, e.depth / 2),
              l = new r.Vector3(e.width / 2, 0, e.depth / 2),
              c = new r.Vector3(-e.width / 2, n, 0),
              u = new r.Vector3(e.width / 2, n, 0);
            4 === e.sideCount && ((c.x += e.depth / 2), (u.x -= e.depth / 2));
            var h = this.parallelBeamsOverPoly(
                "dome structural beams width",
                e.beamMaterial,
                [a, o, c, u],
                0,
                e.beamIntervalBuilder,
                e.beamShape
              ),
              d = this.parallelBeamsOverPoly(
                "dome structural beams depth",
                e.beamMaterial,
                [o, s, c],
                0,
                e.beamIntervalBuilder2,
                e.beamShape
              ),
              p = this.polygonGeometry([a, o, c, u]);
            p = this.polygonGeometry([o, s, c], p);
            var f = new r.Mesh(p, e.glassMaterial),
              m = this.compose("dome back and left side", [
                [h, 0, 0, 0],
                [d, 0, 0, 0],
                [f, 0, 0, 0],
              ]),
              g = m.clone().rotateY(Math.PI);
            g.name = "dome front and right side";
            var v = this.beamsAroundPoly(
                "dome surround beams",
                e.beamMaterial,
                [o, a, l, s],
                e.beamShape
              ),
              y = new r.Vector3(6, 0, 0),
              x = new r.Vector3(0, 1, 0),
              b = [
                {
                  v1: o,
                  v2: c,
                },
                {
                  v1: s,
                  v2: c,
                },
                {
                  v1: a,
                  v2: u,
                },
                {
                  v1: l,
                  v2: u,
                },
                {
                  v1: c.clone().sub(y).add(x),
                  v2: u.clone().add(y).add(x),
                },
              ].map(function (e) {
                var t = e.v2.clone().sub(e.v1).normalize().cross(i).normalize();
                return {
                  v1: e.v1,
                  v2: e.v2,
                  v1Normal: t,
                  v2Normal: t,
                };
              }),
              w = this.extrudeEdges(
                "dome edge",
                e.beamMaterial,
                b,
                e.beamShape
              );
            return this.compose(e.name, [
              [m, 0, 0, 0],
              [g, 0, 0, 0],
              [v, 0, 0, 0],
              [w, 0, 0, 0],
            ]);
          }),
          (e.prototype.__angularDome = function (e) {
            var t = Math.tan((e.angle * Math.PI) / 180),
              n = new r.Vector3(e.width / 2, 0, -e.depth / 2),
              i = new r.Vector3(-e.width / 2, 0, -e.depth / 2),
              o = new r.Vector3(-e.width / 2, 0, e.depth / 2),
              a = new r.Vector3(e.width / 2, 0, e.depth / 2),
              s = new r.Vector3(0, (e.depth / 2) * t, 0),
              l = [n, i, o.clone().add(s), a.clone().add(s)],
              c = this.parallelBeamsOverPoly(
                "roof parallel beams",
                e.beamMaterial,
                l,
                0,
                e.beamIntervalBuilder,
                e.beamShape
              ),
              u = this.beamsAroundPoly(
                "roof surround beams",
                e.beamMaterial,
                l,
                e.beamShape
              ),
              h = new r.Mesh(this.polygonGeometry(l), this.materials.glass),
              d = new r.Vector3(0, -10, 0),
              p = new r.Vector3(-3, 0, 0),
              f = [n, n.clone().add(d), a.clone().add(d), a.clone().add(s)],
              m = f
                .map(function (e) {
                  return e.clone().sub(p);
                })
                .reverse(),
              g = f.reverse().map(function (e) {
                return new r.Vector3(-e.x, e.y, e.z);
              }),
              v = m.reverse().map(function (e) {
                return new r.Vector3(-e.x, e.y, e.z);
              }),
              y = [
                o.clone().add(s).add(p),
                a.clone().add(s).sub(p),
                a.add(d).sub(p),
                o.add(d).add(p),
              ],
              x = this.polygonGeometry(m);
            (x = this.polygonGeometry(f, x)),
              (x = this.polygonGeometry(g, x)),
              (x = this.polygonGeometry(v, x)),
              (x = this.polygonGeometry(y, x)),
              (x = this.polygonGeometry(y.reverse(), x));
            var b = new r.Mesh(x, this.materials.whiteMetal);
            return this.compose(e.name, [
              [c, 0, 0, 0],
              [u, 0, 0, 0],
              [h, 0, 0, 0],
              [b, 0, 0, 0],
            ]);
          }),
          (e.prototype.backgroundSphere = function (e, t) {
            for (
              var n = e || 600,
                i = -t || 160,
                o = this.materials.environmentSphere,
                a = this.sphere("backgroundSphere", o, n),
                s = a.geometry.getAttribute("position"),
                l = new r.Vector3(),
                c = 0;
              c < s.count;
              c++
            )
              if ((l.fromBufferAttribute(s, c), l.y < -i)) {
                var u = -i / l.y;
                l.multiplyScalar(u), s.setXYZ(c, l.x, l.y, l.z);
              }
            return (s.needsUpdate = !0), a;
          }),
          (e.prototype.setEnvironmentTextureFromUrl = function (e, t) {
            this.materials.setEnvironmentTextureFromUrl(e, t);
          }),
          (e.prototype.simplifyVerts = function (e) {
            return e
              .filter(function (e, t, n) {
                return (
                  n[(t - 1 + n.length) % n.length].manhattanDistanceTo(e) >= 1
                );
              })
              .filter(function (e, t, n) {
                var r = n[(t - 1 + n.length) % n.length],
                  i = n[(t + 1) % n.length],
                  o = e.x,
                  a = e.y,
                  s = r.x,
                  l = r.y,
                  c = i.x,
                  u = i.y;
                return o * (l - u) + s * (u - a) + c * (a - l) != 0;
              });
          }),
          e
        );
      })();
      e.Builder = n;
    })(be || (be = {}));
    var we = (function () {
      function e() {
        this.items = {};
        (this.items = {}),
          [
            {
              key: "hof",
              yawDegrees: 0,
              deltaX: 0,
              radius: 3e3,
              floorHeight: 300,
              roll: 0,
            },
            {
              key: "hof_night",
              yawDegrees: 0,
              deltaX: 0,
              radius: 3e3,
              floorHeight: 300,
              roll: 0,
            },
            {
              key: "reynaers",
              yawDegrees: 90,
              deltaX: 0,
              radius: 3e3,
              floorHeight: 220,
              roll: 0,
            },
            {
              key: "reynaers2",
              yawDegrees: 0,
              deltaX: 0,
              radius: 3e3,
              floorHeight: 200,
              roll: 0,
            },
            {
              key: "tom",
              yawDegrees: 78,
              deltaX: -50,
              radius: 600,
              floorHeight: 120,
              roll: -1,
            },
            {
              key: "yves",
              yawDegrees: 92,
              deltaX: 100,
              radius: 650,
              floorHeight: 80,
            },
            {
              key: "lex",
              yawDegrees: -80,
              deltaX: 150,
              radius: 550,
              floorHeight: 70,
              roll: 2,
            },
          ].map(
            function (e) {
              var t = e.key + ".jpg";
              (e.url = kt("textures/equirectangular/" + t)),
                (this.items[e.key] = e);
            }.bind(this)
          );
      }
      return (
        (e.prototype.defaultKey = function () {
          return "reynaers2";
        }),
        (e.prototype.updateConfiguration = function (e) {
          this.items[e.key] = e;
        }),
        (e.prototype.getConfiguration = function (e) {
          return (
            (e = e || this.defaultKey()),
            this.items[e] || this.items[this.defaultKey()]
          );
        }),
        e
      );
    })();
    const _e = {
        type: "change",
      },
      Me = {
        type: "start",
      },
      Se = {
        type: "end",
      };
    class Te extends r.EventDispatcher {
      constructor(e, t) {
        super(),
          void 0 === t &&
            console.warn(
              'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
            ),
          t === document &&
            console.error(
              'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
            ),
          (this.object = e),
          (this.domElement = t),
          (this.domElement.style.touchAction = "none"),
          (this.enabled = !0),
          (this.target = new r.Vector3()),
          (this.minDistance = 0),
          (this.maxDistance = 1 / 0),
          (this.minZoom = 0),
          (this.maxZoom = 1 / 0),
          (this.minPolarAngle = 0),
          (this.maxPolarAngle = Math.PI),
          (this.minAzimuthAngle = -1 / 0),
          (this.maxAzimuthAngle = 1 / 0),
          (this.enableDamping = !1),
          (this.dampingFactor = 0.05),
          (this.enableZoom = !0),
          (this.zoomSpeed = 1),
          (this.enableRotate = !0),
          (this.rotateSpeed = 1),
          (this.enablePan = !0),
          (this.panSpeed = 1),
          (this.screenSpacePanning = !0),
          (this.keyPanSpeed = 7),
          (this.autoRotate = !1),
          (this.autoRotateSpeed = 2),
          (this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown",
          }),
          (this.mouseButtons = {
            LEFT: r.MOUSE.ROTATE,
            MIDDLE: r.MOUSE.DOLLY,
            RIGHT: r.MOUSE.PAN,
          }),
          (this.touches = {
            ONE: r.TOUCH.ROTATE,
            TWO: r.TOUCH.DOLLY_PAN,
          }),
          (this.target0 = this.target.clone()),
          (this.position0 = this.object.position.clone()),
          (this.zoom0 = this.object.zoom),
          (this._domElementKeyEvents = null),
          (this.getPolarAngle = function () {
            return s.phi;
          }),
          (this.getAzimuthalAngle = function () {
            return s.theta;
          }),
          (this.getDistance = function () {
            return this.object.position.distanceTo(this.target);
          }),
          (this.listenToKeyEvents = function (e) {
            e.addEventListener("keydown", j), (this._domElementKeyEvents = e);
          }),
          (this.saveState = function () {
            n.target0.copy(n.target),
              n.position0.copy(n.object.position),
              (n.zoom0 = n.object.zoom);
          }),
          (this.reset = function () {
            n.target.copy(n.target0),
              n.object.position.copy(n.position0),
              (n.object.zoom = n.zoom0),
              n.object.updateProjectionMatrix(),
              n.dispatchEvent(_e),
              n.update(),
              (o = i.NONE);
          }),
          (this.update = (function () {
            const t = new r.Vector3(),
              d = new r.Quaternion().setFromUnitVectors(
                e.up,
                new r.Vector3(0, 1, 0)
              ),
              p = d.clone().invert(),
              f = new r.Vector3(),
              m = new r.Quaternion(),
              g = 2 * Math.PI;
            return function () {
              const e = n.object.position;
              t.copy(e).sub(n.target),
                t.applyQuaternion(d),
                s.setFromVector3(t),
                n.autoRotate &&
                  o === i.NONE &&
                  S(((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed),
                n.enableDamping
                  ? ((s.theta += l.theta * n.dampingFactor),
                    (s.phi += l.phi * n.dampingFactor))
                  : ((s.theta += l.theta), (s.phi += l.phi));
              let r = n.minAzimuthAngle,
                v = n.maxAzimuthAngle;
              return (
                isFinite(r) &&
                  isFinite(v) &&
                  (r < -Math.PI ? (r += g) : r > Math.PI && (r -= g),
                  v < -Math.PI ? (v += g) : v > Math.PI && (v -= g),
                  (s.theta =
                    r <= v
                      ? Math.max(r, Math.min(v, s.theta))
                      : s.theta > (r + v) / 2
                      ? Math.max(r, s.theta)
                      : Math.min(v, s.theta))),
                (s.phi = Math.max(
                  n.minPolarAngle,
                  Math.min(n.maxPolarAngle, s.phi)
                )),
                s.makeSafe(),
                (s.radius *= c),
                (s.radius = Math.max(
                  n.minDistance,
                  Math.min(n.maxDistance, s.radius)
                )),
                !0 === n.enableDamping
                  ? n.target.addScaledVector(u, n.dampingFactor)
                  : n.target.add(u),
                t.setFromSpherical(s),
                t.applyQuaternion(p),
                e.copy(n.target).add(t),
                n.object.lookAt(n.target),
                !0 === n.enableDamping
                  ? ((l.theta *= 1 - n.dampingFactor),
                    (l.phi *= 1 - n.dampingFactor),
                    u.multiplyScalar(1 - n.dampingFactor))
                  : (l.set(0, 0, 0), u.set(0, 0, 0)),
                (c = 1),
                !!(
                  h ||
                  f.distanceToSquared(n.object.position) > a ||
                  8 * (1 - m.dot(n.object.quaternion)) > a
                ) &&
                  (n.dispatchEvent(_e),
                  f.copy(n.object.position),
                  m.copy(n.object.quaternion),
                  (h = !1),
                  !0)
              );
            };
          })()),
          (this.dispose = function () {
            n.domElement.removeEventListener("contextmenu", W),
              n.domElement.removeEventListener("pointerdown", U),
              n.domElement.removeEventListener("pointercancel", G),
              n.domElement.removeEventListener("wheel", V),
              n.domElement.removeEventListener("pointermove", z),
              n.domElement.removeEventListener("pointerup", H),
              null !== n._domElementKeyEvents &&
                n._domElementKeyEvents.removeEventListener("keydown", j);
          });
        const n = this,
          i = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6,
          };
        let o = i.NONE;
        const a = 1e-6,
          s = new r.Spherical(),
          l = new r.Spherical();
        let c = 1;
        const u = new r.Vector3();
        let h = !1;
        const d = new r.Vector2(),
          p = new r.Vector2(),
          f = new r.Vector2(),
          m = new r.Vector2(),
          g = new r.Vector2(),
          v = new r.Vector2(),
          y = new r.Vector2(),
          x = new r.Vector2(),
          b = new r.Vector2(),
          w = [],
          _ = {};

        function M() {
          return Math.pow(0.95, n.zoomSpeed);
        }

        function S(e) {
          l.theta -= e;
        }

        function T(e) {
          l.phi -= e;
        }
        const E = (function () {
            const e = new r.Vector3();
            return function (t, n) {
              e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), u.add(e);
            };
          })(),
          A = (function () {
            const e = new r.Vector3();
            return function (t, r) {
              !0 === n.screenSpacePanning
                ? e.setFromMatrixColumn(r, 1)
                : (e.setFromMatrixColumn(r, 0), e.crossVectors(n.object.up, e)),
                e.multiplyScalar(t),
                u.add(e);
            };
          })(),
          C = (function () {
            const e = new r.Vector3();
            return function (t, r) {
              const i = n.domElement;
              if (n.object.isPerspectiveCamera) {
                const o = n.object.position;
                e.copy(o).sub(n.target);
                let a = e.length();
                (a *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
                  E((2 * t * a) / i.clientHeight, n.object.matrix),
                  A((2 * r * a) / i.clientHeight, n.object.matrix);
              } else
                n.object.isOrthographicCamera
                  ? (E(
                      (t * (n.object.right - n.object.left)) /
                        n.object.zoom /
                        i.clientWidth,
                      n.object.matrix
                    ),
                    A(
                      (r * (n.object.top - n.object.bottom)) /
                        n.object.zoom /
                        i.clientHeight,
                      n.object.matrix
                    ))
                  : (console.warn(
                      "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                    ),
                    (n.enablePan = !1));
            };
          })();

        function P(e) {
          n.object.isPerspectiveCamera
            ? (c /= e)
            : n.object.isOrthographicCamera
            ? ((n.object.zoom = Math.max(
                n.minZoom,
                Math.min(n.maxZoom, n.object.zoom * e)
              )),
              n.object.updateProjectionMatrix(),
              (h = !0))
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (n.enableZoom = !1));
        }

        function L(e) {
          n.object.isPerspectiveCamera
            ? (c *= e)
            : n.object.isOrthographicCamera
            ? ((n.object.zoom = Math.max(
                n.minZoom,
                Math.min(n.maxZoom, n.object.zoom / e)
              )),
              n.object.updateProjectionMatrix(),
              (h = !0))
            : (console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
              ),
              (n.enableZoom = !1));
        }

        function R(e) {
          d.set(e.clientX, e.clientY);
        }

        function I(e) {
          m.set(e.clientX, e.clientY);
        }

        function k() {
          if (1 === w.length) d.set(w[0].pageX, w[0].pageY);
          else {
            const e = 0.5 * (w[0].pageX + w[1].pageX),
              t = 0.5 * (w[0].pageY + w[1].pageY);
            d.set(e, t);
          }
        }

        function D() {
          if (1 === w.length) m.set(w[0].pageX, w[0].pageY);
          else {
            const e = 0.5 * (w[0].pageX + w[1].pageX),
              t = 0.5 * (w[0].pageY + w[1].pageY);
            m.set(e, t);
          }
        }

        function O() {
          const e = w[0].pageX - w[1].pageX,
            t = w[0].pageY - w[1].pageY,
            n = Math.sqrt(e * e + t * t);
          y.set(0, n);
        }

        function B(e) {
          if (1 == w.length) p.set(e.pageX, e.pageY);
          else {
            const t = X(e),
              n = 0.5 * (e.pageX + t.x),
              r = 0.5 * (e.pageY + t.y);
            p.set(n, r);
          }
          f.subVectors(p, d).multiplyScalar(n.rotateSpeed);
          const t = n.domElement;
          S((2 * Math.PI * f.x) / t.clientHeight),
            T((2 * Math.PI * f.y) / t.clientHeight),
            d.copy(p);
        }

        function F(e) {
          if (1 === w.length) g.set(e.pageX, e.pageY);
          else {
            const t = X(e),
              n = 0.5 * (e.pageX + t.x),
              r = 0.5 * (e.pageY + t.y);
            g.set(n, r);
          }
          v.subVectors(g, m).multiplyScalar(n.panSpeed), C(v.x, v.y), m.copy(g);
        }

        function N(e) {
          const t = X(e),
            r = e.pageX - t.x,
            i = e.pageY - t.y,
            o = Math.sqrt(r * r + i * i);
          x.set(0, o),
            b.set(0, Math.pow(x.y / y.y, n.zoomSpeed)),
            P(b.y),
            y.copy(x);
        }

        function U(e) {
          !1 !== n.enabled &&
            (0 === w.length &&
              (n.domElement.setPointerCapture(e.pointerId),
              n.domElement.addEventListener("pointermove", z),
              n.domElement.addEventListener("pointerup", H)),
            (function (e) {
              w.push(e);
            })(e),
            "touch" === e.pointerType
              ? (function (e) {
                  switch (($(e), w.length)) {
                    case 1:
                      switch (n.touches.ONE) {
                        case r.TOUCH.ROTATE:
                          if (!1 === n.enableRotate) return;
                          k(), (o = i.TOUCH_ROTATE);
                          break;
                        case r.TOUCH.PAN:
                          if (!1 === n.enablePan) return;
                          D(), (o = i.TOUCH_PAN);
                          break;
                        default:
                          o = i.NONE;
                      }
                      break;
                    case 2:
                      switch (n.touches.TWO) {
                        case r.TOUCH.DOLLY_PAN:
                          if (!1 === n.enableZoom && !1 === n.enablePan) return;
                          n.enableZoom && O(),
                            n.enablePan && D(),
                            (o = i.TOUCH_DOLLY_PAN);
                          break;
                        case r.TOUCH.DOLLY_ROTATE:
                          if (!1 === n.enableZoom && !1 === n.enableRotate)
                            return;
                          n.enableZoom && O(),
                            n.enableRotate && k(),
                            (o = i.TOUCH_DOLLY_ROTATE);
                          break;
                        default:
                          o = i.NONE;
                      }
                      break;
                    default:
                      o = i.NONE;
                  }
                  o !== i.NONE && n.dispatchEvent(Me);
                })(e)
              : (function (e) {
                  let t;
                  switch (e.button) {
                    case 0:
                      t = n.mouseButtons.LEFT;
                      break;
                    case 1:
                      t = n.mouseButtons.MIDDLE;
                      break;
                    case 2:
                      t = n.mouseButtons.RIGHT;
                      break;
                    default:
                      t = -1;
                  }
                  switch (t) {
                    case r.MOUSE.DOLLY:
                      if (!1 === n.enableZoom) return;
                      !(function (e) {
                        y.set(e.clientX, e.clientY);
                      })(e),
                        (o = i.DOLLY);
                      break;
                    case r.MOUSE.ROTATE:
                      if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === n.enablePan) return;
                        I(e), (o = i.PAN);
                      } else {
                        if (!1 === n.enableRotate) return;
                        R(e), (o = i.ROTATE);
                      }
                      break;
                    case r.MOUSE.PAN:
                      if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === n.enableRotate) return;
                        R(e), (o = i.ROTATE);
                      } else {
                        if (!1 === n.enablePan) return;
                        I(e), (o = i.PAN);
                      }
                      break;
                    default:
                      o = i.NONE;
                  }
                  o !== i.NONE && n.dispatchEvent(Me);
                })(e));
        }

        function z(e) {
          !1 !== n.enabled &&
            ("touch" === e.pointerType
              ? (function (e) {
                  switch (($(e), o)) {
                    case i.TOUCH_ROTATE:
                      if (!1 === n.enableRotate) return;
                      B(e), n.update();
                      break;
                    case i.TOUCH_PAN:
                      if (!1 === n.enablePan) return;
                      F(e), n.update();
                      break;
                    case i.TOUCH_DOLLY_PAN:
                      if (!1 === n.enableZoom && !1 === n.enablePan) return;
                      !(function (e) {
                        n.enableZoom && N(e), n.enablePan && F(e);
                      })(e),
                        n.update();
                      break;
                    case i.TOUCH_DOLLY_ROTATE:
                      if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                      !(function (e) {
                        n.enableZoom && N(e), n.enableRotate && B(e);
                      })(e),
                        n.update();
                      break;
                    default:
                      o = i.NONE;
                  }
                })(e)
              : (function (e) {
                  if (!1 === n.enabled) return;
                  switch (o) {
                    case i.ROTATE:
                      if (!1 === n.enableRotate) return;
                      !(function (e) {
                        p.set(e.clientX, e.clientY),
                          f.subVectors(p, d).multiplyScalar(n.rotateSpeed);
                        const t = n.domElement;
                        S((2 * Math.PI * f.x) / t.clientHeight),
                          T((2 * Math.PI * f.y) / t.clientHeight),
                          d.copy(p),
                          n.update();
                      })(e);
                      break;
                    case i.DOLLY:
                      if (!1 === n.enableZoom) return;
                      !(function (e) {
                        x.set(e.clientX, e.clientY),
                          b.subVectors(x, y),
                          b.y > 0 ? P(M()) : b.y < 0 && L(M()),
                          y.copy(x),
                          n.update();
                      })(e);
                      break;
                    case i.PAN:
                      if (!1 === n.enablePan) return;
                      !(function (e) {
                        g.set(e.clientX, e.clientY),
                          v.subVectors(g, m).multiplyScalar(n.panSpeed),
                          C(v.x, v.y),
                          m.copy(g),
                          n.update();
                      })(e);
                  }
                })(e));
        }

        function H(e) {
          !1 !== n.enabled &&
            (e.pointerType,
            n.dispatchEvent(Se),
            (o = i.NONE),
            q(e),
            0 === w.length &&
              (n.domElement.releasePointerCapture(e.pointerId),
              n.domElement.removeEventListener("pointermove", z),
              n.domElement.removeEventListener("pointerup", H)));
        }

        function G(e) {
          q(e);
        }

        function V(e) {
          !1 === n.enabled ||
            !1 === n.enableZoom ||
            (o !== i.NONE && o !== i.ROTATE) ||
            (e.preventDefault(),
            n.dispatchEvent(Me),
            (function (e) {
              e.deltaY < 0 ? L(M()) : e.deltaY > 0 && P(M()), n.update();
            })(e),
            n.dispatchEvent(Se));
        }

        function j(e) {
          !1 !== n.enabled &&
            !1 !== n.enablePan &&
            (function (e) {
              let t = !1;
              switch (e.code) {
                case n.keys.UP:
                  C(0, n.keyPanSpeed), (t = !0);
                  break;
                case n.keys.BOTTOM:
                  C(0, -n.keyPanSpeed), (t = !0);
                  break;
                case n.keys.LEFT:
                  C(n.keyPanSpeed, 0), (t = !0);
                  break;
                case n.keys.RIGHT:
                  C(-n.keyPanSpeed, 0), (t = !0);
              }
              t && (e.preventDefault(), n.update());
            })(e);
        }

        function W(e) {
          !1 !== n.enabled && e.preventDefault();
        }

        function q(e) {
          delete _[e.pointerId];
          for (let t = 0; t < w.length; t++)
            if (w[t].pointerId == e.pointerId) return void w.splice(t, 1);
        }

        function $(e) {
          let t = _[e.pointerId];
          void 0 === t && ((t = new r.Vector2()), (_[e.pointerId] = t)),
            t.set(e.pageX, e.pageY);
        }

        function X(e) {
          const t = e.pointerId === w[0].pointerId ? w[1] : w[0];
          return _[t.pointerId];
        }
        n.domElement.addEventListener("contextmenu", W),
          n.domElement.addEventListener("pointerdown", U),
          n.domElement.addEventListener("pointercancel", G),
          n.domElement.addEventListener("wheel", V, {
            passive: !1,
          }),
          this.update();
      }
    }
    class Ee {
      constructor(e, t = {}) {
        this.enabled = !0;
        const n = void 0 !== t.defaultThickness ? t.defaultThickness : 0.003,
          i = new r.Color().fromArray(
            void 0 !== t.defaultColor ? t.defaultColor : [0, 0, 0]
          ),
          o = void 0 !== t.defaultAlpha ? t.defaultAlpha : 1,
          a = void 0 !== t.defaultKeepAlive && t.defaultKeepAlive,
          s = {},
          l = {},
          c = {},
          u = {
            outlineThickness: {
              value: n,
            },
            outlineColor: {
              value: i,
            },
            outlineAlpha: {
              value: o,
            },
          },
          h = [
            "#include <common>",
            "#include <uv_pars_vertex>",
            "#include <displacementmap_pars_vertex>",
            "#include <fog_pars_vertex>",
            "#include <morphtarget_pars_vertex>",
            "#include <skinning_pars_vertex>",
            "#include <logdepthbuf_pars_vertex>",
            "#include <clipping_planes_pars_vertex>",
            "uniform float outlineThickness;",
            "vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {",
            "\tfloat thickness = outlineThickness;",
            "\tconst float ratio = 1.0;",
            "\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );",
            "\tvec4 norm = normalize( pos - pos2 );",
            "\treturn pos + norm * thickness * pos.w * ratio;",
            "}",
            "void main() {",
            "\t#include <uv_vertex>",
            "\t#include <beginnormal_vertex>",
            "\t#include <morphnormal_vertex>",
            "\t#include <skinbase_vertex>",
            "\t#include <skinnormal_vertex>",
            "\t#include <begin_vertex>",
            "\t#include <morphtarget_vertex>",
            "\t#include <skinning_vertex>",
            "\t#include <displacementmap_vertex>",
            "\t#include <project_vertex>",
            "\tvec3 outlineNormal = - objectNormal;",
            "\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );",
            "\t#include <logdepthbuf_vertex>",
            "\t#include <clipping_planes_vertex>",
            "\t#include <fog_vertex>",
            "}",
          ].join("\n"),
          d = [
            "#include <common>",
            "#include <fog_pars_fragment>",
            "#include <logdepthbuf_pars_fragment>",
            "#include <clipping_planes_pars_fragment>",
            "uniform vec3 outlineColor;",
            "uniform float outlineAlpha;",
            "void main() {",
            "\t#include <clipping_planes_fragment>",
            "\t#include <logdepthbuf_fragment>",
            "\tgl_FragColor = vec4( outlineColor, outlineAlpha );",
            "\t#include <tonemapping_fragment>",
            "\t#include <encodings_fragment>",
            "\t#include <fog_fragment>",
            "\t#include <premultiplied_alpha_fragment>",
            "}",
          ].join("\n");

        function p(e) {
          const t = (function (e) {
            let t = s[e.uuid];
            return (
              void 0 === t &&
                ((t = {
                  material: new r.ShaderMaterial({
                    type: "OutlineEffect",
                    uniforms: r.UniformsUtils.merge([
                      r.UniformsLib.fog,
                      r.UniformsLib.displacementmap,
                      u,
                    ]),
                    vertexShader: h,
                    fragmentShader: d,
                    side: r.BackSide,
                  }),
                  used: !0,
                  keepAlive: a,
                  count: 0,
                }),
                (s[e.uuid] = t)),
              (t.used = !0),
              t.material
            );
          })(e);
          return (
            (l[t.uuid] = e),
            (function (e, t) {
              if ("invisible" === e.name) return;
              const n = t.userData.outlineParameters;
              (e.fog = t.fog),
                (e.toneMapped = t.toneMapped),
                (e.premultipliedAlpha = t.premultipliedAlpha),
                (e.displacementMap = t.displacementMap),
                void 0 !== n
                  ? (!1 === t.visible
                      ? (e.visible = !1)
                      : (e.visible = void 0 === n.visible || n.visible),
                    (e.transparent =
                      (void 0 !== n.alpha && n.alpha < 1) || t.transparent),
                    void 0 !== n.keepAlive &&
                      (s[t.uuid].keepAlive = n.keepAlive))
                  : ((e.transparent = t.transparent), (e.visible = t.visible));
              (!0 !== t.wireframe && !1 !== t.depthTest) || (e.visible = !1);
              t.clippingPlanes &&
                ((e.clipping = !0),
                (e.clippingPlanes = t.clippingPlanes),
                (e.clipIntersection = t.clipIntersection),
                (e.clipShadows = t.clipShadows));
              e.version = t.version;
            })(t, e),
            t
          );
        }

        function f(e) {
          const t = e.geometry;
          let n = !1;
          return (
            void 0 !== e.geometry &&
              (n = !t.isBufferGeometry || void 0 !== t.attributes.normal),
            !0 === e.isMesh && void 0 !== e.material && !0 === n
          );
        }

        function m(e) {
          if (!1 !== f(e)) {
            if (Array.isArray(e.material))
              for (let t = 0, n = e.material.length; t < n; t++)
                e.material[t] = p(e.material[t]);
            else e.material = p(e.material);
            (c[e.uuid] = e.onBeforeRender), (e.onBeforeRender = v);
          }
        }

        function g(e) {
          if (!1 !== f(e)) {
            if (Array.isArray(e.material))
              for (let t = 0, n = e.material.length; t < n; t++)
                e.material[t] = l[e.material[t].uuid];
            else e.material = l[e.material.uuid];
            e.onBeforeRender = c[e.uuid];
          }
        }

        function v(e, t, n, r, i) {
          const o = l[i.uuid];
          void 0 !== o &&
            (function (e, t) {
              const n = t.userData.outlineParameters;
              (e.uniforms.outlineAlpha.value = t.opacity),
                void 0 !== n &&
                  (void 0 !== n.thickness &&
                    (e.uniforms.outlineThickness.value = n.thickness),
                  void 0 !== n.color &&
                    e.uniforms.outlineColor.value.fromArray(n.color),
                  void 0 !== n.alpha &&
                    (e.uniforms.outlineAlpha.value = n.alpha));
              t.displacementMap &&
                ((e.uniforms.displacementMap.value = t.displacementMap),
                (e.uniforms.displacementScale.value = t.displacementScale),
                (e.uniforms.displacementBias.value = t.displacementBias));
            })(i, o);
        }
        (this.render = function (t, n) {
          let r,
            i = !1;
          if (
            (void 0 !== arguments[2] &&
              (console.warn(
                "THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
              ),
              (r = arguments[2])),
            void 0 !== arguments[3] &&
              (console.warn(
                "THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead."
              ),
              (i = arguments[3])),
            void 0 !== r && e.setRenderTarget(r),
            i && e.clear(),
            !1 === this.enabled)
          )
            return void e.render(t, n);
          const o = e.autoClear;
          (e.autoClear = this.autoClear),
            e.render(t, n),
            (e.autoClear = o),
            this.renderOutline(t, n);
        }),
          (this.renderOutline = function (t, n) {
            const r = e.autoClear,
              i = t.autoUpdate,
              o = t.background,
              a = e.shadowMap.enabled;
            (t.autoUpdate = !1),
              (t.background = null),
              (e.autoClear = !1),
              (e.shadowMap.enabled = !1),
              t.traverse(m),
              e.render(t, n),
              t.traverse(g),
              (function () {
                let e;
                e = Object.keys(l);
                for (let t = 0, n = e.length; t < n; t++) l[e[t]] = void 0;
                e = Object.keys(c);
                for (let t = 0, n = e.length; t < n; t++) c[e[t]] = void 0;
                e = Object.keys(s);
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  !1 === s[n].used
                    ? (s[n].count++,
                      !1 === s[n].keepAlive && s[n].count > 60 && delete s[n])
                    : ((s[n].used = !1), (s[n].count = 0));
                }
              })(),
              (t.autoUpdate = i),
              (t.background = o),
              (e.autoClear = r),
              (e.shadowMap.enabled = a);
          }),
          (this.autoClear = e.autoClear),
          (this.domElement = e.domElement),
          (this.shadowMap = e.shadowMap),
          (this.clear = function (t, n, r) {
            e.clear(t, n, r);
          }),
          (this.getPixelRatio = function () {
            return e.getPixelRatio();
          }),
          (this.setPixelRatio = function (t) {
            e.setPixelRatio(t);
          }),
          (this.getSize = function (t) {
            return e.getSize(t);
          }),
          (this.setSize = function (t, n, r) {
            e.setSize(t, n, r);
          }),
          (this.setViewport = function (t, n, r, i) {
            e.setViewport(t, n, r, i);
          }),
          (this.setScissor = function (t, n, r, i) {
            e.setScissor(t, n, r, i);
          }),
          (this.setScissorTest = function (t) {
            e.setScissorTest(t);
          }),
          (this.setRenderTarget = function (t) {
            e.setRenderTarget(t);
          });
      }
    }
    var Ae,
      Ce,
      Pe = (function () {
        function e(e, t, n, i, o, a, s) {
          (this.activeCameraChanged = function (e) {}),
            (this.cameraO = new r.OrthographicCamera(
              e / -2,
              e / 2,
              t / 2,
              t / -2,
              a,
              s
            )),
            (this.cameraP = new r.PerspectiveCamera(n, e / t, i, o)),
            (this.inOrthographicMode = !0),
            this.toPerspective();
        }
        return (
          (e.prototype.toPerspective = function () {
            this.cameraP.updateMatrixWorld(!1),
              this.cameraP.updateProjectionMatrix(),
              this.inOrthographicMode &&
                ((this.inPerspectiveMode = !0),
                (this.inOrthographicMode = !1),
                (this.camera = this.cameraP),
                this.activeCameraChanged(this.camera));
          }),
          (e.prototype.toOrthographic = function () {
            var e = this.cameraP.fov,
              t = this.cameraP.aspect,
              n = (this.cameraP.near + this.cameraP.far) / 2,
              r = Math.tan((e * Math.PI) / 180 / 2) * n,
              i = r * t;
            (r /= this.cameraP.zoom),
              (i /= this.cameraP.zoom),
              (this.cameraO.left = -i),
              (this.cameraO.right = i),
              (this.cameraO.top = r),
              (this.cameraO.bottom = -r),
              (this.cameraO.view = this.cameraP.view),
              this.cameraO.updateMatrixWorld(!1),
              this.cameraO.updateProjectionMatrix(),
              this.inPerspectiveMode &&
                ((this.inPerspectiveMode = !1),
                (this.inOrthographicMode = !0),
                (this.camera = this.cameraO),
                this.activeCameraChanged(this.camera));
          }),
          e
        );
      })(),
      Le = (function () {
        function e(e) {
          var t = this;
          if (
            ((this.scene = new r.Scene()),
            (this.lookAtTarget = null),
            (this.lookFromOrigin = null),
            (this.lookCallback = null),
            (this.timer = 0),
            (this.controlPositionMaxRadius = 1 / 0),
            (this.controlPositionMinHeight = -1 / 0),
            (this.backgroundScene = null),
            (this.foregroundScene = new r.Object3D()),
            (this.renderUsingComposer = null),
            (this.animations = []),
            (this.screenshotAsBase64JPGCallback = null),
            (this.renderer = new r.WebGLRenderer({
              antialias: !0,
            })),
            this.renderer.setPixelRatio(window.devicePixelRatio),
            e)
          ) {
            var n = e.getBoundingClientRect();
            this.renderer.setSize(n.width, n.height);
          } else this.renderer.setSize(window.innerWidth, window.innerHeight);
          (e = e || document.body).appendChild(this.renderer.domElement),
            (this.cameraCombiner = new Pe(
              window.innerWidth,
              window.innerHeight,
              46,
              1,
              16e3,
              -16e3,
              16e3
            )),
            (this.camera = this.cameraCombiner.cameraP),
            this.camera.position.set(0, 0, 10),
            this.scene.add(this.cameraCombiner.cameraP),
            this.scene.add(this.cameraCombiner.cameraO),
            (this.controls = new Te(
              this.cameraCombiner.cameraP,
              this.renderer.domElement
            )),
            document.body.addEventListener("keydown", function (e) {
              if (t.controls.enabled) {
                t.controls.enableDamping = !0;
                var n = t.controls.object.position,
                  i = t.controls.target,
                  o = i.clone().sub(n);
                (o.y = 0), o.normalize().multiplyScalar(10);
                new r.Vector3(0, 1, 0);
                var a = new r.Euler(0, (Math.PI / 180) * 1.5, 0);
                switch (e.code) {
                  case "ArrowUp":
                    e.stopPropagation(), n.add(o);
                    break;
                  case "ArrowDown":
                    e.stopPropagation(), n.sub(o);
                    break;
                  case "ArrowLeft":
                    e.stopPropagation(),
                      e.shiftKey
                        ? n.add(
                            o.clone().applyEuler(new r.Euler(0, Math.PI / 2, 0))
                          )
                        : o.applyEuler(a);
                    break;
                  case "ArrowRight":
                    e.stopPropagation(),
                      e.shiftKey
                        ? n.add(
                            o
                              .clone()
                              .applyEuler(new r.Euler(0, -Math.PI / 2, 0))
                          )
                        : ((a.y *= -1), o.applyEuler(a));
                    break;
                  default:
                    return;
                }
                (n.y = 0.97 * n.y - 60 * 0.03),
                  i.copy(n.clone().add(o.multiplyScalar(10))),
                  t.controls.update();
              }
            }),
            (this.cameraCombiner.activeCameraChanged = function (e) {
              (t.camera = e),
                (t.controls.object = e),
                t.cameraCombiner.inOrthographicMode && (e.zoom = 10);
            }),
            (this.controls.enableDamping = !0),
            (this.backgroundScene = null),
            window.addEventListener(
              "resize",
              this.onWindowResize.bind(this),
              !1
            ),
            (this.controlPositionMaxRadius = 1 / 0),
            (this.controlPositionMinHeight = -1 / 0),
            (this.lookAtTarget = null),
            (this.lookFromOrigin = null),
            (this.renderer.autoClear = !1),
            this.myAnimate(),
            this.animate(
              function () {
                var e = this.controls.object;
                e.position.length() > 0 &&
                  e.position.clampLength(0, this.controlPositionMaxRadius),
                  e.position.y < this.controlPositionMinHeight &&
                    (e.position.y = this.controlPositionMinHeight);
                return (
                  this.lookAtTarget &&
                    (this.lookAtTarget.length() > 0 &&
                      this.lookAtTarget.clampLength(
                        0,
                        this.controlPositionMaxRadius
                      ),
                    this.controls.target.lerp(this.lookAtTarget, 0.05),
                    this.controls.target.distanceToSquared(this.lookAtTarget) <
                      25 && (this.lookAtTarget = null)),
                  this.lookFromOrigin &&
                    (this.lookFromOrigin.length() > 0 &&
                      this.lookFromOrigin.clampLength(
                        0,
                        this.controlPositionMaxRadius
                      ),
                    e.position.lerp(this.lookFromOrigin, 0.05),
                    e.position.distanceToSquared(this.lookFromOrigin) < 25 &&
                      (this.lookFromOrigin = null)),
                  !this.lookCallback ||
                    this.lookFromOrigin ||
                    this.lookAtTarget ||
                    (this.lookCallback(), (this.lookCallback = null)),
                  e.updateProjectionMatrix(),
                  this.controls.update(),
                  !0
                );
              }.bind(this)
            );
        }
        return (
          Object.defineProperty(e.prototype, "isStillMoving", {
            get: function () {
              return !(!this.lookAtTarget && !this.lookFromOrigin);
            },
            enumerable: !1,
            configurable: !0,
          }),
          (e.prototype.myAnimate = function () {
            var e = this;
            requestAnimationFrame(this.myAnimate.bind(this)),
              this.controls.update();
            for (var t = []; this.animations.length > 0; ) {
              var n = this.animations.shift();
              n(this.timer) && t.push(n);
            }
            this.timer++, (this.animations = t);
            var r = this.camera,
              i = this.renderUsingComposer;
            if (
              (i ||
                (i = function () {
                  e.renderer.clear(!1, !0, !0), e.renderer.render(e.scene, r);
                }),
              this.backgroundScene && this.scene.add(this.backgroundScene),
              this.foregroundScene &&
                (this.scene.add(this.foregroundScene),
                this.foregroundScene.layers.set(1),
                this.foregroundScene.traverse(function (e) {
                  return e.layers.set(1);
                })),
              this.backgroundScene &&
                (this.backgroundScene.layers.set(2),
                r.layers.set(2),
                i(),
                this.renderer.clearDepth()),
              r.layers.set(0),
              i(),
              !this.isStillMoving && this.foregroundScene)
            ) {
              var o = this.scene.background;
              (this.scene.background = null),
                r.layers.set(1),
                i(),
                (this.scene.background = o);
            }
            r.layers.set(0),
              this.foregroundScene && this.scene.remove(this.foregroundScene),
              this.backgroundScene && this.scene.remove(this.backgroundScene),
              this.screenshotAsBase64JPGCallback &&
                (this.screenshotAsBase64JPGCallback(),
                (this.screenshotAsBase64JPGCallback = null));
          }),
          (e.prototype.initPaperMode = function () {
            var e = this,
              t = new Ee(this.renderer, {
                defaultThickNess: 0.01,
                defaultColor: new r.Color(0),
                defaultAlpha: 1,
                defaultKeepAlive: !0,
              });
            this.renderUsingComposer = function () {
              t.render(e.scene, e.camera);
            };
          }),
          (e.prototype.animate = function (e) {
            this.animations.push(e);
          }),
          (e.prototype.clearAnimations = function () {
            for (; this.animations.length > 1; ) this.animations.pop();
          }),
          (e.prototype.lookAt = function (e, t, n) {
            return (
              (this.lookAtTarget =
                "object" == typeof e ? e.clone() : new r.Vector3(e, t, n)),
              this
            );
          }),
          (e.prototype.lookFrom = function (e, t, n) {
            return (
              (this.lookFromOrigin =
                "object" == typeof e ? e.clone() : new r.Vector3(e, t, n)),
              this
            );
          }),
          (e.prototype.setControlLimits = function (e, t) {
            (this.controlPositionMaxRadius = e),
              (this.controlPositionMinHeight = t);
          }),
          (e.prototype.onWindowResize = function () {
            (this.camera.aspect = window.innerWidth / window.innerHeight),
              this.camera.updateProjectionMatrix(),
              this.renderer.setSize(window.innerWidth, window.innerHeight);
          }),
          (e.prototype.screenshotAsBase64EncodedJpg = function (e, t) {
            this.screenshotAsBase64JPGCallback = function () {
              var n = this.renderer.domElement.toDataURL("image/jpg");
              if (t && t.resize) {
                var r = new Image();
                (r.onload = function () {
                  var t = document.createElement("canvas");
                  (t.width = 640), (t.height = 480);
                  var n = t.getContext("2d");
                  (n.fillStyle = "black"), n.fillRect(0, 0, t.width, t.height);
                  var i,
                    o,
                    a,
                    s,
                    l,
                    c =
                      ((i = t.width),
                      (o = t.height),
                      (a = r.width),
                      (s = r.height),
                      (l = s / a),
                      a >= i && l <= 1
                        ? ((a = i), (s = i * l))
                        : s >= o && ((s = o), (a = o / l)),
                      {
                        width: a,
                        height: s,
                      }),
                    u = (t.width - c.width) / 2,
                    h = (t.height - c.height) / 2;
                  n.drawImage(r, u, h, c.width, c.height);
                  var d = t.toDataURL("image/jpg");
                  return e(d);
                }),
                  (r.src = n);
              } else e(n);
            };
          }),
          (e.prototype.lookFromTo = function (e, t, n) {
            this.lookAt(t),
              this.lookFrom(e),
              (this.lookCallback = n || this.lookCallback);
          }),
          (e.prototype.lookAtObject = function (e, t, n, i, o) {
            var a = this.scene.getObjectByName(e);
            if (a) {
              this.scene.updateMatrixWorld();
              var s = new r.Vector3(0, 0, 0),
                l = "object" == typeof t ? t.clone() : new r.Vector3(t, n, i);
              a.localToWorld(s), a.localToWorld(l), this.lookFromTo(l, s, o);
            }
          }),
          (e.prototype.lookFromObjectTo = function (e, t, n, i, o) {
            var a = this.scene.getObjectByName(e);
            if (a) {
              this.scene.updateMatrixWorld();
              var s = "object" == typeof t ? t.clone() : new r.Vector3(t, n, i),
                l = new r.Vector3(0, 0, 0);
              a.localToWorld(l), this.lookFromTo(l, s, o);
            }
          }),
          (e.prototype.lookFromObjectAtObject = function (e, t, n) {
            var i = this.scene.getObjectByName(e),
              o = this.scene.getObjectByName(t);
            if (i && o) {
              this.scene.updateMatrixWorld();
              var a = new r.Vector3(0, 0, 0),
                s = new r.Vector3(0, 0, 0);
              o.localToWorld(a), i.localToWorld(s), this.lookFromTo(s, a, n);
            }
          }),
          (e.prototype.setBackgroundMesh = function (e) {
            this.backgroundScene && (this.backgroundScene = null),
              e &&
                ((this.backgroundScene = new r.Object3D()),
                e.layers.set(2),
                this.backgroundScene.add(e));
          }),
          (e.prototype.setForegroundScene = function (e) {
            this.foregroundScene && (this.foregroundScene = new r.Object3D()),
              e &&
                (this.foregroundScene.add(e),
                this.foregroundScene.layers.set(1),
                this.foregroundScene.traverse(function (e) {
                  return e.layers.set(1);
                }));
          }),
          (e.prototype.setBackgroundTexture = function (e) {
            this.scene.background = e;
          }),
          e
        );
      })(),
      Re = (function () {
        function e(e, t) {
          (this.env = new Le()),
            (this.placeholder = new r.Object3D()),
            (this.lookFromObjectTo = function (e, t, n, r, i) {
              return this.env.lookFromObjectTo(e, t, n, r, i);
            }),
            (this.builder = e),
            (this.backgroundConfigurations = t);
          var n = this.env;
          (n.renderer.shadowMap.enabled = !0),
            (n.renderer.shadowMap.type = r.PCFSoftShadowMap),
            (n.renderer.shadowMap.autoUpdate = !0),
            (window.env = n),
            (window.scene = n.scene),
            window.scene.add(this.placeholder);
          var i = new r.DirectionalLight(16777215, 1);
          i.castShadow = !0;
          var o = i.shadow.camera;
          (o.left = -1024),
            (o.right = 1024),
            (o.top = -1024),
            (o.bottom = 1024),
            (o.near = -1024),
            (o.far = 1024),
            (i.shadow.bias = -0.0075),
            (i.name = "sun"),
            i.position.set(-0.6, 1.08, -1.32),
            n.scene.add(i);
          var a = new r.AmbientLight(16777215, 0.3);
          a.position.copy(i.position.clone().negate()),
            n.scene.add(a),
            (n.controls.rotateSpeed = 0.5),
            (n.controls.autoRotateSpeed = -0.57),
            (n.renderer.domElement.onmousedown = function () {
              (n.controls.autoRotate = !1), (n.lookFromOrigin = null);
            }),
            n.renderer.render(n.scene, n.camera);
        }
        return (
          Object.defineProperty(e.prototype, "domElement", {
            get: function () {
              return this.env.renderer.domElement;
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "scene", {
            get: function () {
              return this.env.scene;
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "isStillMoving", {
            get: function () {
              return this.env.isStillMoving;
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "camera", {
            get: function () {
              return this.env.camera;
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "controls", {
            get: function () {
              return this.env.controls;
            },
            enumerable: !1,
            configurable: !0,
          }),
          (e.prototype.animate = function (e) {
            this.env.animate(e);
          }),
          (e.prototype.clearAnimations = function () {
            this.env.clearAnimations();
          }),
          (e.prototype.setAutoRotate = function (e) {
            (this.env.controls.autoRotate = e),
              e && (this.env.lookFromOrigin = null);
          }),
          (e.prototype.getObjectByName = function (e) {
            return this.env.scene.getObjectByName(e);
          }),
          (e.prototype.setBackgroundConfigurationKey = function (e, t) {
            if (this.backgroundConfigurations) {
              var n = this.backgroundConfigurations.getConfiguration(e),
                r = this.builder.backgroundSphere(n.radius, -n.floorHeight);
              (r.position.y -= 210 - n.floorHeight),
                this.env.setBackgroundMesh(r),
                this.env.setControlLimits(n.radius - 100, 150 - n.floorHeight),
                this.builder.setEnvironmentTextureFromUrl(n.url, function (e) {
                  r.material, t(e);
                }),
                this.env.setBackgroundTexture(null);
            }
          }),
          (e.prototype.setForeGroundScene = function (e) {
            this.env.setForegroundScene(e);
          }),
          (e.prototype.setBackgroundImage = function (e, t) {
            var n = this;
            void 0 === t && (t = !0);
            var i = function (e) {
              if (t) {
                var r = n.env.controls;
                r.enabled =
                  r.enableKeys =
                  r.enablePan =
                  r.enableRotate =
                  r.enableZoom =
                    e;
              }
            };
            if (!e) return this.env.setBackgroundTexture(), void i(!0);
            i(!0);
            var o = document.createElement("canvas");
            (o.width = window.innerWidth), (o.height = window.innerHeight);
            var a = o.getContext("2d");
            (a.fillStyle = "white"), a.fillRect(0, 0, o.width, o.height);
            var s =
                (window.innerWidth / window.innerHeight / e.width) * e.height,
              l = 1;
            s > 1 && ((l /= s), (s = 1));
            var c = window.innerWidth * l,
              u = window.innerHeight * s,
              h = (window.innerWidth - c) / 2,
              d = (window.innerHeight - u) / 2;
            a.drawImage(e, h, d, c, u);
            var p = new r.Texture(o);
            (p.needsUpdate = !0), this.env.setBackgroundTexture(p);
          }),
          (e.prototype.addOrReplaceObject = function (e) {
            var t = this.placeholder.getObjectByName(e.name);
            t && this.placeholder.remove(t), this.placeholder.add(e);
          }),
          (e.prototype.lookAtObject = function (e, t, n, r, i) {
            return this.env.lookAtObject(e, t, n, r, i);
          }),
          (e.prototype.lookFromTo = function (e, t, n) {
            return this.env.lookFromTo(e, t, n);
          }),
          e
        );
      })(),
      Ie =
        ((Ae = function (e, t) {
          return (Ae =
            Object.setPrototypeOf ||
            ({
              __proto__: [],
            } instanceof Array &&
              function (e, t) {
                e.__proto__ = t;
              }) ||
            function (e, t) {
              for (var n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            })(e, t);
        }),
        function (e, t) {
          function n() {
            this.constructor = e;
          }
          Ae(e, t),
            (e.prototype =
              null === t
                ? Object.create(t)
                : ((n.prototype = t.prototype), new n()));
        }),
      ke = be.Builder;
    !(function (e) {
      var t = function (e, t, n, i) {
        (this.asDropTargetId = null),
          (this.asDropTargetUniqueId = null),
          (this.mesh = e),
          (e = e.clone()).position.set(0, 0, 0),
          e.rotation.set(0, 0, 0);
        var o = new r.Box3().setFromObject(e);
        (this.localBoundingBox = new r.Box2(
          new r.Vector2(o.min.x, o.min.y),
          new r.Vector2(o.max.x, o.max.y)
        )),
          (this.grid = t),
          (this.asDropTargetId = n),
          (this.asDropTargetUniqueId = i);
      };
      e.IntersectableMesh = t;
      var n = (function (e) {
        function t(t, n, i, o, a, s) {
          var l = this,
            c = new r.Object3D();
          c.position.copy(t.position),
            c.rotation.copy(t.rotation),
            (c.name = t.name),
            (t.name += " inner"),
            t.position.set(0, 0, 0),
            t.rotation.set(0, 0, 0),
            t.parent && t.parent.add(c),
            c.add(t);
          var u = new r.CircleBufferGeometry();
          try {
            var h = t.clone();
            h.rotation.set(0, 0, 0);
            var d = i && !i.isEmpty() ? i : new r.Box3().setFromObject(h),
              p = new r.Vector3();
            d.getSize(p);
            var f = [
                new r.Vector2(d.min.x, d.min.y),
                new r.Vector2(d.min.x, d.max.y),
                new r.Vector2(d.max.x, d.max.y),
                new r.Vector2(d.max.x, d.min.y),
              ],
              m = new r.Shape(f);
            u = new r.ShapeBufferGeometry(m);
          } catch (e) {
            console.error("Error building intersectable object: ", {
              obj: t,
              verts: f,
              dimensions: i,
            });
          }
          var g =
            window.canDropMaterial ||
            new r.MeshStandardMaterial({
              color: 16777215,
              transparent: !0,
              opacity: 0.5,
              map: new r.TextureLoader().load(
                kt("textures/uv_grid.jpg"),
                function (e) {
                  e.repeat.setScalar(0.01),
                    (e.wrapS = e.wrapT = r.RepeatWrapping);
                }
              ),
            });
          window.canDropMaterial = g;
          var v = new r.Mesh(u, g);
          return (
            new ke(2, null).remapUV(v),
            (v.position.z += 3),
            c.add(v),
            (l = e.call(this, v, o, a, s) || this),
            (v.visible = !1),
            (l.object = c),
            (l.dropTargetId = n),
            l
          );
        }
        return (
          Ie(t, e),
          Object.defineProperty(t.prototype, "name", {
            get: function () {
              return this.object.name;
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "intersectable", {
            get: function () {
              return this;
            },
            enumerable: !1,
            configurable: !0,
          }),
          t
        );
      })(t);
      e.IntersectableObject = n;
      var i = function (e, t, n) {
        if (!t) {
          var i = e;
          return (
            (this.localPoint = new r.Vector2(0, 0)),
            (this.quadrant = new r.Vector2(0, 0)),
            (this.floatingPosition = new r.Vector3(0, 0, 0.5)),
            void (this.intersected = i)
          );
        }
        var o = e;
        if (
          ((this.intersected = t.filter(function (e) {
            return e.intersectable.mesh === o.object;
          })[0]),
          this.intersected)
        ) {
          var a = this.intersected.intersectable.mesh.worldToLocal(o.point);
          this.localPoint = new r.Vector2(a.x, a.y);
          var s = new r.Vector2();
          this.intersected.intersectable.localBoundingBox.getSize(s);
          var l = new r.Vector2(0, 0);
          a.x + 10 < -s.width / 4
            ? (l.x = -1)
            : a.x - 10 > s.width / 4
            ? (l.x = 1)
            : (l.x = 0),
            a.y + 10 < -s.height / 4
              ? (l.y = -1)
              : a.y - 10 > s.height / 4
              ? (l.y = 1)
              : (l.y = 0),
            (this.quadrant = l),
            (this.floatingPosition = n);
        }
      };
      e.Intersection = i;
      var o = (function () {
        function e(e, t) {
          (this.camera = e),
            (this._domElement = t),
            (this.floatingObjects = this.rootObject.getObjectByName(n));
          var n = "floating objects";
          this.floatingObjects ||
            ((this.floatingObjects = new r.Object3D()),
            (this.floatingObjects.name = n),
            this.rootObject.add(this.floatingObjects)),
            (this.rayCaster = new r.Raycaster());
        }
        return (
          Object.defineProperty(e.prototype, "camera", {
            get: function () {
              return this._camera;
            },
            set: function (e) {
              if (this._camera !== e)
                for (
                  this._camera = e, this.rootObject = this.camera;
                  this.rootObject.parent;

                )
                  this.rootObject = this.rootObject.parent;
            },
            enumerable: !1,
            configurable: !0,
          }),
          (e.prototype.intersectPointer = function (e, t) {
            var n = this._domElement.getBoundingClientRect(),
              o = ((e.clientX - n.left) / window.innerWidth) * 2 - 1,
              a = (-(e.clientY - n.top) / window.innerHeight) * 2 + 1;
            this.rayCaster.setFromCamera(
              {
                x: o,
                y: a,
              },
              this.camera
            ),
              this.rootObject.updateMatrixWorld(!1);
            var s = t.map(function (e) {
                return e.intersectable.mesh;
              }),
              l = s.map(function (e) {
                return e.visible;
              });
            s.forEach(function (e) {
              return (e.visible = !0);
            });
            var c = this.rayCaster.intersectObjects(s, !1);
            if (
              (s.forEach(function (e, t) {
                return (e.visible = l[t]);
              }),
              0 !== c.length)
            ) {
              var u = new r.Vector3(o, a, 0.5);
              return (
                u.unproject(this.camera), c.length ? new i(c[0], t, u) : null
              );
            }
          }),
          (e.prototype.floatDraggableAtMousePosition = function (e, t) {
            if (e && e.intersected) {
              var n = e.intersected;
              n.shouldClone &&
                (n = Object.assign({}, n, {
                  shouldClone: !1,
                  intersectable: {
                    mesh: n.intersectable.mesh.clone(),
                    localBoundingBox: n.intersectable.localBoundingBox,
                    object: n.intersectable.object.clone(),
                    dropTargetId: n.intersectable.dropTargetId,
                  },
                })),
                (e.intersected = n);
              var r = n.intersectable.object;
              this.rootObject.updateMatrixWorld(!1),
                this.camera.updateMatrixWorld(!1);
              var i = this.getFloatingPosition(t);
              for (
                r.position.copy(i),
                  r.rotation.setFromRotationMatrix(this.camera.matrix);
                this.floatingObjects.children.length;

              )
                this.floatingObjects.remove(this.floatingObjects.children[0]);
              return (
                r.scale.setScalar(n.screenScale), this.floatingObjects.add(r), e
              );
            }
          }),
          (e.adjustElementPosition = function (e, t, n) {
            var i,
              o = new r.Vector2();
            e.getCenter(o);
            var a = new r.Vector2();

            function s(e, t, n, r, i) {
              return (
                t <= 0 && (t += r - 1),
                n <= 0 && (n += r - 1),
                e != t && e != n && (e = Math.round(e / i) * i),
                Math.min(n, Math.max(t, e))
              );
            }
            e.getSize(a);
            var l = t.intersectable.localBoundingBox.clone();
            if (t.grid) {
              var c = t.grid.filter(function (e) {
                return e.containsPoint(o);
              });
              if (0 === c.length) {
                var u = t.grid.map(function (e) {
                    return e.distanceToPoint(o);
                  }),
                  h = u.reduce(
                    function (e, t, n) {
                      return e.d < t
                        ? {
                            i: n,
                            d: t,
                          }
                        : e;
                    },
                    {
                      i: 0,
                      d: u[0],
                    }
                  ).i;
                c = [t.grid[h]];
              }
              l = c[0].clone();
            }
            var d = new r.Vector2();
            l.getSize(d);
            var p = null !== (i = n.resizeStepSize) && void 0 !== i ? i : 1;
            return (
              (a.height = s(a.height, n.minHeight, n.maxHeight, d.height, p)),
              (a.width = s(a.width, n.minWidth, n.maxWidth, d.width, p)),
              l.expandByVector(a.clone().divideScalar(-2)),
              l.isEmpty() ? l.getCenter(o) : l.clampPoint(o, o),
              new r.Box2().setFromCenterAndSize(o, a)
            );
          }),
          (e.prototype.generateQuickGuid = function () {
            return (
              Math.random().toString(36).substring(2, 15) +
              Math.random().toString(36).substring(2, 15)
            );
          }),
          (e.prototype.attachDraggableToDropTarget = function (t, n) {
            for (; this.floatingObjects.children.length; )
              this.floatingObjects.remove(this.floatingObjects.children[0]);
            if (!n || !n.intersected) return null;
            var i = t.intersected.intersectable,
              o = n.localPoint.clone().sub(t.localPoint),
              a = new r.Vector2();
            t.intersected.originalBoundingBox.getSize(a);
            var s = new r.Vector2();
            t.intersected.originalBoundingBox.getCenter(s),
              n.intersected.intersectable.mesh.parent.add(i.object),
              i.object.scale.copy(t.intersected.originalScale);
            var l = o.sub(s),
              c = new r.Box2().setFromCenterAndSize(s, a),
              u = new r.Vector2(t.intersected.width, t.intersected.height),
              h = new r.Vector2();
            n.intersected.intersectable.localBoundingBox.getSize(h);
            var d = a.clone().sub(u);
            switch (
              (t.intersected.maxWidth === t.intersected.minWidth &&
                t.intersected.width === t.intersected.minWidth &&
                (t.quadrant.x = 0),
              t.intersected.maxHeight === t.intersected.minHeight &&
                t.intersected.height === t.intersected.minHeight &&
                (t.quadrant.y = 0),
              t.quadrant.x)
            ) {
              case -1:
                (c.min.x += l.x), c.max.x - c.min.x + d.width;
                break;
              case 1:
                (c.max.x += l.x), c.max.x - c.min.x + d.width;
                break;
              case 0:
                (c.min.x += l.x), (c.max.x += l.x);
            }
            switch (t.quadrant.y) {
              case -1:
                (c.min.y += l.y), c.max.y - c.min.y + d.height;
                break;
              case 1:
                (c.max.y += l.y), c.max.y - c.min.y + d.height;
                break;
              case 0:
                (c.min.y += l.y), (c.max.y += l.y);
            }
            c.copy(e.adjustElementPosition(c, n.intersected, t.intersected)),
              c.getCenter(o);
            var p = new r.Vector2();
            return (
              c.getSize(p),
              i.object.position.set(o.x, o.y, 5),
              (i.localBoundingBox.min.x = -p.x / 2),
              (i.localBoundingBox.max.x = p.x / 2),
              (i.localBoundingBox.min.y = -p.y / 2),
              (i.localBoundingBox.max.y = p.y / 2),
              (i.object.scale.x = p.x / a.x),
              (i.object.scale.y = p.y / a.y),
              i.object.rotation.set(0, 0, 0),
              {
                droppableId: t.intersected.id,
                dropTargetId: n.intersected.dropTargetId,
                dropTargetName: n.intersected.name,
                position: o.toArray(),
                rotation: [0, 0, 0],
                intersectable: t.intersected.intersectable,
                allowedDropTargets: t.intersected.allowedDropTargets,
                elementId: t.intersected.elementId,
                category: t.intersected.category,
                extendDropArea: t.intersected.extendDropArea,
                id: t.intersected.id,
                localBoundingBox: i.localBoundingBox,
                originalScale: t.intersected.originalScale,
                shouldClone: !1,
                screenScale: t.intersected.screenScale,
                screenPosition: t.intersected.screenPosition,
                minWidth: t.intersected.minWidth,
                maxWidth: t.intersected.maxWidth,
                resizeStepSize: t.intersected.resizeStepSize,
                width: p.width,
                height: p.height,
                minHeight: t.intersected.minHeight,
                maxHeight: t.intersected.maxHeight,
                originalBoundingBox: t.intersected.originalBoundingBox,
                opts: t.intersected.opts,
                windowOpts: t.intersected.windowOpts,
                float: !!t.intersected.float,
                grid: n.intersected.grid,
                useMaterialFromDropTarget:
                  t.intersected.useMaterialFromDropTarget,
                asDropTargetId: t.intersected.asDropTargetId,
                asDropTargetUniqueId:
                  t.intersected.asDropTargetUniqueId ||
                  this.generateQuickGuid(),
                droppedOnUniqueId: n.intersected.asDropTargetUniqueId,
                renderImage: t.intersected.renderImage,
              }
            );
          }),
          (e.prototype.getFloatingPosition = function (e) {
            var t = e.target.getBoundingClientRect(),
              n = ((e.clientX - t.left) / window.innerWidth) * 2 - 1,
              i = (-(e.clientY - t.top) / window.innerHeight) * 2 + 1,
              o = new r.Vector3(n, i, 0.5);
            return (o = o.unproject(this.camera));
          }),
          e
        );
      })();
      e.Intersector = o;
      var a = (function () {
        function e(e) {
          (this.dropped = []),
            (this.dropTargets = []),
            (this.draggables = []),
            (this.activeDropTargetIds = []),
            (this.emitEvent = function (e) {}),
            (this.intersector = e);
        }
        return (
          (e.prototype.addEventListeners = function (e, t) {
            var n = this,
              r = [
                "pointerdown",
                "pointermove",
                "pointerup",
                "dragover",
                "drop",
                "pointerleave",
              ].map(function (r) {
                var i = function (r) {
                  n.activeDropTargetIds.length &&
                    r.target === e &&
                    (n.processPointerEvent(r),
                    (t.enabled = !(
                      n.draggableIntersection &&
                      n.draggableIntersection.intersected
                    )),
                    window.env.camera.isOrthographicCamera &&
                      (t.enableRotate = !1));
                };
                return (
                  e.addEventListener(r, i),
                  {
                    evt: r,
                    handler: i,
                  }
                );
              });
            return function () {
              return r.forEach(function (t) {
                return e.removeEventListener(t.evt, t.handler);
              });
            };
          }),
          Object.defineProperty(e.prototype, "activeDraggables", {
            get: function () {
              var e = this;
              return this.draggables.concat(this.dropped).filter(function (t) {
                return (
                  t.allowedDropTargets === [] ||
                  t.allowedDropTargets.some(function (t) {
                    return e.activeDropTargetIds.indexOf(t) > -1;
                  })
                );
              });
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(e.prototype, "activeDropTargets", {
            get: function () {
              var e = this;
              return this.dropTargets.filter(function (t) {
                return (
                  e.draggableIntersection.intersected.allowedDropTargets.indexOf(
                    t.dropTargetId
                  ) > -1
                );
              });
            },
            enumerable: !1,
            configurable: !0,
          }),
          (e.prototype.beginDrag = function (e, t) {
            var n = this.draggables.filter(function (t) {
              return t.elementId == e;
            })[0];
            (this.draggableIntersection = new i(n, null, null)),
              (this.draggableIntersection =
                this.intersector.floatDraggableAtMousePosition(
                  this.draggableIntersection,
                  t
                )),
              (this.targetIntersection = null),
              (this.currentDropped = null);
          }),
          (e.prototype.processPointerEvent = function (e) {
            var t = this;
            if (this.activeDropTargetIds.length) {
              switch (
                ((this.intersector.camera = window.env.camera),
                e.preventDefault(),
                e.type)
              ) {
                case "pointerdown":
                  if (this.draggableIntersection)
                    return void e.preventDefault();
                  (this.draggableIntersection =
                    this.intersector.intersectPointer(
                      e,
                      this.activeDraggables
                    )),
                    this.draggableIntersection &&
                      ((this.draggableIntersection =
                        this.intersector.floatDraggableAtMousePosition(
                          this.draggableIntersection,
                          e
                        )),
                      (this.dropped = this.dropped.filter(function (e) {
                        return (
                          e.intersectable.mesh !==
                          t.draggableIntersection.intersected.intersectable.mesh
                        );
                      })));
                case "pointermove":
                case "dragover":
                  this.draggableIntersection &&
                    (this.targetIntersection &&
                      this.targetIntersection.intersected.intersectable.mesh.parent.remove(
                        this.draggableIntersection.intersected.intersectable
                          .object
                      ),
                    (this.targetIntersection =
                      this.intersector.intersectPointer(
                        e,
                        this.activeDropTargets
                      )),
                    this.targetIntersection
                      ? (this.currentDropped =
                          this.intersector.attachDraggableToDropTarget(
                            this.draggableIntersection,
                            this.targetIntersection
                          ))
                      : (this.intersector.floatDraggableAtMousePosition(
                          this.draggableIntersection,
                          e
                        ),
                        (this.currentDropped = null)));
                  break;
                case "pointerup":
                case "drop":
                case "pointerleave":
                  if (!this.draggableIntersection) return;
                  this.currentDropped
                    ? ((this.dropped = this.dropped.filter(function (e) {
                        if (
                          e.dropTargetId !== t.currentDropped.dropTargetId ||
                          e.dropTargetName !== t.currentDropped.dropTargetName
                        )
                          return !0;
                        var n = e.intersectable.localBoundingBox
                          .clone()
                          .translate(new r.Vector2().fromArray(e.position))
                          .intersect(
                            t.currentDropped.localBoundingBox
                              .clone()
                              .translate(
                                new r.Vector2().fromArray(
                                  t.currentDropped.position
                                )
                              )
                          );
                        if (n.isEmpty()) return !0;
                        var i = new r.Vector2();
                        return n.getSize(i), i.x < 80 || i.height < 80;
                      })),
                      this.dropped.push(this.currentDropped))
                    : (this.dropped = this.dropped.filter(function (e) {
                        return (
                          e.intersectable.mesh !==
                          t.draggableIntersection.intersected.intersectable.mesh
                        );
                      }));
                  var n =
                    this.draggableIntersection.intersected.intersectable.object;
                  n.parent.remove(n),
                    this.emitEvent(this.dragDropChangedEvent),
                    (this.draggableIntersection = null),
                    (this.targetIntersection = null);
              }
              this.updateGUI(e);
            }
          }),
          (e.prototype.updateGUI = function (e) {
            var t = this;
            this.draggableIntersection &&
              (this.targetIntersection &&
                this.targetIntersection.intersected.intersectable.mesh.parent.add(
                  this.draggableIntersection.intersected.intersectable.object
                ),
              this.dropTargets.forEach(function (e) {
                e.intersectable.mesh.visible =
                  !!t.draggableIntersection &&
                  t.draggableIntersection.intersected.allowedDropTargets.indexOf(
                    e.dropTargetId
                  ) > -1;
              }));
            var n =
              this.draggableIntersection ||
              this.intersector.intersectPointer(e, this.activeDraggables);
            if (n) {
              var r = n.intersected;
              (r.maxWidth || r.width) === r.width &&
                (r.minWidth || r.width) === r.width &&
                (n.quadrant.x = 0),
                (r.maxHeight || r.height) === r.height &&
                  (r.minHeight || r.height) === r.height &&
                  (n.quadrant.y = 0);
              e.target.style.cursor = [
                ["neswnwse-resize", "ns-resize", "nwse-resize"],
                ["ew-resize", "move", "ew-resize"],
                ["nwse-resize", "ns-resize", "nesw-resize"],
              ][n.quadrant.y + 1][n.quadrant.x + 1];
            } else e.target.style.cursor = "";
          }),
          Object.defineProperty(e.prototype, "dragDropChangedEvent", {
            get: function () {
              var e = {
                type: "pointerup",
                dropped: [],
              };
              return (
                (e.dropped = this.dropped.map(function (e) {
                  return Object.assign({}, e, {
                    intersectable: {
                      localBoundingBox: e.intersectable.localBoundingBox,
                      mesh: null,
                    },
                  });
                })),
                e
              );
            },
            enumerable: !1,
            configurable: !0,
          }),
          e
        );
      })();
      e.DnDBehavior = a;
    })(Ce || (Ce = {}));
    var De = n(2);
    var Oe = function () {
      return (function (e) {
        var t = {
            R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
            EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
            ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
            ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
            AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
            CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
            B: "a,3,f+2,2v,690",
            S: "9,2,k",
            WS: "c,k,4f4,1vk+a,u,1j,335",
            ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
            BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
            NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
            AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
            LRO: "6ct",
            RLO: "6cu",
            LRE: "6cq",
            RLE: "6cr",
            PDF: "6cs",
            LRI: "6ee",
            RLI: "6ef",
            FSI: "6eg",
            PDI: "6eh",
          },
          n = {},
          r = {};
        (n.L = 1),
          (r[1] = "L"),
          Object.keys(t).forEach(function (e, t) {
            (n[e] = 1 << (t + 1)), (r[n[e]] = e);
          }),
          Object.freeze(n);
        var i = n.LRI | n.RLI | n.FSI,
          o = n.L | n.R | n.AL,
          a = n.B | n.S | n.WS | n.ON | n.FSI | n.LRI | n.RLI | n.PDI,
          s = n.BN | n.RLE | n.LRE | n.RLO | n.LRO | n.PDF,
          l = n.S | n.WS | n.B | i | n.PDI | s,
          c = null;

        function u(e) {
          return (
            (function () {
              if (!c) {
                c = new Map();
                var e = function (e) {
                  if (t.hasOwnProperty(e)) {
                    var r = 0;
                    t[e].split(",").forEach(function (t) {
                      var i = t.split("+"),
                        o = i[0],
                        a = i[1];
                      (o = parseInt(o, 36)),
                        (a = a ? parseInt(a, 36) : 0),
                        c.set((r += o), n[e]);
                      for (var s = 0; s < a; s++) c.set(++r, n[e]);
                    });
                  }
                };
                for (var r in t) e(r);
              }
            })(),
            c.get(e.codePointAt(0)) || n.L
          );
        }
        var h,
          d,
          p,
          f =
            "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
          m =
            "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye";

        function g(e, t) {
          var n,
            r = 0,
            i = new Map(),
            o = t && new Map();
          return (
            e.split(",").forEach(function e(a) {
              if (-1 !== a.indexOf("+")) for (var s = +a; s--; ) e(n);
              else {
                n = a;
                var l = a.split(">"),
                  c = l[0],
                  u = l[1];
                (c = String.fromCodePoint((r += parseInt(c, 36)))),
                  (u = String.fromCodePoint((r += parseInt(u, 36)))),
                  i.set(c, u),
                  t && o.set(u, c);
              }
            }),
            {
              map: i,
              reverseMap: o,
            }
          );
        }

        function v() {
          if (!h) {
            var e = g(f, !0),
              t = e.map,
              n = e.reverseMap;
            (h = t), (d = n), (p = g(m, !1).map);
          }
        }

        function y(e) {
          return v(), h.get(e) || null;
        }

        function x(e) {
          return v(), d.get(e) || null;
        }

        function b(e) {
          return v(), p.get(e) || null;
        }
        var w = n.L,
          _ = n.R,
          M = n.EN,
          S = n.ES,
          T = n.ET,
          E = n.AN,
          A = n.CS,
          C = n.B,
          P = n.S,
          L = n.ON,
          R = n.BN,
          I = n.NSM,
          k = n.AL,
          D = n.LRO,
          O = n.RLO,
          B = n.LRE,
          F = n.RLE,
          N = n.PDF,
          U = n.LRI,
          z = n.RLI,
          H = n.FSI,
          G = n.PDI;
        var V;

        function j(e) {
          return (
            (function () {
              if (!V) {
                var e = g(
                    "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
                    !0
                  ),
                  t = e.map;
                e.reverseMap.forEach(function (e, n) {
                  t.set(n, e);
                }),
                  (V = t);
              }
            })(),
            V.get(e) || null
          );
        }

        function W(e, t, n, r) {
          var i = e.length;
          (n = Math.max(0, null == n ? 0 : +n)),
            (r = Math.min(i - 1, null == r ? i - 1 : +r));
          var o = [];
          return (
            t.paragraphs.forEach(function (i) {
              var a = Math.max(n, i.start),
                s = Math.min(r, i.end);
              if (a < s) {
                for (
                  var c = t.levels.slice(a, s + 1), h = s;
                  h >= a && u(e[h]) & l;
                  h--
                )
                  c[h] = i.level;
                for (var d = i.level, p = 1 / 0, f = 0; f < c.length; f++) {
                  var m = c[f];
                  m > d && (d = m), m < p && (p = 1 | m);
                }
                for (var g = d; g >= p; g--)
                  for (var v = 0; v < c.length; v++)
                    if (c[v] >= g) {
                      for (var y = v; v + 1 < c.length && c[v + 1] >= g; ) v++;
                      v > y && o.push([y + n, v + n]);
                    }
              }
            }),
            o
          );
        }

        function q(e, t, n, r) {
          for (var i = W(e, t, n, r), o = [], a = 0; a < e.length; a++)
            o[a] = a;
          return (
            i.forEach(function (e) {
              for (
                var t = e[0], n = e[1], r = o.slice(t, n + 1), i = r.length;
                i--;

              )
                o[n - i] = r[i];
            }),
            o
          );
        }
        return (
          (e.closingToOpeningBracket = x),
          (e.getBidiCharType = u),
          (e.getBidiCharTypeName = function (e) {
            return r[u(e)];
          }),
          (e.getCanonicalBracket = b),
          (e.getEmbeddingLevels = function (e, t) {
            for (var n = new Uint32Array(e.length), r = 0; r < e.length; r++)
              n[r] = u(e[r]);
            var c = new Map();

            function h(e, t) {
              var r = n[e];
              (n[e] = t),
                c.set(r, c.get(r) - 1),
                r & a && c.set(a, c.get(a) - 1),
                c.set(t, (c.get(t) || 0) + 1),
                t & a && c.set(a, (c.get(a) || 0) + 1);
            }
            for (
              var d = new Uint8Array(e.length),
                p = new Map(),
                f = [],
                m = null,
                g = 0;
              g < e.length;
              g++
            )
              m ||
                f.push(
                  (m = {
                    start: g,
                    end: e.length - 1,
                    level: "rtl" === t ? 1 : "ltr" === t ? 0 : Ht(g, !1),
                  })
                ),
                n[g] & C && ((m.end = g), (m = null));
            for (
              var v = F | B | O | D | i | G | N | C,
                V = function (e) {
                  return e + (1 & e ? 1 : 2);
                },
                j = function (e) {
                  return e + (1 & e ? 2 : 1);
                },
                W = 0;
              W < f.length;
              W++
            ) {
              var q = [
                  {
                    _level: (m = f[W]).level,
                    _override: 0,
                    _isolate: 0,
                  },
                ],
                $ = void 0,
                X = 0,
                Y = 0,
                J = 0;
              c.clear();
              for (var Z = m.start; Z <= m.end; Z++) {
                var K = n[Z];
                if (
                  (($ = q[q.length - 1]),
                  c.set(K, (c.get(K) || 0) + 1),
                  K & a && c.set(a, (c.get(a) || 0) + 1),
                  K & v)
                )
                  if (K & (F | B)) {
                    d[Z] = $._level;
                    var Q = (K === F ? j : V)($._level);
                    Q <= 125 && !X && !Y
                      ? q.push({
                          _level: Q,
                          _override: 0,
                          _isolate: 0,
                        })
                      : X || Y++;
                  } else if (K & (O | D)) {
                    d[Z] = $._level;
                    var ee = (K === O ? j : V)($._level);
                    ee <= 125 && !X && !Y
                      ? q.push({
                          _level: ee,
                          _override: K & O ? _ : w,
                          _isolate: 0,
                        })
                      : X || Y++;
                  } else if (K & i) {
                    K & H && (K = 1 === Ht(Z + 1, !0) ? z : U),
                      (d[Z] = $._level),
                      $._override && h(Z, $._override);
                    var te = (K === z ? j : V)($._level);
                    te <= 125 && 0 === X && 0 === Y
                      ? (J++,
                        q.push({
                          _level: te,
                          _override: 0,
                          _isolate: 1,
                          _isolInitIndex: Z,
                        }))
                      : X++;
                  } else if (K & G) {
                    if (X > 0) X--;
                    else if (J > 0) {
                      for (Y = 0; !q[q.length - 1]._isolate; ) q.pop();
                      var ne = q[q.length - 1]._isolInitIndex;
                      null != ne && (p.set(ne, Z), p.set(Z, ne)), q.pop(), J--;
                    }
                    ($ = q[q.length - 1]),
                      (d[Z] = $._level),
                      $._override && h(Z, $._override);
                  } else
                    K & N
                      ? (0 === X &&
                          (Y > 0
                            ? Y--
                            : !$._isolate &&
                              q.length > 1 &&
                              (q.pop(), ($ = q[q.length - 1]))),
                        (d[Z] = $._level))
                      : K & C && (d[Z] = m.level);
                else
                  (d[Z] = $._level),
                    $._override && K !== R && h(Z, $._override);
              }
              for (var re = [], ie = null, oe = m.start; oe <= m.end; oe++) {
                var ae = n[oe];
                if (!(ae & s)) {
                  var se = d[oe],
                    le = ae & i,
                    ce = ae === G;
                  ie && se === ie._level
                    ? ((ie._end = oe), (ie._endsWithIsolInit = le))
                    : re.push(
                        (ie = {
                          _start: oe,
                          _end: oe,
                          _level: se,
                          _startsWithPDI: ce,
                          _endsWithIsolInit: le,
                        })
                      );
                }
              }
              for (var ue = [], he = 0; he < re.length; he++) {
                var de = re[he];
                if (
                  !de._startsWithPDI ||
                  (de._startsWithPDI && !p.has(de._start))
                ) {
                  for (
                    var pe = [(ie = de)], fe = void 0;
                    ie && ie._endsWithIsolInit && null != (fe = p.get(ie._end));

                  )
                    for (var me = he + 1; me < re.length; me++)
                      if (re[me]._start === fe) {
                        pe.push((ie = re[me]));
                        break;
                      }
                  for (var ge = [], ve = 0; ve < pe.length; ve++)
                    for (var ye = pe[ve], xe = ye._start; xe <= ye._end; xe++)
                      ge.push(xe);
                  for (
                    var be = d[ge[0]], we = m.level, _e = ge[0] - 1;
                    _e >= 0;
                    _e--
                  )
                    if (!(n[_e] & s)) {
                      we = d[_e];
                      break;
                    }
                  var Me = ge[ge.length - 1],
                    Se = d[Me],
                    Te = m.level;
                  if (!(n[Me] & i))
                    for (var Ee = Me + 1; Ee <= m.end; Ee++)
                      if (!(n[Ee] & s)) {
                        Te = d[Ee];
                        break;
                      }
                  ue.push({
                    _seqIndices: ge,
                    _sosType: Math.max(we, be) % 2 ? _ : w,
                    _eosType: Math.max(Te, Se) % 2 ? _ : w,
                  });
                }
              }
              for (var Ae = 0; Ae < ue.length; Ae++) {
                var Ce = ue[Ae],
                  Pe = Ce._seqIndices,
                  Le = Ce._sosType,
                  Re = Ce._eosType;
                if (c.get(I))
                  for (var Ie = 0; Ie < Pe.length; Ie++) {
                    var ke = Pe[Ie];
                    if (n[ke] & I) {
                      for (var De = Le, Oe = Ie - 1; Oe >= 0; Oe--)
                        if (!(n[Pe[Oe]] & s)) {
                          De = n[Pe[Oe]];
                          break;
                        }
                      h(ke, De & (i | G) ? L : De);
                    }
                  }
                if (c.get(M))
                  for (var Be = 0; Be < Pe.length; Be++) {
                    var Fe = Pe[Be];
                    if (n[Fe] & M)
                      for (var Ne = Be - 1; Ne >= -1; Ne--) {
                        var Ue = -1 === Ne ? Le : n[Pe[Ne]];
                        if (Ue & o) {
                          Ue === k && h(Fe, E);
                          break;
                        }
                      }
                  }
                if (c.get(k))
                  for (var ze = 0; ze < Pe.length; ze++) {
                    var He = Pe[ze];
                    n[He] & k && h(He, _);
                  }
                if (c.get(S) || c.get(A))
                  for (var Ge = 1; Ge < Pe.length - 1; Ge++) {
                    var Ve = Pe[Ge];
                    if (n[Ve] & (S | A)) {
                      for (
                        var je = 0, We = 0, qe = Ge - 1;
                        qe >= 0 && (je = n[Pe[qe]]) & s;
                        qe--
                      );
                      for (
                        var $e = Ge + 1;
                        $e < Pe.length && (We = n[Pe[$e]]) & s;
                        $e++
                      );
                      je === We &&
                        (n[Ve] === S ? je === M : je & (M | E)) &&
                        h(Ve, je);
                    }
                  }
                if (c.get(M))
                  for (var Xe = 0; Xe < Pe.length; Xe++) {
                    var Ye = Pe[Xe];
                    if (n[Ye] & M) {
                      for (
                        var Je = Xe - 1;
                        Je >= 0 && n[Pe[Je]] & (T | s);
                        Je--
                      )
                        h(Pe[Je], M);
                      for (
                        var Ze = Xe + 1;
                        Ze < Pe.length && n[Pe[Ze]] & (T | s);
                        Ze++
                      )
                        h(Pe[Ze], M);
                    }
                  }
                if (c.get(T) || c.get(S) || c.get(A))
                  for (var Ke = 0; Ke < Pe.length; Ke++) {
                    var Qe = Pe[Ke];
                    if (n[Qe] & (T | S | A)) {
                      h(Qe, L);
                      for (var et = Ke - 1; et >= 0 && n[Pe[et]] & s; et--)
                        h(Pe[et], L);
                      for (
                        var tt = Ke + 1;
                        tt < Pe.length && n[Pe[tt]] & s;
                        tt++
                      )
                        h(Pe[tt], L);
                    }
                  }
                if (c.get(M))
                  for (var nt = 0, rt = Le; nt < Pe.length; nt++) {
                    var it = Pe[nt],
                      ot = n[it];
                    ot & M ? rt === w && h(it, w) : ot & o && (rt = ot);
                  }
                if (c.get(a)) {
                  for (
                    var at = _ | M | E, st = at | w, lt = [], ct = [], ut = 0;
                    ut < Pe.length;
                    ut++
                  )
                    if (n[Pe[ut]] & a) {
                      var ht = e[Pe[ut]],
                        dt = void 0;
                      if (null !== y(ht)) {
                        if (!(ct.length < 63)) break;
                        ct.push({
                          char: ht,
                          seqIndex: ut,
                        });
                      } else if (null !== (dt = x(ht)))
                        for (var pt = ct.length - 1; pt >= 0; pt--) {
                          var ft = ct[pt].char;
                          if (ft === dt || ft === x(b(ht)) || y(b(ft)) === ht) {
                            lt.push([ct[pt].seqIndex, ut]), (ct.length = pt);
                            break;
                          }
                        }
                    }
                  lt.sort(function (e, t) {
                    return e[0] - t[0];
                  });
                  for (var mt = 0; mt < lt.length; mt++) {
                    for (
                      var gt = lt[mt],
                        vt = gt[0],
                        yt = gt[1],
                        xt = !1,
                        bt = 0,
                        wt = vt + 1;
                      wt < yt;
                      wt++
                    ) {
                      var _t = Pe[wt];
                      if (n[_t] & st) {
                        xt = !0;
                        var Mt = n[_t] & at ? _ : w;
                        if (Mt === Vt(_t)) {
                          bt = Mt;
                          break;
                        }
                      }
                    }
                    if (xt && !bt) {
                      bt = Le;
                      for (var St = vt - 1; St >= 0; St--) {
                        var Tt = Pe[St];
                        if (n[Tt] & st) {
                          var Et = n[Tt] & at ? _ : w;
                          bt = Et !== Vt(Tt) ? Et : Vt(Tt);
                          break;
                        }
                      }
                    }
                    if (bt) {
                      if (((n[Pe[vt]] = n[Pe[yt]] = bt), bt !== Vt(Pe[vt])))
                        for (var At = vt + 1; At < Pe.length; At++)
                          if (!(n[Pe[At]] & s)) {
                            u(e[Pe[At]]) & I && (n[Pe[At]] = bt);
                            break;
                          }
                      if (bt !== Vt(Pe[yt]))
                        for (var Ct = yt + 1; Ct < Pe.length; Ct++)
                          if (!(n[Pe[Ct]] & s)) {
                            u(e[Pe[Ct]]) & I && (n[Pe[Ct]] = bt);
                            break;
                          }
                    }
                  }
                  for (var Pt = 0; Pt < Pe.length; Pt++)
                    if (n[Pe[Pt]] & a) {
                      for (
                        var Lt = Pt, Rt = Pt, It = Le, kt = Pt - 1;
                        kt >= 0;
                        kt--
                      ) {
                        if (!(n[Pe[kt]] & s)) {
                          It = n[Pe[kt]] & at ? _ : w;
                          break;
                        }
                        Lt = kt;
                      }
                      for (var Dt = Re, Ot = Pt + 1; Ot < Pe.length; Ot++) {
                        if (!(n[Pe[Ot]] & (a | s))) {
                          Dt = n[Pe[Ot]] & at ? _ : w;
                          break;
                        }
                        Rt = Ot;
                      }
                      for (var Bt = Lt; Bt <= Rt; Bt++)
                        n[Pe[Bt]] = It === Dt ? It : Vt(Pe[Bt]);
                      Pt = Rt;
                    }
                }
              }
              for (var Ft = m.start; Ft <= m.end; Ft++) {
                var Nt = d[Ft],
                  Ut = n[Ft];
                if (
                  (1 & Nt
                    ? Ut & (w | M | E) && d[Ft]++
                    : Ut & _
                    ? d[Ft]++
                    : Ut & (E | M) && (d[Ft] += 2),
                  Ut & s && (d[Ft] = 0 === Ft ? m.level : d[Ft - 1]),
                  Ft === m.end || u(e[Ft]) & (P | C))
                )
                  for (var zt = Ft; zt >= 0 && u(e[zt]) & l; zt--)
                    d[zt] = m.level;
              }
            }
            return {
              levels: d,
              paragraphs: f,
            };

            function Ht(t, r) {
              for (var o = t; o < e.length; o++) {
                var a = n[o];
                if (a & (_ | k)) return 1;
                if (a & (C | w) || (r && a === G)) return 0;
                if (a & i) {
                  var s = Gt(o);
                  o = -1 === s ? e.length : s;
                }
              }
              return 0;
            }

            function Gt(t) {
              for (var r = 1, o = t + 1; o < e.length; o++) {
                var a = n[o];
                if (a & C) break;
                if (a & G) {
                  if (0 == --r) return o;
                } else a & i && r++;
              }
              return -1;
            }

            function Vt(e) {
              return 1 & d[e] ? _ : w;
            }
          }),
          (e.getMirroredCharacter = j),
          (e.getMirroredCharactersMap = function (e, t, n, r) {
            var i = e.length;
            (n = Math.max(0, null == n ? 0 : +n)),
              (r = Math.min(i - 1, null == r ? i - 1 : +r));
            for (var o = new Map(), a = n; a <= r; a++)
              if (1 & t[a]) {
                var s = j(e[a]);
                null !== s && o.set(a, s);
              }
            return o;
          }),
          (e.getReorderSegments = W),
          (e.getReorderedIndices = q),
          (e.getReorderedString = function (e, t, n, r) {
            var i = q(e, t, n, r),
              o = [].concat(e);
            return (
              i.forEach(function (n, r) {
                o[r] = (1 & t.levels[n] ? j(e[n]) : null) || e[n];
              }),
              o.join("")
            );
          }),
          (e.openingToClosingBracket = y),
          Object.defineProperty(e, "__esModule", {
            value: !0,
          }),
          e
        );
      })({});
    };
    const Be = /\bvoid\s+main\s*\(\s*\)\s*{/g;

    function Fe(e) {
      return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function (e, t) {
        let n = r.ShaderChunk[t];
        return n ? Fe(n) : e;
      });
    }
    const Ne = [];
    for (let e = 0; e < 256; e++) Ne[e] = (e < 16 ? "0" : "") + e.toString(16);
    const Ue =
        Object.assign ||
        function () {
          let e = arguments[0];
          for (let t = 1, n = arguments.length; t < n; t++) {
            let n = arguments[t];
            if (n) for (let t in n) n.hasOwnProperty(t) && (e[t] = n[t]);
          }
          return e;
        },
      ze = Date.now(),
      He = new WeakMap(),
      Ge = new Map();
    let Ve = 1e10;

    function je(e, t) {
      const n = (function (e) {
        const t = JSON.stringify(e, qe);
        let n = Xe.get(t);
        null == n && Xe.set(t, (n = ++$e));
        return n;
      })(t);
      let i = He.get(e);
      if ((i || He.set(e, (i = Object.create(null))), i[n])) return new i[n]();
      const o = `_onBeforeCompile${n}`,
        a = function (r) {
          e.onBeforeCompile.call(this, r);
          const i =
            this.customProgramCacheKey() +
            "|" +
            r.vertexShader +
            "|" +
            r.fragmentShader;
          let a = Ge[i];
          if (!a) {
            const e = (function ({ vertexShader: e, fragmentShader: t }, n, r) {
              let {
                vertexDefs: i,
                vertexMainIntro: o,
                vertexMainOutro: a,
                vertexTransform: s,
                fragmentDefs: l,
                fragmentMainIntro: c,
                fragmentMainOutro: u,
                fragmentColorTransform: h,
                customRewriter: d,
                timeUniform: p,
              } = n;
              (i = i || ""),
                (o = o || ""),
                (a = a || ""),
                (l = l || ""),
                (c = c || ""),
                (u = u || ""),
                (s || d) && (e = Fe(e));
              (h || d) &&
                (t = Fe(
                  (t = t.replace(
                    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
                    "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
                  ))
                ));
              if (d) {
                let n = d({
                  vertexShader: e,
                  fragmentShader: t,
                });
                (e = n.vertexShader), (t = n.fragmentShader);
              }
              if (h) {
                let e = [];
                (t = t.replace(
                  /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
                  (t) => (e.push(t), "")
                )),
                  (u = `${h}\n${e.join("\n")}\n${u}`);
              }
              if (p) {
                const e = `\nuniform float ${p};\n`;
                (i = e + i), (l = e + l);
              }
              s &&
                ((e = `vec3 troika_position_${r};\nvec3 troika_normal_${r};\nvec2 troika_uv_${r};\n${e}\n`),
                (i = `${i}\nvoid troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${s}\n}\n`),
                (o = `\ntroika_position_${r} = vec3(position);\ntroika_normal_${r} = vec3(normal);\ntroika_uv_${r} = vec2(uv);\ntroikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});\n${o}\n`),
                (e = e.replace(/\b(position|normal|uv)\b/g, (e, t, n, i) =>
                  /\battribute\s+vec[23]\s+$/.test(i.substr(0, n))
                    ? t
                    : `troika_${t}_${r}`
                )));
              return (
                (e = We(e, r, i, o, a)),
                (t = We(t, r, l, c, u)),
                {
                  vertexShader: e,
                  fragmentShader: t,
                }
              );
            })(r, t, n);
            a = Ge[i] = e;
          }
          (r.vertexShader = a.vertexShader),
            (r.fragmentShader = a.fragmentShader),
            Ue(r.uniforms, this.uniforms),
            t.timeUniform &&
              (r.uniforms[t.timeUniform] = {
                get value() {
                  return Date.now() - ze;
                },
              }),
            this[o] && this[o](r);
        },
        s = function () {
          return l(t.chained ? e : e.clone());
        },
        l = function (r) {
          const i = Object.create(r, c);
          return (
            Object.defineProperty(i, "baseMaterial", {
              value: e,
            }),
            Object.defineProperty(i, "id", {
              value: Ve++,
            }),
            (i.uuid = (function () {
              const e = (4294967295 * Math.random()) | 0,
                t = (4294967295 * Math.random()) | 0,
                n = (4294967295 * Math.random()) | 0,
                r = (4294967295 * Math.random()) | 0;
              return (
                Ne[255 & e] +
                Ne[(e >> 8) & 255] +
                Ne[(e >> 16) & 255] +
                Ne[(e >> 24) & 255] +
                "-" +
                Ne[255 & t] +
                Ne[(t >> 8) & 255] +
                "-" +
                Ne[((t >> 16) & 15) | 64] +
                Ne[(t >> 24) & 255] +
                "-" +
                Ne[(63 & n) | 128] +
                Ne[(n >> 8) & 255] +
                "-" +
                Ne[(n >> 16) & 255] +
                Ne[(n >> 24) & 255] +
                Ne[255 & r] +
                Ne[(r >> 8) & 255] +
                Ne[(r >> 16) & 255] +
                Ne[(r >> 24) & 255]
              ).toUpperCase();
            })()),
            (i.uniforms = Ue({}, r.uniforms, t.uniforms)),
            (i.defines = Ue({}, r.defines, t.defines)),
            (i.defines[`TROIKA_DERIVED_MATERIAL_${n}`] = ""),
            (i.extensions = Ue({}, r.extensions, t.extensions)),
            (i._listeners = void 0),
            i
          );
        },
        c = {
          constructor: {
            value: s,
          },
          isDerivedMaterial: {
            value: !0,
          },
          customProgramCacheKey: {
            writable: !0,
            configurable: !0,
            value: function () {
              return e.customProgramCacheKey() + "|" + n;
            },
          },
          onBeforeCompile: {
            get: () => a,
            set(e) {
              this[o] = e;
            },
          },
          copy: {
            writable: !0,
            configurable: !0,
            value: function (t) {
              return (
                e.copy.call(this, t),
                e.isShaderMaterial ||
                  e.isDerivedMaterial ||
                  (Ue(this.extensions, t.extensions),
                  Ue(this.defines, t.defines),
                  Ue(this.uniforms, r.UniformsUtils.clone(t.uniforms))),
                this
              );
            },
          },
          clone: {
            writable: !0,
            configurable: !0,
            value: function () {
              const t = new e.constructor();
              return l(t).copy(this);
            },
          },
          getDepthMaterial: {
            writable: !0,
            configurable: !0,
            value: function () {
              let n = this._depthMaterial;
              return (
                n ||
                  ((n = this._depthMaterial =
                    je(
                      e.isDerivedMaterial
                        ? e.getDepthMaterial()
                        : new r.MeshDepthMaterial({
                            depthPacking: r.RGBADepthPacking,
                          }),
                      t
                    )),
                  (n.defines.IS_DEPTH_MATERIAL = ""),
                  (n.uniforms = this.uniforms)),
                n
              );
            },
          },
          getDistanceMaterial: {
            writable: !0,
            configurable: !0,
            value: function () {
              let n = this._distanceMaterial;
              return (
                n ||
                  ((n = this._distanceMaterial =
                    je(
                      e.isDerivedMaterial
                        ? e.getDistanceMaterial()
                        : new r.MeshDistanceMaterial(),
                      t
                    )),
                  (n.defines.IS_DISTANCE_MATERIAL = ""),
                  (n.uniforms = this.uniforms)),
                n
              );
            },
          },
          dispose: {
            writable: !0,
            configurable: !0,
            value() {
              const { _depthMaterial: t, _distanceMaterial: n } = this;
              t && t.dispose(), n && n.dispose(), e.dispose.call(this);
            },
          },
        };
      return (i[n] = s), new s();
    }

    function We(e, t, n, r, i) {
      return (
        (r || i || n) &&
          ((e = e.replace(Be, `\n${n}\nvoid troikaOrigMain${t}() {`)),
          (e += `\nvoid main() {\n  ${r}\n  troikaOrigMain${t}();\n  ${i}\n}`)),
        e
      );
    }

    function qe(e, t) {
      return "uniforms" === e
        ? void 0
        : "function" == typeof t
        ? t.toString()
        : t;
    }
    let $e = 0;
    const Xe = new Map();
    r.DoubleSide;
    r.Mesh;

    function Ye(e) {
      function t(e, t, n, r, i, o, a) {
        const s = 1 - a;
        return {
          x: s * s * e + 2 * s * a * n + a * a * i,
          y: s * s * t + 2 * s * a * r + a * a * o,
        };
      }

      function n(e, t, n, r, i, o, a, s, l) {
        const c = 1 - l;
        return {
          x:
            c * c * c * e +
            3 * c * c * l * n +
            3 * c * l * l * i +
            l * l * l * a,
          y:
            c * c * c * t +
            3 * c * c * l * r +
            3 * c * l * l * o +
            l * l * l * s,
        };
      }

      function r() {
        return (self.performance || Date).now();
      }
      return function (i, o, a, s, l, c = 1) {
        const u = r(),
          h = new Uint8Array(i * o),
          d = s[2] - s[0],
          p = s[3] - s[1],
          f = e(s),
          m = /([MLQCZ])([^MLQCZ]*)/g;
        let g, v, y, x, b;
        for (; (g = m.exec(a)); ) {
          const e = g[2]
            .replace(/^\s*|\s*$/g, "")
            .split(/[,\s]+/)
            .map((e) => parseFloat(e));
          switch (g[1]) {
            case "M":
              (x = v = e[0]), (b = y = e[1]);
              break;
            case "L":
              (e[0] === x && e[1] === b) ||
                f.addLineSegment(x, b, (x = e[0]), (b = e[1]));
              break;
            case "Q": {
              let n = {
                x: x,
                y: b,
              };
              for (let r = 1; r < 16; r++) {
                let i = t(x, b, e[0], e[1], e[2], e[3], r / 15);
                f.addLineSegment(n.x, n.y, i.x, i.y), (n = i);
              }
              (x = e[2]), (b = e[3]);
              break;
            }
            case "C": {
              let t = {
                x: x,
                y: b,
              };
              for (let r = 1; r < 16; r++) {
                let i = n(x, b, e[0], e[1], e[2], e[3], e[4], e[5], r / 15);
                f.addLineSegment(t.x, t.y, i.x, i.y), (t = i);
              }
              (x = e[4]), (b = e[5]);
              break;
            }
            case "Z":
              (x === v && b === y) || f.addLineSegment(x, b, v, y);
          }
        }
        for (let e = 0; e < i; e++)
          for (let t = 0; t < o; t++) {
            const n = f.findNearestSignedDistance(
              s[0] + (d * (e + 0.5)) / i,
              s[1] + (p * (t + 0.5)) / o,
              l
            );
            let r = Math.pow(1 - Math.abs(n) / l, c) / 2;
            n < 0 && (r = 1 - r),
              (r = Math.max(0, Math.min(255, Math.round(255 * r)))),
              (h[t * i + e] = r);
          }
        return {
          textureData: h,
          timing: r() - u,
        };
      };
    }

    function Je(e) {
      let t = !1;
      const n = [];

      function r() {
        t &&
          (n.sort(function (e, t) {
            return e.maxX - t.maxX;
          }),
          (t = !1));
      }

      function i(e, t, n, r, i, o) {
        const a = i - n,
          s = o - r,
          l = a * a + s * s,
          c = l ? Math.max(0, Math.min(1, ((e - n) * a + (t - r) * s) / l)) : 0,
          u = e - (n + c * a),
          h = t - (r + c * s);
        return u * u + h * h;
      }
      return {
        addLineSegment: function (e, r, i, o) {
          const a = {
            x0: e,
            y0: r,
            x1: i,
            y1: o,
            minX: Math.min(e, i),
            minY: Math.min(r, o),
            maxX: Math.max(e, i),
            maxY: Math.max(r, o),
          };
          n.push(a), (t = !0);
        },
        findNearestSignedDistance: function (e, t) {
          r();
          let o = 1 / 0,
            a = 1 / 0;
          for (let r = n.length; r--; ) {
            const s = n[r];
            if (s.maxX + a <= e) break;
            if (e + a > s.minX && t - a < s.maxY && t + a > s.minY) {
              const n = i(e, t, s.x0, s.y0, s.x1, s.y1);
              n < o && ((o = n), (a = Math.sqrt(o)));
            }
          }
          return (
            (function (e, t) {
              r();
              let i = !1;
              for (let r = n.length; r--; ) {
                const o = n[r];
                if (o.maxX <= e) break;
                if (o.minY < t && o.maxY > t) {
                  o.y0 > t != o.y1 > t &&
                    e < ((o.x1 - o.x0) * (t - o.y0)) / (o.y1 - o.y0) + o.x0 &&
                    (i = !i);
                }
              }
              return i;
            })(e, t) && (a = -a),
            a
          );
        },
      };
    }
    /*!
    Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
    Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
    */
    const Ze = Object(De.c)({
        name: "Typr Font Parser",
        dependencies: [
          function () {
            return (
              "undefined" == typeof window && (self.window = self),
              (function (e) {
                var t = {
                  parse: function (e) {
                    var n = t._bin,
                      r = new Uint8Array(e);
                    if ("ttcf" == n.readASCII(r, 0, 4)) {
                      var i = 4;
                      n.readUshort(r, i),
                        (i += 2),
                        n.readUshort(r, i),
                        (i += 2);
                      var o = n.readUint(r, i);
                      i += 4;
                      for (var a = [], s = 0; s < o; s++) {
                        var l = n.readUint(r, i);
                        (i += 4), a.push(t._readFont(r, l));
                      }
                      return a;
                    }
                    return [t._readFont(r, 0)];
                  },
                  _readFont: function (e, n) {
                    var r = t._bin,
                      i = n;
                    r.readFixed(e, n), (n += 4);
                    var o = r.readUshort(e, n);
                    (n += 2),
                      r.readUshort(e, n),
                      (n += 2),
                      r.readUshort(e, n),
                      (n += 2),
                      r.readUshort(e, n),
                      (n += 2);
                    for (
                      var a = [
                          "cmap",
                          "head",
                          "hhea",
                          "maxp",
                          "hmtx",
                          "name",
                          "OS/2",
                          "post",
                          "loca",
                          "glyf",
                          "kern",
                          "CFF ",
                          "GPOS",
                          "GSUB",
                          "SVG ",
                        ],
                        s = {
                          _data: e,
                          _offset: i,
                        },
                        l = {},
                        c = 0;
                      c < o;
                      c++
                    ) {
                      var u = r.readASCII(e, n, 4);
                      (n += 4), r.readUint(e, n), (n += 4);
                      var h = r.readUint(e, n);
                      n += 4;
                      var d = r.readUint(e, n);
                      (n += 4),
                        (l[u] = {
                          offset: h,
                          length: d,
                        });
                    }
                    for (c = 0; c < a.length; c++) {
                      var p = a[c];
                      l[p] &&
                        (s[p.trim()] = t[p.trim()].parse(
                          e,
                          l[p].offset,
                          l[p].length,
                          s
                        ));
                    }
                    return s;
                  },
                  _tabOffset: function (e, n, r) {
                    for (
                      var i = t._bin,
                        o = i.readUshort(e, r + 4),
                        a = r + 12,
                        s = 0;
                      s < o;
                      s++
                    ) {
                      var l = i.readASCII(e, a, 4);
                      (a += 4), i.readUint(e, a), (a += 4);
                      var c = i.readUint(e, a);
                      if (((a += 4), i.readUint(e, a), (a += 4), l == n))
                        return c;
                    }
                    return 0;
                  },
                };
                (t._bin = {
                  readFixed: function (e, t) {
                    return (
                      ((e[t] << 8) | e[t + 1]) +
                      ((e[t + 2] << 8) | e[t + 3]) / 65540
                    );
                  },
                  readF2dot14: function (e, n) {
                    return t._bin.readShort(e, n) / 16384;
                  },
                  readInt: function (e, n) {
                    return t._bin._view(e).getInt32(n);
                  },
                  readInt8: function (e, n) {
                    return t._bin._view(e).getInt8(n);
                  },
                  readShort: function (e, n) {
                    return t._bin._view(e).getInt16(n);
                  },
                  readUshort: function (e, n) {
                    return t._bin._view(e).getUint16(n);
                  },
                  readUshorts: function (e, n, r) {
                    for (var i = [], o = 0; o < r; o++)
                      i.push(t._bin.readUshort(e, n + 2 * o));
                    return i;
                  },
                  readUint: function (e, n) {
                    return t._bin._view(e).getUint32(n);
                  },
                  readUint64: function (e, n) {
                    return (
                      4294967296 * t._bin.readUint(e, n) +
                      t._bin.readUint(e, n + 4)
                    );
                  },
                  readASCII: function (e, t, n) {
                    for (var r = "", i = 0; i < n; i++)
                      r += String.fromCharCode(e[t + i]);
                    return r;
                  },
                  readUnicode: function (e, t, n) {
                    for (var r = "", i = 0; i < n; i++) {
                      var o = (e[t++] << 8) | e[t++];
                      r += String.fromCharCode(o);
                    }
                    return r;
                  },
                  _tdec:
                    "undefined" != typeof window && window.TextDecoder
                      ? new window.TextDecoder()
                      : null,
                  readUTF8: function (e, n, r) {
                    var i = t._bin._tdec;
                    return i && 0 == n && r == e.length
                      ? i.decode(e)
                      : t._bin.readASCII(e, n, r);
                  },
                  readBytes: function (e, t, n) {
                    for (var r = [], i = 0; i < n; i++) r.push(e[t + i]);
                    return r;
                  },
                  readASCIIArray: function (e, t, n) {
                    for (var r = [], i = 0; i < n; i++)
                      r.push(String.fromCharCode(e[t + i]));
                    return r;
                  },
                  _view: function (e) {
                    return (
                      e._dataView ||
                      (e._dataView = e.buffer
                        ? new DataView(e.buffer, e.byteOffset, e.byteLength)
                        : new DataView(new Uint8Array(e).buffer))
                    );
                  },
                }),
                  (t._lctf = {}),
                  (t._lctf.parse = function (e, n, r, i, o) {
                    var a = t._bin,
                      s = {},
                      l = n;
                    a.readFixed(e, n), (n += 4);
                    var c = a.readUshort(e, n);
                    n += 2;
                    var u = a.readUshort(e, n);
                    n += 2;
                    var h = a.readUshort(e, n);
                    return (
                      (n += 2),
                      (s.scriptList = t._lctf.readScriptList(e, l + c)),
                      (s.featureList = t._lctf.readFeatureList(e, l + u)),
                      (s.lookupList = t._lctf.readLookupList(e, l + h, o)),
                      s
                    );
                  }),
                  (t._lctf.readLookupList = function (e, n, r) {
                    var i = t._bin,
                      o = n,
                      a = [],
                      s = i.readUshort(e, n);
                    n += 2;
                    for (var l = 0; l < s; l++) {
                      var c = i.readUshort(e, n);
                      n += 2;
                      var u = t._lctf.readLookupTable(e, o + c, r);
                      a.push(u);
                    }
                    return a;
                  }),
                  (t._lctf.readLookupTable = function (e, n, r) {
                    var i = t._bin,
                      o = n,
                      a = {
                        tabs: [],
                      };
                    (a.ltype = i.readUshort(e, n)),
                      (n += 2),
                      (a.flag = i.readUshort(e, n)),
                      (n += 2);
                    var s = i.readUshort(e, n);
                    n += 2;
                    for (var l = a.ltype, c = 0; c < s; c++) {
                      var u = i.readUshort(e, n);
                      n += 2;
                      var h = r(e, l, o + u, a);
                      a.tabs.push(h);
                    }
                    return a;
                  }),
                  (t._lctf.numOfOnes = function (e) {
                    for (var t = 0, n = 0; n < 32; n++)
                      0 != ((e >>> n) & 1) && t++;
                    return t;
                  }),
                  (t._lctf.readClassDef = function (e, n) {
                    var r = t._bin,
                      i = [],
                      o = r.readUshort(e, n);
                    if (((n += 2), 1 == o)) {
                      var a = r.readUshort(e, n);
                      n += 2;
                      var s = r.readUshort(e, n);
                      n += 2;
                      for (var l = 0; l < s; l++)
                        i.push(a + l),
                          i.push(a + l),
                          i.push(r.readUshort(e, n)),
                          (n += 2);
                    }
                    if (2 == o) {
                      var c = r.readUshort(e, n);
                      for (n += 2, l = 0; l < c; l++)
                        i.push(r.readUshort(e, n)),
                          (n += 2),
                          i.push(r.readUshort(e, n)),
                          (n += 2),
                          i.push(r.readUshort(e, n)),
                          (n += 2);
                    }
                    return i;
                  }),
                  (t._lctf.getInterval = function (e, t) {
                    for (var n = 0; n < e.length; n += 3) {
                      var r = e[n],
                        i = e[n + 1];
                      if ((e[n + 2], r <= t && t <= i)) return n;
                    }
                    return -1;
                  }),
                  (t._lctf.readCoverage = function (e, n) {
                    var r = t._bin,
                      i = {};
                    (i.fmt = r.readUshort(e, n)), (n += 2);
                    var o = r.readUshort(e, n);
                    return (
                      (n += 2),
                      1 == i.fmt && (i.tab = r.readUshorts(e, n, o)),
                      2 == i.fmt && (i.tab = r.readUshorts(e, n, 3 * o)),
                      i
                    );
                  }),
                  (t._lctf.coverageIndex = function (e, n) {
                    var r = e.tab;
                    if (1 == e.fmt) return r.indexOf(n);
                    if (2 == e.fmt) {
                      var i = t._lctf.getInterval(r, n);
                      if (-1 != i) return r[i + 2] + (n - r[i]);
                    }
                    return -1;
                  }),
                  (t._lctf.readFeatureList = function (e, n) {
                    var r = t._bin,
                      i = n,
                      o = [],
                      a = r.readUshort(e, n);
                    n += 2;
                    for (var s = 0; s < a; s++) {
                      var l = r.readASCII(e, n, 4);
                      n += 4;
                      var c = r.readUshort(e, n);
                      n += 2;
                      var u = t._lctf.readFeatureTable(e, i + c);
                      (u.tag = l.trim()), o.push(u);
                    }
                    return o;
                  }),
                  (t._lctf.readFeatureTable = function (e, n) {
                    var r = t._bin,
                      i = n,
                      o = {},
                      a = r.readUshort(e, n);
                    (n += 2), a > 0 && (o.featureParams = i + a);
                    var s = r.readUshort(e, n);
                    (n += 2), (o.tab = []);
                    for (var l = 0; l < s; l++)
                      o.tab.push(r.readUshort(e, n + 2 * l));
                    return o;
                  }),
                  (t._lctf.readScriptList = function (e, n) {
                    var r = t._bin,
                      i = n,
                      o = {},
                      a = r.readUshort(e, n);
                    n += 2;
                    for (var s = 0; s < a; s++) {
                      var l = r.readASCII(e, n, 4);
                      n += 4;
                      var c = r.readUshort(e, n);
                      (n += 2),
                        (o[l.trim()] = t._lctf.readScriptTable(e, i + c));
                    }
                    return o;
                  }),
                  (t._lctf.readScriptTable = function (e, n) {
                    var r = t._bin,
                      i = n,
                      o = {},
                      a = r.readUshort(e, n);
                    (n += 2), (o.default = t._lctf.readLangSysTable(e, i + a));
                    var s = r.readUshort(e, n);
                    n += 2;
                    for (var l = 0; l < s; l++) {
                      var c = r.readASCII(e, n, 4);
                      n += 4;
                      var u = r.readUshort(e, n);
                      (n += 2),
                        (o[c.trim()] = t._lctf.readLangSysTable(e, i + u));
                    }
                    return o;
                  }),
                  (t._lctf.readLangSysTable = function (e, n) {
                    var r = t._bin,
                      i = {};
                    r.readUshort(e, n),
                      (n += 2),
                      (i.reqFeature = r.readUshort(e, n)),
                      (n += 2);
                    var o = r.readUshort(e, n);
                    return (n += 2), (i.features = r.readUshorts(e, n, o)), i;
                  }),
                  (t.CFF = {}),
                  (t.CFF.parse = function (e, n, r) {
                    var i = t._bin;
                    (e = new Uint8Array(e.buffer, n, r))[(n = 0)],
                      e[++n],
                      e[++n],
                      e[++n],
                      n++;
                    var o = [];
                    n = t.CFF.readIndex(e, n, o);
                    for (var a = [], s = 0; s < o.length - 1; s++)
                      a.push(i.readASCII(e, n + o[s], o[s + 1] - o[s]));
                    n += o[o.length - 1];
                    var l = [];
                    n = t.CFF.readIndex(e, n, l);
                    var c = [];
                    for (s = 0; s < l.length - 1; s++)
                      c.push(t.CFF.readDict(e, n + l[s], n + l[s + 1]));
                    n += l[l.length - 1];
                    var u = c[0],
                      h = [];
                    n = t.CFF.readIndex(e, n, h);
                    var d = [];
                    for (s = 0; s < h.length - 1; s++)
                      d.push(i.readASCII(e, n + h[s], h[s + 1] - h[s]));
                    if (
                      ((n += h[h.length - 1]),
                      t.CFF.readSubrs(e, n, u),
                      u.CharStrings)
                    ) {
                      (n = u.CharStrings),
                        (h = []),
                        (n = t.CFF.readIndex(e, n, h));
                      var p = [];
                      for (s = 0; s < h.length - 1; s++)
                        p.push(i.readBytes(e, n + h[s], h[s + 1] - h[s]));
                      u.CharStrings = p;
                    }
                    if (u.ROS) {
                      n = u.FDArray;
                      var f = [];
                      for (
                        n = t.CFF.readIndex(e, n, f), u.FDArray = [], s = 0;
                        s < f.length - 1;
                        s++
                      ) {
                        var m = t.CFF.readDict(e, n + f[s], n + f[s + 1]);
                        t.CFF._readFDict(e, m, d), u.FDArray.push(m);
                      }
                      (n += f[f.length - 1]),
                        (n = u.FDSelect),
                        (u.FDSelect = []);
                      var g = e[n];
                      if ((n++, 3 != g)) throw g;
                      var v = i.readUshort(e, n);
                      for (n += 2, s = 0; s < v + 1; s++)
                        u.FDSelect.push(i.readUshort(e, n), e[n + 2]), (n += 3);
                    }
                    return (
                      u.Encoding &&
                        (u.Encoding = t.CFF.readEncoding(
                          e,
                          u.Encoding,
                          u.CharStrings.length
                        )),
                      u.charset &&
                        (u.charset = t.CFF.readCharset(
                          e,
                          u.charset,
                          u.CharStrings.length
                        )),
                      t.CFF._readFDict(e, u, d),
                      u
                    );
                  }),
                  (t.CFF._readFDict = function (e, n, r) {
                    var i;
                    for (var o in (n.Private &&
                      ((i = n.Private[1]),
                      (n.Private = t.CFF.readDict(e, i, i + n.Private[0])),
                      n.Private.Subrs &&
                        t.CFF.readSubrs(e, i + n.Private.Subrs, n.Private)),
                    n))
                      -1 !=
                        [
                          "FamilyName",
                          "FontName",
                          "FullName",
                          "Notice",
                          "version",
                          "Copyright",
                        ].indexOf(o) && (n[o] = r[n[o] - 426 + 35]);
                  }),
                  (t.CFF.readSubrs = function (e, n, r) {
                    var i = t._bin,
                      o = [];
                    n = t.CFF.readIndex(e, n, o);
                    var a,
                      s = o.length;
                    (a = s < 1240 ? 107 : s < 33900 ? 1131 : 32768),
                      (r.Bias = a),
                      (r.Subrs = []);
                    for (var l = 0; l < o.length - 1; l++)
                      r.Subrs.push(i.readBytes(e, n + o[l], o[l + 1] - o[l]));
                  }),
                  (t.CFF.tableSE = [
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8,
                    9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
                    24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
                    39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
                    54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
                    69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
                    84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102,
                    103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113,
                    114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0,
                    124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134,
                    135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
                    0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
                  ]),
                  (t.CFF.glyphByUnicode = function (e, t) {
                    for (var n = 0; n < e.charset.length; n++)
                      if (e.charset[n] == t) return n;
                    return -1;
                  }),
                  (t.CFF.glyphBySE = function (e, n) {
                    return n < 0 || n > 255
                      ? -1
                      : t.CFF.glyphByUnicode(e, t.CFF.tableSE[n]);
                  }),
                  (t.CFF.readEncoding = function (e, n, r) {
                    t._bin;
                    var i = [".notdef"],
                      o = e[n];
                    if ((n++, 0 != o))
                      throw "error: unknown encoding format: " + o;
                    var a = e[n];
                    n++;
                    for (var s = 0; s < a; s++) i.push(e[n + s]);
                    return i;
                  }),
                  (t.CFF.readCharset = function (e, n, r) {
                    var i = t._bin,
                      o = [".notdef"],
                      a = e[n];
                    if ((n++, 0 == a))
                      for (var s = 0; s < r; s++) {
                        var l = i.readUshort(e, n);
                        (n += 2), o.push(l);
                      }
                    else {
                      if (1 != a && 2 != a) throw "error: format: " + a;
                      for (; o.length < r; ) {
                        (l = i.readUshort(e, n)), (n += 2);
                        var c = 0;
                        for (
                          1 == a
                            ? ((c = e[n]), n++)
                            : ((c = i.readUshort(e, n)), (n += 2)),
                            s = 0;
                          s <= c;
                          s++
                        )
                          o.push(l), l++;
                      }
                    }
                    return o;
                  }),
                  (t.CFF.readIndex = function (e, n, r) {
                    var i = t._bin,
                      o = i.readUshort(e, n) + 1,
                      a = e[(n += 2)];
                    if ((n++, 1 == a))
                      for (var s = 0; s < o; s++) r.push(e[n + s]);
                    else if (2 == a)
                      for (s = 0; s < o; s++)
                        r.push(i.readUshort(e, n + 2 * s));
                    else if (3 == a)
                      for (s = 0; s < o; s++)
                        r.push(16777215 & i.readUint(e, n + 3 * s - 1));
                    else if (1 != o)
                      throw "unsupported offset size: " + a + ", count: " + o;
                    return (n += o * a) - 1;
                  }),
                  (t.CFF.getCharString = function (e, n, r) {
                    var i = t._bin,
                      o = e[n],
                      a = e[n + 1];
                    e[n + 2], e[n + 3], e[n + 4];
                    var s = 1,
                      l = null,
                      c = null;
                    o <= 20 && ((l = o), (s = 1)),
                      12 == o && ((l = 100 * o + a), (s = 2)),
                      21 <= o && o <= 27 && ((l = o), (s = 1)),
                      28 == o && ((c = i.readShort(e, n + 1)), (s = 3)),
                      29 <= o && o <= 31 && ((l = o), (s = 1)),
                      32 <= o && o <= 246 && ((c = o - 139), (s = 1)),
                      247 <= o &&
                        o <= 250 &&
                        ((c = 256 * (o - 247) + a + 108), (s = 2)),
                      251 <= o &&
                        o <= 254 &&
                        ((c = 256 * -(o - 251) - a - 108), (s = 2)),
                      255 == o && ((c = i.readInt(e, n + 1) / 65535), (s = 5)),
                      (r.val = null != c ? c : "o" + l),
                      (r.size = s);
                  }),
                  (t.CFF.readCharString = function (e, n, r) {
                    for (var i = n + r, o = t._bin, a = []; n < i; ) {
                      var s = e[n],
                        l = e[n + 1];
                      e[n + 2], e[n + 3], e[n + 4];
                      var c = 1,
                        u = null,
                        h = null;
                      s <= 20 && ((u = s), (c = 1)),
                        12 == s && ((u = 100 * s + l), (c = 2)),
                        (19 != s && 20 != s) || ((u = s), (c = 2)),
                        21 <= s && s <= 27 && ((u = s), (c = 1)),
                        28 == s && ((h = o.readShort(e, n + 1)), (c = 3)),
                        29 <= s && s <= 31 && ((u = s), (c = 1)),
                        32 <= s && s <= 246 && ((h = s - 139), (c = 1)),
                        247 <= s &&
                          s <= 250 &&
                          ((h = 256 * (s - 247) + l + 108), (c = 2)),
                        251 <= s &&
                          s <= 254 &&
                          ((h = 256 * -(s - 251) - l - 108), (c = 2)),
                        255 == s &&
                          ((h = o.readInt(e, n + 1) / 65535), (c = 5)),
                        a.push(null != h ? h : "o" + u),
                        (n += c);
                    }
                    return a;
                  }),
                  (t.CFF.readDict = function (e, n, r) {
                    for (var i = t._bin, o = {}, a = []; n < r; ) {
                      var s = e[n],
                        l = e[n + 1];
                      e[n + 2], e[n + 3], e[n + 4];
                      var c = 1,
                        u = null,
                        h = null;
                      if (
                        (28 == s && ((h = i.readShort(e, n + 1)), (c = 3)),
                        29 == s && ((h = i.readInt(e, n + 1)), (c = 5)),
                        32 <= s && s <= 246 && ((h = s - 139), (c = 1)),
                        247 <= s &&
                          s <= 250 &&
                          ((h = 256 * (s - 247) + l + 108), (c = 2)),
                        251 <= s &&
                          s <= 254 &&
                          ((h = 256 * -(s - 251) - l - 108), (c = 2)),
                        255 == s)
                      )
                        throw (
                          ((h = i.readInt(e, n + 1) / 65535),
                          (c = 5),
                          "unknown number")
                        );
                      if (30 == s) {
                        var d = [];
                        for (c = 1; ; ) {
                          var p = e[n + c];
                          c++;
                          var f = p >> 4,
                            m = 15 & p;
                          if (
                            (15 != f && d.push(f),
                            15 != m && d.push(m),
                            15 == m)
                          )
                            break;
                        }
                        for (
                          var g = "",
                            v = [
                              0,
                              1,
                              2,
                              3,
                              4,
                              5,
                              6,
                              7,
                              8,
                              9,
                              ".",
                              "e",
                              "e-",
                              "reserved",
                              "-",
                              "endOfNumber",
                            ],
                            y = 0;
                          y < d.length;
                          y++
                        )
                          g += v[d[y]];
                        h = parseFloat(g);
                      }
                      s <= 21 &&
                        ((u = [
                          "version",
                          "Notice",
                          "FullName",
                          "FamilyName",
                          "Weight",
                          "FontBBox",
                          "BlueValues",
                          "OtherBlues",
                          "FamilyBlues",
                          "FamilyOtherBlues",
                          "StdHW",
                          "StdVW",
                          "escape",
                          "UniqueID",
                          "XUID",
                          "charset",
                          "Encoding",
                          "CharStrings",
                          "Private",
                          "Subrs",
                          "defaultWidthX",
                          "nominalWidthX",
                        ][s]),
                        (c = 1),
                        12 == s &&
                          ((u = [
                            "Copyright",
                            "isFixedPitch",
                            "ItalicAngle",
                            "UnderlinePosition",
                            "UnderlineThickness",
                            "PaintType",
                            "CharstringType",
                            "FontMatrix",
                            "StrokeWidth",
                            "BlueScale",
                            "BlueShift",
                            "BlueFuzz",
                            "StemSnapH",
                            "StemSnapV",
                            "ForceBold",
                            0,
                            0,
                            "LanguageGroup",
                            "ExpansionFactor",
                            "initialRandomSeed",
                            "SyntheticBase",
                            "PostScript",
                            "BaseFontName",
                            "BaseFontBlend",
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            "ROS",
                            "CIDFontVersion",
                            "CIDFontRevision",
                            "CIDFontType",
                            "CIDCount",
                            "UIDBase",
                            "FDArray",
                            "FDSelect",
                            "FontName",
                          ][l]),
                          (c = 2))),
                        null != u
                          ? ((o[u] = 1 == a.length ? a[0] : a), (a = []))
                          : a.push(h),
                        (n += c);
                    }
                    return o;
                  }),
                  (t.cmap = {}),
                  (t.cmap.parse = function (e, n, r) {
                    (e = new Uint8Array(e.buffer, n, r)), (n = 0);
                    var i = t._bin,
                      o = {};
                    i.readUshort(e, n), (n += 2);
                    var a = i.readUshort(e, n);
                    n += 2;
                    var s = [];
                    o.tables = [];
                    for (var l = 0; l < a; l++) {
                      var c = i.readUshort(e, n);
                      n += 2;
                      var u = i.readUshort(e, n);
                      n += 2;
                      var h = i.readUint(e, n);
                      n += 4;
                      var d = "p" + c + "e" + u,
                        p = s.indexOf(h);
                      if (-1 == p) {
                        var f;
                        (p = o.tables.length), s.push(h);
                        var m = i.readUshort(e, h);
                        0 == m
                          ? (f = t.cmap.parse0(e, h))
                          : 4 == m
                          ? (f = t.cmap.parse4(e, h))
                          : 6 == m
                          ? (f = t.cmap.parse6(e, h))
                          : 12 == m
                          ? (f = t.cmap.parse12(e, h))
                          : console.debug("unknown format: " + m, c, u, h),
                          o.tables.push(f);
                      }
                      if (null != o[d])
                        throw "multiple tables for one platform+encoding";
                      o[d] = p;
                    }
                    return o;
                  }),
                  (t.cmap.parse0 = function (e, n) {
                    var r = t._bin,
                      i = {};
                    (i.format = r.readUshort(e, n)), (n += 2);
                    var o = r.readUshort(e, n);
                    (n += 2), r.readUshort(e, n), (n += 2), (i.map = []);
                    for (var a = 0; a < o - 6; a++) i.map.push(e[n + a]);
                    return i;
                  }),
                  (t.cmap.parse4 = function (e, n) {
                    var r = t._bin,
                      i = n,
                      o = {};
                    (o.format = r.readUshort(e, n)), (n += 2);
                    var a = r.readUshort(e, n);
                    (n += 2), r.readUshort(e, n), (n += 2);
                    var s = r.readUshort(e, n);
                    n += 2;
                    var l = s / 2;
                    (o.searchRange = r.readUshort(e, n)),
                      (n += 2),
                      (o.entrySelector = r.readUshort(e, n)),
                      (n += 2),
                      (o.rangeShift = r.readUshort(e, n)),
                      (n += 2),
                      (o.endCount = r.readUshorts(e, n, l)),
                      (n += 2 * l),
                      (n += 2),
                      (o.startCount = r.readUshorts(e, n, l)),
                      (n += 2 * l),
                      (o.idDelta = []);
                    for (var c = 0; c < l; c++)
                      o.idDelta.push(r.readShort(e, n)), (n += 2);
                    for (
                      o.idRangeOffset = r.readUshorts(e, n, l),
                        n += 2 * l,
                        o.glyphIdArray = [];
                      n < i + a;

                    )
                      o.glyphIdArray.push(r.readUshort(e, n)), (n += 2);
                    return o;
                  }),
                  (t.cmap.parse6 = function (e, n) {
                    var r = t._bin,
                      i = {};
                    (i.format = r.readUshort(e, n)),
                      (n += 2),
                      r.readUshort(e, n),
                      (n += 2),
                      r.readUshort(e, n),
                      (n += 2),
                      (i.firstCode = r.readUshort(e, n)),
                      (n += 2);
                    var o = r.readUshort(e, n);
                    (n += 2), (i.glyphIdArray = []);
                    for (var a = 0; a < o; a++)
                      i.glyphIdArray.push(r.readUshort(e, n)), (n += 2);
                    return i;
                  }),
                  (t.cmap.parse12 = function (e, n) {
                    var r = t._bin,
                      i = {};
                    (i.format = r.readUshort(e, n)),
                      (n += 2),
                      (n += 2),
                      r.readUint(e, n),
                      (n += 4),
                      r.readUint(e, n),
                      (n += 4);
                    var o = r.readUint(e, n);
                    (n += 4), (i.groups = []);
                    for (var a = 0; a < o; a++) {
                      var s = n + 12 * a,
                        l = r.readUint(e, s + 0),
                        c = r.readUint(e, s + 4),
                        u = r.readUint(e, s + 8);
                      i.groups.push([l, c, u]);
                    }
                    return i;
                  }),
                  (t.glyf = {}),
                  (t.glyf.parse = function (e, t, n, r) {
                    for (var i = [], o = 0; o < r.maxp.numGlyphs; o++)
                      i.push(null);
                    return i;
                  }),
                  (t.glyf._parseGlyf = function (e, n) {
                    var r = t._bin,
                      i = e._data,
                      o = t._tabOffset(i, "glyf", e._offset) + e.loca[n];
                    if (e.loca[n] == e.loca[n + 1]) return null;
                    var a = {};
                    if (
                      ((a.noc = r.readShort(i, o)),
                      (o += 2),
                      (a.xMin = r.readShort(i, o)),
                      (o += 2),
                      (a.yMin = r.readShort(i, o)),
                      (o += 2),
                      (a.xMax = r.readShort(i, o)),
                      (o += 2),
                      (a.yMax = r.readShort(i, o)),
                      (o += 2),
                      a.xMin >= a.xMax || a.yMin >= a.yMax)
                    )
                      return null;
                    if (a.noc > 0) {
                      a.endPts = [];
                      for (var s = 0; s < a.noc; s++)
                        a.endPts.push(r.readUshort(i, o)), (o += 2);
                      var l = r.readUshort(i, o);
                      if (((o += 2), i.length - o < l)) return null;
                      (a.instructions = r.readBytes(i, o, l)), (o += l);
                      var c = a.endPts[a.noc - 1] + 1;
                      for (a.flags = [], s = 0; s < c; s++) {
                        var u = i[o];
                        if ((o++, a.flags.push(u), 0 != (8 & u))) {
                          var h = i[o];
                          o++;
                          for (var d = 0; d < h; d++) a.flags.push(u), s++;
                        }
                      }
                      for (a.xs = [], s = 0; s < c; s++) {
                        var p = 0 != (2 & a.flags[s]),
                          f = 0 != (16 & a.flags[s]);
                        p
                          ? (a.xs.push(f ? i[o] : -i[o]), o++)
                          : f
                          ? a.xs.push(0)
                          : (a.xs.push(r.readShort(i, o)), (o += 2));
                      }
                      for (a.ys = [], s = 0; s < c; s++)
                        (p = 0 != (4 & a.flags[s])),
                          (f = 0 != (32 & a.flags[s])),
                          p
                            ? (a.ys.push(f ? i[o] : -i[o]), o++)
                            : f
                            ? a.ys.push(0)
                            : (a.ys.push(r.readShort(i, o)), (o += 2));
                      var m = 0,
                        g = 0;
                      for (s = 0; s < c; s++)
                        (m += a.xs[s]),
                          (g += a.ys[s]),
                          (a.xs[s] = m),
                          (a.ys[s] = g);
                    } else {
                      var v;
                      a.parts = [];
                      do {
                        (v = r.readUshort(i, o)), (o += 2);
                        var y = {
                          m: {
                            a: 1,
                            b: 0,
                            c: 0,
                            d: 1,
                            tx: 0,
                            ty: 0,
                          },
                          p1: -1,
                          p2: -1,
                        };
                        if (
                          (a.parts.push(y),
                          (y.glyphIndex = r.readUshort(i, o)),
                          (o += 2),
                          1 & v)
                        ) {
                          var x = r.readShort(i, o);
                          o += 2;
                          var b = r.readShort(i, o);
                          o += 2;
                        } else
                          (x = r.readInt8(i, o)),
                            o++,
                            (b = r.readInt8(i, o)),
                            o++;
                        2 & v
                          ? ((y.m.tx = x), (y.m.ty = b))
                          : ((y.p1 = x), (y.p2 = b)),
                          8 & v
                            ? ((y.m.a = y.m.d = r.readF2dot14(i, o)), (o += 2))
                            : 64 & v
                            ? ((y.m.a = r.readF2dot14(i, o)),
                              (o += 2),
                              (y.m.d = r.readF2dot14(i, o)),
                              (o += 2))
                            : 128 & v &&
                              ((y.m.a = r.readF2dot14(i, o)),
                              (o += 2),
                              (y.m.b = r.readF2dot14(i, o)),
                              (o += 2),
                              (y.m.c = r.readF2dot14(i, o)),
                              (o += 2),
                              (y.m.d = r.readF2dot14(i, o)),
                              (o += 2));
                      } while (32 & v);
                      if (256 & v) {
                        var w = r.readUshort(i, o);
                        for (o += 2, a.instr = [], s = 0; s < w; s++)
                          a.instr.push(i[o]), o++;
                      }
                    }
                    return a;
                  }),
                  (t.GPOS = {}),
                  (t.GPOS.parse = function (e, n, r, i) {
                    return t._lctf.parse(e, n, r, i, t.GPOS.subt);
                  }),
                  (t.GPOS.subt = function (e, n, r, i) {
                    var o = t._bin,
                      a = r,
                      s = {};
                    if (
                      ((s.fmt = o.readUshort(e, r)),
                      (r += 2),
                      1 == n ||
                        2 == n ||
                        3 == n ||
                        7 == n ||
                        (8 == n && s.fmt <= 2))
                    ) {
                      var l = o.readUshort(e, r);
                      (r += 2), (s.coverage = t._lctf.readCoverage(e, l + a));
                    }
                    if (1 == n && 1 == s.fmt) {
                      var c = o.readUshort(e, r);
                      r += 2;
                      var u = t._lctf.numOfOnes(c);
                      0 != c && (s.pos = t.GPOS.readValueRecord(e, r, c));
                    } else if (2 == n && s.fmt >= 1 && s.fmt <= 2) {
                      (c = o.readUshort(e, r)), (r += 2);
                      var h = o.readUshort(e, r);
                      (r += 2), (u = t._lctf.numOfOnes(c));
                      var d = t._lctf.numOfOnes(h);
                      if (1 == s.fmt) {
                        s.pairsets = [];
                        var p = o.readUshort(e, r);
                        r += 2;
                        for (var f = 0; f < p; f++) {
                          var m = a + o.readUshort(e, r);
                          r += 2;
                          var g = o.readUshort(e, m);
                          m += 2;
                          for (var v = [], y = 0; y < g; y++) {
                            var x = o.readUshort(e, m);
                            (m += 2),
                              0 != c &&
                                ((T = t.GPOS.readValueRecord(e, m, c)),
                                (m += 2 * u)),
                              0 != h &&
                                ((E = t.GPOS.readValueRecord(e, m, h)),
                                (m += 2 * d)),
                              v.push({
                                gid2: x,
                                val1: T,
                                val2: E,
                              });
                          }
                          s.pairsets.push(v);
                        }
                      }
                      if (2 == s.fmt) {
                        var b = o.readUshort(e, r);
                        r += 2;
                        var w = o.readUshort(e, r);
                        r += 2;
                        var _ = o.readUshort(e, r);
                        r += 2;
                        var M = o.readUshort(e, r);
                        for (
                          r += 2,
                            s.classDef1 = t._lctf.readClassDef(e, a + b),
                            s.classDef2 = t._lctf.readClassDef(e, a + w),
                            s.matrix = [],
                            f = 0;
                          f < _;
                          f++
                        ) {
                          var S = [];
                          for (y = 0; y < M; y++) {
                            var T = null,
                              E = null;
                            0 != c &&
                              ((T = t.GPOS.readValueRecord(e, r, c)),
                              (r += 2 * u)),
                              0 != h &&
                                ((E = t.GPOS.readValueRecord(e, r, h)),
                                (r += 2 * d)),
                              S.push({
                                val1: T,
                                val2: E,
                              });
                          }
                          s.matrix.push(S);
                        }
                      }
                    } else {
                      if (9 == n && 1 == s.fmt) {
                        var A = o.readUshort(e, r);
                        r += 2;
                        var C = o.readUint(e, r);
                        if (((r += 4), 9 == i.ltype)) i.ltype = A;
                        else if (i.ltype != A)
                          throw "invalid extension substitution";
                        return t.GPOS.subt(e, i.ltype, a + C);
                      }
                      console.debug(
                        "unsupported GPOS table LookupType",
                        n,
                        "format",
                        s.fmt
                      );
                    }
                    return s;
                  }),
                  (t.GPOS.readValueRecord = function (e, n, r) {
                    var i = t._bin,
                      o = [];
                    return (
                      o.push(1 & r ? i.readShort(e, n) : 0),
                      (n += 1 & r ? 2 : 0),
                      o.push(2 & r ? i.readShort(e, n) : 0),
                      (n += 2 & r ? 2 : 0),
                      o.push(4 & r ? i.readShort(e, n) : 0),
                      (n += 4 & r ? 2 : 0),
                      o.push(8 & r ? i.readShort(e, n) : 0),
                      (n += 8 & r ? 2 : 0),
                      o
                    );
                  }),
                  (t.GSUB = {}),
                  (t.GSUB.parse = function (e, n, r, i) {
                    return t._lctf.parse(e, n, r, i, t.GSUB.subt);
                  }),
                  (t.GSUB.subt = function (e, n, r, i) {
                    var o = t._bin,
                      a = r,
                      s = {};
                    if (
                      ((s.fmt = o.readUshort(e, r)),
                      (r += 2),
                      1 != n && 4 != n && 5 != n && 6 != n)
                    )
                      return null;
                    if (
                      1 == n ||
                      4 == n ||
                      (5 == n && s.fmt <= 2) ||
                      (6 == n && s.fmt <= 2)
                    ) {
                      var l = o.readUshort(e, r);
                      (r += 2), (s.coverage = t._lctf.readCoverage(e, a + l));
                    }
                    if (1 == n && s.fmt >= 1 && s.fmt <= 2) {
                      if (1 == s.fmt) (s.delta = o.readShort(e, r)), (r += 2);
                      else if (2 == s.fmt) {
                        var c = o.readUshort(e, r);
                        (r += 2),
                          (s.newg = o.readUshorts(e, r, c)),
                          (r += 2 * s.newg.length);
                      }
                    } else if (4 == n) {
                      (s.vals = []), (c = o.readUshort(e, r)), (r += 2);
                      for (var u = 0; u < c; u++) {
                        var h = o.readUshort(e, r);
                        (r += 2), s.vals.push(t.GSUB.readLigatureSet(e, a + h));
                      }
                    } else if (5 == n && 2 == s.fmt) {
                      if (2 == s.fmt) {
                        var d = o.readUshort(e, r);
                        (r += 2),
                          (s.cDef = t._lctf.readClassDef(e, a + d)),
                          (s.scset = []);
                        var p = o.readUshort(e, r);
                        for (r += 2, u = 0; u < p; u++) {
                          var f = o.readUshort(e, r);
                          (r += 2),
                            s.scset.push(
                              0 == f ? null : t.GSUB.readSubClassSet(e, a + f)
                            );
                        }
                      }
                    } else if (6 == n && 3 == s.fmt) {
                      if (3 == s.fmt) {
                        for (u = 0; u < 3; u++) {
                          (c = o.readUshort(e, r)), (r += 2);
                          for (var m = [], g = 0; g < c; g++)
                            m.push(
                              t._lctf.readCoverage(
                                e,
                                a + o.readUshort(e, r + 2 * g)
                              )
                            );
                          (r += 2 * c),
                            0 == u && (s.backCvg = m),
                            1 == u && (s.inptCvg = m),
                            2 == u && (s.ahedCvg = m);
                        }
                        (c = o.readUshort(e, r)),
                          (r += 2),
                          (s.lookupRec = t.GSUB.readSubstLookupRecords(
                            e,
                            r,
                            c
                          ));
                      }
                    } else {
                      if (7 == n && 1 == s.fmt) {
                        var v = o.readUshort(e, r);
                        r += 2;
                        var y = o.readUint(e, r);
                        if (((r += 4), 9 == i.ltype)) i.ltype = v;
                        else if (i.ltype != v)
                          throw "invalid extension substitution";
                        return t.GSUB.subt(e, i.ltype, a + y);
                      }
                      console.debug(
                        "unsupported GSUB table LookupType",
                        n,
                        "format",
                        s.fmt
                      );
                    }
                    return s;
                  }),
                  (t.GSUB.readSubClassSet = function (e, n) {
                    var r = t._bin.readUshort,
                      i = n,
                      o = [],
                      a = r(e, n);
                    n += 2;
                    for (var s = 0; s < a; s++) {
                      var l = r(e, n);
                      (n += 2), o.push(t.GSUB.readSubClassRule(e, i + l));
                    }
                    return o;
                  }),
                  (t.GSUB.readSubClassRule = function (e, n) {
                    var r = t._bin.readUshort,
                      i = {},
                      o = r(e, n),
                      a = r(e, (n += 2));
                    (n += 2), (i.input = []);
                    for (var s = 0; s < o - 1; s++)
                      i.input.push(r(e, n)), (n += 2);
                    return (
                      (i.substLookupRecords = t.GSUB.readSubstLookupRecords(
                        e,
                        n,
                        a
                      )),
                      i
                    );
                  }),
                  (t.GSUB.readSubstLookupRecords = function (e, n, r) {
                    for (var i = t._bin.readUshort, o = [], a = 0; a < r; a++)
                      o.push(i(e, n), i(e, n + 2)), (n += 4);
                    return o;
                  }),
                  (t.GSUB.readChainSubClassSet = function (e, n) {
                    var r = t._bin,
                      i = n,
                      o = [],
                      a = r.readUshort(e, n);
                    n += 2;
                    for (var s = 0; s < a; s++) {
                      var l = r.readUshort(e, n);
                      (n += 2), o.push(t.GSUB.readChainSubClassRule(e, i + l));
                    }
                    return o;
                  }),
                  (t.GSUB.readChainSubClassRule = function (e, n) {
                    for (
                      var r = t._bin,
                        i = {},
                        o = ["backtrack", "input", "lookahead"],
                        a = 0;
                      a < o.length;
                      a++
                    ) {
                      var s = r.readUshort(e, n);
                      (n += 2),
                        1 == a && s--,
                        (i[o[a]] = r.readUshorts(e, n, s)),
                        (n += 2 * i[o[a]].length);
                    }
                    return (
                      (s = r.readUshort(e, n)),
                      (n += 2),
                      (i.subst = r.readUshorts(e, n, 2 * s)),
                      (n += 2 * i.subst.length),
                      i
                    );
                  }),
                  (t.GSUB.readLigatureSet = function (e, n) {
                    var r = t._bin,
                      i = n,
                      o = [],
                      a = r.readUshort(e, n);
                    n += 2;
                    for (var s = 0; s < a; s++) {
                      var l = r.readUshort(e, n);
                      (n += 2), o.push(t.GSUB.readLigature(e, i + l));
                    }
                    return o;
                  }),
                  (t.GSUB.readLigature = function (e, n) {
                    var r = t._bin,
                      i = {
                        chain: [],
                      };
                    (i.nglyph = r.readUshort(e, n)), (n += 2);
                    var o = r.readUshort(e, n);
                    n += 2;
                    for (var a = 0; a < o - 1; a++)
                      i.chain.push(r.readUshort(e, n)), (n += 2);
                    return i;
                  }),
                  (t.head = {}),
                  (t.head.parse = function (e, n, r) {
                    var i = t._bin,
                      o = {};
                    return (
                      i.readFixed(e, n),
                      (n += 4),
                      (o.fontRevision = i.readFixed(e, n)),
                      (n += 4),
                      i.readUint(e, n),
                      (n += 4),
                      i.readUint(e, n),
                      (n += 4),
                      (o.flags = i.readUshort(e, n)),
                      (n += 2),
                      (o.unitsPerEm = i.readUshort(e, n)),
                      (n += 2),
                      (o.created = i.readUint64(e, n)),
                      (n += 8),
                      (o.modified = i.readUint64(e, n)),
                      (n += 8),
                      (o.xMin = i.readShort(e, n)),
                      (n += 2),
                      (o.yMin = i.readShort(e, n)),
                      (n += 2),
                      (o.xMax = i.readShort(e, n)),
                      (n += 2),
                      (o.yMax = i.readShort(e, n)),
                      (n += 2),
                      (o.macStyle = i.readUshort(e, n)),
                      (n += 2),
                      (o.lowestRecPPEM = i.readUshort(e, n)),
                      (n += 2),
                      (o.fontDirectionHint = i.readShort(e, n)),
                      (n += 2),
                      (o.indexToLocFormat = i.readShort(e, n)),
                      (n += 2),
                      (o.glyphDataFormat = i.readShort(e, n)),
                      (n += 2),
                      o
                    );
                  }),
                  (t.hhea = {}),
                  (t.hhea.parse = function (e, n, r) {
                    var i = t._bin,
                      o = {};
                    return (
                      i.readFixed(e, n),
                      (n += 4),
                      (o.ascender = i.readShort(e, n)),
                      (n += 2),
                      (o.descender = i.readShort(e, n)),
                      (n += 2),
                      (o.lineGap = i.readShort(e, n)),
                      (n += 2),
                      (o.advanceWidthMax = i.readUshort(e, n)),
                      (n += 2),
                      (o.minLeftSideBearing = i.readShort(e, n)),
                      (n += 2),
                      (o.minRightSideBearing = i.readShort(e, n)),
                      (n += 2),
                      (o.xMaxExtent = i.readShort(e, n)),
                      (n += 2),
                      (o.caretSlopeRise = i.readShort(e, n)),
                      (n += 2),
                      (o.caretSlopeRun = i.readShort(e, n)),
                      (n += 2),
                      (o.caretOffset = i.readShort(e, n)),
                      (n += 2),
                      (n += 8),
                      (o.metricDataFormat = i.readShort(e, n)),
                      (n += 2),
                      (o.numberOfHMetrics = i.readUshort(e, n)),
                      (n += 2),
                      o
                    );
                  }),
                  (t.hmtx = {}),
                  (t.hmtx.parse = function (e, n, r, i) {
                    for (
                      var o = t._bin,
                        a = {
                          aWidth: [],
                          lsBearing: [],
                        },
                        s = 0,
                        l = 0,
                        c = 0;
                      c < i.maxp.numGlyphs;
                      c++
                    )
                      c < i.hhea.numberOfHMetrics &&
                        ((s = o.readUshort(e, n)),
                        (n += 2),
                        (l = o.readShort(e, n)),
                        (n += 2)),
                        a.aWidth.push(s),
                        a.lsBearing.push(l);
                    return a;
                  }),
                  (t.kern = {}),
                  (t.kern.parse = function (e, n, r, i) {
                    var o = t._bin,
                      a = o.readUshort(e, n);
                    if (((n += 2), 1 == a))
                      return t.kern.parseV1(e, n - 2, r, i);
                    var s = o.readUshort(e, n);
                    n += 2;
                    for (
                      var l = {
                          glyph1: [],
                          rval: [],
                        },
                        c = 0;
                      c < s;
                      c++
                    ) {
                      (n += 2), (r = o.readUshort(e, n)), (n += 2);
                      var u = o.readUshort(e, n);
                      n += 2;
                      var h = u >>> 8;
                      if (0 != (h &= 15))
                        throw "unknown kern table format: " + h;
                      n = t.kern.readFormat0(e, n, l);
                    }
                    return l;
                  }),
                  (t.kern.parseV1 = function (e, n, r, i) {
                    var o = t._bin;
                    o.readFixed(e, n), (n += 4);
                    var a = o.readUint(e, n);
                    n += 4;
                    for (
                      var s = {
                          glyph1: [],
                          rval: [],
                        },
                        l = 0;
                      l < a;
                      l++
                    ) {
                      o.readUint(e, n), (n += 4);
                      var c = o.readUshort(e, n);
                      (n += 2), o.readUshort(e, n), (n += 2);
                      var u = c >>> 8;
                      if (0 != (u &= 15))
                        throw "unknown kern table format: " + u;
                      n = t.kern.readFormat0(e, n, s);
                    }
                    return s;
                  }),
                  (t.kern.readFormat0 = function (e, n, r) {
                    var i = t._bin,
                      o = -1,
                      a = i.readUshort(e, n);
                    (n += 2),
                      i.readUshort(e, n),
                      (n += 2),
                      i.readUshort(e, n),
                      (n += 2),
                      i.readUshort(e, n),
                      (n += 2);
                    for (var s = 0; s < a; s++) {
                      var l = i.readUshort(e, n);
                      n += 2;
                      var c = i.readUshort(e, n);
                      n += 2;
                      var u = i.readShort(e, n);
                      (n += 2),
                        l != o &&
                          (r.glyph1.push(l),
                          r.rval.push({
                            glyph2: [],
                            vals: [],
                          }));
                      var h = r.rval[r.rval.length - 1];
                      h.glyph2.push(c), h.vals.push(u), (o = l);
                    }
                    return n;
                  }),
                  (t.loca = {}),
                  (t.loca.parse = function (e, n, r, i) {
                    var o = t._bin,
                      a = [],
                      s = i.head.indexToLocFormat,
                      l = i.maxp.numGlyphs + 1;
                    if (0 == s)
                      for (var c = 0; c < l; c++)
                        a.push(o.readUshort(e, n + (c << 1)) << 1);
                    if (1 == s)
                      for (c = 0; c < l; c++)
                        a.push(o.readUint(e, n + (c << 2)));
                    return a;
                  }),
                  (t.maxp = {}),
                  (t.maxp.parse = function (e, n, r) {
                    var i = t._bin,
                      o = {},
                      a = i.readUint(e, n);
                    return (
                      (n += 4),
                      (o.numGlyphs = i.readUshort(e, n)),
                      (n += 2),
                      65536 == a &&
                        ((o.maxPoints = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxContours = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxCompositePoints = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxCompositeContours = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxZones = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxTwilightPoints = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxStorage = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxFunctionDefs = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxInstructionDefs = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxStackElements = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxSizeOfInstructions = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxComponentElements = i.readUshort(e, n)),
                        (n += 2),
                        (o.maxComponentDepth = i.readUshort(e, n)),
                        (n += 2)),
                      o
                    );
                  }),
                  (t.name = {}),
                  (t.name.parse = function (e, n, r) {
                    var i = t._bin,
                      o = {};
                    i.readUshort(e, n), (n += 2);
                    var a = i.readUshort(e, n);
                    (n += 2), i.readUshort(e, n);
                    for (
                      var s,
                        l = [
                          "copyright",
                          "fontFamily",
                          "fontSubfamily",
                          "ID",
                          "fullName",
                          "version",
                          "postScriptName",
                          "trademark",
                          "manufacturer",
                          "designer",
                          "description",
                          "urlVendor",
                          "urlDesigner",
                          "licence",
                          "licenceURL",
                          "---",
                          "typoFamilyName",
                          "typoSubfamilyName",
                          "compatibleFull",
                          "sampleText",
                          "postScriptCID",
                          "wwsFamilyName",
                          "wwsSubfamilyName",
                          "lightPalette",
                          "darkPalette",
                        ],
                        c = (n += 2),
                        u = 0;
                      u < a;
                      u++
                    ) {
                      var h = i.readUshort(e, n);
                      n += 2;
                      var d = i.readUshort(e, n);
                      n += 2;
                      var p = i.readUshort(e, n);
                      n += 2;
                      var f = i.readUshort(e, n);
                      n += 2;
                      var m = i.readUshort(e, n);
                      n += 2;
                      var g = i.readUshort(e, n);
                      n += 2;
                      var v,
                        y = l[f],
                        x = c + 12 * a + g;
                      if (0 == h) v = i.readUnicode(e, x, m / 2);
                      else if (3 == h && 0 == d) v = i.readUnicode(e, x, m / 2);
                      else if (0 == d) v = i.readASCII(e, x, m);
                      else if (1 == d) v = i.readUnicode(e, x, m / 2);
                      else if (3 == d) v = i.readUnicode(e, x, m / 2);
                      else {
                        if (1 != h)
                          throw "unknown encoding " + d + ", platformID: " + h;
                        (v = i.readASCII(e, x, m)),
                          console.debug(
                            "reading unknown MAC encoding " + d + " as ASCII"
                          );
                      }
                      var b = "p" + h + "," + p.toString(16);
                      null == o[b] && (o[b] = {}),
                        (o[b][void 0 !== y ? y : f] = v),
                        (o[b]._lang = p);
                    }
                    for (var w in o)
                      if (null != o[w].postScriptName && 1033 == o[w]._lang)
                        return o[w];
                    for (var w in o)
                      if (null != o[w].postScriptName && 0 == o[w]._lang)
                        return o[w];
                    for (var w in o)
                      if (null != o[w].postScriptName && 3084 == o[w]._lang)
                        return o[w];
                    for (var w in o)
                      if (null != o[w].postScriptName) return o[w];
                    for (var w in o) {
                      s = w;
                      break;
                    }
                    return (
                      console.debug(
                        "returning name table with languageID " + o[s]._lang
                      ),
                      o[s]
                    );
                  }),
                  (t["OS/2"] = {}),
                  (t["OS/2"].parse = function (e, n, r) {
                    var i = t._bin.readUshort(e, n);
                    n += 2;
                    var o = {};
                    if (0 == i) t["OS/2"].version0(e, n, o);
                    else if (1 == i) t["OS/2"].version1(e, n, o);
                    else if (2 == i || 3 == i || 4 == i)
                      t["OS/2"].version2(e, n, o);
                    else {
                      if (5 != i) throw "unknown OS/2 table version: " + i;
                      t["OS/2"].version5(e, n, o);
                    }
                    return o;
                  }),
                  (t["OS/2"].version0 = function (e, n, r) {
                    var i = t._bin;
                    return (
                      (r.xAvgCharWidth = i.readShort(e, n)),
                      (n += 2),
                      (r.usWeightClass = i.readUshort(e, n)),
                      (n += 2),
                      (r.usWidthClass = i.readUshort(e, n)),
                      (n += 2),
                      (r.fsType = i.readUshort(e, n)),
                      (n += 2),
                      (r.ySubscriptXSize = i.readShort(e, n)),
                      (n += 2),
                      (r.ySubscriptYSize = i.readShort(e, n)),
                      (n += 2),
                      (r.ySubscriptXOffset = i.readShort(e, n)),
                      (n += 2),
                      (r.ySubscriptYOffset = i.readShort(e, n)),
                      (n += 2),
                      (r.ySuperscriptXSize = i.readShort(e, n)),
                      (n += 2),
                      (r.ySuperscriptYSize = i.readShort(e, n)),
                      (n += 2),
                      (r.ySuperscriptXOffset = i.readShort(e, n)),
                      (n += 2),
                      (r.ySuperscriptYOffset = i.readShort(e, n)),
                      (n += 2),
                      (r.yStrikeoutSize = i.readShort(e, n)),
                      (n += 2),
                      (r.yStrikeoutPosition = i.readShort(e, n)),
                      (n += 2),
                      (r.sFamilyClass = i.readShort(e, n)),
                      (n += 2),
                      (r.panose = i.readBytes(e, n, 10)),
                      (n += 10),
                      (r.ulUnicodeRange1 = i.readUint(e, n)),
                      (n += 4),
                      (r.ulUnicodeRange2 = i.readUint(e, n)),
                      (n += 4),
                      (r.ulUnicodeRange3 = i.readUint(e, n)),
                      (n += 4),
                      (r.ulUnicodeRange4 = i.readUint(e, n)),
                      (n += 4),
                      (r.achVendID = [
                        i.readInt8(e, n),
                        i.readInt8(e, n + 1),
                        i.readInt8(e, n + 2),
                        i.readInt8(e, n + 3),
                      ]),
                      (n += 4),
                      (r.fsSelection = i.readUshort(e, n)),
                      (n += 2),
                      (r.usFirstCharIndex = i.readUshort(e, n)),
                      (n += 2),
                      (r.usLastCharIndex = i.readUshort(e, n)),
                      (n += 2),
                      (r.sTypoAscender = i.readShort(e, n)),
                      (n += 2),
                      (r.sTypoDescender = i.readShort(e, n)),
                      (n += 2),
                      (r.sTypoLineGap = i.readShort(e, n)),
                      (n += 2),
                      (r.usWinAscent = i.readUshort(e, n)),
                      (n += 2),
                      (r.usWinDescent = i.readUshort(e, n)),
                      n + 2
                    );
                  }),
                  (t["OS/2"].version1 = function (e, n, r) {
                    var i = t._bin;
                    return (
                      (n = t["OS/2"].version0(e, n, r)),
                      (r.ulCodePageRange1 = i.readUint(e, n)),
                      (n += 4),
                      (r.ulCodePageRange2 = i.readUint(e, n)),
                      n + 4
                    );
                  }),
                  (t["OS/2"].version2 = function (e, n, r) {
                    var i = t._bin;
                    return (
                      (n = t["OS/2"].version1(e, n, r)),
                      (r.sxHeight = i.readShort(e, n)),
                      (n += 2),
                      (r.sCapHeight = i.readShort(e, n)),
                      (n += 2),
                      (r.usDefault = i.readUshort(e, n)),
                      (n += 2),
                      (r.usBreak = i.readUshort(e, n)),
                      (n += 2),
                      (r.usMaxContext = i.readUshort(e, n)),
                      n + 2
                    );
                  }),
                  (t["OS/2"].version5 = function (e, n, r) {
                    var i = t._bin;
                    return (
                      (n = t["OS/2"].version2(e, n, r)),
                      (r.usLowerOpticalPointSize = i.readUshort(e, n)),
                      (n += 2),
                      (r.usUpperOpticalPointSize = i.readUshort(e, n)),
                      n + 2
                    );
                  }),
                  (t.post = {}),
                  (t.post.parse = function (e, n, r) {
                    var i = t._bin,
                      o = {};
                    return (
                      (o.version = i.readFixed(e, n)),
                      (n += 4),
                      (o.italicAngle = i.readFixed(e, n)),
                      (n += 4),
                      (o.underlinePosition = i.readShort(e, n)),
                      (n += 2),
                      (o.underlineThickness = i.readShort(e, n)),
                      (n += 2),
                      o
                    );
                  }),
                  null == t && (t = {}),
                  null == t.U && (t.U = {}),
                  (t.U.codeToGlyph = function (e, t) {
                    var n = e.cmap,
                      r = -1;
                    if (
                      (null != n.p0e4
                        ? (r = n.p0e4)
                        : null != n.p3e1
                        ? (r = n.p3e1)
                        : null != n.p1e0
                        ? (r = n.p1e0)
                        : null != n.p0e3 && (r = n.p0e3),
                      -1 == r)
                    )
                      throw "no familiar platform and encoding!";
                    var i = n.tables[r];
                    if (0 == i.format) return t >= i.map.length ? 0 : i.map[t];
                    if (4 == i.format) {
                      for (var o = -1, a = 0; a < i.endCount.length; a++)
                        if (t <= i.endCount[a]) {
                          o = a;
                          break;
                        }
                      return -1 == o || i.startCount[o] > t
                        ? 0
                        : 65535 &
                            (0 != i.idRangeOffset[o]
                              ? i.glyphIdArray[
                                  t -
                                    i.startCount[o] +
                                    (i.idRangeOffset[o] >> 1) -
                                    (i.idRangeOffset.length - o)
                                ]
                              : t + i.idDelta[o]);
                    }
                    if (12 == i.format) {
                      if (t > i.groups[i.groups.length - 1][1]) return 0;
                      for (a = 0; a < i.groups.length; a++) {
                        var s = i.groups[a];
                        if (s[0] <= t && t <= s[1]) return s[2] + (t - s[0]);
                      }
                      return 0;
                    }
                    throw "unknown cmap table format " + i.format;
                  }),
                  (t.U.glyphToPath = function (e, n) {
                    var r = {
                      cmds: [],
                      crds: [],
                    };
                    if (e.SVG && e.SVG.entries[n]) {
                      var i = e.SVG.entries[n];
                      return null == i
                        ? r
                        : ("string" == typeof i &&
                            ((i = t.SVG.toPath(i)), (e.SVG.entries[n] = i)),
                          i);
                    }
                    if (e.CFF) {
                      var o = {
                          x: 0,
                          y: 0,
                          stack: [],
                          nStems: 0,
                          haveWidth: !1,
                          width: e.CFF.Private
                            ? e.CFF.Private.defaultWidthX
                            : 0,
                          open: !1,
                        },
                        a = e.CFF,
                        s = e.CFF.Private;
                      if (a.ROS) {
                        for (var l = 0; a.FDSelect[l + 2] <= n; ) l += 2;
                        s = a.FDArray[a.FDSelect[l + 1]].Private;
                      }
                      t.U._drawCFF(e.CFF.CharStrings[n], o, a, s, r);
                    } else e.glyf && t.U._drawGlyf(n, e, r);
                    return r;
                  }),
                  (t.U._drawGlyf = function (e, n, r) {
                    var i = n.glyf[e];
                    null == i && (i = n.glyf[e] = t.glyf._parseGlyf(n, e)),
                      null != i &&
                        (i.noc > -1
                          ? t.U._simpleGlyph(i, r)
                          : t.U._compoGlyph(i, n, r));
                  }),
                  (t.U._simpleGlyph = function (e, n) {
                    for (var r = 0; r < e.noc; r++) {
                      for (
                        var i = 0 == r ? 0 : e.endPts[r - 1] + 1,
                          o = e.endPts[r],
                          a = i;
                        a <= o;
                        a++
                      ) {
                        var s = a == i ? o : a - 1,
                          l = a == o ? i : a + 1,
                          c = 1 & e.flags[a],
                          u = 1 & e.flags[s],
                          h = 1 & e.flags[l],
                          d = e.xs[a],
                          p = e.ys[a];
                        if (a == i)
                          if (c) {
                            if (!u) {
                              t.U.P.moveTo(n, d, p);
                              continue;
                            }
                            t.U.P.moveTo(n, e.xs[s], e.ys[s]);
                          } else
                            u
                              ? t.U.P.moveTo(n, e.xs[s], e.ys[s])
                              : t.U.P.moveTo(
                                  n,
                                  (e.xs[s] + d) / 2,
                                  (e.ys[s] + p) / 2
                                );
                        c
                          ? u && t.U.P.lineTo(n, d, p)
                          : h
                          ? t.U.P.qcurveTo(n, d, p, e.xs[l], e.ys[l])
                          : t.U.P.qcurveTo(
                              n,
                              d,
                              p,
                              (d + e.xs[l]) / 2,
                              (p + e.ys[l]) / 2
                            );
                      }
                      t.U.P.closePath(n);
                    }
                  }),
                  (t.U._compoGlyph = function (e, n, r) {
                    for (var i = 0; i < e.parts.length; i++) {
                      var o = {
                          cmds: [],
                          crds: [],
                        },
                        a = e.parts[i];
                      t.U._drawGlyf(a.glyphIndex, n, o);
                      for (var s = a.m, l = 0; l < o.crds.length; l += 2) {
                        var c = o.crds[l],
                          u = o.crds[l + 1];
                        r.crds.push(c * s.a + u * s.b + s.tx),
                          r.crds.push(c * s.c + u * s.d + s.ty);
                      }
                      for (l = 0; l < o.cmds.length; l++)
                        r.cmds.push(o.cmds[l]);
                    }
                  }),
                  (t.U._getGlyphClass = function (e, n) {
                    var r = t._lctf.getInterval(n, e);
                    return -1 == r ? 0 : n[r + 2];
                  }),
                  (t.U.getPairAdjustment = function (e, n, r) {
                    var i = 0;
                    if (e.GPOS)
                      for (
                        var o = e.GPOS,
                          a = o.lookupList,
                          s = o.featureList,
                          l = [],
                          c = 0;
                        c < s.length;
                        c++
                      ) {
                        var u = s[c];
                        if ("kern" == u.tag)
                          for (var h = 0; h < u.tab.length; h++)
                            if (!l[u.tab[h]]) {
                              l[u.tab[h]] = !0;
                              for (
                                var d = a[u.tab[h]], p = 0;
                                p < d.tabs.length;
                                p++
                              )
                                if (null != d.tabs[p]) {
                                  var f,
                                    m = d.tabs[p];
                                  if (
                                    !m.coverage ||
                                    -1 !=
                                      (f = t._lctf.coverageIndex(m.coverage, n))
                                  )
                                    if (1 == d.ltype);
                                    else if (2 == d.ltype) {
                                      var g;
                                      if (1 == m.fmt) {
                                        var v = m.pairsets[f];
                                        for (c = 0; c < v.length; c++)
                                          v[c].gid2 == r && (g = v[c]);
                                      } else if (2 == m.fmt) {
                                        var y = t.U._getGlyphClass(
                                            n,
                                            m.classDef1
                                          ),
                                          x = t.U._getGlyphClass(
                                            r,
                                            m.classDef2
                                          );
                                        g = m.matrix[y][x];
                                      }
                                      g &&
                                        g.val1 &&
                                        g.val1[2] &&
                                        (i += g.val1[2]),
                                        g &&
                                          g.val2 &&
                                          g.val2[0] &&
                                          (i += g.val2[0]);
                                    }
                                }
                            }
                      }
                    if (e.kern) {
                      var b = e.kern.glyph1.indexOf(n);
                      if (-1 != b) {
                        var w = e.kern.rval[b].glyph2.indexOf(r);
                        -1 != w && (i += e.kern.rval[b].vals[w]);
                      }
                    }
                    return i;
                  }),
                  (t.U._applySubs = function (e, n, r, i) {
                    for (
                      var o = e.length - n - 1, a = 0;
                      a < r.tabs.length;
                      a++
                    )
                      if (null != r.tabs[a]) {
                        var s,
                          l = r.tabs[a];
                        if (
                          !l.coverage ||
                          -1 != (s = t._lctf.coverageIndex(l.coverage, e[n]))
                        )
                          if (1 == r.ltype)
                            e[n],
                              1 == l.fmt
                                ? (e[n] = e[n] + l.delta)
                                : (e[n] = l.newg[s]);
                          else if (4 == r.ltype)
                            for (var c = l.vals[s], u = 0; u < c.length; u++) {
                              var h = c[u],
                                d = h.chain.length;
                              if (!(d > o)) {
                                for (var p = !0, f = 0, m = 0; m < d; m++) {
                                  for (; -1 == e[n + f + (1 + m)]; ) f++;
                                  h.chain[m] != e[n + f + (1 + m)] && (p = !1);
                                }
                                if (p) {
                                  for (e[n] = h.nglyph, m = 0; m < d + f; m++)
                                    e[n + m + 1] = -1;
                                  break;
                                }
                              }
                            }
                          else if (5 == r.ltype && 2 == l.fmt)
                            for (
                              var g = t._lctf.getInterval(l.cDef, e[n]),
                                v = l.cDef[g + 2],
                                y = l.scset[v],
                                x = 0;
                              x < y.length;
                              x++
                            ) {
                              var b = y[x],
                                w = b.input;
                              if (!(w.length > o)) {
                                for (p = !0, m = 0; m < w.length; m++) {
                                  var _ = t._lctf.getInterval(
                                    l.cDef,
                                    e[n + 1 + m]
                                  );
                                  if (-1 == g && l.cDef[_ + 2] != w[m]) {
                                    p = !1;
                                    break;
                                  }
                                }
                                if (p) {
                                  var M = b.substLookupRecords;
                                  for (u = 0; u < M.length; u += 2)
                                    M[u], M[u + 1];
                                }
                              }
                            }
                          else if (6 == r.ltype && 3 == l.fmt) {
                            if (
                              !t.U._glsCovered(
                                e,
                                l.backCvg,
                                n - l.backCvg.length
                              )
                            )
                              continue;
                            if (!t.U._glsCovered(e, l.inptCvg, n)) continue;
                            if (
                              !t.U._glsCovered(
                                e,
                                l.ahedCvg,
                                n + l.inptCvg.length
                              )
                            )
                              continue;
                            var S = l.lookupRec;
                            for (x = 0; x < S.length; x += 2) {
                              g = S[x];
                              var T = i[S[x + 1]];
                              t.U._applySubs(e, n + g, T, i);
                            }
                          }
                      }
                  }),
                  (t.U._glsCovered = function (e, n, r) {
                    for (var i = 0; i < n.length; i++)
                      if (-1 == t._lctf.coverageIndex(n[i], e[r + i]))
                        return !1;
                    return !0;
                  }),
                  (t.U.glyphsToPath = function (e, n, r) {
                    for (
                      var i = {
                          cmds: [],
                          crds: [],
                        },
                        o = 0,
                        a = 0;
                      a < n.length;
                      a++
                    ) {
                      var s = n[a];
                      if (-1 != s) {
                        for (
                          var l =
                              a < n.length - 1 && -1 != n[a + 1] ? n[a + 1] : 0,
                            c = t.U.glyphToPath(e, s),
                            u = 0;
                          u < c.crds.length;
                          u += 2
                        )
                          i.crds.push(c.crds[u] + o),
                            i.crds.push(c.crds[u + 1]);
                        for (r && i.cmds.push(r), u = 0; u < c.cmds.length; u++)
                          i.cmds.push(c.cmds[u]);
                        r && i.cmds.push("X"),
                          (o += e.hmtx.aWidth[s]),
                          a < n.length - 1 &&
                            (o += t.U.getPairAdjustment(e, s, l));
                      }
                    }
                    return i;
                  }),
                  (t.U.P = {}),
                  (t.U.P.moveTo = function (e, t, n) {
                    e.cmds.push("M"), e.crds.push(t, n);
                  }),
                  (t.U.P.lineTo = function (e, t, n) {
                    e.cmds.push("L"), e.crds.push(t, n);
                  }),
                  (t.U.P.curveTo = function (e, t, n, r, i, o, a) {
                    e.cmds.push("C"), e.crds.push(t, n, r, i, o, a);
                  }),
                  (t.U.P.qcurveTo = function (e, t, n, r, i) {
                    e.cmds.push("Q"), e.crds.push(t, n, r, i);
                  }),
                  (t.U.P.closePath = function (e) {
                    e.cmds.push("Z");
                  }),
                  (t.U._drawCFF = function (e, n, r, i, o) {
                    for (
                      var a = n.stack,
                        s = n.nStems,
                        l = n.haveWidth,
                        c = n.width,
                        u = n.open,
                        h = 0,
                        d = n.x,
                        p = n.y,
                        f = 0,
                        m = 0,
                        g = 0,
                        v = 0,
                        y = 0,
                        x = 0,
                        b = 0,
                        w = 0,
                        _ = 0,
                        M = 0,
                        S = {
                          val: 0,
                          size: 0,
                        };
                      h < e.length;

                    ) {
                      t.CFF.getCharString(e, h, S);
                      var T = S.val;
                      if (((h += S.size), "o1" == T || "o18" == T))
                        a.length % 2 != 0 &&
                          !l &&
                          (c = a.shift() + i.nominalWidthX),
                          (s += a.length >> 1),
                          (a.length = 0),
                          (l = !0);
                      else if ("o3" == T || "o23" == T)
                        a.length % 2 != 0 &&
                          !l &&
                          (c = a.shift() + i.nominalWidthX),
                          (s += a.length >> 1),
                          (a.length = 0),
                          (l = !0);
                      else if ("o4" == T)
                        a.length > 1 &&
                          !l &&
                          ((c = a.shift() + i.nominalWidthX), (l = !0)),
                          u && t.U.P.closePath(o),
                          (p += a.pop()),
                          t.U.P.moveTo(o, d, p),
                          (u = !0);
                      else if ("o5" == T)
                        for (; a.length > 0; )
                          (d += a.shift()),
                            (p += a.shift()),
                            t.U.P.lineTo(o, d, p);
                      else if ("o6" == T || "o7" == T)
                        for (
                          var E = a.length, A = "o6" == T, C = 0;
                          C < E;
                          C++
                        ) {
                          var P = a.shift();
                          A ? (d += P) : (p += P),
                            (A = !A),
                            t.U.P.lineTo(o, d, p);
                        }
                      else if ("o8" == T || "o24" == T) {
                        E = a.length;
                        for (var L = 0; L + 6 <= E; )
                          (f = d + a.shift()),
                            (m = p + a.shift()),
                            (g = f + a.shift()),
                            (v = m + a.shift()),
                            (d = g + a.shift()),
                            (p = v + a.shift()),
                            t.U.P.curveTo(o, f, m, g, v, d, p),
                            (L += 6);
                        "o24" == T &&
                          ((d += a.shift()),
                          (p += a.shift()),
                          t.U.P.lineTo(o, d, p));
                      } else {
                        if ("o11" == T) break;
                        if (
                          "o1234" == T ||
                          "o1235" == T ||
                          "o1236" == T ||
                          "o1237" == T
                        )
                          "o1234" == T &&
                            ((m = p),
                            (g = (f = d + a.shift()) + a.shift()),
                            (M = v = m + a.shift()),
                            (x = v),
                            (w = p),
                            (d =
                              (b =
                                (y = (_ = g + a.shift()) + a.shift()) +
                                a.shift()) + a.shift()),
                            t.U.P.curveTo(o, f, m, g, v, _, M),
                            t.U.P.curveTo(o, y, x, b, w, d, p)),
                            "o1235" == T &&
                              ((f = d + a.shift()),
                              (m = p + a.shift()),
                              (g = f + a.shift()),
                              (v = m + a.shift()),
                              (_ = g + a.shift()),
                              (M = v + a.shift()),
                              (y = _ + a.shift()),
                              (x = M + a.shift()),
                              (b = y + a.shift()),
                              (w = x + a.shift()),
                              (d = b + a.shift()),
                              (p = w + a.shift()),
                              a.shift(),
                              t.U.P.curveTo(o, f, m, g, v, _, M),
                              t.U.P.curveTo(o, y, x, b, w, d, p)),
                            "o1236" == T &&
                              ((f = d + a.shift()),
                              (m = p + a.shift()),
                              (g = f + a.shift()),
                              (M = v = m + a.shift()),
                              (x = v),
                              (b =
                                (y = (_ = g + a.shift()) + a.shift()) +
                                a.shift()),
                              (w = x + a.shift()),
                              (d = b + a.shift()),
                              t.U.P.curveTo(o, f, m, g, v, _, M),
                              t.U.P.curveTo(o, y, x, b, w, d, p)),
                            "o1237" == T &&
                              ((f = d + a.shift()),
                              (m = p + a.shift()),
                              (g = f + a.shift()),
                              (v = m + a.shift()),
                              (_ = g + a.shift()),
                              (M = v + a.shift()),
                              (y = _ + a.shift()),
                              (x = M + a.shift()),
                              (b = y + a.shift()),
                              (w = x + a.shift()),
                              Math.abs(b - d) > Math.abs(w - p)
                                ? (d = b + a.shift())
                                : (p = w + a.shift()),
                              t.U.P.curveTo(o, f, m, g, v, _, M),
                              t.U.P.curveTo(o, y, x, b, w, d, p));
                        else if ("o14" == T) {
                          if (
                            (a.length > 0 &&
                              !l &&
                              ((c = a.shift() + r.nominalWidthX), (l = !0)),
                            4 == a.length)
                          ) {
                            var R = a.shift(),
                              I = a.shift(),
                              k = a.shift(),
                              D = a.shift(),
                              O = t.CFF.glyphBySE(r, k),
                              B = t.CFF.glyphBySE(r, D);
                            t.U._drawCFF(r.CharStrings[O], n, r, i, o),
                              (n.x = R),
                              (n.y = I),
                              t.U._drawCFF(r.CharStrings[B], n, r, i, o);
                          }
                          u && (t.U.P.closePath(o), (u = !1));
                        } else if ("o19" == T || "o20" == T)
                          a.length % 2 != 0 &&
                            !l &&
                            (c = a.shift() + i.nominalWidthX),
                            (s += a.length >> 1),
                            (a.length = 0),
                            (l = !0),
                            (h += (s + 7) >> 3);
                        else if ("o21" == T)
                          a.length > 2 &&
                            !l &&
                            ((c = a.shift() + i.nominalWidthX), (l = !0)),
                            (p += a.pop()),
                            (d += a.pop()),
                            u && t.U.P.closePath(o),
                            t.U.P.moveTo(o, d, p),
                            (u = !0);
                        else if ("o22" == T)
                          a.length > 1 &&
                            !l &&
                            ((c = a.shift() + i.nominalWidthX), (l = !0)),
                            (d += a.pop()),
                            u && t.U.P.closePath(o),
                            t.U.P.moveTo(o, d, p),
                            (u = !0);
                        else if ("o25" == T) {
                          for (; a.length > 6; )
                            (d += a.shift()),
                              (p += a.shift()),
                              t.U.P.lineTo(o, d, p);
                          (f = d + a.shift()),
                            (m = p + a.shift()),
                            (g = f + a.shift()),
                            (v = m + a.shift()),
                            (d = g + a.shift()),
                            (p = v + a.shift()),
                            t.U.P.curveTo(o, f, m, g, v, d, p);
                        } else if ("o26" == T)
                          for (a.length % 2 && (d += a.shift()); a.length > 0; )
                            (f = d),
                              (m = p + a.shift()),
                              (d = g = f + a.shift()),
                              (p = (v = m + a.shift()) + a.shift()),
                              t.U.P.curveTo(o, f, m, g, v, d, p);
                        else if ("o27" == T)
                          for (a.length % 2 && (p += a.shift()); a.length > 0; )
                            (m = p),
                              (g = (f = d + a.shift()) + a.shift()),
                              (v = m + a.shift()),
                              (d = g + a.shift()),
                              (p = v),
                              t.U.P.curveTo(o, f, m, g, v, d, p);
                        else if ("o10" == T || "o29" == T) {
                          var F = "o10" == T ? i : r;
                          if (0 == a.length)
                            console.debug("error: empty stack");
                          else {
                            var N = a.pop(),
                              U = F.Subrs[N + F.Bias];
                            (n.x = d),
                              (n.y = p),
                              (n.nStems = s),
                              (n.haveWidth = l),
                              (n.width = c),
                              (n.open = u),
                              t.U._drawCFF(U, n, r, i, o),
                              (d = n.x),
                              (p = n.y),
                              (s = n.nStems),
                              (l = n.haveWidth),
                              (c = n.width),
                              (u = n.open);
                          }
                        } else if ("o30" == T || "o31" == T) {
                          var z = a.length,
                            H = ((L = 0), "o31" == T);
                          for (L += z - (E = -3 & z); L < E; )
                            H
                              ? ((m = p),
                                (g = (f = d + a.shift()) + a.shift()),
                                (p = (v = m + a.shift()) + a.shift()),
                                E - L == 5
                                  ? ((d = g + a.shift()), L++)
                                  : (d = g),
                                (H = !1))
                              : ((f = d),
                                (m = p + a.shift()),
                                (g = f + a.shift()),
                                (v = m + a.shift()),
                                (d = g + a.shift()),
                                E - L == 5
                                  ? ((p = v + a.shift()), L++)
                                  : (p = v),
                                (H = !0)),
                              t.U.P.curveTo(o, f, m, g, v, d, p),
                              (L += 4);
                        } else {
                          if ("o" == (T + "").charAt(0))
                            throw (
                              (console.debug("Unknown operation: " + T, e), T)
                            );
                          a.push(T);
                        }
                      }
                    }
                    (n.x = d),
                      (n.y = p),
                      (n.nStems = s),
                      (n.haveWidth = l),
                      (n.width = c),
                      (n.open = u);
                  });
                var n = t,
                  r = {
                    Typr: n,
                  };
                return (
                  (e.Typr = n),
                  (e.default = r),
                  Object.defineProperty(e, "__esModule", {
                    value: !0,
                  }),
                  e
                );
              })({}).Typr
            );
          },
          /*!
             Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
             (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
             Original licenses apply: 
             - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
             - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
             */
          function () {
            return (function (e) {
              var t = Uint8Array,
                n = Uint16Array,
                r = Uint32Array,
                i = new t([
                  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4,
                  4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0,
                ]),
                o = new t([
                  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9,
                  9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
                ]),
                a = new t([
                  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1,
                  15,
                ]),
                s = function (e, t) {
                  for (var i = new n(31), o = 0; o < 31; ++o)
                    i[o] = t += 1 << e[o - 1];
                  var a = new r(i[30]);
                  for (o = 1; o < 30; ++o)
                    for (var s = i[o]; s < i[o + 1]; ++s)
                      a[s] = ((s - i[o]) << 5) | o;
                  return [i, a];
                },
                l = s(i, 2),
                c = l[0],
                u = l[1];
              (c[28] = 258), (u[258] = 28);
              for (
                var h = s(o, 0)[0], d = new n(32768), p = 0;
                p < 32768;
                ++p
              ) {
                var f = ((43690 & p) >>> 1) | ((21845 & p) << 1);
                (f =
                  ((61680 & (f = ((52428 & f) >>> 2) | ((13107 & f) << 2))) >>>
                    4) |
                  ((3855 & f) << 4)),
                  (d[p] = (((65280 & f) >>> 8) | ((255 & f) << 8)) >>> 1);
              }
              var m = function (e, t, r) {
                  for (var i = e.length, o = 0, a = new n(t); o < i; ++o)
                    ++a[e[o] - 1];
                  var s,
                    l = new n(t);
                  for (o = 0; o < t; ++o) l[o] = (l[o - 1] + a[o - 1]) << 1;
                  if (r) {
                    s = new n(1 << t);
                    var c = 15 - t;
                    for (o = 0; o < i; ++o)
                      if (e[o])
                        for (
                          var u = (o << 4) | e[o],
                            h = t - e[o],
                            p = l[e[o] - 1]++ << h,
                            f = p | ((1 << h) - 1);
                          p <= f;
                          ++p
                        )
                          s[d[p] >>> c] = u;
                  } else
                    for (s = new n(i), o = 0; o < i; ++o)
                      e[o] && (s[o] = d[l[e[o] - 1]++] >>> (15 - e[o]));
                  return s;
                },
                g = new t(288);
              for (p = 0; p < 144; ++p) g[p] = 8;
              for (p = 144; p < 256; ++p) g[p] = 9;
              for (p = 256; p < 280; ++p) g[p] = 7;
              for (p = 280; p < 288; ++p) g[p] = 8;
              var v = new t(32);
              for (p = 0; p < 32; ++p) v[p] = 5;
              var y = m(g, 9, 1),
                x = m(v, 5, 1),
                b = function (e) {
                  for (var t = e[0], n = 1; n < e.length; ++n)
                    e[n] > t && (t = e[n]);
                  return t;
                },
                w = function (e, t, n) {
                  var r = (t / 8) | 0;
                  return ((e[r] | (e[r + 1] << 8)) >> (7 & t)) & n;
                },
                _ = function (e, t) {
                  var n = (t / 8) | 0;
                  return (e[n] | (e[n + 1] << 8) | (e[n + 2] << 16)) >> (7 & t);
                },
                M = [
                  "unexpected EOF",
                  "invalid block type",
                  "invalid length/literal",
                  "invalid distance",
                  "stream finished",
                  "no stream handler",
                  ,
                  "no callback",
                  "invalid UTF-8 data",
                  "extra field too long",
                  "date not in range 1980-2099",
                  "filename too long",
                  "stream finishing",
                  "invalid zip data",
                ],
                S = function (e, t, n) {
                  var r = new Error(t || M[e]);
                  if (
                    ((r.code = e),
                    Error.captureStackTrace && Error.captureStackTrace(r, S),
                    !n)
                  )
                    throw r;
                  return r;
                },
                T = function (e, s, l) {
                  var u = e.length;
                  if (!u || (l && !l.l && u < 5)) return s || new t(0);
                  var d = !s || l,
                    p = !l || l.i;
                  l || (l = {}), s || (s = new t(3 * u));
                  var f,
                    g = function (e) {
                      var n = s.length;
                      if (e > n) {
                        var r = new t(Math.max(2 * n, e));
                        r.set(s), (s = r);
                      }
                    },
                    v = l.f || 0,
                    M = l.p || 0,
                    T = l.b || 0,
                    E = l.l,
                    A = l.d,
                    C = l.m,
                    P = l.n,
                    L = 8 * u;
                  do {
                    if (!E) {
                      l.f = v = w(e, M, 1);
                      var R = w(e, M + 1, 3);
                      if (((M += 3), !R)) {
                        var I =
                            e[
                              (V = (((f = M) / 8) | 0) + (7 & f && 1) + 4) - 4
                            ] |
                            (e[V - 3] << 8),
                          k = V + I;
                        if (k > u) {
                          p && S(0);
                          break;
                        }
                        d && g(T + I),
                          s.set(e.subarray(V, k), T),
                          (l.b = T += I),
                          (l.p = M = 8 * k);
                        continue;
                      }
                      if (1 == R) (E = y), (A = x), (C = 9), (P = 5);
                      else if (2 == R) {
                        var D = w(e, M, 31) + 257,
                          O = w(e, M + 10, 15) + 4,
                          B = D + w(e, M + 5, 31) + 1;
                        M += 14;
                        for (var F = new t(B), N = new t(19), U = 0; U < O; ++U)
                          N[a[U]] = w(e, M + 3 * U, 7);
                        M += 3 * O;
                        var z = b(N),
                          H = (1 << z) - 1,
                          G = m(N, z, 1);
                        for (U = 0; U < B; ) {
                          var V,
                            j = G[w(e, M, H)];
                          if (((M += 15 & j), (V = j >>> 4) < 16)) F[U++] = V;
                          else {
                            var W = 0,
                              q = 0;
                            for (
                              16 == V
                                ? ((q = 3 + w(e, M, 3)),
                                  (M += 2),
                                  (W = F[U - 1]))
                                : 17 == V
                                ? ((q = 3 + w(e, M, 7)), (M += 3))
                                : 18 == V &&
                                  ((q = 11 + w(e, M, 127)), (M += 7));
                              q--;

                            )
                              F[U++] = W;
                          }
                        }
                        var $ = F.subarray(0, D),
                          X = F.subarray(D);
                        (C = b($)),
                          (P = b(X)),
                          (E = m($, C, 1)),
                          (A = m(X, P, 1));
                      } else S(1);
                      if (M > L) {
                        p && S(0);
                        break;
                      }
                    }
                    d && g(T + 131072);
                    for (
                      var Y = (1 << C) - 1, J = (1 << P) - 1, Z = M;
                      ;
                      Z = M
                    ) {
                      var K = (W = E[_(e, M) & Y]) >>> 4;
                      if ((M += 15 & W) > L) {
                        p && S(0);
                        break;
                      }
                      if ((W || S(2), K < 256)) s[T++] = K;
                      else {
                        if (256 == K) {
                          (Z = M), (E = null);
                          break;
                        }
                        var Q = K - 254;
                        if (K > 264) {
                          var ee = i[(U = K - 257)];
                          (Q = w(e, M, (1 << ee) - 1) + c[U]), (M += ee);
                        }
                        var te = A[_(e, M) & J],
                          ne = te >>> 4;
                        if (
                          (te || S(3),
                          (M += 15 & te),
                          (X = h[ne]),
                          ne > 3 &&
                            ((ee = o[ne]),
                            (X += _(e, M) & ((1 << ee) - 1)),
                            (M += ee)),
                          M > L)
                        ) {
                          p && S(0);
                          break;
                        }
                        d && g(T + 131072);
                        for (var re = T + Q; T < re; T += 4)
                          (s[T] = s[T - X]),
                            (s[T + 1] = s[T + 1 - X]),
                            (s[T + 2] = s[T + 2 - X]),
                            (s[T + 3] = s[T + 3 - X]);
                        T = re;
                      }
                    }
                    (l.l = E),
                      (l.p = Z),
                      (l.b = T),
                      E && ((v = 1), (l.m = C), (l.d = A), (l.n = P));
                  } while (!v);
                  return T == s.length
                    ? s
                    : (function (e, i, o) {
                        (null == i || i < 0) && (i = 0),
                          (null == o || o > e.length) && (o = e.length);
                        var a = new (
                          e instanceof n ? n : e instanceof r ? r : t
                        )(o - i);
                        return a.set(e.subarray(i, o)), a;
                      })(s, 0, T);
                },
                E = new t(0),
                A = "undefined" != typeof TextDecoder && new TextDecoder();
              try {
                A.decode(E, {
                  stream: !0,
                });
              } catch (e) {}
              return (
                (e.convert_streams = function (e) {
                  var t = new DataView(e),
                    n = 0;

                  function r() {
                    var e = t.getUint16(n);
                    return (n += 2), e;
                  }

                  function i() {
                    var e = t.getUint32(n);
                    return (n += 4), e;
                  }

                  function o(e) {
                    v.setUint16(y, e), (y += 2);
                  }

                  function a(e) {
                    v.setUint32(y, e), (y += 4);
                  }
                  for (
                    var s = {
                        signature: i(),
                        flavor: i(),
                        length: i(),
                        numTables: r(),
                        reserved: r(),
                        totalSfntSize: i(),
                        majorVersion: r(),
                        minorVersion: r(),
                        metaOffset: i(),
                        metaLength: i(),
                        metaOrigLength: i(),
                        privOffset: i(),
                        privLength: i(),
                      },
                      l = 0;
                    Math.pow(2, l) <= s.numTables;

                  )
                    l++;
                  l--;
                  for (
                    var c = 16 * Math.pow(2, l),
                      u = 16 * s.numTables - c,
                      h = 12,
                      d = [],
                      p = 0;
                    p < s.numTables;
                    p++
                  )
                    d.push({
                      tag: i(),
                      offset: i(),
                      compLength: i(),
                      origLength: i(),
                      origChecksum: i(),
                    }),
                      (h += 16);
                  var f,
                    m = new Uint8Array(
                      12 +
                        16 * d.length +
                        d.reduce(function (e, t) {
                          return e + t.origLength + 4;
                        }, 0)
                    ),
                    g = m.buffer,
                    v = new DataView(g),
                    y = 0;
                  return (
                    a(s.flavor),
                    o(s.numTables),
                    o(c),
                    o(l),
                    o(u),
                    d.forEach(function (e) {
                      a(e.tag),
                        a(e.origChecksum),
                        a(h),
                        a(e.origLength),
                        (e.outOffset = h),
                        (h += e.origLength) % 4 != 0 && (h += 4 - (h % 4));
                    }),
                    d.forEach(function (t) {
                      var n,
                        r = e.slice(t.offset, t.offset + t.compLength);
                      if (t.compLength != t.origLength) {
                        var i = new Uint8Array(t.origLength);
                        (n = new Uint8Array(r, 2)), T(n, i);
                      } else i = new Uint8Array(r);
                      m.set(i, t.outOffset);
                      var o = 0;
                      (h = t.outOffset + t.origLength) % 4 != 0 &&
                        (o = 4 - (h % 4)),
                        m.set(
                          new Uint8Array(o).buffer,
                          t.outOffset + t.origLength
                        ),
                        (f = h + o);
                    }),
                    g.slice(0, f)
                  );
                }),
                Object.defineProperty(e, "__esModule", {
                  value: !0,
                }),
                e
              );
            })({}).convert_streams;
          },
          function (e, t) {
            const n = {
                M: 2,
                L: 2,
                Q: 4,
                C: 6,
                Z: 0,
              },
              r = {
                C: "18g,ca,368,1kz",
                D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
                R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
                L: "x9u,jff,a,fd,jv",
                T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
              };
            let i;

            function o(e) {
              if (!i) {
                const e = {
                  R: 2,
                  L: 1,
                  D: 4,
                  C: 16,
                  U: 32,
                  T: 8,
                };
                i = new Map();
                for (let t in r) {
                  let n = 0;
                  r[t].split(",").forEach((r) => {
                    let [o, a] = r.split("+");
                    (o = parseInt(o, 36)),
                      (a = a ? parseInt(a, 36) : 0),
                      i.set((n += o), e[t]);
                    for (let r = a; r--; ) i.set(++n, e[t]);
                  });
                }
              }
              return i.get(e) || 32;
            }
            const a = [null, "isol", "init", "fina", "medi"];

            function s(e) {
              const t = new Uint8Array(e.length);
              let n = 32,
                r = 1,
                i = -1;
              for (let a = 0; a < e.length; a++) {
                const s = e.codePointAt(a);
                let l = 0 | o(s),
                  c = 1;
                8 & l ||
                  (21 & n
                    ? 22 & l
                      ? ((c = 3), (1 !== r && 3 !== r) || t[i]++)
                      : 33 & l && ((2 !== r && 4 !== r) || t[i]--)
                    : 34 & n && ((2 !== r && 4 !== r) || t[i]--),
                  (r = t[a] = c),
                  (n = l),
                  (i = a),
                  s > 65535 && a++);
              }
              return t;
            }

            function l(t) {
              const r = Object.create(null),
                i = {
                  unitsPerEm: t.head.unitsPerEm,
                  ascender: t.hhea.ascender,
                  descender: t.hhea.descender,
                  forEachGlyph(o, l, c, u) {
                    let h = 0;
                    const d = (1 / i.unitsPerEm) * l,
                      p = (function (t, n) {
                        const r = [];
                        for (let i = 0; i < n.length; i++) {
                          const o = n.codePointAt(i);
                          o > 65535 && i++, r.push(e.U.codeToGlyph(t, o));
                        }
                        const i = t.GSUB;
                        if (i) {
                          const { lookupList: t, featureList: o } = i;
                          let l;
                          const c =
                              /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/,
                            u = [];
                          o.forEach((i) => {
                            if (c.test(i.tag))
                              for (let o = 0; o < i.tab.length; o++) {
                                if (u[i.tab[o]]) continue;
                                u[i.tab[o]] = !0;
                                const c = t[i.tab[o]],
                                  h = /^(isol|init|fina|medi)$/.test(i.tag);
                                h && !l && (l = s(n));
                                for (let n = 0; n < r.length; n++)
                                  (l && h && a[l[n]] !== i.tag) ||
                                    e.U._applySubs(r, n, c, t);
                              }
                          });
                        }
                        return r;
                      })(t, o);
                    let f = 0,
                      m = -1;
                    return (
                      p.forEach((i, a) => {
                        if (-1 !== i) {
                          let o = r[i];
                          if (!o) {
                            const { cmds: a, crds: s } = e.U.glyphToPath(t, i);
                            let l,
                              c,
                              u,
                              h,
                              d = "",
                              p = 0;
                            for (let e = 0, t = a.length; e < t; e++) {
                              const t = n[a[e]];
                              d += a[e];
                              for (let e = 1; e <= t; e++)
                                d += (e > 1 ? "," : "") + s[p++];
                            }
                            if (s.length) {
                              (l = c = 1 / 0), (u = h = -1 / 0);
                              for (let e = 0, t = s.length; e < t; e += 2) {
                                let t = s[e],
                                  n = s[e + 1];
                                t < l && (l = t),
                                  n < c && (c = n),
                                  t > u && (u = t),
                                  n > h && (h = n);
                              }
                            } else l = u = c = h = 0;
                            o = r[i] = {
                              index: i,
                              advanceWidth: t.hmtx.aWidth[i],
                              xMin: l,
                              yMin: c,
                              xMax: u,
                              yMax: h,
                              path: d,
                              pathCommandCount: a.length,
                            };
                          }
                          -1 !== m && (h += e.U.getPairAdjustment(t, m, i) * d),
                            u.call(null, o, h, f),
                            o.advanceWidth && (h += o.advanceWidth * d),
                            c && (h += c * l),
                            (m = i);
                        }
                        f += o.codePointAt(f) > 65535 ? 2 : 1;
                      }),
                      h
                    );
                  },
                };
              return i;
            }
            return function (n) {
              const r = new Uint8Array(n, 0, 4),
                i = e._bin.readASCII(r, 0, 4);
              if ("wOFF" === i) n = t(n);
              else if ("wOF2" === i)
                throw new Error("woff2 fonts not supported");
              return l(e.parse(n)[0]);
            };
          },
        ],
        init: (e, t, n) => n(e(), t()),
      }),
      Ke = {
        defaultFontURL:
          "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
        sdfGlyphSize: 64,
        sdfMargin: 1 / 16,
        sdfExponent: 9,
        textureWidth: 2048,
      },
      Qe = new r.Color();
    let et = !1;

    function tt() {
      return (self.performance || Date).now();
    }
    const nt = Object.create(null);

    function rt(e, t) {
      (et = !0), (e = it({}, e));
      const n = tt();
      if (
        ((e.font = (function (e) {
          ot ||
            (ot =
              "undefined" == typeof document
                ? {}
                : document.createElement("a"));
          return (ot.href = e), ot.href;
        })(e.font || Ke.defaultFontURL)),
        (e.text = "" + e.text),
        (e.sdfGlyphSize = e.sdfGlyphSize || Ke.sdfGlyphSize),
        null != e.colorRanges)
      ) {
        let t = {};
        for (let n in e.colorRanges)
          if (e.colorRanges.hasOwnProperty(n)) {
            let r = e.colorRanges[n];
            "number" != typeof r && (r = Qe.set(r).getHex()), (t[n] = r);
          }
        e.colorRanges = t;
      }
      Object.freeze(e);
      const { textureWidth: i, sdfExponent: o } = Ke,
        { sdfGlyphSize: a } = e;
      let s = nt[a];
      s ||
        (s = nt[a] =
          {
            glyphCount: 0,
            sdfTexture: new r.DataTexture(
              new Uint8Array(a * i * 4),
              i,
              a,
              r.RGBAFormat,
              void 0,
              void 0,
              void 0,
              void 0,
              r.LinearFilter,
              r.LinearFilter
            ),
            glyphsByFont: new Map(),
          });
      let l = s.glyphsByFont.get(e.font);
      l || s.glyphsByFont.set(e.font, (l = new Map())),
        lt(e).then((r) => {
          const {
              glyphIds: i,
              glyphPositions: c,
              fontSize: u,
              unitsPerEm: h,
              timings: d,
            } = r,
            p = [],
            f = new Float32Array(4 * i.length),
            m = u / h;
          let g = 0,
            v = 0;
          const y = tt();
          i.forEach((e, t) => {
            let n = l.get(e);
            if (!n) {
              const { path: t, pathBounds: i } = r.glyphData[e],
                o =
                  (Math.max(i[2] - i[0], i[3] - i[1]) / a) *
                  (Ke.sdfMargin * a + 0.5),
                c = s.glyphCount++,
                u = [i[0] - o, i[1] - o, i[2] + o, i[3] + o];
              l.set(
                e,
                (n = {
                  path: t,
                  atlasIndex: c,
                  sdfViewBox: u,
                })
              ),
                p.push(n);
            }
            const { sdfViewBox: o } = n,
              u = c[v++],
              h = c[v++];
            (f[g++] = u + o[0] * m),
              (f[g++] = h + o[1] * m),
              (f[g++] = u + o[2] * m),
              (f[g++] = h + o[3] * m),
              (i[t] = n.atlasIndex);
          }),
            (d.quads = (d.quads || 0) + (tt() - y));
          const x = tt();
          (d.sdf = {}),
            De.a
              .all(
                p.map(({ path: e, atlasIndex: t, sdfViewBox: n }) => {
                  const r = Math.max(n[2] - n[0], n[3] - n[1]);
                  return st(a, a, e, n, r, Ke.sdfExponent).then(
                    ({ textureData: e, timing: n }) => (
                      (d.sdf[t] = n),
                      {
                        atlasIndex: t,
                        textureData: e,
                        timing: n,
                      }
                    )
                  );
                })
              )
              .then((l) => {
                l.length &&
                  (l.forEach(({ atlasIndex: e, textureData: t }) => {
                    const n = s.sdfTexture.image;
                    for (; n.data.length < (e + 1) * a * a; ) {
                      const e = new Uint8Array(2 * n.data.length);
                      e.set(n.data),
                        (n.data = e),
                        (n.height *= 2),
                        s.sdfTexture.dispose();
                    }
                    const r = Math.floor(e / 4),
                      i = n.width / a,
                      o =
                        Math.floor(r / i) * n.width * a * 4 +
                        (r % i) * a * 4 +
                        (e % 4);
                    for (let e = 0; e < a; e++) {
                      const r = e * a,
                        i = o + e * n.width * 4;
                      for (let e = 0; e < a; e++) n.data[i + 4 * e] = t[r + e];
                    }
                  }),
                  (s.sdfTexture.needsUpdate = !0)),
                  (d.sdfTotal = tt() - x),
                  (d.total = tt() - n),
                  t(
                    Object.freeze({
                      parameters: e,
                      sdfTexture: s.sdfTexture,
                      sdfGlyphSize: a,
                      sdfExponent: o,
                      glyphBounds: f,
                      glyphAtlasIndices: i,
                      glyphColors: r.glyphColors,
                      caretPositions: r.caretPositions,
                      caretHeight: r.caretHeight,
                      chunkedBounds: r.chunkedBounds,
                      ascender: r.ascender,
                      descender: r.descender,
                      lineHeight: r.lineHeight,
                      topBaseline: r.topBaseline,
                      blockBounds: r.blockBounds,
                      visibleBounds: r.visibleBounds,
                      timings: r.timings,
                      get totalBounds() {
                        return (
                          console.log(
                            "totalBounds deprecated, use blockBounds instead"
                          ),
                          r.blockBounds
                        );
                      },
                      get totalBlockSize() {
                        console.log(
                          "totalBlockSize deprecated, use blockBounds instead"
                        );
                        const [e, t, n, i] = r.blockBounds;
                        return [n - e, i - t];
                      },
                    })
                  );
              });
        });
    }

    function it(e, t) {
      for (let n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
      return e;
    }
    let ot;
    const at = Object(De.c)({
        name: "Typesetter",
        dependencies: [
          Ke,
          Ze,
          function (e, t, n) {
            const { defaultFontURL: r } = n,
              i = Object.create(null),
              o =
                /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
              a =
                /[\s\-\u007C\u00AD\u2010\u2012-\u2014\u2027\u2056\u2E17\u2E40]/;

            function s(t, n) {
              t || (t = r);
              let o = i[t];
              o
                ? o.pending
                  ? o.pending.push(n)
                  : n(o)
                : ((i[t] = {
                    pending: [n],
                  }),
                  (function (t, n) {
                    !(function i() {
                      const o = (e) => {
                        console.error(
                          `Failure loading font ${t}${
                            t === r ? "" : "; trying fallback"
                          }`,
                          e
                        ),
                          t !== r && ((t = r), i());
                      };
                      try {
                        const r = new XMLHttpRequest();
                        r.open("get.html", t, !0),
                          (r.responseType = "arraybuffer"),
                          (r.onload = function () {
                            if (r.status >= 400) o(new Error(r.statusText));
                            else if (r.status > 0)
                              try {
                                const t = e(r.response);
                                n(t);
                              } catch (e) {
                                o(e);
                              }
                          }),
                          (r.onerror = o),
                          r.send();
                      } catch (e) {
                        o(e);
                      }
                    })();
                  })(t, (e) => {
                    let n = i[t].pending;
                    (i[t] = e), n.forEach((t) => t(e));
                  }));
            }

            function l(
              {
                text: e = "",
                font: n = r,
                sdfGlyphSize: i = 64,
                fontSize: l = 1,
                letterSpacing: p = 0,
                lineHeight: f = "normal",
                maxWidth: m = 1 / 0,
                direction: g,
                textAlign: v = "left",
                textIndent: y = 0,
                whiteSpace: x = "normal",
                overflowWrap: b = "normal",
                anchorX: w = 0,
                anchorY: _ = 0,
                includeCaretPositions: M = !1,
                chunkedBoundsSize: S = 8192,
                colorRanges: T = null,
              },
              E,
              A = !1
            ) {
              const C = h(),
                P = {
                  fontLoad: 0,
                  typesetting: 0,
                };
              e.indexOf("\r") > -1 &&
                (console.info(
                  "Typesetter: got text with \\r chars; normalizing to \\n"
                ),
                (e = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n"))),
                (l = +l),
                (p = +p),
                (m = +m),
                (f = f || "normal"),
                (y = +y),
                s(n, (n) => {
                  const r = isFinite(m);
                  let i = null,
                    s = null,
                    L = null,
                    R = null,
                    I = null,
                    k = null,
                    D = null,
                    O = 0,
                    B = 0,
                    F = "nowrap" !== x;
                  const { ascender: N, descender: U, unitsPerEm: z } = n;
                  P.fontLoad = h() - C;
                  const H = h(),
                    G = l / z;
                  "normal" === f && (f = (N - U) / z);
                  const V = ((f *= l) - (N - U) * G) / 2,
                    j = -(N * G + V),
                    W = Math.min(f, (N - U) * G),
                    q = ((N + U) / 2) * G - W / 2;
                  let $ = y,
                    X = new d();
                  const Y = [X];
                  n.forEachGlyph(e, l, p, (t, n, i) => {
                    const s = e.charAt(i),
                      c = t.advanceWidth * G,
                      u = X.count;
                    let h;
                    if (
                      ("isEmpty" in t ||
                        ((t.isWhitespace = !!s && /\s/.test(s)),
                        (t.canBreakAfter = !!s && a.test(s)),
                        (t.isEmpty =
                          t.xMin === t.xMax || t.yMin === t.yMax || o.test(s))),
                      t.isWhitespace || t.isEmpty || B++,
                      F && r && !t.isWhitespace && n + c + $ > m && u)
                    ) {
                      if (X.glyphAt(u - 1).glyphObj.canBreakAfter)
                        (h = new d()), ($ = -n);
                      else
                        for (let e = u; e--; ) {
                          if (0 === e && "break-word" === b) {
                            (h = new d()), ($ = -n);
                            break;
                          }
                          if (X.glyphAt(e).glyphObj.canBreakAfter) {
                            h = X.splitAt(e + 1);
                            const t = h.glyphAt(0).x;
                            $ -= t;
                            for (let e = h.count; e--; ) h.glyphAt(e).x -= t;
                            break;
                          }
                        }
                      h &&
                        ((X.isSoftWrapped = !0), (X = h), Y.push(X), (O = m));
                    }
                    let f = X.glyphAt(X.count);
                    (f.glyphObj = t),
                      (f.x = n + $),
                      (f.width = c),
                      (f.charIndex = i),
                      "\n" === s &&
                        ((X = new d()), Y.push(X), ($ = -(n + c + p * l) + y));
                  }),
                    Y.forEach((e) => {
                      for (let t = e.count; t--; ) {
                        let { glyphObj: n, x: r, width: i } = e.glyphAt(t);
                        if (!n.isWhitespace)
                          return (
                            (e.width = r + i),
                            void (e.width > O && (O = e.width))
                          );
                      }
                    });
                  let J = 0,
                    Z = 0;
                  if (
                    (w &&
                      ("number" == typeof w
                        ? (J = -w)
                        : "string" == typeof w &&
                          (J =
                            -O *
                            ("left" === w
                              ? 0
                              : "center" === w
                              ? 0.5
                              : "right" === w
                              ? 1
                              : c(w)))),
                    _)
                  )
                    if ("number" == typeof _) Z = -_;
                    else if ("string" == typeof _) {
                      let e = Y.length * f;
                      Z =
                        "top" === _
                          ? 0
                          : "top-baseline" === _
                          ? -j
                          : "middle" === _
                          ? e / 2
                          : "bottom" === _
                          ? e
                          : "bottom-baseline" === _
                          ? e - V + U * G
                          : c(_) * e;
                    }
                  if (!A) {
                    const r = t.getEmbeddingLevels(e, g);
                    (i = new Uint16Array(B)),
                      (s = new Float32Array(2 * B)),
                      (L = {}),
                      (k = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
                      (D = []);
                    let o = j;
                    M && (I = new Float32Array(3 * e.length)),
                      T && (R = new Uint8Array(3 * B));
                    let a,
                      l,
                      c = 0,
                      h = -1,
                      d = -1;
                    if (
                      (Y.forEach((p, m) => {
                        let { count: g, width: y } = p;
                        if (g > 0) {
                          let f = 0;
                          for (
                            let e = g;
                            e-- && p.glyphAt(e).glyphObj.isWhitespace;

                          )
                            f++;
                          let m = 0,
                            x = 0;
                          if ("center" === v) m = (O - y) / 2;
                          else if ("right" === v) m = O - y;
                          else if ("justify" === v && p.isSoftWrapped) {
                            let e = 0;
                            for (let t = g - f; t--; )
                              p.glyphAt(t).glyphObj.isWhitespace && e++;
                            x = (O - y) / e;
                          }
                          if (x || m) {
                            let e = 0;
                            for (let t = 0; t < g; t++) {
                              let n = p.glyphAt(t);
                              const r = n.glyphObj;
                              (n.x += m + e),
                                0 !== x &&
                                  r.isWhitespace &&
                                  t < g - f &&
                                  ((e += x), (n.width += x));
                            }
                          }
                          const b = t.getReorderSegments(
                            e,
                            r,
                            p.glyphAt(0).charIndex,
                            p.glyphAt(p.count - 1).charIndex
                          );
                          for (let e = 0; e < b.length; e++) {
                            const [t, n] = b[e];
                            let r = 1 / 0,
                              i = -1 / 0;
                            for (let e = 0; e < g; e++)
                              if (p.glyphAt(e).charIndex >= t) {
                                let t = e,
                                  o = e;
                                for (; o < g; o++) {
                                  let e = p.glyphAt(o);
                                  if (e.charIndex > n) break;
                                  o < g - f &&
                                    ((r = Math.min(r, e.x)),
                                    (i = Math.max(i, e.x + e.width)));
                                }
                                for (let e = t; e < o; e++) {
                                  const t = p.glyphAt(e);
                                  t.x = i - (t.x + t.width - r);
                                }
                                break;
                              }
                          }
                          let w;
                          const _ = (e) => (w = e);
                          for (let f = 0; f < g; f++) {
                            let m = p.glyphAt(f);
                            w = m.glyphObj;
                            const g = w.index,
                              v = 1 & r.levels[m.charIndex];
                            if (v) {
                              const r = t.getMirroredCharacter(e[m.charIndex]);
                              r && n.forEachGlyph(r, 0, 0, _);
                            }
                            if (M) {
                              const { charIndex: e } = m,
                                t = m.x + J,
                                n = m.x + m.width + J;
                              (I[3 * e] = v ? n : t),
                                (I[3 * e + 1] = v ? t : n),
                                (I[3 * e + 2] = o + q + Z);
                              const r = e - h;
                              r > 1 && u(I, h, r), (h = e);
                            }
                            if (T) {
                              const { charIndex: e } = m;
                              for (; e > d; )
                                d++, T.hasOwnProperty(d) && (l = T[d]);
                            }
                            if (!w.isWhitespace && !w.isEmpty) {
                              const e = c++;
                              L[g] ||
                                (L[g] = {
                                  path: w.path,
                                  pathBounds: [w.xMin, w.yMin, w.xMax, w.yMax],
                                });
                              const t = m.x + J,
                                n = o + Z;
                              (s[2 * e] = t), (s[2 * e + 1] = n);
                              const r = t + w.xMin * G,
                                u = n + w.yMin * G,
                                h = t + w.xMax * G,
                                d = n + w.yMax * G;
                              r < k[0] && (k[0] = r),
                                u < k[1] && (k[1] = u),
                                h > k[2] && (k[2] = h),
                                d > k[3] && (k[3] = d),
                                e % S == 0 &&
                                  ((a = {
                                    start: e,
                                    end: e,
                                    rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                  }),
                                  D.push(a)),
                                a.end++;
                              const p = a.rect;
                              if (
                                (r < p[0] && (p[0] = r),
                                u < p[1] && (p[1] = u),
                                h > p[2] && (p[2] = h),
                                d > p[3] && (p[3] = d),
                                (i[e] = g),
                                T)
                              ) {
                                const t = 3 * e;
                                (R[t] = (l >> 16) & 255),
                                  (R[t + 1] = (l >> 8) & 255),
                                  (R[t + 2] = 255 & l);
                              }
                            }
                          }
                        }
                        o -= f;
                      }),
                      I)
                    ) {
                      const t = e.length - h;
                      t > 1 && u(I, h, t);
                    }
                  }
                  (P.typesetting = h() - H),
                    E({
                      glyphIds: i,
                      glyphPositions: s,
                      glyphData: L,
                      caretPositions: I,
                      caretHeight: W,
                      glyphColors: R,
                      chunkedBounds: D,
                      fontSize: l,
                      unitsPerEm: z,
                      ascender: N * G,
                      descender: U * G,
                      lineHeight: f,
                      topBaseline: j,
                      blockBounds: [J, Z - Y.length * f, J + O, Z],
                      visibleBounds: k,
                      timings: P,
                    });
                });
            }

            function c(e) {
              let t = e.match(/^([\d.]+)%$/),
                n = t ? parseFloat(t[1]) : NaN;
              return isNaN(n) ? 0 : n / 100;
            }

            function u(e, t, n) {
              const r = e[3 * t],
                i = e[3 * t + 1],
                o = e[3 * t + 2],
                a = (i - r) / n;
              for (let i = 0; i < n; i++) {
                const n = 3 * (t + i);
                (e[n] = r + a * i),
                  (e[n + 1] = r + a * (i + 1)),
                  (e[n + 2] = o);
              }
            }

            function h() {
              return (self.performance || Date).now();
            }

            function d() {
              this.data = [];
            }
            const p = ["glyphObj", "x", "width", "charIndex"];
            return (
              (d.prototype = {
                width: 0,
                isSoftWrapped: !1,
                get count() {
                  return Math.ceil(this.data.length / p.length);
                },
                glyphAt(e) {
                  let t = d.flyweight;
                  return (t.data = this.data), (t.index = e), t;
                },
                splitAt(e) {
                  let t = new d();
                  return (t.data = this.data.splice(e * p.length)), t;
                },
              }),
              (d.flyweight = p.reduce(
                (e, t, n, r) => (
                  Object.defineProperty(e, t, {
                    get() {
                      return this.data[this.index * p.length + n];
                    },
                    set(e) {
                      this.data[this.index * p.length + n] = e;
                    },
                  }),
                  e
                ),
                {
                  data: null,
                  index: 0,
                }
              )),
              {
                typeset: l,
                measure: function (e, t) {
                  l(
                    e,
                    (e) => {
                      const [n, r, i, o] = e.blockBounds;
                      t({
                        width: i - n,
                        height: o - r,
                      });
                    },
                    {
                      metricsOnly: !0,
                    }
                  );
                },
                loadFont: s,
              }
            );
          },
          Oe,
        ],
        init(e, t, n, r) {
          const { defaultFontURL: i } = e;
          return n(t, r(), {
            defaultFontURL: i,
          });
        },
      }),
      st = (function () {
        const e = {};
        let t = 0;
        return function (...n) {
          const r = "TroikaTextSDFGenerator_" + (t++ % 4);
          let i = e[r];
          return (
            i ||
              (i = e[r] =
                {
                  workerModule: Object(De.c)({
                    name: r,
                    workerId: r,
                    dependencies: [Ke, Je, Ye],
                    init(e, t, n) {
                      const { sdfExponent: r, sdfMargin: i } = e;
                      return n(t, {
                        sdfExponent: r,
                        sdfMargin: i,
                      });
                    },
                    getTransferables: (e) => [e.textureData.buffer],
                  }),
                  requests: 0,
                  idleTimer: null,
                }),
            i.requests++,
            clearTimeout(i.idleTimer),
            i.workerModule(...n).then(
              (e) => (
                0 == --i.requests &&
                  (i.idleTimer = setTimeout(() => {
                    Object(De.d)(r);
                  }, 2e3)),
                e
              )
            )
          );
        };
      })(),
      lt = Object(De.c)({
        name: "Typesetter",
        dependencies: [at, De.b],
        init: (e, t) =>
          function (n) {
            const r = new t();
            return e.typeset(n, r.resolve), r;
          },
        getTransferables(e) {
          const t = [e.glyphPositions.buffer, e.glyphIds.buffer];
          return (
            e.caretPositions && t.push(e.caretPositions.buffer),
            e.glyphColors && t.push(e.glyphColors.buffer),
            t
          );
        },
      });
    const ct = (() => {
      const e = {};
      class t extends r.InstancedBufferGeometry {
        constructor() {
          super(),
            (this.detail = 1),
            (this.curveRadius = 0),
            (this.groups = [
              {
                start: 0,
                count: 1 / 0,
                materialIndex: 0,
              },
              {
                start: 0,
                count: 1 / 0,
                materialIndex: 1,
              },
            ]),
            (this.boundingSphere = new r.Sphere()),
            (this.boundingBox = new r.Box3());
        }
        computeBoundingSphere() {}
        computeBoundingBox() {}
        setSide(e) {
          const t = this.getIndex().count;
          this.setDrawRange(
            e === r.BackSide ? t / 2 : 0,
            e === r.DoubleSide ? t : t / 2
          );
        }
        set detail(t) {
          if (t !== this._detail) {
            (this._detail = t), ("number" != typeof t || t < 1) && (t = 1);
            let n = (function (t) {
              let n = e[t];
              if (!n) {
                const i = new r.PlaneBufferGeometry(1, 1, t, t),
                  o = i.clone(),
                  a = i.attributes,
                  s = o.attributes,
                  l = new r.BufferGeometry(),
                  c = a.uv.count;
                for (let e = 0; e < c; e++)
                  (s.position.array[3 * e] *= -1),
                    (s.normal.array[3 * e + 2] *= -1);
                ["position", "normal", "uv"].forEach((e) => {
                  l.setAttribute(
                    e,
                    new r.Float32BufferAttribute(
                      [...a[e].array, ...s[e].array],
                      a[e].itemSize
                    )
                  );
                }),
                  l.setIndex([
                    ...i.index.array,
                    ...o.index.array.map((e) => e + c),
                  ]),
                  l.translate(0.5, 0.5, 0),
                  (n = e[t] = l);
              }
              return n;
            })(t);
            ["position", "normal", "uv"].forEach((e) => {
              this.attributes[e] = n.attributes[e].clone();
            }),
              this.setIndex(n.getIndex().clone());
          }
        }
        get detail() {
          return this._detail;
        }
        set curveRadius(e) {
          e !== this._curveRadius &&
            ((this._curveRadius = e), this._updateBounds());
        }
        get curveRadius() {
          return this._curveRadius;
        }
        updateGlyphs(e, t, r, o, a) {
          n(this, "aTroikaGlyphBounds", e, 4),
            n(this, "aTroikaGlyphIndex", t, 1),
            n(this, "aTroikaGlyphColor", a, 3),
            (this._blockBounds = r),
            (this._chunkedBounds = o),
            i(this, t.length),
            this._updateBounds();
        }
        _updateBounds() {
          const e = this._blockBounds;
          if (e) {
            const { curveRadius: t, boundingBox: n } = this;
            if (t) {
              const { PI: r, floor: i, min: o, max: a, sin: s, cos: l } = Math,
                c = r / 2,
                u = 2 * r,
                h = Math.abs(t),
                d = e[0] / h,
                p = e[2] / h,
                f =
                  i((d + c) / u) !== i((p + c) / u)
                    ? -h
                    : o(s(d) * h, s(p) * h),
                m =
                  i((d - c) / u) !== i((p - c) / u) ? h : a(s(d) * h, s(p) * h),
                g =
                  i((d + r) / u) !== i((p + r) / u)
                    ? 2 * h
                    : a(h - l(d) * h, h - l(p) * h);
              n.min.set(f, e[1], t < 0 ? -g : 0),
                n.max.set(m, e[3], t < 0 ? 0 : g);
            } else n.min.set(e[0], e[1], 0), n.max.set(e[2], e[3], 0);
            n.getBoundingSphere(this.boundingSphere);
          }
        }
        applyClipRect(e) {
          let t = this.getAttribute("aTroikaGlyphIndex").count,
            n = this._chunkedBounds;
          if (n)
            for (let r = n.length; r--; ) {
              t = n[r].end;
              let i = n[r].rect;
              if (i[1] < e.w && i[3] > e.y && i[0] < e.z && i[2] > e.x) break;
            }
          i(this, t);
        }
      }

      function n(e, t, n, i) {
        const o = e.getAttribute(t);
        n
          ? o && o.array.length === n.length
            ? (o.array.set(n), (o.needsUpdate = !0))
            : (e.setAttribute(t, new r.InstancedBufferAttribute(n, i)),
              delete e._maxInstanceCount,
              e.dispose())
          : o && e.deleteAttribute(t);
      }

      function i(e, t) {
        e[
          e.hasOwnProperty("instanceCount")
            ? "instanceCount"
            : "maxInstancedCount"
        ] = t;
      }
      return (
        t.prototype.setAttribute ||
          (t.prototype.setAttribute = function (e, t) {
            return (this.attributes[e] = t), this;
          }),
        t
      );
    })();
    const ut = (() => {
      const e = new r.MeshBasicMaterial({
          color: 16777215,
          side: r.DoubleSide,
          transparent: !0,
        }),
        t = new r.Matrix4(),
        n = new r.Vector3(),
        i = new r.Vector3(),
        o = [],
        a = new r.Vector3();

      function s(e) {
        return Array.isArray(e) ? e[0] : e;
      }
      let l = () => {
          const t = new r.Mesh(new r.PlaneBufferGeometry(1, 1), e);
          return (l = () => t), t;
        },
        c = () => {
          const t = new r.Mesh(new r.PlaneBufferGeometry(1, 1, 32, 1), e);
          return (c = () => t), t;
        };
      const u = {
          type: "syncstart",
        },
        h = {
          type: "synccomplete",
        },
        d = [
          "font",
          "fontSize",
          "letterSpacing",
          "lineHeight",
          "maxWidth",
          "overflowWrap",
          "text",
          "direction",
          "textAlign",
          "textIndent",
          "whiteSpace",
          "anchorX",
          "anchorY",
          "colorRanges",
          "sdfGlyphSize",
        ],
        p = d.concat(
          "material",
          "color",
          "depthOffset",
          "clipRect",
          "curveRadius",
          "orientation",
          "glyphGeometryDetail"
        );
      class f extends r.Mesh {
        constructor() {
          super(new ct(), null),
            (this.text = ""),
            (this.anchorX = 0),
            (this.anchorY = 0),
            (this.curveRadius = 0),
            (this.direction = "auto"),
            (this.font = null),
            (this.fontSize = 0.1),
            (this.letterSpacing = 0),
            (this.lineHeight = "normal"),
            (this.maxWidth = 1 / 0),
            (this.overflowWrap = "normal"),
            (this.textAlign = "left"),
            (this.textIndent = 0),
            (this.whiteSpace = "normal"),
            (this.material = null),
            (this.color = null),
            (this.colorRanges = null),
            (this.outlineWidth = 0),
            (this.outlineColor = 0),
            (this.outlineOpacity = 1),
            (this.outlineBlur = 0),
            (this.outlineOffsetX = 0),
            (this.outlineOffsetY = 0),
            (this.strokeWidth = 0),
            (this.strokeColor = 8421504),
            (this.strokeOpacity = 1),
            (this.fillOpacity = 1),
            (this.depthOffset = 0),
            (this.clipRect = null),
            (this.orientation = "+x+y"),
            (this.glyphGeometryDetail = 1),
            (this.sdfGlyphSize = null),
            (this.debugSDF = !1);
        }
        sync(e) {
          this._needsSync &&
            ((this._needsSync = !1),
            this._isSyncing
              ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e)
              : ((this._isSyncing = !0),
                this.dispatchEvent(u),
                rt(
                  {
                    text: this.text,
                    font: this.font,
                    fontSize: this.fontSize || 0.1,
                    letterSpacing: this.letterSpacing || 0,
                    lineHeight: this.lineHeight || "normal",
                    maxWidth: this.maxWidth,
                    direction: this.direction || "auto",
                    textAlign: this.textAlign,
                    textIndent: this.textIndent,
                    whiteSpace: this.whiteSpace,
                    overflowWrap: this.overflowWrap,
                    anchorX: this.anchorX,
                    anchorY: this.anchorY,
                    colorRanges: this.colorRanges,
                    includeCaretPositions: !0,
                    sdfGlyphSize: this.sdfGlyphSize,
                  },
                  (t) => {
                    (this._isSyncing = !1),
                      (this._textRenderInfo = t),
                      this.geometry.updateGlyphs(
                        t.glyphBounds,
                        t.glyphAtlasIndices,
                        t.blockBounds,
                        t.chunkedBounds,
                        t.glyphColors
                      );
                    const n = this._queuedSyncs;
                    n &&
                      ((this._queuedSyncs = null),
                      (this._needsSync = !0),
                      this.sync(() => {
                        n.forEach((e) => e && e());
                      })),
                      this.dispatchEvent(h),
                      e && e();
                  }
                )));
        }
        onBeforeRender(e, t, n, i, o, a) {
          this.sync(),
            o.isTroikaTextMaterial && this._prepareForRender(o),
            (o._hadOwnSide = o.hasOwnProperty("side")),
            this.geometry.setSide((o._actualSide = o.side)),
            (o.side = r.FrontSide);
        }
        onAfterRender(e, t, n, r, i, o) {
          i._hadOwnSide ? (i.side = i._actualSide) : delete i.side;
        }
        dispose() {
          this.geometry.dispose();
        }
        get textRenderInfo() {
          return this._textRenderInfo || null;
        }
        get material() {
          let t = this._derivedMaterial;
          const n =
            this._baseMaterial ||
            this._defaultMaterial ||
            (this._defaultMaterial = e.clone());
          if (
            ((t && t.baseMaterial === n) ||
              ((t = this._derivedMaterial =
                (function (e) {
                  const t = je(e, {
                    chained: !0,
                    extensions: {
                      derivatives: !0,
                    },
                    uniforms: {
                      uTroikaSDFTexture: {
                        value: null,
                      },
                      uTroikaSDFTextureSize: {
                        value: new r.Vector2(),
                      },
                      uTroikaSDFGlyphSize: {
                        value: 0,
                      },
                      uTroikaSDFExponent: {
                        value: 0,
                      },
                      uTroikaTotalBounds: {
                        value: new r.Vector4(0, 0, 0, 0),
                      },
                      uTroikaClipRect: {
                        value: new r.Vector4(0, 0, 0, 0),
                      },
                      uTroikaDistanceOffset: {
                        value: 0,
                      },
                      uTroikaOutlineOpacity: {
                        value: 0,
                      },
                      uTroikaFillOpacity: {
                        value: 1,
                      },
                      uTroikaPositionOffset: {
                        value: new r.Vector2(),
                      },
                      uTroikaCurveRadius: {
                        value: 0,
                      },
                      uTroikaBlurRadius: {
                        value: 0,
                      },
                      uTroikaStrokeWidth: {
                        value: 0,
                      },
                      uTroikaStrokeColor: {
                        value: new r.Color(),
                      },
                      uTroikaStrokeOpacity: {
                        value: 1,
                      },
                      uTroikaOrient: {
                        value: new r.Matrix3(),
                      },
                      uTroikaUseGlyphColors: {
                        value: !0,
                      },
                      uTroikaSDFDebug: {
                        value: !1,
                      },
                    },
                    vertexDefs:
                      "\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n",
                    vertexTransform:
                      "\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n",
                    fragmentDefs:
                      "\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of encoding in SDFGenerator.js\n  \n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  \n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  \n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n",
                    fragmentColorTransform:
                      "\nfloat aaDist = troikaGetAADist();\nfloat distance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(distance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  distance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n",
                    customRewriter({ vertexShader: e, fragmentShader: t }) {
                      let n = /\buniform\s+vec3\s+diffuse\b/;
                      return (
                        n.test(t) &&
                          ((t = t
                            .replace(n, "varying vec3 vTroikaGlyphColor")
                            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
                          n.test(e) ||
                            (e = e.replace(
                              Be,
                              "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
                            ))),
                        {
                          vertexShader: e,
                          fragmentShader: t,
                        }
                      );
                    },
                  });
                  return (
                    (t.transparent = !0),
                    Object.defineProperties(t, {
                      isTroikaTextMaterial: {
                        value: !0,
                      },
                      shadowSide: {
                        get() {
                          return this.side;
                        },
                        set() {},
                      },
                    }),
                    t
                  );
                })(n)),
              n.addEventListener("dispose", function e() {
                n.removeEventListener("dispose", e), t.dispose();
              })),
            this.outlineWidth ||
              this.outlineBlur ||
              this.outlineOffsetX ||
              this.outlineOffsetY)
          ) {
            let e = t._outlineMtl;
            return (
              e ||
                ((e = t._outlineMtl =
                  Object.create(t, {
                    id: {
                      value: t.id + 0.1,
                    },
                  })),
                (e.isTextOutlineMaterial = !0),
                (e.depthWrite = !1),
                (e.map = null),
                t.addEventListener("dispose", function n() {
                  t.removeEventListener("dispose", n), e.dispose();
                })),
              [e, t]
            );
          }
          return t;
        }
        set material(e) {
          e && e.isTroikaTextMaterial
            ? ((this._derivedMaterial = e),
              (this._baseMaterial = e.baseMaterial))
            : (this._baseMaterial = e);
        }
        get glyphGeometryDetail() {
          return this.geometry.detail;
        }
        set glyphGeometryDetail(e) {
          this.geometry.detail = e;
        }
        get curveRadius() {
          return this.geometry.curveRadius;
        }
        set curveRadius(e) {
          this.geometry.curveRadius = e;
        }
        get customDepthMaterial() {
          return s(this.material).getDepthMaterial();
        }
        get customDistanceMaterial() {
          return s(this.material).getDistanceMaterial();
        }
        _prepareForRender(e) {
          const o = e.isTextOutlineMaterial,
            s = e.uniforms,
            l = this.textRenderInfo;
          if (l) {
            const { sdfTexture: e, blockBounds: t } = l;
            (s.uTroikaSDFTexture.value = e),
              s.uTroikaSDFTextureSize.value.set(e.image.width, e.image.height),
              (s.uTroikaSDFGlyphSize.value = l.sdfGlyphSize),
              (s.uTroikaSDFExponent.value = l.sdfExponent),
              s.uTroikaTotalBounds.value.fromArray(t),
              (s.uTroikaUseGlyphColors.value = !o && !!l.glyphColors);
            let n,
              r,
              i,
              a = 0,
              c = 0,
              u = 0,
              h = 0,
              d = 0;
            if (o) {
              let {
                outlineWidth: e,
                outlineOffsetX: t,
                outlineOffsetY: r,
                outlineBlur: i,
                outlineOpacity: o,
              } = this;
              (a = this._parsePercent(e) || 0),
                (c = Math.max(0, this._parsePercent(i) || 0)),
                (n = o),
                (h = this._parsePercent(t) || 0),
                (d = this._parsePercent(r) || 0);
            } else
              (u = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
                u &&
                  ((i = this.strokeColor),
                  s.uTroikaStrokeColor.value.set(null == i ? 8421504 : i),
                  (r = this.strokeOpacity),
                  null == r && (r = 1)),
                (n = this.fillOpacity);
            (s.uTroikaDistanceOffset.value = a),
              s.uTroikaPositionOffset.value.set(h, d),
              (s.uTroikaBlurRadius.value = c),
              (s.uTroikaStrokeWidth.value = u),
              (s.uTroikaStrokeOpacity.value = r),
              (s.uTroikaFillOpacity.value = null == n ? 1 : n),
              (s.uTroikaCurveRadius.value = this.curveRadius || 0);
            let p = this.clipRect;
            if (p && Array.isArray(p) && 4 === p.length)
              s.uTroikaClipRect.value.fromArray(p);
            else {
              const e = 100 * (this.fontSize || 0.1);
              s.uTroikaClipRect.value.set(
                t[0] - e,
                t[1] - e,
                t[2] + e,
                t[3] + e
              );
            }
            this.geometry.applyClipRect(s.uTroikaClipRect.value);
          }
          (s.uTroikaSDFDebug.value = !!this.debugSDF),
            (e.polygonOffset = !!this.depthOffset),
            (e.polygonOffsetFactor = e.polygonOffsetUnits =
              this.depthOffset || 0);
          const c = o ? this.outlineColor || 0 : this.color;
          if (null == c) delete e.color;
          else {
            const t = e.hasOwnProperty("color")
              ? e.color
              : (e.color = new r.Color());
            (c === t._input && "object" != typeof c) || t.set((t._input = c));
          }
          let u = this.orientation || "+x+y";
          if (u !== e._orientation) {
            let r = s.uTroikaOrient.value;
            u = u.replace(/[^-+xyz]/g, "");
            let o = "+x+y" !== u && u.match(/^([-+])([xyz])([-+])([xyz])$/);
            if (o) {
              let [, e, s, l, c] = o;
              (n.set(0, 0, 0)[s] = "-" === e ? 1 : -1),
                (i.set(0, 0, 0)[c] = "-" === l ? -1 : 1),
                t.lookAt(a, n.cross(i), i),
                r.setFromMatrix4(t);
            } else r.identity();
            e._orientation = u;
          }
        }
        _parsePercent(e) {
          if ("string" == typeof e) {
            let t = e.match(/^(-?[\d.]+)%$/),
              n = t ? parseFloat(t[1]) : NaN;
            e = (isNaN(n) ? 0 : n / 100) * this.fontSize;
          }
          return e;
        }
        localPositionToTextCoords(e, t = new r.Vector2()) {
          t.copy(e);
          const n = this.curveRadius;
          return (
            n &&
              (t.x =
                Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)),
            t
          );
        }
        worldPositionToTextCoords(e, t = new r.Vector2()) {
          return (
            n.copy(e), this.localPositionToTextCoords(this.worldToLocal(n), t)
          );
        }
        raycast(e, t) {
          const { textRenderInfo: n, curveRadius: r } = this;
          if (n) {
            const i = n.blockBounds,
              a = r ? c() : l(),
              s = a.geometry,
              { position: u, uv: h } = s.attributes;
            for (let e = 0; e < h.count; e++) {
              let t = i[0] + h.getX(e) * (i[2] - i[0]);
              const n = i[1] + h.getY(e) * (i[3] - i[1]);
              let o = 0;
              r && ((o = r - Math.cos(t / r) * r), (t = Math.sin(t / r) * r)),
                u.setXYZ(e, t, n, o);
            }
            (s.boundingSphere = this.geometry.boundingSphere),
              (s.boundingBox = this.geometry.boundingBox),
              (a.matrixWorld = this.matrixWorld),
              (a.material.side = this.material.side),
              (o.length = 0),
              a.raycast(e, o);
            for (let e = 0; e < o.length; e++)
              (o[e].object = this), t.push(o[e]);
          }
        }
        copy(e) {
          const t = this.geometry;
          return (
            super.copy(e),
            (this.geometry = t),
            p.forEach((t) => {
              this[t] = e[t];
            }),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      d.forEach((e) => {
        const t = "_private_" + e;
        Object.defineProperty(f.prototype, e, {
          get() {
            return this[t];
          },
          set(e) {
            e !== this[t] && ((this[t] = e), (this._needsSync = !0));
          },
        });
      });
      let m = !1;
      return (
        Object.defineProperty(f.prototype, "anchor", {
          get() {
            return this._deprecated_anchor;
          },
          set(e) {
            (this._deprecated_anchor = e),
              m ||
                (console.warn(
                  "TextMesh: `anchor` has been deprecated; use `anchorX` and `anchorY` instead."
                ),
                (m = !0)),
              Array.isArray(e)
                ? ((this.anchorX = `${100 * (+e[0] || 0)}%`),
                  (this.anchorY = `${100 * (+e[1] || 0)}%`))
                : (this.anchorX = this.anchorY = 0);
          },
        }),
        f
      );
    })();
    new WeakMap();
    new WeakMap();
    var ht,
      dt,
      pt,
      ft = (function () {
        var e = function (t, n) {
          return (e =
            Object.setPrototypeOf ||
            ({
              __proto__: [],
            } instanceof Array &&
              function (e, t) {
                e.__proto__ = t;
              }) ||
            function (e, t) {
              for (var n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            })(t, n);
        };
        return function (t, n) {
          function r() {
            this.constructor = t;
          }
          e(t, n),
            (t.prototype =
              null === n
                ? Object.create(n)
                : ((r.prototype = n.prototype), new r()));
        };
      })(),
      mt = function () {
        return (mt =
          Object.assign ||
          function (e) {
            for (var t, n = 1, r = arguments.length; n < r; n++)
              for (var i in (t = arguments[n]))
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e;
          }).apply(this, arguments);
      },
      gt = function () {
        for (var e = 0, t = 0, n = arguments.length; t < n; t++)
          e += arguments[t].length;
        var r = Array(e),
          i = 0;
        for (t = 0; t < n; t++)
          for (var o = arguments[t], a = 0, s = o.length; a < s; a++, i++)
            r[i] = o[a];
        return r;
      },
      vt = be.Builder,
      yt = be.IntervalBuilder;
    (dt = ht || (ht = {})),
      (pt = (function (e) {
        function t(t, n) {
          var r = e.call(this, t, n) || this;
          return (
            (r.elementCache = []),
            (r.loadedMeshes = []),
            (function ({ font: e, characters: t, sdfGlyphSize: n }, r) {
              rt(
                {
                  font: e,
                  sdfGlyphSize: n,
                  text: Array.isArray(t) ? t.join("\n") : "" + t,
                },
                r
              );
            })(
              {
                characters: "01234567890.,m",
              },
              function () {}
            ),
            r
          );
        }
        return (
          ft(t, e),
          (t.prototype.buildGlassDecoration = function (e, t, n, i) {
            var o,
              a = this,
              s = new r.BufferGeometry(),
              l = this.materials[n.materialId],
              c = new r.Vector3().fromArray(n.offset || [0, 0, 0]),
              u = (
                n.shape || [
                  [-0.5, -0.5],
                  [0.5, -0.5],
                  [0.5, 0.5],
                  [-0.5, 0.5],
                ]
              ).map(function (e) {
                return new r.Vector2().fromArray(e);
              });
            if (n.isSmoothShape) {
              o = new r.Shape();
              var h = u.pop();
              o.moveTo(h.x, h.y), o.splineThru(u);
            } else o = new r.Shape(u);
            var d = new r.ExtrudeBufferGeometry(o, {
              steps: 1,
              depth: 1,
              bevelEnabled: !1,
            });
            switch (((e += 2 * c.x), (t += 2 * c.y), n.type)) {
              case "grid":
                var p = new yt().withMaxWidth(n.maxGridWidth);
                (n.gridSides && 0 != n.gridSides[0]) ||
                  (p = p.withoutBorders());
                var f = d.clone();
                f.scale(n.meshThickness, n.meshDepth, t);
                var m = p.forRange(0, e);
                m.map(function (i) {
                  var o = f.clone();
                  o.rotateX(Math.PI / 2);
                  var l = new r.Vector3();
                  n.stepSize
                    ? (l.x =
                        Math.round(i / n.stepSize[0]) * n.stepSize[0] - e / 2)
                    : (l.x = i - e / 2),
                    (l.z += c.z),
                    (l.y += t / 2),
                    o.translate(l.x, l.y, l.z),
                    (s = a.mergeGeometries(o, s));
                }),
                  (p = new yt().withMaxWidth(n.maxGridHeight)),
                  (n.gridSides && 0 != n.gridSides[1]) ||
                    (p = p.withoutBorders());
                var g = d.clone();
                g.scale(n.meshThickness, n.meshDepth, e);
                var v = p.forRange(0, t);
                if (
                  (v.map(function (i) {
                    var o = g.clone();
                    o.rotateX(Math.PI / 2), o.rotateZ(Math.PI / 2);
                    var l = new r.Vector3();
                    (l.z += c.z),
                      n.stepSize
                        ? (l.y =
                            Math.round(i / n.stepSize[1]) * n.stepSize[1] -
                            t / 2)
                        : (l.y = i - t / 2),
                      (l.x -= e / 2),
                      o.translate(l.x, l.y, l.z),
                      (s = a.mergeGeometries(o, s));
                  }),
                  n.cross && n.cross.visible && m.length && v.length)
                ) {
                  var y = n.cross.offset || [0, 0, 0],
                    x = d.clone();
                  x.scale(
                    n.cross.meshThickness,
                    n.cross.height,
                    n.cross.meshDepth
                  ),
                    m.map(function (i) {
                      v.map(function (o) {
                        var l,
                          c = x.clone(),
                          u = new r.Vector3();
                        (u.x = e / 2 - i),
                          (u.y = t / 2 - o),
                          (u.z = n.cross.height / 2),
                          u.add(
                            new ((l = r.Vector3).bind.apply(
                              l,
                              gt([void 0], y)
                            ))()
                          ),
                          c.translate(u.x, u.y, u.z),
                          (s = a.mergeGeometries(c, s));
                      });
                    });
                }
                break;
              case "panel":
                (b = this.box(
                  "panel",
                  l,
                  e,
                  t,
                  n.meshDepth
                ).geometry).translate(0, 0, c.z),
                  (s = this.mergeGeometries(b, s));
                break;
              case "box":
                var b;
                (t -= c.y),
                  (b = this.box(
                    "box",
                    l,
                    e + n.meshThickness,
                    t + n.meshThickness,
                    n.meshDepth
                  ).geometry).translate(0, -c.y, c.z),
                  (s = this.mergeGeometries(b, s));
                break;
              case "prairie":
                p = new yt().withFunction(function (e, t) {
                  return [e + 15, t - 15];
                });
                var w = this.box(
                    "vert",
                    l,
                    n.meshThickness,
                    t,
                    n.meshDepth
                  ).geometry,
                  _ = this.box(
                    "vert",
                    l,
                    e,
                    n.meshThickness,
                    n.meshDepth
                  ).geometry;
                p.forRange(-e / 2, e / 2).map(function (e) {
                  var t = w.clone();
                  t.translate(e, 0, c.z), (s = a.mergeGeometries(t, s));
                }),
                  p.forRange(-t / 2, t / 2).map(function (e) {
                    var t = _.clone();
                    t.translate(0, e, c.z), (s = a.mergeGeometries(t, s));
                  });
            }
            var M = new r.Mesh(s, l);
            if (
              (this.remapUV(M),
              n.elements && n.elements.length > 0 && "grid" === n.type)
            ) {
              var S = function (e, t, n) {
                  return (t - e) * n + e;
                },
                T = this.buildGlassDecorationBBoxes(e, t, n);
              n.elements.forEach(function (e) {
                var t = e.relativePosition || [0.5, 0.5],
                  n = e.absoluteSizeDelta || [0, 0],
                  o = e.offset || [0, 0, 0],
                  s = i.elements.filter(function (t) {
                    return t.id === e.elementId;
                  })[0];
                (s = JSON.parse(JSON.stringify(s))),
                  T.forEach(function (e) {
                    var c,
                      u = new r.Vector2();
                    e.getSize(u);
                    var h = new r.Vector2(
                      S(e.min.x, e.max.x, t[0]),
                      S(e.min.y, e.max.y, 1 - t[1])
                    );
                    (s.width = u.x + n[0]), (s.height = u.y + n[1]);
                    var d = a.buildElement(s.id, s.elementType, s, i, 0, l);
                    (d.position.x += h.x),
                      (d.position.y += h.y),
                      d.position.add(
                        new ((c = r.Vector3).bind.apply(c, gt([void 0], o)))()
                      ),
                      M.add(d);
                  });
              });
            }
            return M;
          }),
          (t.prototype.buildGlassDecorationBBoxes = function (e, t, n) {
            var i = new r.Vector2(e, t).clone().divideScalar(2),
              o = i.clone().negate();
            if (!n) return [new r.Box2(o, i)];
            switch ((new r.Vector2().fromArray(n.offset || [0, 0]), n.type)) {
              case "grid":
                for (
                  var a = [],
                    s = Math.ceil(e / n.maxGridWidth),
                    l = Math.ceil(t / n.maxGridHeight),
                    c = e / s,
                    u = t / l,
                    h = n.meshThickness / 2,
                    d = new r.Vector2(c, u),
                    p = (d.clone().divideScalar(2).clone().negate(), 0);
                  p < l;
                  p++
                )
                  for (var f = 0; f < s; f++) {
                    var m = d.clone().multiply(new r.Vector2(f, p)),
                      g = m.clone().add(d);
                    n.stepSize &&
                      ((m.x = Math.round(m.x / n.stepSize[0]) * n.stepSize[0]),
                      (m.y = Math.round(m.y / n.stepSize[1]) * n.stepSize[1]),
                      (g.x = Math.round(g.x / n.stepSize[0]) * n.stepSize[0]),
                      (g.y = Math.round(g.y / n.stepSize[1]) * n.stepSize[1]));
                    var v = new r.Box2(
                      m.add(o).addScalar(h),
                      g.add(o).addScalar(-h)
                    );
                    a.push(v);
                  }
                return a;
              default:
                return [new r.Box2(o, i)];
            }
          }),
          (t.prototype.rotateEl = function (e, t, n, i, o, a, s) {
            ((e = e.clone()).position.x += t),
              (e.position.y += n),
              (e.position.z += i);
            var l = new r.Object3D();
            l.children.push(e),
              (l.rotation.x += o),
              (l.rotation.y += a),
              (l.rotation.z += s),
              (l.position.x -= t),
              (l.position.y -= n),
              (l.position.z -= i);
            var c = new r.Object3D();
            return c.add(l), c;
          }),
          (t.prototype.addGlassDecoration = function (e, t, n, r, i) {
            if (!e) return !0;
            var o = t.glassDecorations.filter(function (t) {
              return t.id === e;
            })[0];
            return (
              n.add(this.buildGlassDecoration(r, i, o, t)), "box" != o.type
            );
          }),
          (t.prototype.swapUV = function (e) {
            e.traverse(function (e) {
              if ("geometry" in e) {
                var t = e.geometry.getAttribute("uv"),
                  n = new r.Vector2();
                if (t instanceof r.BufferAttribute)
                  for (var i = 0; i < t.count; i++)
                    n.fromBufferAttribute(t, i), t.setXY(i, n.y, n.x);
              }
            });
          }),
          (t.prototype.buildElement = function (e, t, n, r, i, o) {
            var a = void 0;
            if (n)
              if (n.doNotCache)
                a = this.buildElementInternal(n.id, n.elementType, n, r, i, o);
              else {
                n.constProps && Object.assign(n, n.constProps);
                var s = JSON.stringify(n),
                  l = this.elementCache
                    .map(function (e) {
                      return e.pars;
                    })
                    .indexOf(s);
                l < 0 ||
                ["meshFromFile", "spriteFromFile", "text"].some(function (e) {
                  return e === n.elementType;
                })
                  ? ((a = this.buildElementInternal(
                      n.id,
                      n.elementType,
                      n,
                      r,
                      i,
                      o
                    )),
                    this.elementCache.length > 50 && this.elementCache.pop(),
                    (a = a.clone()))
                  : ((a = this.elementCache[l].value.clone()),
                    this.elementCache.splice(l)),
                  (a.name = e),
                  this.elementCache.unshift({
                    pars: s,
                    value: a.clone(),
                  });
              }
            return a;
          }),
          (t.prototype.buildElementInternal = function (e, t, n, i, o, a) {
            var s = this,
              l = [];
            (a = a || this.materials["default element material"]),
              n &&
                ((n = Object.assign({}, n)).baseMaterialId &&
                  (a = this.materials[n.baseMaterialId]),
                (o = n.pctOpen || o));
            var c,
              u,
              h,
              d,
              p,
              f,
              m = ((((o = o || 0) / 100) * Math.PI) / 2) * 0.9,
              g = m / 8,
              v = {
                window: this.bevelXYVectorArray(
                  this.xyRectVerts(7, 4, 0, !0),
                  0.5
                ),
                door: this.bevelXYVectorArray(
                  this.xyRectVerts(12, 4, 0, !0),
                  0.5
                ),
              },
              y = this.materials.glass;
            n &&
              n.opts &&
              n.opts.fillMaterialId &&
              (y = this.materials[n.opts.fillMaterialId]),
              this.materials.aluminium ||
                ((this.materials.aluminium = this.materials.whiteMetal.clone()),
                (this.materials.aluminium.metalness = 0.8),
                (this.materials.aluminium.roughness = 0.6));
            var x = this.materials.aluminium,
              b = mt({}, n);
            switch (t) {
              case "gap":
                break;
              case "imagePlaneFromFile":
              case "meshFromFile":
              case "spriteFromFile":
                var w = this.loadedMeshes
                    .map(function (e) {
                      return e.id;
                    })
                    .indexOf(n.id),
                  _ = void 0;
                if (w < 0) {
                  switch (t) {
                    case "meshFromFile":
                      var M = [],
                        S = n.opts.overruleMaterials;
                      _ = this.loadMesh(n.id, kt(n.opts.url), function (e) {
                        n.opts.overruleMaterials &&
                          e.traverse(function (e) {
                            e.material &&
                              (e.material.isMultiMaterial
                                ? e.material.forEach(function (t, n) {
                                    M.push(t),
                                      t.name &&
                                        S[t.name] &&
                                        (e.material[n] =
                                          s.materials[S[t.name]]);
                                  })
                                : (e.material.name &&
                                    S[e.material.name] &&
                                    (e.material =
                                      s.materials[S[e.material.name]]),
                                  M.push(e.material)));
                          });
                      });
                      break;
                    case "spriteFromFile":
                      _ = this.loadSprite(
                        n.id,
                        kt(n.opts.url),
                        n.width,
                        n.height,
                        null
                      );
                      break;
                    case "imagePlaneFromFile":
                      _ = this.loadImagePlane(
                        n.id,
                        kt(n.opts.url),
                        n.minWidth,
                        n.minHeight,
                        n.maxWidth,
                        n.maxHeight
                      );
                      break;
                    default:
                      throw "wtf";
                  }
                  this.loadedMeshes.push({
                    id: n.id,
                    mesh: _,
                  });
                } else _ = this.loadedMeshes[w].mesh;
                l.push([_]);
                break;
              case "text":
              case "horizontalArrowWithLabel":
                var T = Object.assign(
                    {
                      text: "text",
                      fontSize: 20,
                      color: 0,
                      anchorX: "center",
                      anchorY: "top",
                      labelRotation: [0, Math.PI, Math.PI / 2],
                    },
                    n.opts
                  ),
                  E = new ut();
                if (
                  (E.material.addEventListener ||
                    (E.material.addEventListener = function () {}),
                  Object.keys(T).forEach(function (e) {
                    e in E && (E[e] = T[e]);
                  }),
                  (E.text = T.label),
                  E.sync(),
                  (_ = new r.Object3D()).add(E),
                  _.rotation.fromArray(T.labelRotation),
                  l.push([_]),
                  "horizontalArrowWithLabel" == t)
                ) {
                  var A = new r.MeshBasicMaterial({
                    color: 0,
                  });
                  A.name = "arrow";
                  var C = new r.LineBasicMaterial({
                    color: 0,
                    linewidth: 3,
                  });
                  C.name = "arrow";
                  var P = new r.LineDashedMaterial({
                    color: 0,
                    dashSize: 3,
                    gapSize: 3,
                    scale: 100,
                  });
                  P.name = "arrow";
                  var L = new r.BufferGeometry();
                  L.setAttribute(
                    "position",
                    new r.Float32BufferAttribute([0, -0.5, 0, 0, 0.5, 0], 3)
                  );
                  var R = new r.CylinderBufferGeometry(0, 0.5, 1, 5, 1);
                  R.translate(0, -0.5, 0);
                  var I = new r.Line(L, C);
                  I.scale.y = n.width;
                  var k = new r.Line(L, P);
                  k.scale.y = n.width;
                  var D = new r.Line(L, P);
                  (D.scale.y = n.height), (D.rotation.z = Math.PI / 2);
                  var O = D.clone(),
                    B = new r.Mesh(R, A);
                  (B.scale.y = 4 * C.linewidth),
                    (B.scale.x = 2 * C.linewidth),
                    (B.scale.z = 2 * C.linewidth);
                  var F = B.clone();
                  k.computeLineDistances(),
                    D.computeLineDistances(),
                    O.computeLineDistances(),
                    (F.rotation.x = Math.PI),
                    l.push(
                      [I, 0, 0, 0],
                      [k, n.height, 0, 0],
                      [B, 0, n.width / 2, 0],
                      [F, 0, -n.width / 2, 0],
                      [D, n.height / 2, n.width / 2, 0],
                      [O, n.height / 2, -n.width / 2, 0]
                    );
                }
                break;
              case "extrudeShape":
                var N = n.opts.shape.map(function (e) {
                    return new r.Vector2().fromArray(e);
                  }),
                  U = void 0;
                if (n && n.opts && n.opts.smoothShape) {
                  U = new r.Shape();
                  var z = N.pop();
                  U.moveTo(z.x, z.y), U.splineThru(N);
                } else U = new r.Shape(N);
                var H = new r.ExtrudeBufferGeometry(U, {
                    steps: 1,
                    depth: n.opts.height,
                    bevelEnabled: !1,
                  }),
                  G = new r.Mesh(H, a);
                l.push([G]);
                break;
              case "element grid":
                var V = Object.assign({}, n),
                  j = (V.opts.horizontalSplits || [])
                    .concat([V.width])
                    .map(function (e) {
                      return e / 10;
                    }),
                  W = (V.opts.verticalSplits || [])
                    .concat([V.height])
                    .map(function (e) {
                      return e / 10;
                    }),
                  q = new r.Object3D();
                (q.name = "elements"),
                  V.opts.sections.forEach(function (e, t) {
                    var n = j[e.range.column],
                      r = j[e.range.column + e.range.columnSpan] - n,
                      l = W[e.range.row],
                      c = W[e.range.row + e.range.rowSpan] - l,
                      u = i.elements.filter(function (t) {
                        return t.id == e.filling;
                      });
                    if (u.length) {
                      var d = u[0];
                      ((d = Object.assign({}, d)).width = r),
                        (d.height = c),
                        d.opts &&
                          ((d.width += d.opts.deltaWidth || 0),
                          (d.height += d.opts.deltaHeight || 0)),
                        (h = s.buildElementInternal(
                          "cell " + e.range.row + ", " + e.range.column,
                          d.elementType,
                          d,
                          i,
                          o,
                          a
                        )).position.set(n + r / 2, l + c / 2, 0),
                        q.add(h);
                    }
                  }),
                  l.push([q]);
                break;
              case "windowPanel":
                n.opts = n.opts || {};
                var $ = [
                    {
                      height: n.height,
                      glassDecorationId: n.opts.glassDecorationId,
                    },
                  ],
                  X = [];
                if (n.opts) {
                  if (n.opts.windowsHaveT) {
                    var Y = n.opts.windowsTHeight || 40;
                    (Y = Math.min(Y, n.height)),
                      ($[0].height -= Y),
                      $.push({
                        height: Y,
                        glassDecorationId: n.opts.glassDecorationIdForT,
                      });
                  }
                  n.opts.windowsHaveBottomPanel &&
                    ((Y = n.opts.windowsBottomPanelHeight || 60),
                    (Y = Math.min(Y, n.height)),
                    ($[0].height -= Y),
                    $.unshift({
                      height: Y,
                      glassDecorationId: n.opts.glassDecorationIdForBottomPanel,
                    }));
                  var J = n.opts.maxWindowPanelWidth || 6e5;
                  if (n.width > J) {
                    var Z = n.width / 2;
                    X = new yt()
                      .withMaxWidth(J)
                      .withoutBorders()
                      .forRange(-Z, Z);
                  }
                }
                var K = -n.height / 2;
                $.forEach(function (e) {
                  var t = new r.Object3D(),
                    o = X.slice(0);
                  o.unshift(-n.width / 2), o.push(n.width / 2);
                  for (var c = !1, u = 1; u < o.length; u++) {
                    var d = o[u] - o[u - 1],
                      p = new r.Object3D();
                    t.add(p),
                      (p.position.x = (o[u] + o[u - 1]) / 2),
                      (c = s.addGlassDecoration(
                        e.glassDecorationId,
                        i,
                        p,
                        d,
                        e.height
                      ));
                  }
                  l.push([t, 0, K + e.height / 2, 0]),
                    c &&
                      ((h = s.xyFramedPanel(
                        "window",
                        a,
                        y,
                        n.width,
                        e.height,
                        v.window
                      )),
                      l.push([h, 0, K + e.height / 2, 0]),
                      X.reduce(function (e, t) {
                        (e = e || s.box("vert beam", a, 5, n.height, 5)),
                          l.push([e.clone(), t, 0, 0]);
                      }, null)),
                    (K += e.height);
                });
                break;
              case "doorPanel":
                (c = this.xyFrame(
                  "door panel frame",
                  a,
                  n.width - 8,
                  n.height - 8,
                  v.door
                )),
                  (u = this.box("door panel", a, n.width - 8, n.height - 8, 1)),
                  this.remapUV(u),
                  l.push([c]),
                  l.push([u, 0, 0, 0]);
                break;
              case "doorPanelWithGlass":
                c = this.xyFrame(
                  "door panel frame",
                  a,
                  n.width - 8,
                  n.height - 8,
                  v.door
                );
                var Q = n.height - 8 - n.glassHeight;
                (u = this.box("door panel", a, n.width - 8, Q, 1)),
                  this.remapUV(u),
                  (h = this.xyPanel(
                    "door glass",
                    y,
                    n.width - 8,
                    n.glassHeight
                  )),
                  this.addGlassDecoration(
                    n.opts.glassDecorationId,
                    i,
                    h,
                    n.width - 16,
                    n.glassHeight - 8
                  );
                var ee = this.box("door glass edge", a, n.width - 16, 10, 2);
                this.remapUV(ee, !0),
                  l.push([c]),
                  l.push([u, 0, -n.glassHeight / 2, 0]),
                  l.push([h, 0, Q / 2, 0]),
                  l.push([ee, 0, (Q - n.glassHeight) / 2, 0]);
                break;
              case "glassdecoration":
                (_ = new r.Object3D()),
                  this.addGlassDecoration(
                    n.opts.glassDecorationId,
                    i,
                    _,
                    n.width,
                    n.height
                  ),
                  l.push([_]);
                break;
              case "windowTop":
                (h = this.buildElementInternal(
                  "window panel",
                  "windowPanel",
                  n,
                  i,
                  o,
                  a
                )),
                  (d = this.xyFrame(
                    "window frame",
                    a,
                    n.width + 7,
                    n.height + 7,
                    v.window
                  )),
                  l.push(
                    [this.rotateEl(h, 0, -n.height / 2 - 2, 2, -g, 0, 0), 0, 0],
                    [d, 0, 0]
                  );
                break;
              case "windowLeft":
                (h = this.buildElementInternal(
                  "window panel",
                  "windowPanel",
                  n,
                  i,
                  o,
                  a
                )),
                  (d = this.xyFrame(
                    "window frame",
                    a,
                    n.width + 7,
                    n.height + 7,
                    v.window
                  )),
                  l.push(
                    [this.rotateEl(h, n.width / 2 + 2, 0, -2, 0, -m, 0), 0, 0],
                    [d, 0, 0]
                  );
                break;
              case "windowRight":
                (h = this.buildElementInternal(
                  "window panel",
                  "windowPanel",
                  n,
                  i,
                  o,
                  a
                )),
                  (d = this.xyFrame(
                    "window frame",
                    a,
                    n.width + 7,
                    n.height + 7,
                    v.window
                  )),
                  l.push(
                    [this.rotateEl(h, -n.width / 2 - 2, 0, -2, 0, m, 0), 0, 0],
                    [d, 0, 0]
                  );
                break;
              case "doubleWindow":
                (n.width = n.width - 12),
                  (n.height = n.height - 12),
                  n.window &&
                    ((n.window.width = n.width / 2),
                    (n.window.height = n.height)),
                  (h = this.buildElementInternal(
                    "window panel",
                    "windowPanel",
                    n.window,
                    i,
                    o,
                    a
                  )),
                  (d = this.xyFrame(
                    "window frame",
                    a,
                    2 * n.window.width + 14,
                    n.window.height + 9,
                    v.window
                  )),
                  l.push(
                    [
                      this.rotateEl(h, n.window.width / 2 + 2, 0, -2, 0, -m, 0),
                      -n.window.width / 2 - 2,
                      0,
                    ],
                    [
                      this.rotateEl(h, -n.window.width / 2 - 2, 0, -2, 0, m, 0),
                      n.window.width / 2 + 2,
                      0,
                    ],
                    [d, 0, 0]
                  );
                break;
              case "rightDoorWithGlass":
              case "leftDoorWithGlass":
              case "rightDoor":
              case "leftDoor":
                (f = this.xyFrame(
                  "door frame",
                  a,
                  n.width + 4,
                  n.height + 2,
                  v.window
                )),
                  l.push([f, 0, 0]);
                var te = "leftDoor" === t || "leftDoorWithGlass" === t ? 1 : -1;
                p =
                  "rightDoor" === t || "leftDoor" === t
                    ? "doorPanel"
                    : "doorPanelWithGlass";
                var ne = this.buildElementInternal("door panel", p, n, i, o, a);
                ((We = this.buildElementInternal(
                  "door handle",
                  "handle",
                  null,
                  i,
                  o,
                  a
                )).position.x += te * (n.width / 2 - 12)),
                  (We.rotation.y = te < 0 ? 0 : Math.PI),
                  ne.add(We),
                  l.push([
                    this.rotateEl(
                      ne,
                      (n.width / 2) * te,
                      0,
                      -2 * te,
                      0,
                      -m * te,
                      0
                    ),
                    0,
                    0,
                  ]);
                break;
              case "invisibleRightDoor":
              case "invisibleLeftDoor":
                (c = this.xyFrame(
                  "door panel frame",
                  a,
                  n.width - 8,
                  n.height - 8,
                  v.door
                )),
                  (u = this.box("door panel", a, n.width, n.height, 1)),
                  this.remapUV(u);
                var re = this.compose("invisible panel", [
                  [c, 0, 0, -1],
                  [u, 0, 0, 1],
                ]);
                (te = "invisibleRightDoor" === t ? 1 : -1),
                  ((We = this.buildElementInternal(
                    "door handle",
                    "handle",
                    null,
                    i,
                    o,
                    a
                  )).position.x += -te * (n.width / 2 - 12)),
                  (We.rotation.y = -te < 0 ? 0 : Math.PI),
                  re.add(We),
                  l.push([
                    this.rotateEl(re, (-n.width * te) / 2, 0, 0, 0, m * te, 0),
                    0,
                    0,
                    0,
                  ]),
                  l.push([
                    this.box("hack", a, 0.1, 0.1, 0.1),
                    (-n.width / 2) * te,
                    0,
                    0,
                  ]);
                break;
              case "invisibleDoubleDoor":
                ["invisibleRightDoor", "invisibleLeftDoor"].forEach(function (
                  e
                ) {
                  (c = s.xyFrame(
                    "door panel frame",
                    a,
                    n.width / 2 - 8,
                    n.height - 8,
                    v.door
                  )),
                    (u = s.box("door panel", a, n.width / 2, n.height, 1)),
                    s.remapUV(u);
                  var t = s.compose("invisible panel", [
                      [c, 0, 0, -1],
                      [u, 0, 0, 1],
                    ]),
                    r = s.buildElementInternal(
                      "door handle",
                      "handle",
                      null,
                      i,
                      o,
                      a
                    ),
                    h = "invisibleRightDoor" === e ? 1 : -1;
                  (r.position.x += -h * (n.width / 4 - 12)),
                    (r.rotation.y = -h < 0 ? 0 : Math.PI),
                    t.add(r),
                    l.push([
                      s.rotateEl(t, (-n.width * h) / 4, 0, 0, 0, m * h, 0),
                      (n.width * h) / 4,
                      0,
                      0,
                    ]);
                });
                break;
              case "doubleDoor":
              case "doubleDoorWithGlass":
                (f = this.xyFrame(
                  "door frame",
                  a,
                  n.width + 4,
                  n.height + 2,
                  v.window
                )),
                  l.push([f, 0, 0]),
                  (p = "doubleDoor" === t ? "doorPanel" : "doorPanelWithGlass"),
                  ((se = Object.assign({}, n)).width /= 2),
                  se.window && (se.window.width = n.width / 2);
                var ie = (oe = this.buildElementInternal(
                  "door panel",
                  p,
                  se,
                  i,
                  o,
                  a
                )).clone();
                ((ce = this.buildElementInternal(
                  "door handle",
                  "handle",
                  null,
                  se,
                  o,
                  a
                )).position.x = -(se.width / 2 - 12)),
                  oe.add(ce),
                  l.push([
                    this.rotateEl(ie, se.width / 2, 0, -2, 0, -m, 0),
                    -se.width / 2,
                    0,
                    0,
                  ]),
                  l.push([
                    this.rotateEl(oe, -se.width / 2, 0, -2, 0, m, 0),
                    se.width / 2,
                    0,
                    0,
                  ]);
                break;
              case "frenchDoors":
                (f = this.xyFrame(
                  "door frame",
                  a,
                  n.width + 4,
                  n.height + 2,
                  v.window
                )),
                  l.push([f, 0, 0]);
                var oe,
                  ae = Object.assign(
                    {
                      maxPanelWidth: 80,
                      noHandle: !1,
                    },
                    n.opts
                  ),
                  se = Object.assign({}, n, n.window),
                  le = Math.min(n.width / 2, ae.maxPanelWidth);
                if (
                  ((se.width = le),
                  (se.height = n.height - 6),
                  se.window && (se.window.width = n.width / 2),
                  (ie = (oe = this.buildElementInternal(
                    "french door panel",
                    "windowPanel",
                    se,
                    i,
                    o,
                    a
                  )).clone()),
                  !ae.noHandle)
                )
                  var ce = this.buildElementInternal(
                    "door handle",
                    "handle",
                    null,
                    se,
                    o,
                    a
                  );
                if (
                  (l.push([
                    this.rotateEl(ie, se.width / 2, 0, -2, 0, -m, 0),
                    -se.width / 2 - 2,
                    0,
                    0,
                  ]),
                  l.push([
                    this.rotateEl(oe, -se.width / 2, 0, -2, 0, m, 0),
                    se.width / 2 + 2,
                    0,
                    0,
                  ]),
                  (we = n.width / 2 - le - 2) > 0)
                ) {
                  se.width = we;
                  var ue = this.buildElementInternal(
                    "remainging window",
                    "windowPanel",
                    se,
                    i,
                    o,
                    a
                  );
                  l.push([ue, -we / 2 - le]), l.push([ue, +we / 2 + le]);
                }
                break;
              case "pole":
                var he = n.opts.thickness || 12;
                ((G = this.box(
                  "pole",
                  a,
                  he,
                  n.opts.height || 200,
                  he
                )).rotation.x = Math.PI / 2),
                  this.remapUV(G),
                  l.push([G]);
                break;
              case "roundpole":
                he = n.opts.thickness || 12;
                var de = new r.CylinderBufferGeometry(12, 12, n.height, 12);
                (G = new r.Mesh(de, a)), l.push([G]);
                break;
              case "slidingGlassDoors":
                var pe = n.width;
                (pe += 6), (n.height = n.height + 6);
                var fe = n.width <= 400 ? 4 : 5,
                  me = pe / fe + 10,
                  ge = this.glassSlidersLeftFrontToRightBack(
                    "glass door",
                    this.materials,
                    pe,
                    n.height,
                    fe,
                    me,
                    o
                  ),
                  ve = this.box("top rail glass door", a, pe, 8, 6);
                l.push([ge]), l.push([ve, 0, n.height / 2 - 4, 0]);
                break;
              case "slidingDoorLeft":
              case "slidingDoorRight":
                (n.width = n.width - 7),
                  (n.height = n.height - 8),
                  n.window &&
                    ((n.window.width = n.width / 2),
                    (n.window.height = n.height)),
                  (h = this.buildElementInternal(
                    "window panel",
                    "windowPanel",
                    n.window,
                    i,
                    o,
                    a
                  )),
                  ((d = this.xyFrame(
                    "window frame",
                    a,
                    n.width + 10,
                    n.window.height + 9,
                    v.window
                  )).scale.z = 2.5);
                var ye = "slidingDoorLeft" === t;
                l.push(
                  [
                    h,
                    n.window.width * (0.5 - (ye ? o / 100 : 0)),
                    0,
                    ye ? -4 : 0,
                  ],
                  [
                    h,
                    -n.window.width * (0.5 - (ye ? 0 : o / 100)),
                    0,
                    ye ? 0 : -4,
                  ],
                  [d, 0, 0, -2]
                );
                break;
              case "slidingDoorLeft3":
              case "slidingDoorRight3":
                (n.width = n.width - 7),
                  (n.height = n.height - 8),
                  n.window &&
                    ((n.window.width = n.width / 3),
                    (n.window.height = n.height)),
                  (h = this.buildElementInternal(
                    "window panel",
                    "windowPanel",
                    n.window,
                    i,
                    o,
                    a
                  )),
                  ((d = this.xyFrame(
                    "window frame",
                    a,
                    n.width + 10,
                    n.window.height + 9,
                    v.window
                  )).scale.z = 5);
                var xe = "slidingDoorLeft3" === t ? 1 : -1;
                l.push(
                  [
                    h,
                    (-n.width / 2 +
                      n.window.width * (0.5 + 2 * (1 - o / 100))) *
                      xe,
                    0,
                    -8,
                  ],
                  [
                    h,
                    (-n.width / 2 +
                      n.window.width * (0.5 + 1 * (1 - o / 100))) *
                      xe,
                    0,
                    -4,
                  ],
                  [
                    h,
                    (-n.width / 2 +
                      n.window.width * (0.5 + 0 * (1 - o / 100))) *
                      xe,
                    0,
                    0,
                  ],
                  [d, 0, 0, -6]
                );
                break;
              case "slidingDoorDouble":
                (n.width = n.width - 7),
                  (n.height = n.height - 8),
                  n.window &&
                    ((n.window.width = n.width / 4),
                    (n.window.height = n.height)),
                  (h = this.buildElementInternal(
                    "window panel",
                    "windowPanel",
                    n.window,
                    i,
                    o,
                    a
                  )),
                  ((d = this.xyFrame(
                    "window frame",
                    a,
                    n.width + 10,
                    n.window.height + 9,
                    v.window
                  )).scale.z = 2.5),
                  l.push(
                    [h, 1.5 * n.window.width, 0, 0],
                    [h, 1.5 * -n.window.width, 0, 0],
                    [h, n.window.width * (0.5 + o / 100), 0, -4],
                    [h, -n.window.width * (0.5 + o / 100), 0, -4],
                    [d, 0, 0]
                  );
                break;
              case "accordeonDoorLeft":
              case "accordeonDoorRight":
              case "accordeonDoorMiddle":
                (n.width = n.width - 16),
                  (n.height = n.height - 8),
                  (d = this.xyFrame(
                    "window frame",
                    a,
                    n.width,
                    n.height,
                    v.window
                  )),
                  "accordeonDoorMiddle" === t &&
                    ((n.width /= 2), (n.width -= 2));
                var be = Math.ceil(n.width / 60),
                  we = (n.width + 12) / be - 4;
                n.window &&
                  ((n.window.width = we), (n.window.height = n.height + 4)),
                  (h = this.buildElementInternal(
                    "window panel",
                    "windowPanel",
                    n.window,
                    i,
                    o,
                    a
                  )),
                  (d.scale.z = 2.5);
                for (
                  var _e = ((o / 100) * Math.PI) / 2,
                    Me = ((_ = new r.Object3D()), 0);
                  Me < be;
                  Me++
                ) {
                  var Se = h.clone();
                  (Se.rotation.y = _e * (1 - 2 * (1 & Me))),
                    (Se.position.x =
                      -4 -
                      n.width / 2 +
                      (Me + 0.5) * we * Math.cos(_e) +
                      4 * Me),
                    (Se.position.z = -Math.sin(_e) * (we / 2)),
                    _.add(Se);
                }
                switch ((l.push(d, 0, -2), t)) {
                  case "accordeonDoorLeft":
                    l.push([_]);
                    break;
                  case "accordeonDoorRight":
                    (_.rotation.z = Math.PI),
                      _.children.map(function (e) {
                        e.rotation.z += Math.PI;
                      }),
                      l.push([_]);
                    break;
                  case "accordeonDoorMiddle":
                    var Te = _.clone();
                    (Te.rotation.z = Math.PI),
                      Te.children.map(function (e) {
                        e.rotation.z += Math.PI;
                      }),
                      l.push([_, -n.width / 2 - 6]),
                      l.push([Te, n.width / 2 + 6]);
                }
                break;
              case "trapezoid":
                Z = (n = Object.assign({}, n)).width / 2;
                var Ee = n.height / 2,
                  Ae = ((_e = n.opts.angle || 5), 0),
                  Ce =
                    n.opts.deltaHeight ||
                    Math.sin((_e / 180) * Math.PI) * Z * 2;
                Ce > 0 && ((Ae = -Ce), (Ce = 0)),
                  n.opts.extendOutside && ((Ae *= -1), (Ce *= -1));
                var Pe = [
                  new r.Vector2(-Z, -Ee),
                  new r.Vector2(-Z, Ee + Ae),
                  new r.Vector2(Z, Ee + Ce),
                  new r.Vector2(Z, -Ee),
                ];
                Pe.push(Pe[0]), Pe.push(Pe[1]);
                var Le = function (e) {
                    return new r.Vector3(e.x, e.y + (Ae + Ce) / 2, 0);
                  },
                  Re = this.simplifyVerts(Pe).map(Le);
                if (Re.length < 3) break;
                var Ie = this.extrudeShapeOnYPlane(
                    "trapezoid border",
                    a,
                    v.window,
                    Re,
                    !1
                  ),
                  ke = this.polygonGeometry(Re);
                Re = Re.reverse();
                var De = this.polygonGeometry(Re),
                  Oe = new r.Mesh(ke, y),
                  Be = new r.Mesh(De, y),
                  Fe = -(Ae + Ce) / 2;
                if (
                  (l.push([Ie, 0, Fe], [Oe, 0, Fe], [Be, 0, Fe]),
                  n.opts.glassDecorationId)
                ) {
                  Re = Pe.map(Le);
                  var Ne = i.glassDecorations.filter(function (e) {
                      return e.id === n.opts.glassDecorationId;
                    })[0],
                    Ue = new yt()
                      .withMaxWidth(Ne.maxGridWidth)
                      .withoutBorders(),
                    ze = new yt()
                      .withMaxWidth(Ne.maxGridHeight)
                      .withoutBorders(),
                    He = this.xyRectVerts(
                      Ne.meshThickness,
                      Ne.meshDepth,
                      0,
                      !0
                    ),
                    Ge = this.parallelBeamsOverPoly(
                      "glass deco",
                      this.materials[Ne.materialId],
                      Re,
                      3,
                      Ue,
                      He
                    );
                  l.push([Ge, 0, Fe, 0]);
                  var Ve = this.parallelBeamsOverPoly(
                    "glass deco",
                    this.materials[Ne.materialId],
                    Re,
                    0,
                    ze,
                    He
                  );
                  l.push([Ve, 0, Fe, 0]);
                }
                break;
              case "handle":
                var je = this.xyRectVerts(15, 13.5);
                je = this.bevelXYVectorArray(je, 1.5);
                var We,
                  qe = this.xyRectVerts(3, 3);
                qe.push(qe[0]),
                  (qe = this.bevelXYVectorArray(qe, 0.4 * 1.5)),
                  ((We = this.extrudeShapeOnYPlane(
                    "handle",
                    x,
                    qe,
                    je,
                    !0
                  )).rotation.x = Math.PI / 2),
                  (We.rotation.y = Math.PI),
                  (We = this.rotateEl(
                    We,
                    7.5,
                    0,
                    0,
                    0,
                    0,
                    -Math.sin((o / 100) * Math.PI) / 2
                  )),
                  l.push([We]),
                  l.push([this.box("handle plate", x, 4.5, 12, 7), -7.5, -3]);
                break;
              case "dome flat":
                var $e = Object.assign(
                  {
                    spanWidth: 60,
                  },
                  n.opts
                );
                ((Xe = this.roofDome(
                  "roof",
                  "flat",
                  n.width,
                  n.height,
                  a,
                  $e.spanWidth
                )).rotation.x = Math.PI / 2),
                  l.push([Xe]);
                break;
              case "dome saddle":
                ($e = Object.assign(
                  {
                    spanWidth: 60,
                  },
                  n.opts
                )),
                  ((Xe = this.roofDome(
                    "roof",
                    "saddle",
                    n.width,
                    n.height,
                    a,
                    $e.spanWidth
                  )).rotation.x = Math.PI / 2),
                  l.push([Xe]);
                break;
              case "dome pyramid":
                ($e = Object.assign(
                  {
                    spanWidth: 60,
                  },
                  n.opts
                )),
                  ((Xe = this.roofDome(
                    "roof",
                    "pyramid",
                    n.width,
                    n.height,
                    a,
                    $e.spanWidth
                  )).rotation.x = Math.PI / 2),
                  l.push([Xe]);
                break;
              case "dome pyramid simple":
                $e = Object.assign(
                  {
                    spanWidth: 60,
                  },
                  n.opts
                );
                var Xe,
                  Ye = 0.6 * Math.min(n.width, n.height);
                ((Xe = this.roofDome(
                  "roof",
                  "pyramid",
                  n.width,
                  n.height,
                  a,
                  $e.spanWidth,
                  Ye
                )).rotation.x = Math.PI / 2),
                  l.push([Xe]);
                break;
              case "blinds":
                n.opts = Object.assign(
                  {
                    maxShutterWidth: 20,
                    shutterHeight: 1.8,
                    openPct: 50,
                    collapsePct: 0,
                    ledLight: !1,
                    maxLedLightWidth: 120,
                    alwaysVertical: !1,
                    gutters: !1,
                    gap: 0.5,
                  },
                  n.opts || {}
                );
                var Je = ((n.opts.openPct || 0) * Math.PI) / 100;
                ((Ke = this.horizontalShutters(
                  "blinds",
                  a,
                  n.opts.maxShutterWidth,
                  n.opts.shutterHeight,
                  Je,
                  n.width,
                  n.height,
                  n.opts.ledLight ? n.opts.lightMaterialId : null,
                  n.opts.collapsePct / 100,
                  n.opts.maxLedLightWidth,
                  n.opts.gap
                )).rotation.x = Math.PI / 2),
                  l.push([Ke]);
                break;
              case "blindsCurved":
                n.opts = Object.assign(
                  {
                    curvesWidth: 40,
                    curvesThickness: 0.1,
                    collapsePct: 50,
                  },
                  n.opts || {}
                );
                var Ze = this.curvedShutters(
                  "blindsCurved",
                  a,
                  n.opts.curvesWidth,
                  n.opts.curvesThickness,
                  n.width,
                  n.height,
                  n.opts.collapsePct / 100,
                  n.opts.alwaysVertical,
                  n.opts.gutters
                );
                l.push([Ze]);
                break;
              case "horizontalBlinds":
                var Ke;
                (n.opts = Object.assign(
                  {
                    maxShutterWidth: 20,
                    shutterHeight: 1.8,
                    openPct: 50,
                    collapsePct: 0,
                    ledLight: !1,
                    maxLedLightWidth: 120,
                    gap: 0.5,
                  },
                  n.opts || {}
                )),
                  (Je = ((n.opts.openPct || 0) * Math.PI) / 100),
                  ((Ke = this.fixedShutters(
                    "blinds",
                    a,
                    n.opts.maxShutterWidth,
                    n.opts.shutterHeight,
                    Je,
                    n.height,
                    n.width,
                    n.opts.ledLight ? n.opts.lightMaterialId : null,
                    n.opts.collapsePct / 100,
                    n.opts.maxLedLightWidth,
                    n.opts.gap
                  )).rotation.y += Math.PI / 2),
                  (Ke.rotation.x = Math.PI / 2),
                  l.push([Ke]);
                break;
              case "panel":
                if (
                  ((he = 2.2),
                  n && n.opts && n.opts.thickness && (he = n.opts.thickness),
                  0 == n.width && 0 == n.height && 0 == he)
                )
                  break;
                var Qe = this.box("panel", a, n.width, n.height, he);
                l.push([Qe]), this.remapUV(Qe);
                break;
              case "frame":
                (n.width = n.width - 1),
                  (n.height = n.height - 1),
                  (d = this.xyFrame(
                    "window frame",
                    a,
                    n.width,
                    n.height,
                    [
                      [0, 0, 0],
                      [0, 1, 0],
                      [0, 1, 1],
                      [0, 0, 1],
                    ].map(function (e) {
                      return new r.Vector3().fromArray(e);
                    })
                  )),
                  l.push([d]);
                break;
              case "horizontalScreen":
                (he = 0.3),
                  n && n.opts && n.opts.depth && (he = n.opts.depth),
                  (_ = new r.Object3D());
                var et = ((st = n.height) * (100 - o)) / 100;
                (Qe = this.box("panel", a, n.width, et, he)).position.y =
                  st - et / 2;
                var tt = n.bottomBarHeight || 3,
                  nt = n.bottomBarDepth || 1,
                  rt = this.materials[n.bottomBarMaterialId] || a;
                (ve = this.box("bottom rail", rt, n.width, tt, nt)).position.y =
                  st - et - tt / 2;
                var it = this.box("hack", rt, 0.1, 0.1, 0.1),
                  ot = this.materials[n.topBarMaterialId] || a,
                  at = this.box("bottom rail", ot, n.width + 10, 4, 2);
                (ve.position.y = st - et - tt / 2),
                  (at.position.y = st - 2),
                  (it.position.y = n.height / 2),
                  this.remapUV(Qe),
                  _.add(Qe),
                  _.add(ve),
                  _.add(at),
                  _.add(it),
                  l.push([_, 0, -st / 2, 0]);
                break;
              case "gondula":
                he = 0.3;
                var st,
                  lt = 40;
                if (
                  (n &&
                    n.opts &&
                    (n.opts.depth && (he = n.opts.depth),
                    n.opts.bottomHeight && (lt = n.opts.bottomHeight)),
                  (et = ((st = n.height) * (100 - o)) / 100) > lt)
                ) {
                  var ct = this.box("glass", y, n.width, et - lt, he);
                  l.push([ct, 0, st / 2 - (et - lt) / 2, 0]);
                }
                (Q = Math.min(lt, et)),
                  (Qe = this.box("panel", a, n.width, Q, he)),
                  l.push([Qe, 0, st / 2 - et + Q / 2, 0]),
                  (ve = this.box("bottom rail", a, n.width, 3, 1)),
                  l.push([ve, 0, st / 2 - et + 1.5, 0]),
                  this.remapUV(Qe);
                break;
              case "arc support beams":
                (et = n.height), (pe = n.width);
                var ht = {
                  beamShape: [
                    [-4, 0],
                    [-4, 16],
                    [4, 16],
                    [4, 0],
                    [-4, 0],
                  ],
                  beamShapeIsSmooth: !1,
                  maxSpan: 120,
                  profileSize: 8,
                  ballSize: 80,
                  poleRadius: 8,
                  arcRadius: 0.7 * et,
                  arcCenter: {
                    x: 0,
                    y: 0,
                  },
                  arcStartAngle: -Math.PI / 10,
                  arcEndAngle: Math.PI / 10,
                };
                n && n.opts && Object.assign(ht, n.opts);
                var dt = ht.arcRadius,
                  pt = ht.beamShape.map(function (e) {
                    return new r.Vector2(
                      dt + e[1] / 1.75 - ht.profileSize / 2,
                      e[0] / 1.75
                    );
                  }),
                  ft = new r.LatheBufferGeometry(
                    pt,
                    Math.round(dt / 15),
                    ht.arcStartAngle,
                    ht.arcEndAngle - ht.arcStartAngle
                  ),
                  gt = new r.Mesh(ft, a);
                (gt.rotation.x = Math.PI / 2),
                  (gt.rotation.y = Math.PI),
                  (gt.rotation.z = Math.PI / 2);
                var vt = this.sphere("koppeling", a, ht.ballSize / 2);
                vt.position.set(
                  Math.sin(ht.arcStartAngle) * dt,
                  0,
                  Math.cos(ht.arcStartAngle) * dt
                ),
                  gt.add(vt);
                var xt = vt.clone();
                xt.position.set(
                  Math.sin(ht.arcEndAngle) * dt,
                  0,
                  Math.cos(ht.arcEndAngle) * dt
                ),
                  gt.add(xt),
                  new yt()
                    .withMaxWidth(ht.maxSpan)
                    .forRange(-pe / 2, pe / 2)
                    .forEach(function (e) {
                      l.push([gt, e, ht.arcCenter.x, ht.arcCenter.y]);
                    });
                break;
              case "arc roof":
                et = n.height;
                var bt = n.width,
                  wt =
                    (new r.Object3D(),
                    {
                      beamShape: [
                        [-3.5, 0],
                        [-3.5, 5.5],
                        [3.5, 5.5],
                        [3.5, 0],
                        [-4, 0],
                      ],
                      beamShapeIsSmooth: !1,
                      maxSpan: 60,
                      glassMaterialId: "glass",
                      glassBackMaterialId: null,
                      profileSize: 8,
                      ballSize: 8,
                      poleRadius: 8,
                      arcRadius: 0.7 * et,
                      arcCenter: {
                        x: 0,
                        y: 0,
                      },
                      arcStartAngle: -Math.PI / 10,
                      arcEndAngle: Math.PI / 10,
                      arcSupportCount: 4,
                      arcSupportOffsetStartAngle: 0,
                      arcSupportOffsetEndAngle: 0,
                    });
                n && n.opts && Object.assign(wt, n.opts);
                var _t = wt.arcRadius + 9,
                  Mt = new r.CylinderBufferGeometry(
                    _t,
                    _t,
                    bt,
                    Math.round(_t / 4),
                    4,
                    !0,
                    wt.arcStartAngle + Math.PI,
                    wt.arcEndAngle - wt.arcStartAngle
                  ),
                  St =
                    ((Oe = new r.Mesh(Mt, this.materials[wt.glassMaterialId])),
                    this.materials[
                      wt.glassBackMaterialId || wt.glassMaterialId
                    ].clone());
                (St.side = r.BackSide),
                  ((Be = new r.Mesh(Mt, St)).rotation.x = Oe.rotation.x =
                    Math.PI / 2),
                  (Be.rotation.z = Oe.rotation.z = -Math.PI / 2),
                  l.push([Oe, 0, wt.arcCenter.x, wt.arcCenter.y]),
                  l.push([Be, 0, wt.arcCenter.x, wt.arcCenter.y]),
                  (N = wt.beamShape.map(function (e) {
                    return new r.Vector2(e[0] - wt.ballSize, e[1]);
                  })),
                  (U = new r.Shape(N)),
                  (H = new r.ExtrudeBufferGeometry(U, {
                    steps: 1,
                    depth: bt - 10,
                    bevelEnabled: !1,
                  }));
                var Tt = new r.Mesh(H, a);
                (_t -= 6), wt.arcRadius, wt.arcEndAngle, wt.arcStartAngle;
                var Et = wt.arcSupportCount + 2;
                new yt()
                  .withCount(Et)
                  .withoutBorders()
                  .forRange(
                    wt.arcStartAngle + wt.arcSupportOffsetStartAngle,
                    wt.arcEndAngle + wt.arcSupportOffsetEndAngle
                  )
                  .forEach(function (e) {
                    var t = Tt.clone();
                    (t.rotation.y = -Math.PI / 2),
                      (t.rotation.z = -e),
                      l.push([
                        t,
                        bt / 2 - 5,
                        wt.arcCenter.x + Math.cos(e) * _t,
                        wt.arcCenter.y + Math.sin(e) * _t,
                      ]);
                  });
                break;
              case "equirectangular sphere":
                var At = new r.Mesh(new r.SphereBufferGeometry(1, 50, 25), a);
                (At.name = "noshading"),
                  (At.rotation.x += Math.PI / 2),
                  (At.scale.x = -n.width / 2),
                  (At.scale.z = n.width / 2),
                  (At.scale.y = n.height / 2),
                  l.push([At]);
                break;
              case "floormaps":
                var Ct = [],
                  Pt = new r.Object3D(),
                  Lt = Object.assign(
                    {
                      polygons: [],
                      wallHeight: 230,
                    },
                    n.opts
                  ),
                  Rt = this.xyRectVerts(10, Lt.wallHeight / 5);
                Rt.push(Rt[0]),
                  n.opts.polygons.forEach(function (e) {
                    var t,
                      n = Ct.filter(function (t) {
                        return t.name == e.layer;
                      });
                    n.length
                      ? (t = n[0])
                      : (((t = new r.Object3D()).name = e.layer),
                        Ct.push(t),
                        Pt.add(t));
                    var i = s.extrudeShapeOnYPlaneNew(
                      e.name,
                      a,
                      Rt,
                      e.vertices.map(function (e) {
                        return new r.Vector3(e[0], e[1], 0);
                      }),
                      !1
                    );
                    t.add(i);
                  }),
                  Ct.forEach(function (e, t) {
                    e.position.z -= t * Lt.wallHeight;
                  });
                var It = new r.Box3().setFromObject(Pt),
                  Dt = new r.Vector3();
                It.getCenter(Dt);
                var Ot = new r.Vector3();
                It.getSize(Ot),
                  Pt.position.sub(Dt),
                  this.remapUV2(Pt),
                  l.push([Pt]);
                break;
              case "pointLight":
                var Bt = mt(
                  {
                    color: 16777215,
                    intensity: 1,
                    decay: 2,
                    distance: 500,
                    castShadow: !1,
                    shadowIntensity: 1,
                  },
                  n.opts || {}
                );
                if ("intensity" in Bt && 0 == Bt.intensity) break;
                var Ft = new r.PointLight(
                  Bt.color,
                  Bt.intensity,
                  Bt.distance,
                  Bt.decay
                );
                if (
                  ((Ft.castShadow = Bt.castShadow),
                  (Ft.shadow.bias = -0.01),
                  l.push([Ft]),
                  Bt.shadowIntensity < 1 && Bt.castShadow)
                ) {
                  var Nt = Ft.clone();
                  (Nt.castShadow = !1),
                    (Ft.intensity *= Bt.shadowIntensity),
                    (Nt.intensity *= 1 - Bt.shadowIntensity),
                    l.push([Nt]);
                }
                break;
              case "spotLight":
                var Ut = mt(
                    {
                      color: 16777215,
                      intensity: 1,
                      decay: 2,
                      distance: 400,
                      castShadow: !1,
                      direction: [0, 1, 0],
                      angle: Math.PI / 3,
                      penumbra: 0,
                      shadowIntensity: 1,
                      shadowMapSize: 128,
                      height: 1,
                    },
                    n.opts || {}
                  ),
                  zt = new r.SpotLight(
                    Ut.color,
                    Ut.intensity,
                    Ut.distance,
                    Ut.angle,
                    Ut.penumbra,
                    Ut.decay
                  );
                zt.castShadow = Ut.castShadow;
                var Ht = new r.MeshPhysicalMaterial({
                    color: Ut.color,
                    emissive: Ut.color,
                    emissiveIntensity: Math.max(10 * Ut.intensity, 1),
                  }),
                  Gt = new r.Vector3().fromArray(Ut.direction).normalize();
                if (n.rotation) {
                  var Vt = new r.Euler().fromArray(n.rotation);
                  (Vt.y += Math.PI / 2), (Gt = Gt.applyEuler(Vt));
                }
                zt.position.fromArray(n.position);
                var jt = this.box(
                  "spotlightRep",
                  Ht,
                  n.width,
                  n.height,
                  Ut.height
                );
                if (
                  (jt.position.add(Gt.clone().multiplyScalar(5)),
                  "intensity" in Ut && 0 == Ut.intensity)
                ) {
                  l.push([jt]);
                  break;
                }
                var Wt = this.box("spotlighttarget", Ht, 0.001, 0.001, 0.001);
                if (
                  ((zt.target = Wt),
                  Wt.position.add(
                    Gt.clone().multiplyScalar(100).add(jt.position)
                  ),
                  l.push([zt], [jt], [Wt]),
                  Ut.shadowIntensity < 1 && Ut.castShadow)
                ) {
                  var qt = zt.clone();
                  (qt.castShadow = !1),
                    (zt.intensity *= Ut.shadowIntensity),
                    (qt.intensity *= 1 - Ut.shadowIntensity),
                    l.push([qt]);
                }
                break;
              case "flexroof":
                var $t = ($e = n.opts || {}).spanWidth || 60,
                  Xt = n.height,
                  Yt = $e.edgeVerts.map(function (e) {
                    return new r.Vector3(e[0], 0, e[1]);
                  }),
                  Jt = $e.topVerts.map(function (e) {
                    return new r.Vector3(e[0], Xt, e[1]);
                  }),
                  Zt = $e.edgeTopIndexes.map(function (e) {
                    return Jt[e];
                  }),
                  Kt =
                    (Yt[Yt.length - 1].manhattanDistanceTo(Yt[0]),
                    new r.Object3D()),
                  Qt = Yt.slice(1)
                    .map(function (e, t) {
                      return [Yt[t], e, Zt[t + 1], Zt[t]].reduce(function (
                        e,
                        t
                      ) {
                        return (
                          (!e.length ||
                            e[e.length - 1].manhattanDistanceTo(t) > 1) &&
                            e.push(t),
                          e
                        );
                      },
                      []);
                    })
                    .filter(function (e) {
                      return e.length > 2;
                    }),
                  en = $e.beamShape
                    ? $e.beamShape.map(function (e) {
                        var t = e[0],
                          n = e[1];
                        return new r.Vector3(t, n, 0);
                      })
                    : this.default.beamShape,
                  tn = $e.parallelBeamShape
                    ? $e.parallelBeamShape.map(function (e) {
                        var t = e[0],
                          n = e[1];
                        return new r.Vector3(t, n, 0);
                      })
                    : en,
                  nn = $e.ribBeamShape
                    ? $e.ribBeamShape.map(function (e) {
                        var t = e[0],
                          n = e[1];
                        return new r.Vector3(t, n, 0);
                      })
                    : en,
                  rn = $e.topBeamShape
                    ? $e.topBeamShape.map(function (e) {
                        var t = e[0],
                          n = e[1];
                        return new r.Vector3(t, n, 0);
                      })
                    : en,
                  on = $e.bottomBeamShape
                    ? $e.bottomBeamShape.map(function (e) {
                        var t = e[0],
                          n = e[1];
                        return new r.Vector3(t, n, 0);
                      })
                    : en,
                  an = {
                    parallelBeamIntervalBuilder: new yt()
                      .withMaxWidth($t)
                      .withoutBorders(),
                    splitBeamIntervalBuilder: new yt()
                      .withMaxWidth(2 * $t)
                      .withoutBorders(),
                    glassMaterial:
                      this.materials[$e.glassMaterialId || "glass"] ||
                      this.materials.glass,
                    beamMaterial: a,
                  };
                Qt.forEach(function (e, t) {
                  if (
                    3 ===
                      (e = e.map(function (e) {
                        return e.clone();
                      })).length &&
                    e[0].distanceTo(e[1]) <
                      0.8 *
                        Math.min(e[0].distanceTo(e[2]), e[1].distanceTo(e[2]))
                  ) {
                    var n = s.beamsToLastPointOverTriangle(
                      "edge " + t,
                      an.beamMaterial,
                      e[0],
                      e[1],
                      e[2],
                      an.splitBeamIntervalBuilder,
                      tn
                    );
                    Kt.add(n);
                  } else (n = s.parallelBeamsOverPoly("edge " + t, an.beamMaterial, e, 0, an.parallelBeamIntervalBuilder, tn)), Kt.add(n);
                  var i = s.polygonGeometry(e);
                  Kt.add(new r.Mesh(i, an.glassMaterial));
                });
                var sn = new r.Vector3(0, 1, 0),
                  ln = function (e, t) {
                    var n = e.map(function (e) {
                        var t = e.v2.clone().sub(e.v1).normalize(),
                          n = t.clone().multiplyScalar(3),
                          i = e.v1.clone().sub(n),
                          o = e.v2.clone().add(n),
                          a = t.clone().cross(sn).normalize();
                        return (
                          a.manhattanLength() < 0.1 &&
                            (a = new r.Vector3(0, 0, 1).cross(sn)),
                          {
                            v1: i,
                            v2: o,
                            v1Normal: a,
                            v2Normal: a,
                          }
                        );
                      }),
                      i = s.extrudeEdges("edges", an.beamMaterial, n, t);
                    Kt.add(i);
                  };
                ln(
                  Zt.slice(1).map(function (e, t) {
                    return {
                      v1: Zt[t],
                      v2: e,
                    };
                  }),
                  rn
                );
                var cn = Yt.map(function (e, t) {
                  return {
                    v1: e,
                    v2: Zt[t],
                  };
                });
                ln(cn.slice(0, 1), nn),
                  ln(
                    cn.slice(1, -1),
                    tn.map(function (e) {
                      return new r.Vector3(e.y, -e.x, e.z);
                    })
                  ),
                  ln(
                    cn.slice(-1),
                    nn
                      .map(function (e) {
                        return new r.Vector3(-e.x, e.y, e.z);
                      })
                      .reverse()
                  ),
                  ln(
                    Yt.slice(1).map(function (e, t) {
                      return {
                        v1: Yt[t],
                        v2: e,
                        beamShape: en,
                      };
                    }),
                    on
                  ),
                  (Kt.rotation.x = -Math.PI / 2),
                  l.push([Kt]);
            }
            var un = this.compose(e, l);
            if (n && (n.rotation || n.position || n.scale)) {
              var hn = new r.Object3D();
              (hn.name = un.name),
                hn.add(un),
                (un.name += " wrapped"),
                n.rotation && un.rotation.fromArray(n.rotation),
                n.position && un.position.fromArray(n.position),
                n.scale && un.scale.fromArray(n.scale),
                (un = hn);
            }
            if ((n && n.swapUV && this.swapUV(un), n && n.children)) {
              var dn = function (e, t, n, r, i) {
                return (
                  void 0 === t && (t = e),
                  void 0 === n && (n = e),
                  t <= 0 ? (t += r) : (t = e),
                  n <= 0 ? (n += r) : (n = e),
                  e != t && e != n && (e = Math.round(e / i) * i),
                  Math.min(n, Math.max(t, e))
                );
              };
              (n = b).children.forEach(function (e, t) {
                var r,
                  l,
                  c = Object.assign({}, n);
                (c.children = []),
                  ((c = Object.assign(c, e)).width = dn(
                    e.width || n.width,
                    e.minWidth,
                    e.maxWidth,
                    n.width,
                    null !== (r = e.resizeStepSize) && void 0 !== r ? r : 1
                  )),
                  (c.height = dn(
                    e.height || n.height,
                    e.minHeight,
                    e.maxHeight,
                    n.height,
                    null !== (l = e.resizeStepSize) && void 0 !== l ? l : 1
                  ));
                var u = s.buildElementInternal(
                  n.id + c.id,
                  c.elementType,
                  c,
                  i,
                  o,
                  a
                );
                un.add(u);
              });
            }
            return un;
          }),
          (t.prototype.checkLineIntersection = function (
            e,
            t,
            n,
            r,
            i,
            o,
            a,
            s
          ) {
            var l,
              c,
              u,
              h,
              d = {
                x: null,
                y: null,
                onLine1: !1,
                onLine2: !1,
              };
            return (
              0 == (l = (s - o) * (n - e) - (a - i) * (r - t)) ||
                ((h = (n - e) * (c = t - o) - (r - t) * (u = e - i)),
                (c = ((a - i) * c - (s - o) * u) / l),
                (u = h / l),
                (d.x = e + c * (n - e)),
                (d.y = t + c * (r - t)),
                c > 0 && c < 1 && (d.onLine1 = !0),
                u > 0 && u < 1 && (d.onLine2 = !0)),
              d
            );
          }),
          (t.prototype.extrudeShapeOnYPlaneNew = function (e, t, n, i, o) {
            var a = this,
              s = i.slice(0);
            s.unshift(s.pop());
            var l = i.map(function (e, t) {
                var n = s[t],
                  r = n.clone().sub(e).normalize(),
                  i = r.x;
                return (
                  (r.x = -r.y),
                  (r.y = i),
                  {
                    vl: e.clone(),
                    vr: n.clone(),
                    i: t,
                    n: r,
                  }
                );
              }),
              c = n.map(function (e, t) {
                var n = l.map(function (t, n) {
                    var r = t.n.clone().multiplyScalar(e.x);
                    return (
                      (r.z -= e.y),
                      {
                        vl: t.vl.clone().add(r),
                        vr: t.vr.clone().add(r),
                      }
                    );
                  }),
                  i = n.slice(0);
                return (
                  i.unshift(i.pop()),
                  n.reduce(function (e, t, n) {
                    var o = i[n],
                      s = a.checkLineIntersection(
                        t.vl.x,
                        t.vl.y,
                        t.vr.x,
                        t.vr.y,
                        o.vl.x,
                        o.vl.y,
                        o.vr.x,
                        o.vr.y
                      );
                    return (
                      null !== s.x &&
                        null !== s.y &&
                        e.push(new r.Vector3(s.x, s.y, t.vl.z)),
                      e
                    );
                  }, [])
                );
              }),
              u = new Float32Array(i.length * n.length * 2 * 3 * 3),
              h = new Float32Array(i.length * n.length * 2 * 3 * 3),
              d = new Float32Array(i.length * n.length * 2 * 2 * 3),
              p = 0,
              f = 0,
              m = 0,
              g = new r.Vector3(),
              v = new r.Vector3(),
              y = n.map(function (e, t, n) {
                return 0 == t ? 0 : n[t - 1].distanceTo(e);
              }),
              x = i.map(function (e, t, n) {
                return 0 == t ? 0 : n[t - 1].distanceTo(e);
              });
            c.forEach(function (e, t, n) {
              0 !== t &&
                e.forEach(function (e, r, i) {
                  var o = r - 1;
                  o < 0 && (o += i.length);
                  var a = n[t - 1][o],
                    s = y[t - 1],
                    l = x[o],
                    c = n[t - 1][r],
                    b = y[t - 1],
                    w = x[r],
                    _ = n[t][r],
                    M = y[t],
                    S = x[r],
                    T = n[t][o],
                    E = y[t],
                    A = x[o];
                  (u[p++] = a.x),
                    (u[p++] = a.y),
                    (u[p++] = a.z),
                    (d[m++] = s),
                    (d[m++] = l),
                    (u[p++] = _.x),
                    (u[p++] = _.y),
                    (u[p++] = _.z),
                    (d[m++] = M),
                    (d[m++] = S),
                    (u[p++] = c.x),
                    (u[p++] = c.y),
                    (u[p++] = c.z),
                    (d[m++] = b),
                    (d[m++] = w),
                    (u[p++] = _.x),
                    (u[p++] = _.y),
                    (u[p++] = _.z),
                    (d[m++] = M),
                    (d[m++] = S),
                    (u[p++] = a.x),
                    (u[p++] = a.y),
                    (u[p++] = a.z),
                    (d[m++] = s),
                    (d[m++] = l),
                    (u[p++] = T.x),
                    (u[p++] = T.y),
                    (u[p++] = T.z),
                    (d[m++] = E),
                    (d[m++] = A),
                    g.subVectors(a, c),
                    v.subVectors(_, c),
                    g.cross(v),
                    g.normalize();
                  for (var C = g.x, P = g.y, L = g.z, R = 0; R < 6; R++)
                    (h[f++] = C), (h[f++] = P), (h[f++] = L);
                });
            });
            var b = new r.BufferGeometry();
            (u = u.slice(0, p)),
              (h = h.slice(0, p)),
              b.setAttribute("position", new r.BufferAttribute(u, 3)),
              b.setAttribute("normal", new r.BufferAttribute(h, 3)),
              b.setAttribute("uv", new r.BufferAttribute(d, 2)),
              b.computeBoundingSphere(),
              b.computeBoundingBox(),
              this.computeFaceNormals(b);
            var w = new r.Mesh(b, t);
            return (w.name = e), w;
          }),
          t
        );
      })(vt)),
      (dt.ElementBuilder = pt);
    var xt,
      bt,
      wt,
      _t,
      Mt,
      St,
      Tt = n(4);
    (bt = xt || (xt = {})),
      (wt = new r.Vector3(0, 1, 0)),
      (_t = new r.Vector3()),
      (Mt = {
        v1: _t,
        v2: _t,
        side: _t,
        up: _t,
        out: _t,
        name: "nullVect",
      }),
      (St = (function () {
        function e(e, t, n) {
          if (
            ((this.verts = []),
            (this.vertOutwardDirections = []),
            (this.isClosed = !0),
            (this.edges = []),
            (this.normal = new r.Vector3()),
            (this.localMatrix = new r.Matrix4()),
            (this.verts = e.slice(0)),
            !(this.verts.length < 2))
          ) {
            this.verts.length > 2 &&
            this.verts[this.verts.length - 1].distanceToSquared(this.verts[0]) <
              16
              ? ((this.isClosed = !0), this.verts.pop())
              : (this.isClosed = t || !1);
            var i = this.verts.slice(0),
              o = this.verts.slice(0);
            if (
              (this.isClosed ? o.unshift(o.pop()) : (i.pop(), o.shift()),
              this.verts.length < 3)
            )
              this.normal = wt;
            else {
              var a = this.verts,
                s = a[0],
                l = a[1],
                c = a[2];
              this.normal = l
                .clone()
                .sub(s)
                .cross(c.clone().sub(l))
                .normalize()
                .negate();
            }
            this.edges = i.map(function (e, t) {
              var r = o[t],
                i = r.clone().sub(e).normalize(),
                a = this.normal,
                s = i.clone().cross(a);
              return {
                v1: e,
                v2: r,
                side: i,
                up: a,
                out: s,
                name: n ? n[t] : null,
              };
            }, this);
            var u = this.edges.slice(0),
              h = this.edges.slice(0);
            this.isClosed ? u.push(u.shift()) : (u.unshift(Mt), h.push(Mt)),
              (this.vertOutwardDirections = u.map(function (e, t) {
                var n = h[t];
                return e.out.clone().add(n.out);
              }));
            var d = this.verts
                .reduce(function (e, t) {
                  return e.add(t);
                }, new r.Vector3())
                .divideScalar(this.verts.length),
              p = this.normal,
              f = this.edges[0].v1.clone().sub(this.edges[0].v2).normalize(),
              m = p.clone().cross(f);
            (this.localMatrix = new r.Matrix4().makeBasis(f, m, p)),
              this.localMatrix.setPosition(d);
          }
        }
        return (
          (e.prototype.move = function (e) {
            var t = this.verts.map(function (t) {
              return t.clone().add(e);
            }, this);
            return new bt.Shape(
              t,
              this.isClosed,
              this.edges.map(function (e) {
                return e.name;
              })
            );
          }),
          (e.prototype.checkLineIntersection = function (
            e,
            t,
            n,
            r,
            i,
            o,
            a,
            s
          ) {
            var l,
              c,
              u,
              h,
              d = {
                x: null,
                y: null,
                onLine1: !1,
                onLine2: !1,
              };
            return (
              0 == (l = (s - o) * (n - e) - (a - i) * (r - t)) ||
                ((h = (n - e) * (c = t - o) - (r - t) * (u = e - i)),
                (c = ((a - i) * c - (s - o) * u) / l),
                (u = h / l),
                (d.x = e + c * (n - e)),
                (d.y = t + c * (r - t)),
                c > 0 && c < 1 && (d.onLine1 = !0),
                u > 0 && u < 1 && (d.onLine2 = !0)),
              d
            );
          }),
          (e.prototype.expand = function (t) {
            var n = this;
            if (this.verts.length < 2) return new e(this.verts, this.isClosed);
            var i = this.edges
              .filter(function (e) {
                return e.v1.manhattanDistanceTo(e.v2) > 1;
              })
              .map(function (e) {
                var n = e.out.clone().normalize().multiplyScalar(t.x);
                return {
                  v1: e.v1.clone().add(n),
                  v2: e.v2.clone().add(n),
                  name: e.name,
                };
              })
              .map(function (e, i, o) {
                if (!n.isClosed && (0 == i || i === o.length - 1))
                  return {
                    v: e.v1,
                    i: i,
                    name: e.name,
                    isDefined: !0,
                  };
                var a = o[(i || o.length) - 1],
                  s = n.checkLineIntersection(
                    e.v1.x,
                    e.v1.y,
                    e.v2.x,
                    e.v2.y,
                    a.v1.x,
                    a.v1.y,
                    a.v2.x,
                    a.v2.y
                  );
                return {
                  v: new r.Vector3(s.x, s.y, t.y),
                  name: e.name,
                  i: i,
                };
              });
            return (
              i.unshift(i.pop()),
              i.length && void 0 === i[0]
                ? new bt.Shape([], this.isClosed, [])
                : new bt.Shape(
                    i.map(function (e) {
                      return e.v;
                    }),
                    this.isClosed,
                    i.map(function (e) {
                      return e.name;
                    })
                  )
            );
          }),
          (e.prototype.joinUp = function (e) {
            if (this.verts.length < 2) return [];
            console.assert(this.edges.length === e.edges.length),
              console.assert(this.isClosed === e.isClosed);
            var t = this.edges,
              n = e.edges;
            return t.map(function (e, t) {
              var r = n[t],
                i = [r.v2, e.v2, e.v1, r.v1];
              return new bt.Shape(i, !0).withName(e.name);
            });
          }),
          (e.prototype.withName = function (e) {
            return (this.name = e), this;
          }),
          (e.prototype.extrudePath = function (e) {
            var t = this;
            return e.length < 2 || this.verts.length < 2
              ? []
              : e
                  .map(function (e) {
                    return t.expand(e);
                  }, this)
                  .reduce(function (e, t, n, r) {
                    return n > 0 && (e = e.concat(r[n - 1].joinUp(t))), e;
                  }, []);
          }),
          (e.prototype.normalizeVerticesZUp = function () {
            if (!(this.verts.length < 2)) {
              var e = new r.Matrix4().copy(this.localMatrix).invert(),
                t = this.verts.map(function (t) {
                  return t.applyMatrix4(e);
                });
              return new bt.Shape(
                t,
                this.isClosed,
                this.edges.map(function (e) {
                  return e.name;
                })
              );
            }
          }),
          e
        );
      })()),
      (bt.Shape = St);
    var Et,
      At,
      Ct,
      Pt,
      Lt = function () {
        for (var e = 0, t = 0, n = arguments.length; t < n; t++)
          e += arguments[t].length;
        var r = Array(e),
          i = 0;
        for (t = 0; t < n; t++)
          for (var o = arguments[t], a = 0, s = o.length; a < s; a++, i++)
            r[i] = o[a];
        return r;
      },
      Rt = Tt.a.getRalDict();
    (At = Et || (Et = {})),
      (Ct = (function () {
        function e() {
          (this.obj = new r.Object3D()),
            (this.dropTargets = []),
            (this.dropped = []),
            (this.actionableObjects = []);
        }
        return (
          (e.prototype.add = function (e) {
            var t = e.obj.position.clone();
            this.obj.add(e.obj);
            var n = this.obj.worldToLocal(t);
            return (
              e.obj.position.copy(n),
              (this.dropTargets = this.dropTargets.concat(e.dropTargets)),
              (this.dropped = this.dropped.concat(e.dropped)),
              (this.actionableObjects = this.actionableObjects.concat(
                e.actionableObjects
              )),
              this
            );
          }),
          e
        );
      })()),
      (Pt = (function () {
        function e(e, t) {
          (this.textures = []),
            (this.cachedPanoMaterials = {}),
            (this.panoCenterMesh = new r.Mesh(
              new r.SphereBufferGeometry(15),
              new r.MeshBasicMaterial({
                color: 8978312,
              })
            )),
            (this.previousDraggableElements = null),
            (this.previousDraggableInput = "abc"),
            (this.pngRenderContext = null),
            (this.configGenerator = null),
            (this.boxToVertices = function (e) {
              return [
                new r.Vector2(e.min.x, e.min.y),
                new r.Vector2(e.max.x, e.min.y),
                new r.Vector2(e.max.x, e.max.y),
                new r.Vector2(e.min.x, e.max.y),
              ];
            }),
            (this.materials = t),
            (this.elementBuilder = new ht.ElementBuilder(e, t));
        }
        return (
          (e.prototype.loadTexturesAndMaterial = function (e, t) {
            var n = this;
            (e = this.parseConfiguration(e, t)).textures.forEach(function (e) {
              return n.loadTexture(e);
            }),
              e.materials.forEach(function (e) {
                return n.loadMaterial(e);
              }),
              e.elements
                .filter(function (e) {
                  return e && "meshFromFile" === e.elementType;
                })
                .forEach(function (t) {
                  n.elementBuilder.buildElement(
                    t.id,
                    t.elementType,
                    t,
                    e,
                    0,
                    new r.MeshBasicMaterial()
                  );
                });
          }),
          (e.prototype.notNull = function (e, t) {
            return e || console.error("missing lookup: " + t), e;
          }),
          (e.prototype.build = function (e, t, n, i) {
            var o = this;
            void 0 === i && (i = []), (t = this.parseConfiguration(t, n));
            var a = this.notNull(
              t.models.filter(function (t) {
                return t.id === e;
              })[0],
              "model." + e
            );
            return (
              t.textures.forEach(function (e) {
                return o.loadTexture(e);
              }),
              t.materials.forEach(function (e) {
                return o.loadMaterial(e);
              }),
              a.buildSteps.reduce(
                function (e, n) {
                  if (n.disabled) return e;
                  try {
                    if (n.cloneStepWithName) {
                      var o = this.notNull(
                        a.buildSteps.filter(function (e) {
                          return e.name === n.cloneStepWithName;
                        })[0],
                        "buildstep.name = " + n.cloneStepWithName
                      );
                      n = Object.assign({}, o, n);
                    }
                    var s;
                    switch (n.type) {
                      case "siding":
                        s = this.buildSiding(
                          this.notNull(
                            t.sidings.filter(function (e) {
                              return e.id === n.id;
                            })[0],
                            "siding.id =" + n.id
                          ),
                          t
                        );
                        break;
                      case "plane":
                        s = this.buildPlane(
                          this.notNull(
                            t.planes.filter(function (e) {
                              return e.id === n.id;
                            })[0],
                            "planes.id =" + n.id
                          ),
                          t
                        );
                        break;
                      case "element":
                        s = this.buildElement(
                          this.notNull(
                            t.elements.filter(function (e) {
                              return e && e.id === n.id;
                            })[0],
                            "elements.id = " + n.id
                          ),
                          t,
                          0,
                          i
                        );
                        break;
                      case "placeholder":
                        s = new Ct();
                        break;
                      case "panos":
                        s = this.buildPanos(t.panos);
                        break;
                      default:
                        throw "unknown build step type: " + n.type;
                    }
                    s &&
                      s.obj &&
                      (s.obj.rotateX(Math.PI / 2),
                      (s.obj.position.y -= 200),
                      (s.obj.name = n.name),
                      n.position &&
                        s.obj.position.add(
                          new r.Vector3().fromArray(n.position)
                        ),
                      n.rotation &&
                        ((s.obj.rotation.x += n.rotation[0]),
                        (s.obj.rotation.y += n.rotation[1]),
                        (s.obj.rotation.z += n.rotation[2])),
                      n.scale && s.obj.scale.fromArray(n.scale),
                      void 0 !== n.visible && (s.obj.visible = n.visible),
                      i.some(function (e) {
                        return e == n.name;
                      }) && s.actionableObjects.push(s.obj),
                      e.add(s));
                  } catch (e) {
                    console.warn(
                      "unable to build the following step: \n" +
                        JSON.stringify(n, null, 2) +
                        "\n" +
                        e
                    );
                  }
                  return e;
                }.bind(this),
                new Ct()
              )
            );
          }),
          (e.prototype.loadTexture = function (e) {
            if (
              !this.textures.filter(function (t) {
                return t.name === e.id;
              }).length
            ) {
              var t = new r.TextureLoader()
                .setPath(contentRoute)
                .load(e.imageUrl);
              (t.name = e.id),
                (t.wrapS = t.wrapT = r.RepeatWrapping),
                e.repeat
                  ? t.repeat.set(e.repeat.x, e.repeat.y)
                  : t.repeat.set(0.01, 0.01),
                e.offset && t.offset.set(e.offset.x, e.offset.y),
                e.wrap &&
                  ((t.wrapS = e.wrap.x
                    ? r.MirroredRepeatWrapping
                    : r.RepeatWrapping),
                  (t.wrapT = e.wrap.y
                    ? r.MirroredRepeatWrapping
                    : r.RepeatWrapping)),
                (t.name = e.id),
                this.textures.push(t);
            }
          }),
          (e.prototype.loadPanoMaterials = function (e) {
            var t = this,
              n = {};
            return (
              e.forEach(function (e) {
                if (t.cachedPanoMaterials[e]) n[e] = t.cachedPanoMaterials[e];
                else {
                  var i = new r.MeshBasicMaterial(),
                    o = new r.TextureLoader().load(e, function () {
                      (i.map = o), (i.needsUpdate = !0);
                    });
                  n[e] = i;
                }
              }),
              (this.cachedPanoMaterials = n),
              this.cachedPanoMaterials
            );
          }),
          (e.prototype.buildPanos = function (e) {
            var t = this;
            (this.panoCenterMesh.material.depthTest = !1),
              (this.panoCenterMesh.material.transparent = !0),
              (this.panoCenterMesh.position.z = 85);
            var n = this.loadPanoMaterials(
                e.map(function (e) {
                  return e.url;
                })
              ),
              i = new r.SphereBufferGeometry(1, 50, 25),
              o = new r.Object3D();
            (o.name = "panos"),
              e.forEach(function (e) {
                var a = new r.Mesh(i, n[e.url]);
                (a.name = "noshading"),
                  (a.rotation.x -= Math.PI / 2),
                  (a.rotation.y += -e.rotation * Math.PI * 2),
                  a.scale.setScalar(100),
                  (a.scale.x *= -1);
                var s = new r.Object3D();
                s.position.fromArray(e.position),
                  (s.position.z *= -230),
                  (a.position.z -= (e.camHeight || 145) - 100),
                  (s.name = e.label),
                  s.add(a),
                  s.add(t.panoCenterMesh.clone()),
                  o.add(s);
              });
            var a = new Ct();
            return (a.obj = o), a;
          }),
          (e.prototype.loadMaterial = function (e) {
            var t,
              n = this,
              i = function (e, t) {
                return new Number(e) == e ? e : t;
              },
              o = function (e) {
                return n.notNull(
                  n.textures.filter(function (t) {
                    return t.name === e;
                  })[0],
                  "textures.name = " + e
                );
              },
              a = {
                name: e.id,
                color: e.colorRAL
                  ? Rt.getHexColor(e.colorRAL)
                  : i(e.colorHex, 16777215),
                roughness: i(e.roughness, 0.5),
                metalness: i(e.metalness, 0.5),
              };
            e.transparent && (a.transparent = !0),
              e.opacity && ((a.transparent = !0), (a.opacity = e.opacity)),
              e.useEnvMap && (a.envMap = this.materials.environmentSphere.map),
              e.map && (a.map = o(e.map.textureId)),
              e.bump &&
                ((a.bumpMap = o(e.bump.textureId)),
                (a.bumpScale = i(e.bump.bumpScale, 0.5))),
              e.emissiveColorHex &&
                (a.emissive = new r.Color(e.emissiveColorHex)),
              e.emissiveIntensity &&
                (a.emissiveIntensity = e.emissiveIntensity),
              "visible" in e && (a.visible = e.visible),
              e.noShading
                ? (delete a.roughness,
                  delete a.metalness,
                  (t = new r.MeshBasicMaterial(a)))
                : (t = new r.MeshStandardMaterial(a)),
              this.materials[e.id]
                ? (this.materials[e.id].copy(t),
                  (this.materials[e.id].needsUpdate = !0))
                : (this.materials[e.id] = t);
          }),
          (e.prototype.buildElement = function (e, t, n, i) {
            if (e) {
              var o = new Ct();
              return (
                (o.obj = this.elementBuilder.buildElement(
                  e.id,
                  e.elementType,
                  e,
                  t,
                  n,
                  new r.MeshBasicMaterial()
                )),
                o.obj &&
                  i &&
                  o.obj.traverse(function (e) {
                    i.some(function (t) {
                      return t === e.name;
                    }) && o.actionableObjects.push(e);
                  }),
                o
              );
            }
          }),
          (e.prototype.buildDraggableElements = function (e, t, n, i) {
            var o = this,
              a = Object.assign({}, n.$data),
              s = JSON.stringify(a) + e.join("$$$$");
            return (
              (null != this.previousDraggableElements &&
                this.previousDraggableInput == s) ||
                ((this.previousDraggableInput = s),
                (t = this.parseConfiguration(t, n)),
                (this.previousDraggableElements = t.draggableElements
                  .filter(function (e) {
                    return !!e;
                  })
                  .filter(function (n) {
                    return (
                      (n.allowedDropTargets === [] ||
                        n.allowedDropTargets.some(function (t) {
                          return e.indexOf(t) > -1;
                        })) &&
                      t.elements.find(function (e) {
                        return (null == e ? void 0 : e.id) === n.elementId;
                      })
                    );
                  })
                  .map(function (e) {
                    var n = Object.assign(
                        {},
                        t.elements.filter(function (t) {
                          return t && t.id === e.elementId;
                        })[0]
                      ),
                      a = o.buildElement(n, t, 0, i).obj,
                      s = new r.Box3().setFromCenterAndSize(
                        new r.Vector3(0, 0, 0),
                        new r.Vector3(n.width, n.height, 0)
                      ),
                      l = new Ce.IntersectableObject(
                        a,
                        null,
                        s,
                        null,
                        null,
                        n.asDropTargetUniqueId
                      );
                    return (
                      (l.mesh.visible = !1),
                      {
                        allowedDropTargets: e.allowedDropTargets,
                        elementId: l.object.name,
                        category: e.category,
                        extendDropArea: e.extendDropArea,
                        id: l.object.name,
                        intersectable: l,
                        originalScale: a.scale,
                        screenScale: e.screenScale || 0.005,
                        screenPosition: new r.Vector2(0, 0),
                        shouldClone: !0,
                        width: n.width,
                        minWidth: void 0 === n.minWidth ? n.width : n.minWidth,
                        maxWidth: void 0 === n.maxWidth ? n.width : n.maxWidth,
                        height: n.height,
                        minHeight:
                          void 0 === n.minHeight ? n.height : n.minHeight,
                        maxHeight:
                          void 0 === n.maxHeight ? n.height : n.maxHeight,
                        resizeStepSize: n.resizeStepSize,
                        originalBoundingBox: new r.Box2().setFromCenterAndSize(
                          l.object.position,
                          l.localBoundingBox.getSize(new r.Vector2())
                        ),
                        opts: n.opts,
                        windowOpts: (n.window && n.window.opts) || {},
                        float: !!n.float,
                        useMaterialFromDropTarget: e.useMaterialFromDropTarget,
                        asDropTargetId: n.asDropTargetId,
                        asDropTargetUniqueId: null,
                        renderImage: n.renderImage,
                      }
                    );
                  }))),
              this.previousDraggableElements
            );
          }),
          (e.prototype.renderToPng = function (e, t, n, i) {
            var o, a, s, l, c, u;
            if ((void 0 === n && (n = !1), (a = new r.Scene()).add(e), !i)) {
              var h = (i = new r.Box3().setFromObject(a))
                .getSize(new r.Vector3())
                .multiplyScalar(0.2);
              i.expandByVector(h);
            }
            return (
              (o = new r.OrthographicCamera(
                i.min.x,
                i.max.x,
                i.min.y,
                i.max.y,
                i.max.z,
                i.min.z
              )),
              (u = new r.DirectionalLight()).position.set(-100, 0, -100),
              a.add(o),
              a.add(u),
              a.updateMatrixWorld(!0),
              this.pngRenderContext ||
                (this.pngRenderContext = new r.WebGLRenderer({
                  alpha: !0,
                  preserveDrawingBuffer: !0,
                })),
              (s = i.max.x - i.min.x),
              (l = i.max.y - i.min.y),
              n && (s = l = Math.max(s, l)),
              (c = t / Math.max(s, l)),
              this.pngRenderContext.setSize(s * c, l * c),
              this.pngRenderContext.render(a, o),
              this.pngRenderContext.domElement.toDataURL("image/png")
            );
          }),
          (e.prototype.buildGlassDecorationBBoxes = function (e, t, n) {
            return this.elementBuilder.buildGlassDecorationBBoxes(e, t, n);
          }),
          (e.prototype.evalFormula = function (e, t) {
            var n = Array.isArray(t) ? t.join("\n") : t;
            return Function.apply(null, e.concat("return " + n));
          }),
          (e.prototype.resetConfigurationParser = function () {
            this.configGenerator = null;
          }),
          (e.prototype.parseConfiguration = function (e, t) {
            if (!this.configGenerator) {
              var n = "with (__q) {\n";
              (n +=
                e.vars
                  .map(function (t) {
                    var n = Array.isArray(t.formula)
                      ? t.formula.join("\n")
                      : t.formula;
                    return e.$data
                      ? 'q.$set("vars.' +
                          t.id +
                          '",vars["' +
                          t.id +
                          '"] =(' +
                          n +
                          ")(__q))"
                      : '(vars["' + t.id + '"] =(' + n + ")(__q))";
                  })
                  .join(",") + ";"),
                (n += "return " + this.createGenerator(e, ["builder"])),
                (n += "}"),
                (this.configGenerator =
                  this.configGenerator || new Function("__q", n));
            }
            var r = this.configGenerator(t);
            return (
              r.vars
                .filter(function (e) {
                  return "updateConfiguration" == e.id;
                })
                .map(function (e) {
                  var n = e.formula;
                  new Function("__q", "return (" + n + ")(__q)")(r.vars)(t, r);
                }),
              r
            );
          }),
          (e.prototype.createGenerator = function (e, t) {
            var n = this;
            try {
              switch (!0) {
                case Array.isArray(e):
                  return (
                    "[" +
                    e
                      .map(function (e, r) {
                        return n.createGenerator(
                          e,
                          Lt(t, ["[" + (e.id ? r + ":" + e.id : r) + "]"])
                        );
                      })
                      .join(",") +
                    "]"
                  );
                case e instanceof Object:
                  return (
                    "{" +
                    Object.keys(e)
                      .map(function (r) {
                        return (
                          '"' +
                          r +
                          '":' +
                          n.createGenerator(e[r], Lt(t, ["[" + r + "]"]))
                        );
                      })
                      .join(",") +
                    "}"
                  );
                case "string" == typeof e && 0 === e.indexOf("$"):
                  var r = "(" + e.substring(1) + ")";
                  return 1 == r.indexOf("function") ? r + "(__q)" : r;
                default:
                  return JSON.stringify(e, null, 2);
              }
            } catch (n) {
              throw (
                (console.error("error parsing configuration template:", {
                  configurationTemplate: e,
                  path: t.join(""),
                }),
                n)
              );
            }
          }),
          (e.prototype.buildShape = function (e) {
            try {
              var t;
              if (e.turtle)
                t = e.turtle.reduce(
                  function (e, t, n, i) {
                    switch (t.op) {
                      case "move":
                        var o = (t.parameter || 1) * e.scale;
                        e.position.add(e.direction.clone().multiplyScalar(o));
                        break;
                      case "scale":
                        e.scale = t.parameter || 1;
                        break;
                      case "turn":
                        var a;
                        switch (t.parameter) {
                          case "left":
                            a = -90;
                            break;
                          case "right":
                            a = 90;
                            break;
                          case "back":
                            a = 180;
                            break;
                          default:
                            a = parseFloat(t.parameter);
                        }
                        (a *= Math.PI / 180),
                          e.direction.applyAxisAngle(new r.Vector3(0, 0, 1), a);
                        break;
                      case "label":
                        e.vertices.push(e.position.clone()),
                          e.edgeNames.push(t.parameter);
                        break;
                      default:
                        console.error("unknown step type", t);
                    }
                    return n === i.length - 1 && e.vertices.push(e.position), e;
                  }.bind(this),
                  {
                    position: new r.Vector3(0, 0, 0),
                    direction: new r.Vector3(0, 1, 0),
                    scale: 1,
                    vertices: [],
                    edgeNames: [],
                  }
                );
              else {
                if (!e.vertices)
                  throw "need at least a turtle or vertices for shape";
                t = {
                  vertices: [],
                  edgeNames: [],
                };
                for (var n = e.vertices, i = 0; i < e.vertices.length; i++)
                  t.vertices.push(new r.Vector3(n[i][0], n[i][1], 0)),
                    t.edgeNames.push(e.id + " edge " + i);
                t.vertices.push(t.vertices[0].clone()),
                  t.edgeNames.push(e.id + " edge " + i);
              }
              e.offset &&
                t.vertices.forEach(function (t) {
                  (t.x += e.offset[0]), (t.y += e.offset[1]);
                }),
                e.flip &&
                  t.vertices.forEach(function (t) {
                    (t.x *= e.flip.x ? -1 : 1), (t.y *= e.flip.y ? -1 : 1);
                  });
              var o = new xt.Shape(t.vertices, !1, t.edgeNames);
              return (
                o.normal.z > 0 &&
                  (o = new xt.Shape(
                    o.verts.slice(0).reverse(),
                    o.isClosed,
                    o.edges
                      .map(function (e) {
                        return e.name;
                      })
                      .reverse()
                  )),
                o
              );
            } catch (t) {
              throw (
                (console.warn(
                  "unable to build the following shape: \n" +
                    JSON.stringify(e, null, 2) +
                    "\n" +
                    t
                ),
                t)
              );
            }
          }),
          (e.prototype.buildBorder = function (e, t, n) {
            var i = this.notNull(
                n.shapes.filter(function (e) {
                  return e.id === t.borderShapeId;
                })[0],
                "shapes.id = " + t.borderShapeId
              ),
              o = this.buildShape(i);
            if (t.offset) {
              var a = new r.Vector3(t.offset.x, t.offset.y, 0);
              o.verts.forEach(function (e) {
                return e.add(a);
              });
            }
            var s = this.materials[t.materialId];
            return this.extrudeShapeOnYPlane(
              t.borderShapeId,
              s,
              o.verts,
              e.verts,
              !e.isClosed
            );
          }),
          (e.prototype.checkLineIntersection = function (
            e,
            t,
            n,
            r,
            i,
            o,
            a,
            s
          ) {
            var l,
              c,
              u,
              h,
              d = {
                x: null,
                y: null,
                onLine1: !1,
                onLine2: !1,
              };
            return (
              0 == (l = (s - o) * (n - e) - (a - i) * (r - t)) ||
                ((h = (n - e) * (c = t - o) - (r - t) * (u = e - i)),
                (c = ((a - i) * c - (s - o) * u) / l),
                (u = h / l),
                (d.x = e + c * (n - e)),
                (d.y = t + c * (r - t)),
                c > 0 && c < 1 && (d.onLine1 = !0),
                u > 0 && u < 1 && (d.onLine2 = !0)),
              d
            );
          }),
          (e.prototype.extrudeShapeOnYPlane = function (e, t, n, i, o) {
            var a = this,
              s = i.slice(0);
            s.unshift(s.pop());
            var l = i.map(function (e, t) {
                var n = s[t],
                  r = n.clone().sub(e).normalize(),
                  i = r.x;
                return (
                  (r.x = -r.y),
                  (r.y = i),
                  {
                    vl: e.clone(),
                    vr: n.clone(),
                    i: t,
                    n: r,
                  }
                );
              }),
              c = n.map(function (e, t) {
                var n = l.map(function (t, n) {
                    var r = t.n.clone().multiplyScalar(e.x);
                    return (
                      (r.z -= e.y),
                      {
                        vl: t.vl.clone().add(r),
                        vr: t.vr.clone().add(r),
                      }
                    );
                  }),
                  i = n.slice(0);
                return (
                  i.unshift(i.pop()),
                  n.reduce(function (e, t, n) {
                    var o = i[n],
                      s = a.checkLineIntersection(
                        t.vl.x,
                        t.vl.y,
                        t.vr.x,
                        t.vr.y,
                        o.vl.x,
                        o.vl.y,
                        o.vr.x,
                        o.vr.y
                      );
                    return (
                      null !== s.x &&
                        null !== s.y &&
                        e.push(new r.Vector3(s.x, s.y, t.vl.z)),
                      e
                    );
                  }, [])
                );
              }),
              u = new Float32Array(i.length * n.length * 2 * 3 * 3),
              h = new Float32Array(i.length * n.length * 2 * 3 * 3),
              d = new Float32Array(i.length * n.length * 2 * 2 * 3),
              p = 0,
              f = 0,
              m = 0,
              g = new r.Vector3(),
              v = new r.Vector3(),
              y = n.map(function (e, t, n) {
                return 0 == t ? 0 : n[t - 1].distanceTo(e);
              }),
              x = i.map(function (e, t, n) {
                return 0 == t ? 0 : n[t - 1].distanceTo(e);
              });
            c.forEach(function (e, t, n) {
              0 !== t &&
                e.forEach(function (e, r, i) {
                  var o = r - 1;
                  o < 0 && (o += i.length);
                  var a = n[t - 1][o],
                    s = y[t - 1],
                    l = x[o],
                    c = n[t - 1][r],
                    b = y[t - 1],
                    w = x[r],
                    _ = n[t][r],
                    M = y[t],
                    S = x[r],
                    T = n[t][o],
                    E = y[t],
                    A = x[o];
                  (u[p++] = a.x),
                    (u[p++] = a.y),
                    (u[p++] = a.z),
                    (d[m++] = s),
                    (d[m++] = l),
                    (u[p++] = _.x),
                    (u[p++] = _.y),
                    (u[p++] = _.z),
                    (d[m++] = M),
                    (d[m++] = S),
                    (u[p++] = c.x),
                    (u[p++] = c.y),
                    (u[p++] = c.z),
                    (d[m++] = b),
                    (d[m++] = w),
                    (u[p++] = _.x),
                    (u[p++] = _.y),
                    (u[p++] = _.z),
                    (d[m++] = M),
                    (d[m++] = S),
                    (u[p++] = a.x),
                    (u[p++] = a.y),
                    (u[p++] = a.z),
                    (d[m++] = s),
                    (d[m++] = l),
                    (u[p++] = T.x),
                    (u[p++] = T.y),
                    (u[p++] = T.z),
                    (d[m++] = E),
                    (d[m++] = A),
                    g.subVectors(a, c),
                    v.subVectors(_, c),
                    g.cross(v),
                    g.normalize();
                  for (var C = g.x, P = g.y, L = g.z, R = 0; R < 6; R++)
                    (h[f++] = C), (h[f++] = P), (h[f++] = L);
                });
            });
            var b = new r.BufferGeometry();
            (u = u.slice(0, p)),
              (h = h.slice(0, p)),
              b.setAttribute("position", new r.BufferAttribute(u, 3)),
              b.setAttribute("normal", new r.BufferAttribute(h, 3)),
              b.setAttribute("uv", new r.BufferAttribute(d, 2)),
              b.computeBoundingSphere();
            var w = new r.Mesh(b, t);
            return (w.name = e), w;
          }),
          (e.prototype.createDropTargetFromMesh = function (
            e,
            t,
            n,
            r,
            i,
            o,
            a
          ) {
            if (e) {
              var s = new Ce.IntersectableObject(t, e, r, i, o, a);
              return (s.intersectable.mesh.visible = !1), s;
            }
          }),
          (e.prototype.populateDropTargetWithElements = function (e, t, n) {
            var i = this,
              o = e.dropTargetId,
              a = e.intersectable.mesh,
              s = new r.Box3().setFromObject(a),
              l = new r.Box2(
                new r.Vector2(s.min.x, s.min.y),
                new r.Vector2(s.max.x, s.max.y)
              ),
              c = new r.Vector2();
            return (
              l.getSize(c),
              t.droppedElements
                .filter(function (t) {
                  return (
                    (t.allowedDropTargets === [] ||
                      t.allowedDropTargets.indexOf(o) > -1) &&
                    (t.droppedOnUniqueId
                      ? t.droppedOnUniqueId === e.asDropTargetUniqueId
                      : t.dropTargetName === a.parent.name)
                  );
                })
                .map(function (o) {
                  var s = new r.Vector2().fromArray(o.position || [0, 0]);
                  if (e.grid) {
                    var u = e.grid.filter(function (e) {
                      return e.containsPoint(s);
                    });
                    if (!u.length) return null;
                    (l = u[0]).getSize(c);
                  }
                  var h = i.notNull(
                      t.elements.filter(function (e) {
                        return e && e.id === o.elementId;
                      })[0],
                      "elements.id = " + o.elementId
                    ),
                    d = Object.assign({}, h);

                  function p(e, t, n, r, i) {
                    return (
                      t <= 0 && (t += r),
                      n <= 0 && (n += r),
                      Math.min(n, Math.max(t, e))
                    );
                  }
                  (d.minWidth = void 0 === d.minWidth ? d.width : d.minWidth),
                    (d.maxWidth = void 0 === d.maxWidth ? d.width : d.maxWidth),
                    (d.width = o.width || d.width),
                    (d.minHeight =
                      void 0 === d.minHeight ? d.height : d.minHeight),
                    (d.maxHeight =
                      void 0 === d.maxHeight ? d.height : d.maxHeight),
                    (d.height = o.height || d.height),
                    (d.height = p(
                      d.height,
                      d.minHeight,
                      d.maxHeight,
                      c.height,
                      d.resizeStepSize
                    )),
                    (d.width = p(
                      d.width,
                      d.minWidth,
                      d.maxWidth,
                      c.width,
                      d.resizeStepSize
                    )),
                    o.useMaterialFromDropTarget && (d.baseMaterialId = n);
                  var f = l
                    .clone()
                    .expandByVector(
                      new r.Vector2(d.width, d.height).divideScalar(-2)
                    );
                  f.isEmpty() ? f.getCenter(s) : f.clampPoint(s, s),
                    (d.opts = Object.assign({}, d.opts, o.opts)),
                    d.window &&
                      o.windowOpts &&
                      (d.window.opts = Object.assign(
                        {},
                        d.window.opts,
                        o.windowOpts
                      ));
                  var m = i.elementBuilder.buildElement(
                    "dropped " + o.elementId,
                    d.elementType,
                    d,
                    t,
                    0,
                    i.materials[n] || new r.MeshBasicMaterial()
                  );
                  m.position.set(s.x, s.y, 0),
                    m.rotation.fromArray(o.rotation || [0, 0, 0]);
                  var g = new r.Box3().setFromCenterAndSize(
                      new r.Vector3(0, 0, 0),
                      new r.Vector3(d.width, d.height, 0)
                    ),
                    v = new Ce.IntersectableObject(
                      m,
                      null,
                      g,
                      null,
                      null,
                      o.asDropTargetUniqueId
                    );
                  return (
                    a.parent.add(v.object),
                    {
                      id: "dropped " + d.id,
                      allowedDropTargets: o.allowedDropTargets,
                      droppableId: o.droppableId,
                      dropTargetId: o.dropTargetId,
                      dropTargetName: o.dropTargetName,
                      elementId: o.elementId,
                      extendDropArea: o.extendDropArea,
                      intersectable: v,
                      shouldClone: !1,
                      localBoundingBox: v.localBoundingBox,
                      position: o.position,
                      rotation: o.rotation,
                      screenScale: o.screenScale,
                      screenPosition: o.screenPosition,
                      originalScale: m.scale.clone(),
                      minWidth: d.minWidth,
                      maxWidth: d.maxWidth,
                      width: d.width,
                      minHeight: d.minHeight,
                      maxHeight: d.maxHeight,
                      resizeStepSize: d.resizeStepSize,
                      height: d.height,
                      originalBoundingBox: new r.Box2().setFromCenterAndSize(
                        new r.Vector2().fromArray(o.position),
                        v.localBoundingBox.getSize(new r.Vector2())
                      ),
                      opts: o.opts,
                      windowOpts: o.windowOpts,
                      float: !!o.float,
                      useMaterialFromDropTarget: o.useMaterialFromDropTarget,
                      asDropTargetId: d.asDropTargetId,
                      asDropTargetUniqueId: o.asDropTargetUniqueId,
                      droppedOnUniqueId: o.droppedOnUniqueId,
                    }
                  );
                })
                .filter(function (e) {
                  return !!e;
                })
            );
          }),
          (e.prototype.buildSiding = function (e, t) {
            var n = this,
              i = this.notNull(
                t.shapes.filter(function (t) {
                  return t.id === e.shapeId;
                })[0],
                "shapes.id = " + e.shapeId
              ),
              o = this.buildShape(i);
            o.normal.z > 0 && o.normal.negate();
            var a = new r.Vector2(0, 0);
            return o.edges.reduce(function (i, o, s) {
              var l = o.v1.distanceTo(o.v2);
              if (l < 1 || e.height <= 0) return i;
              var c = e.sides.filter(function (e) {
                return e.id === o.name;
              });
              if (!c.length) return i;
              if (!1 === c[0].visible) return i;
              var u = new xt.Shape(
                  [
                    new r.Vector3(l / 2, e.height, 0),
                    new r.Vector3(l / 2, 0, 0),
                    new r.Vector3(-l / 2, 0, 0),
                    new r.Vector3(-l / 2, e.height, 0),
                  ],
                  !0
                ),
                h = new r.Box2().setFromPoints(u.verts),
                d = new r.Vector2();
              h.getSize(d),
                (h = new r.Box2().setFromCenterAndSize(new r.Vector2(0, 0), d)),
                (u.name = o.name);
              var p = c[0].layerIds;
              p = Array.isArray(p) ? p : [p];
              var f = null;
              return (
                p.forEach(function (s, l) {
                  var p = c[0].dropTargetId,
                    m = n.notNull(
                      t.layers.filter(function (e) {
                        return e.id === s;
                      })[0],
                      "layers.id = " + s
                    ),
                    g = (new r.Vector2(0, 0), u);
                  g.name = o.name;
                  var v = -(m = Object.assign({}, m)).thickness - m.height,
                    y = n.holesForDroppedElements(
                      o.name,
                      p,
                      h.clone().expandByScalar(m.expand || 0),
                      t,
                      !1
                    ),
                    x = n.buildLayer(g, y, m, t, a, !0);
                  if (0 === l) {
                    if (m.glassDecorationId) {
                      var b = t.glassDecorations.filter(function (e) {
                        return e.id === m.glassDecorationId;
                      });
                      b.length &&
                        (f = n.buildGlassDecorationBBoxes(
                          d.width,
                          d.height,
                          b[0]
                        ));
                    }
                    n.addDropTargets(
                      x,
                      p,
                      v,
                      g,
                      t,
                      !0,
                      f,
                      m.materialId,
                      null,
                      null
                    );
                  }
                  var w = o.v1.clone().sub(o.v2),
                    _ = Math.atan2(w.y, -w.x);
                  x.obj.rotation.set(-Math.PI / 2, _, 0);
                  var M = o.v1.clone().lerp(o.v2, 0.5);
                  (x.obj.position.x += M.x),
                    (x.obj.position.y += M.y - e.height / 2),
                    (x.obj.position.z -= M.z + e.height / 2),
                    i.add(x);
                }),
                (a.x += l),
                i
              );
            }, new Ct());
          }),
          (e.prototype.buildLayer = function (e, t, n, i, o, a) {
            var s,
              l = new Ct(),
              c = e;
            n.expand && (c = e.expand(new r.Vector2(n.expand, 0)));
            var u = null;
            a
              ? ((u = new r.Matrix4().copy(c.localMatrix).invert()),
                (s = c.verts.map(function (e) {
                  return new r.Vector2().fromArray(
                    e.clone().applyMatrix4(u).toArray()
                  );
                })))
              : (s = c.verts.map(function (e) {
                  return new r.Vector2(e.x, e.y);
                }));
            var h = new r.Shape(s);
            new r.Box2().setFromPoints(s), (h.holes = t);
            var d = new r.ExtrudeBufferGeometry(h, {
                bevelEnabled: !1,
                steps: 1,
                depth: n.thickness,
              }),
              p = new r.Mesh(d, this.materials[n.materialId]);
            if (
              ((p.name = e.name),
              (l.obj.name = e.name),
              l.obj.add(p),
              a
                ? (p.position.z += n.height * (a ? 1 : -1))
                : (p.position.z -= n.height + n.thickness),
              void 0 !== n.visible && (p.visible = !!n.visible),
              a
                ? (l.obj.setRotationFromMatrix(e.localMatrix),
                  l.obj.position.setFromMatrixPosition(e.localMatrix),
                  this.elementBuilder.remapUV(p, n.swapUV, o))
                : this.elementBuilder.remapUV(p, n.swapUV, o),
              (l.obj.name = e.name),
              n.glassDecorationId)
            ) {
              var f = this.notNull(
                  i.glassDecorations.filter(function (e) {
                    return e.id === n.glassDecorationId;
                  })[0],
                  "glassDecoration.id =" + n.glassDecorationId
                ),
                m = new r.Box2().setFromPoints(s),
                g = new r.Vector2();
              m.getSize(g);
              var v = this.elementBuilder.buildGlassDecoration(
                  g.width,
                  g.height,
                  f,
                  i
                ),
                y = new r.Vector2();
              m.getCenter(y),
                v.position.copy(p.position).add(new r.Vector3(y.x, 0, y.y)),
                v.rotation.copy(p.rotation),
                l.obj.add(v);
            }
            return l;
          }),
          (e.prototype.holesForDroppedElements = function (e, t, n, i, o, a) {
            var s = this;
            return t
              ? i.droppedElements
                  .filter(function (n) {
                    return n.dropTargetName === e && n.dropTargetId === t;
                  })
                  .filter(function (e) {
                    return !e.float;
                  })
                  .reduce(function (e, t) {
                    var i = t.localBoundingBox,
                      l = new r.Vector2(i.min.x, i.min.y),
                      c = new r.Vector2(i.max.x, i.max.y),
                      u = new r.Box2(l, c).translate(
                        new r.Vector2().fromArray(t.position)
                      ),
                      h = s.boxToVertices(u);
                    return (
                      o &&
                        (h = h.map(function (e) {
                          return new r.Vector2(-e.x, e.y);
                        })),
                      a &&
                        h.forEach(function (e) {
                          return e.add(a);
                        }),
                      e.push(
                        new r.Path(
                          h.map(function (e) {
                            return n.clampPoint(e, new r.Vector2());
                          })
                        )
                      ),
                      e
                    );
                  }, [])
              : [];
          }),
          (e.prototype.addDropTargets = function (
            e,
            t,
            n,
            i,
            o,
            a,
            s,
            l,
            c,
            u
          ) {
            var h = this;
            if (t) {
              var d,
                p = (i = new xt.Shape(
                  i.verts.map(function (e) {
                    return e.clone();
                  })
                )).expand(new r.Vector2(-2, 0)).verts;
              if (p.length < 2) return;
              var f = i.localMatrix.clone(),
                m = new r.Vector3().setFromMatrixPosition(f).multiplyScalar(-1);
              d = p.map(function (e) {
                return new r.Vector2().fromArray(e.clone().add(m).toArray());
              });
              var g = new r.Shape(d),
                v = new r.ExtrudeBufferGeometry(g, {
                  bevelEnabled: !1,
                  steps: 1,
                  depth: 3,
                }),
                y = new r.Mesh(v);
              (y.name = e.obj.name),
                (y.position.z -= n - 3),
                e.obj.add(y),
                (y.visible = !1);
              var x = new r.Box3().setFromPoints(
                  d.map(function (e) {
                    return new r.Vector3(e.x, e.y, 0);
                  })
                ),
                b = this.createDropTargetFromMesh(t, y, o, x, s, c, u),
                w = this.populateDropTargetWithElements(b, o, l);
              w.forEach(function (e) {
                return (e.intersectable.object.position.z -= 3);
              }),
                e.dropTargets.push(b),
                (e.dropped = e.dropped.concat(w)),
                e.obj.children.map(function (e) {
                  return e.localToWorld(new r.Vector3(0, 0, 0));
                });
              var _ = new Ct();
              w
                .filter(function (e) {
                  return e.asDropTargetId;
                })
                .map(function (t) {
                  var n = new r.Vector3(t.position[1], t.position[0]),
                    i = new r.Box2().setFromCenterAndSize(
                      new r.Vector2(n.x, n.y),
                      new r.Vector2(t.height, t.width)
                    ),
                    a = [
                      new r.Vector3(i.min.y, i.min.x, 0),
                      new r.Vector3(i.min.y, i.max.x, 0),
                      new r.Vector3(i.max.y, i.max.x, 0),
                      new r.Vector3(i.max.y, i.min.x, 0),
                    ];
                  h.addDropTargets(
                    e,
                    t.asDropTargetId,
                    0,
                    new xt.Shape(a),
                    o,
                    !1,
                    null,
                    l,
                    null,
                    t.asDropTargetUniqueId
                  );
                }),
                e.add(_),
                a &&
                  (e.obj.setRotationFromMatrix(i.localMatrix),
                  e.obj.position.setFromMatrixPosition(i.localMatrix));
            }
          }),
          (e.prototype.simplifyVerts = function (e) {
            return e
              .filter(function (e, t, n) {
                return (
                  n[(t - 1 + n.length) % n.length].manhattanDistanceTo(e) >= 1
                );
              })
              .filter(function (e, t, n) {
                var r = n[(t - 1 + n.length) % n.length],
                  i = n[(t + 1) % n.length],
                  o = e.x,
                  a = e.y,
                  s = r.x,
                  l = r.y,
                  c = i.x,
                  u = i.y;
                return o * (l - u) + s * (u - a) + c * (a - l) != 0;
              });
          }),
          (e.prototype.buildPlane = function (e, t) {
            var n = this,
              i = this.buildShape(
                this.notNull(
                  t.shapes.filter(function (t) {
                    return t.id === e.shapeId;
                  })[0],
                  "shapes.id =" + e.shapeId
                )
              ),
              o = i.verts.map(function (e) {
                return new r.Vector2(e.x, e.y);
              });
            (o = this.simplifyVerts(o)),
              (i = new xt.Shape(
                o.map(function (e) {
                  return new r.Vector3(e.x, e.y, 0);
                }),
                i.isClosed
              ));
            var a = new Ct(),
              s = new r.Box2().setFromPoints(o),
              l = new r.Vector2();
            s.getCenter(l);
            var c = this.holesForDroppedElements(
              e.id,
              e.dropTargetId,
              s,
              t,
              !0,
              l
            );
            if (e.useHolesFrom) {
              var u = this.notNull(
                  t.planes.filter(function (t) {
                    return t.id === e.useHolesFrom;
                  })[0],
                  "planes.id = " + e.useHolesFrom
                ),
                h = this.buildShape(
                  this.notNull(
                    t.shapes.filter(function (e) {
                      return e.id === u.shapeId;
                    })[0],
                    "shapes.id =" + u.shapeId
                  )
                ),
                d = new r.Box2().setFromPoints(
                  h.verts.map(function (e) {
                    return new r.Vector2(e.x, e.y);
                  })
                ),
                p = new r.Vector2();
              d.getCenter(p),
                (c = this.holesForDroppedElements(
                  u.id,
                  u.dropTargetId,
                  d,
                  t,
                  !0,
                  p
                ));
            }
            var f,
              m = 0,
              g = new r.Vector2();
            s.getSize(g);
            var v = "";
            e.layerIds.forEach(function (e, o) {
              var s = n.notNull(
                  t.layers.filter(function (t) {
                    return t.id === e;
                  })[0],
                  "layers.id = " + e
                ),
                u = n.buildLayer(i, c, s, t, new r.Vector2(), !1);
              if (
                (a.add(u),
                (m = Math.max(m, s.height + s.thickness)),
                s.borderId)
              ) {
                var h = n.notNull(
                    t.borders.filter(function (e) {
                      return e.id === s.borderId;
                    })[0],
                    "border.id =" + s.borderId
                  ),
                  d = n.buildBorder(i, h, t);
                a.obj.add(d), (d.position.z -= s.height);
              }
              if (s.glassDecorationId && 0 == o) {
                var p = t.glassDecorations.filter(function (e) {
                  return e.id === s.glassDecorationId;
                });
                p.length &&
                  (f = n
                    .buildGlassDecorationBBoxes(g.width, g.height, p[0])
                    .map(function (e) {
                      return e.translate(l);
                    }));
              }
              v = v || s.materialId;
            });
            var y = new Ct();
            y.obj.name = e.id;
            var x = new r.Box3().setFromPoints(i.verts),
              b = new xt.Shape(
                this.boxToVertices(x).map(function (e) {
                  return new r.Vector3(e.x, e.y, 0);
                }),
                !0
              );
            return (
              (b.name = i.name),
              this.addDropTargets(
                y,
                e.dropTargetId,
                -m,
                b,
                t,
                !0,
                f,
                v,
                null,
                null
              ),
              a.add(y),
              a
            );
          }),
          e
        );
      })()),
      (At.Builder = Pt);
    var It = be.Builder;

    function kt(e) {
      return e.match(/(^(https?\:\/)?\/)/) ? e : contentRoute + e;
    }
    var Dt = function (e, t) {
        var n = window;
        (this.language = n.language),
          (this.newUrl = n.newUrl),
          (this.isLoggedIn = n.isLoggedIn),
          (this.serverParameters = t || n.serverParameters),
          (this.loginUrl = n.loginUrl),
          (this.logoUrl = n.logoUrl),
          (this.config = e);
      },
      Ot = function () {
        var e = new i();
        this.materials = e;
        var t = new we(),
          n = new It(10, e),
          o = new Re(n, t);
        (this.renderer = o), (this.env = this.renderer.env);
        var a = new Ce.Intersector(o.camera, o.domElement),
          s = new Et.Builder(8, e);
        (this.newBuilder = s), (window.newBuilder = s);
        var l = new Ce.DnDBehavior(a);
        (this.dragNDrop = l), l.addEventListeners(o.domElement, o.controls);
        var c = new r.Object3D(),
          u = function (e) {
            return (c.visible = !1);
          },
          h = function (e) {
            return (c.visible = !0);
          },
          d = this.env.scene.getObjectByName("sun"),
          p = d.clone();
        p.position.negate(),
          (p.position.y *= -1),
          (p.intensity /= 4),
          (p.castShadow = !1);
        var f = new r.AmbientLight(16777215, 0.3);
        (f.name = "ambient"),
          this.env.scene.add(p),
          this.env.scene.add(f),
          this.env,
          (this.attachComponent = function () {
            var e = new r.Object3D();
            (e.name = "front Object"),
              e.add(d.clone()),
              e.add(p.clone()),
              e.add(f.clone()),
              o.setForeGroundScene(e),
              o.domElement.addEventListener("mousedown", u),
              o.domElement.addEventListener("mouseup", h),
              (window.renderer = o);
          }),
          (this.detachComponent = function () {
            o.domElement.removeEventListener("mousedown", u),
              o.domElement.removeEventListener("mouseup", h),
              o.clearAnimations();
          }),
          (this.updateDraggableElements = function (e) {
            for (; c.children.length; ) c.remove(c.children[0]);
            e.forEach(function (e, t) {
              c.add(e.intersectable.object);
            }),
              (l.draggables = e);
          });
      };
  },
  function (e, t, n) {
    "use strict";
    var r;
    n.d(t, "a", function () {
      return r;
    }),
      (function (e) {
        e.getRalDict = function () {
          var e = {
            1e3: {
              code: "1000",
              rgbApprox: "214-199-148",
              rgbHex: "#BEBD7F",
              name: "Green beige",
            },
            1001: {
              code: "1001",
              rgbApprox: "217-186-140",
              rgbHex: "#C2B078",
              name: "Beige",
            },
            1002: {
              code: "1002",
              rgbApprox: "198-166-100",
              rgbHex: "#C6A664",
              name: "Sand yellow",
            },
            1003: {
              code: "1003",
              rgbApprox: "229-190-001",
              rgbHex: "#E5BE01",
              name: "Signal yellow",
            },
            1004: {
              code: "1004",
              rgbApprox: "205-164-052",
              rgbHex: "#CDA434",
              name: "Golden yellow",
            },
            1005: {
              code: "1005",
              rgbApprox: "169-131-007",
              rgbHex: "#A98307",
              name: "Honey yellow",
            },
            1006: {
              code: "1006",
              rgbApprox: "228-160-016",
              rgbHex: "#E4A010",
              name: "Maize yellow",
            },
            1007: {
              code: "1007",
              rgbApprox: "220-156-000",
              rgbHex: "#DC9D00",
              name: "Daffodil yellow",
            },
            1011: {
              code: "1011",
              rgbApprox: "138-102-066",
              rgbHex: "#8A6642",
              name: "Brown beige",
            },
            1012: {
              code: "1012",
              rgbApprox: "199-180-070",
              rgbHex: "#C7B446",
              name: "Lemon yellow",
            },
            1013: {
              code: "1013",
              rgbApprox: "234-230-202",
              rgbHex: "#EAE6CA",
              name: "Oyster white",
            },
            1014: {
              code: "1014",
              rgbApprox: "225-204-079",
              rgbHex: "#E1CC4F",
              name: "Ivory",
            },
            1015: {
              code: "1015",
              rgbApprox: "230-214-144",
              rgbHex: "#E6D690",
              name: "Light ivory",
            },
            1016: {
              code: "1016",
              rgbApprox: "237-255-033",
              rgbHex: "#EDFF21",
              name: "Sulfur yellow",
            },
            1017: {
              code: "1017",
              rgbApprox: "245-208-051",
              rgbHex: "#F5D033",
              name: "Saffron yellow",
            },
            1018: {
              code: "1018",
              rgbApprox: "248-243-053",
              rgbHex: "#F8F32B",
              name: "Zinc yellow",
            },
            1019: {
              code: "1019",
              rgbApprox: "158-151-100",
              rgbHex: "#9E9764",
              name: "Grey beige",
            },
            1020: {
              code: "1020",
              rgbApprox: "153-153-080",
              rgbHex: "#999950",
              name: "Olive yellow",
            },
            1021: {
              code: "1021",
              rgbApprox: "243-218-011",
              rgbHex: "#F3DA0B",
              name: "Rape yellow",
            },
            1023: {
              code: "1023",
              rgbApprox: "250-210-001",
              rgbHex: "#FAD201",
              name: "Traffic yellow",
            },
            1024: {
              code: "1024",
              rgbApprox: "174-160-075",
              rgbHex: "#AEA04B",
              name: "Ochre yellow",
            },
            1026: {
              code: "1026",
              rgbApprox: "255-255-000",
              rgbHex: "#FFFF00",
              name: "Luminous yellow",
            },
            1027: {
              code: "1027",
              rgbApprox: "157-145-001",
              rgbHex: "#9D9101",
              name: "Curry",
            },
            1028: {
              code: "1028",
              rgbApprox: "244-169-000",
              rgbHex: "#F4A900",
              name: "Melon yellow",
            },
            1032: {
              code: "1032",
              rgbApprox: "214-174-001",
              rgbHex: "#D6AE01",
              name: "Broom yellow",
            },
            1033: {
              code: "1033",
              rgbApprox: "243-165-005",
              rgbHex: "#F3A505",
              name: "Dahlia yellow",
            },
            1034: {
              code: "1034",
              rgbApprox: "239-169-074",
              rgbHex: "#EFA94A",
              name: "Pastel yellow",
            },
            1035: {
              code: "1035",
              rgbApprox: "106-093-077",
              rgbHex: "#6A5D4D",
              name: "Pearl beige",
            },
            1036: {
              code: "1036",
              rgbApprox: "112-083-053",
              rgbHex: "#705335",
              name: "Pearl gold",
            },
            1037: {
              code: "1037",
              rgbApprox: "243-159-024",
              rgbHex: "#F39F18",
              name: "Sun yellow",
            },
            2e3: {
              code: "2000",
              rgbApprox: "237-118-014",
              rgbHex: "#ED760E",
              name: "Yellow orange",
            },
            2001: {
              code: "2001",
              rgbApprox: "201-060-032",
              rgbHex: "#C93C20",
              name: "Red orange",
            },
            2002: {
              code: "2002",
              rgbApprox: "203-040-033",
              rgbHex: "#CB2821",
              name: "Vermilion",
            },
            2003: {
              code: "2003",
              rgbApprox: "255-117-020",
              rgbHex: "#FF7514",
              name: "Pastel orange",
            },
            2004: {
              code: "2004",
              rgbApprox: "244-070-017",
              rgbHex: "#F44611",
              name: "Pure orange",
            },
            2005: {
              code: "2005",
              rgbApprox: "255-035-001",
              rgbHex: "#FF2301",
              name: "Luminous orange",
            },
            2007: {
              code: "2007",
              rgbApprox: "255-164-032",
              rgbHex: "#FFA420",
              name: "Luminous bright orange",
            },
            2008: {
              code: "2008",
              rgbApprox: "247-094-037",
              rgbHex: "#F75E25",
              name: "Bright red orange",
            },
            2009: {
              code: "2009",
              rgbApprox: "245-064-033",
              rgbHex: "#F54021",
              name: "Traffic orange",
            },
            2010: {
              code: "2010",
              rgbApprox: "216-075-032",
              rgbHex: "#D84B20",
              name: "Signal orange",
            },
            2011: {
              code: "2011",
              rgbApprox: "236-124-038",
              rgbHex: "#EC7C26",
              name: "Deep orange",
            },
            2012: {
              code: "2012",
              rgbApprox: "235-106-014",
              rgbHex: "#E55137",
              name: "Salmon range",
            },
            2013: {
              code: "2013",
              rgbApprox: "195-088-049",
              rgbHex: "#C35831",
              name: "Pearl orange",
            },
            3e3: {
              code: "3000",
              rgbApprox: "175-043-030",
              rgbHex: "#AF2B1E",
              name: "Flame red",
            },
            3001: {
              code: "3001",
              rgbApprox: "165-032-025",
              rgbHex: "#A52019",
              name: "Signal red",
            },
            3002: {
              code: "3002",
              rgbApprox: "162-035-029",
              rgbHex: "#A2231D",
              name: "Carmine red",
            },
            3003: {
              code: "3003",
              rgbApprox: "155-017-030",
              rgbHex: "#9B111E",
              name: "Ruby red",
            },
            3004: {
              code: "3004",
              rgbApprox: "117-021-030",
              rgbHex: "#75151E",
              name: "Purple red",
            },
            3005: {
              code: "3005",
              rgbApprox: "094-033-041",
              rgbHex: "#5E2129",
              name: "Wine red",
            },
            3007: {
              code: "3007",
              rgbApprox: "065-034-039",
              rgbHex: "#412227",
              name: "Black red",
            },
            3009: {
              code: "3009",
              rgbApprox: "100-036-036",
              rgbHex: "#642424",
              name: "Oxide red",
            },
            3011: {
              code: "3011",
              rgbApprox: "120-031-025",
              rgbHex: "#781F19",
              name: "Brown red",
            },
            3012: {
              code: "3012",
              rgbApprox: "193-135-107",
              rgbHex: "#C1876B",
              name: "Beige red",
            },
            3013: {
              code: "3013",
              rgbApprox: "161-035-018",
              rgbHex: "#A12312",
              name: "Tomato red",
            },
            3014: {
              code: "3014",
              rgbApprox: "211-110-112",
              rgbHex: "#D36E70",
              name: "Antique pink",
            },
            3015: {
              code: "3015",
              rgbApprox: "234-137-154",
              rgbHex: "#EA899A",
              name: "Light pink",
            },
            3016: {
              code: "3016",
              rgbApprox: "179-040-033",
              rgbHex: "#B32821",
              name: "Coral red",
            },
            3017: {
              code: "3017",
              rgbApprox: "230-050-068",
              rgbHex: "#E63244",
              name: "Rose",
            },
            3018: {
              code: "3018",
              rgbApprox: "213-048-050",
              rgbHex: "#D53032",
              name: "Strawberry red",
            },
            3020: {
              code: "3020",
              rgbApprox: "204-006-005",
              rgbHex: "#CC0605",
              name: "Traffic red",
            },
            3022: {
              code: "3022",
              rgbApprox: "217-080-048",
              rgbHex: "#D95030",
              name: "Salmon pink",
            },
            3024: {
              code: "3024",
              rgbApprox: "248-000-000",
              rgbHex: "#F80000",
              name: "Luminous red",
            },
            3026: {
              code: "3026",
              rgbApprox: "254-000-000",
              rgbHex: "#FE0000",
              name: "Luminous bright red",
            },
            3027: {
              code: "3027",
              rgbApprox: "197-029-052",
              rgbHex: "#C51D34",
              name: "Raspberry red",
            },
            3028: {
              code: "3028",
              rgbApprox: "203-050-052",
              rgbHex: "#CB3234",
              name: "Pure  red",
            },
            3031: {
              code: "3031",
              rgbApprox: "179-036-040",
              rgbHex: "#B32428",
              name: "Orient red",
            },
            3032: {
              code: "3032",
              rgbApprox: "114-020-034",
              rgbHex: "#721422",
              name: "Pearl ruby red",
            },
            3033: {
              code: "3033",
              rgbApprox: "180-076-067",
              rgbHex: "#B44C43",
              name: "Pearl pink",
            },
            4001: {
              code: "4001",
              rgbApprox: "109-063-091",
              rgbHex: "#6D3F5B",
              name: "Red lilac",
            },
            4002: {
              code: "4002",
              rgbApprox: "146-043-062",
              rgbHex: "#922B3E",
              name: "Red violet",
            },
            4003: {
              code: "4003",
              rgbApprox: "222-076-138",
              rgbHex: "#DE4C8A",
              name: "Heather violet",
            },
            4004: {
              code: "4004",
              rgbApprox: "110-028-052",
              rgbHex: "#641C34",
              name: "Claret violet",
            },
            4005: {
              code: "4005",
              rgbApprox: "108-070-117",
              rgbHex: "#6C4675",
              name: "Blue lilac",
            },
            4006: {
              code: "4006",
              rgbApprox: "160-052-114",
              rgbHex: "#A03472",
              name: "Traffic purple",
            },
            4007: {
              code: "4007",
              rgbApprox: "074-025-044",
              rgbHex: "#4A192C",
              name: "Purple violet",
            },
            4008: {
              code: "4008",
              rgbApprox: "146-078-125",
              rgbHex: "#924E7D",
              name: "Signal violet",
            },
            4009: {
              code: "4009",
              rgbApprox: "164-125-144",
              rgbHex: "#A18594",
              name: "Pastel violet",
            },
            4010: {
              code: "4010",
              rgbApprox: "215-045-109",
              rgbHex: "#CF3476",
              name: "Telemagenta",
            },
            4011: {
              code: "4011",
              rgbApprox: "134-115-161",
              rgbHex: "#8673A1",
              name: "Pearl violet",
            },
            4012: {
              code: "4012",
              rgbApprox: "108-104-129",
              rgbHex: "#6C6874",
              name: "Pearl black berry",
            },
            5e3: {
              code: "5000",
              rgbApprox: "042-046-075",
              rgbHex: "#354D73",
              name: "Violet blue",
            },
            5001: {
              code: "5001",
              rgbApprox: "031-052-056",
              rgbHex: "#1F3438",
              name: "Green blue",
            },
            5002: {
              code: "5002",
              rgbApprox: "032-033-079",
              rgbHex: "#20214F",
              name: "Ultramarine blue",
            },
            5003: {
              code: "5003",
              rgbApprox: "029-030-051",
              rgbHex: "#1D1E33",
              name: "Saphire blue",
            },
            5004: {
              code: "5004",
              rgbApprox: "032-033-079",
              rgbHex: "#18171C",
              name: "Black blue",
            },
            5005: {
              code: "5005",
              rgbApprox: "030-045-110",
              rgbHex: "#1E2460",
              name: "Signal blue",
            },
            5007: {
              code: "5007",
              rgbApprox: "062-095-138",
              rgbHex: "#3E5F8A",
              name: "Brillant blue",
            },
            5008: {
              code: "5008",
              rgbApprox: "038-037-045",
              rgbHex: "#26252D",
              name: "Grey blue",
            },
            5009: {
              code: "5009",
              rgbApprox: "002-086-105",
              rgbHex: "#025669",
              name: "Azure blue",
            },
            5010: {
              code: "5010",
              rgbApprox: "014-041-075",
              rgbHex: "#0E294B",
              name: "Gentian blue",
            },
            5011: {
              code: "5011",
              rgbApprox: "035-026-036",
              rgbHex: "#231A24",
              name: "Steel blue",
            },
            5012: {
              code: "5012",
              rgbApprox: "059-131-189",
              rgbHex: "#3B83BD",
              name: "Light blue",
            },
            5013: {
              code: "5013",
              rgbApprox: "037-041-074",
              rgbHex: "#1E213D",
              name: "Cobalt blue",
            },
            5014: {
              code: "5014",
              rgbApprox: "096-111-140",
              rgbHex: "#606E8C",
              name: "Pigeon blue",
            },
            5015: {
              code: "5015",
              rgbApprox: "034-113-179",
              rgbHex: "#2271B3",
              name: "Sky blue",
            },
            5017: {
              code: "5017",
              rgbApprox: "006-057-113",
              rgbHex: "#063971",
              name: "Traffic blue",
            },
            5018: {
              code: "5018",
              rgbApprox: "063-136-143",
              rgbHex: "#3F888F",
              name: "Turquoise blue",
            },
            5019: {
              code: "5019",
              rgbApprox: "027-085-131",
              rgbHex: "#1B5583",
              name: "Capri blue",
            },
            5020: {
              code: "5020",
              rgbApprox: "029-051-074",
              rgbHex: "#1D334A",
              name: "Ocean blue",
            },
            5021: {
              code: "5021",
              rgbApprox: "037-109-123",
              rgbHex: "#256D7B",
              name: "Water blue",
            },
            5022: {
              code: "5022",
              rgbApprox: "037-040-080",
              rgbHex: "#252850",
              name: "Night blue",
            },
            5023: {
              code: "5023",
              rgbApprox: "073-103-141",
              rgbHex: "#49678D",
              name: "Distant blue",
            },
            5024: {
              code: "5024",
              rgbApprox: "093-155-155",
              rgbHex: "#5D9B9B",
              name: "Pastel blue",
            },
            5025: {
              code: "5025",
              rgbApprox: "042-100-120",
              rgbHex: "#2A6478",
              name: "Pearl gentian blue",
            },
            5026: {
              code: "5026",
              rgbApprox: "016-044-084",
              rgbHex: "#102C54",
              name: "Pearl night blue",
            },
            6e3: {
              code: "6000",
              rgbApprox: "049-102-080",
              rgbHex: "#316650",
              name: "Patina green",
            },
            6001: {
              code: "6001",
              rgbApprox: "040-114-051",
              rgbHex: "#287233",
              name: "Emerald green",
            },
            6002: {
              code: "6002",
              rgbApprox: "045-087-044",
              rgbHex: "#2D572C",
              name: "Leaf green",
            },
            6003: {
              code: "6003",
              rgbApprox: "066-070-050",
              rgbHex: "#424632",
              name: "Olive green",
            },
            6004: {
              code: "6004",
              rgbApprox: "031-058-061",
              rgbHex: "#1F3A3D",
              name: "Blue green",
            },
            6005: {
              code: "6005",
              rgbApprox: "047-069-056",
              rgbHex: "#2F4538",
              name: "Moss green",
            },
            6006: {
              code: "6006",
              rgbApprox: "062-059-050",
              rgbHex: "#3E3B32",
              name: "Grey olive",
            },
            6007: {
              code: "6007",
              rgbApprox: "052-059-041",
              rgbHex: "#343B29",
              name: "Bottle green",
            },
            6008: {
              code: "6008",
              rgbApprox: "057-053-042",
              rgbHex: "#39352A",
              name: "Brown green",
            },
            6009: {
              code: "6009",
              rgbApprox: "049-055-043",
              rgbHex: "#31372B",
              name: "Fir green",
            },
            6010: {
              code: "6010",
              rgbApprox: "053-104-045",
              rgbHex: "#35682D",
              name: "Grass green",
            },
            6011: {
              code: "6011",
              rgbApprox: "088-114-070",
              rgbHex: "#587246",
              name: "Reseda green",
            },
            6012: {
              code: "6012",
              rgbApprox: "052-062-064",
              rgbHex: "#343E40",
              name: "Black green",
            },
            6013: {
              code: "6013",
              rgbApprox: "108-113-086",
              rgbHex: "#6C7156",
              name: "Reed green",
            },
            6014: {
              code: "6014",
              rgbApprox: "071-064-046",
              rgbHex: "#47402E",
              name: "Yellow olive",
            },
            6015: {
              code: "6015",
              rgbApprox: "059-060-054",
              rgbHex: "#3B3C36",
              name: "Black olive",
            },
            6016: {
              code: "6016",
              rgbApprox: "030-089-069",
              rgbHex: "#1E5945",
              name: "Turquoise green",
            },
            6017: {
              code: "6017",
              rgbApprox: "076-145-065",
              rgbHex: "#4C9141",
              name: "May green",
            },
            6018: {
              code: "6018",
              rgbApprox: "087-166-057",
              rgbHex: "#57A639",
              name: "Yellow green",
            },
            6019: {
              code: "6019",
              rgbApprox: "189-236-182",
              rgbHex: "#BDECB6",
              name: "Pastel green",
            },
            6020: {
              code: "6020",
              rgbApprox: "046-058-035",
              rgbHex: "#2E3A23",
              name: "Chrome green",
            },
            6021: {
              code: "6021",
              rgbApprox: "137-172-118",
              rgbHex: "#89AC76",
              name: "Pale green",
            },
            6022: {
              code: "6022",
              rgbApprox: "037-034-027",
              rgbHex: "#25221B",
              name: "Olive drab",
            },
            6024: {
              code: "6024",
              rgbApprox: "048-132-070",
              rgbHex: "#308446",
              name: "Traffic green",
            },
            6025: {
              code: "6025",
              rgbApprox: "061-100-045",
              rgbHex: "#3D642D",
              name: "Fern green",
            },
            6026: {
              code: "6026",
              rgbApprox: "001-093-082",
              rgbHex: "#015D52",
              name: "Opal green",
            },
            6027: {
              code: "6027",
              rgbApprox: "132-195-190",
              rgbHex: "#84C3BE",
              name: "Light green",
            },
            6028: {
              code: "6028",
              rgbApprox: "044-085-069",
              rgbHex: "#2C5545",
              name: "Pine green",
            },
            6029: {
              code: "6029",
              rgbApprox: "032-096-061",
              rgbHex: "#20603D",
              name: "Mint green",
            },
            6032: {
              code: "6032",
              rgbApprox: "049-127-067",
              rgbHex: "#317F43",
              name: "Signal green",
            },
            6033: {
              code: "6033",
              rgbApprox: "073-126-118",
              rgbHex: "#497E76",
              name: "Mint turquoise",
            },
            6034: {
              code: "6034",
              rgbApprox: "127-181-181",
              rgbHex: "#7FB5B5",
              name: "Pastel turquoise",
            },
            6035: {
              code: "6035",
              rgbApprox: "028-084-045",
              rgbHex: "#1C542D",
              name: "Pearl green",
            },
            6036: {
              code: "6036",
              rgbApprox: "022-053-055",
              rgbHex: "#193737",
              name: "Pearl opal green",
            },
            6037: {
              code: "6037",
              rgbApprox: "000-143-057",
              rgbHex: "#008F39",
              name: "Pure green",
            },
            6038: {
              code: "6038",
              rgbApprox: "000-187-045",
              rgbHex: "#00BB2D",
              name: "Luminous green",
            },
            7e3: {
              code: "7000",
              rgbApprox: "120-133-139",
              rgbHex: "#78858B",
              name: "Squirrel grey",
            },
            7001: {
              code: "7001",
              rgbApprox: "138-149-151",
              rgbHex: "#8A9597",
              name: "Silver grey",
            },
            7002: {
              code: "7002",
              rgbApprox: "126-123-082",
              rgbHex: "#7E7B52",
              name: "Olive grey",
            },
            7003: {
              code: "7003",
              rgbApprox: "108-112-089",
              rgbHex: "#6C7059",
              name: "Moss grey",
            },
            7004: {
              code: "7004",
              rgbApprox: "150-153-146",
              rgbHex: "#969992",
              name: "Signal grey",
            },
            7005: {
              code: "7005",
              rgbApprox: "100-107-099",
              rgbHex: "#646B63",
              name: "Mouse grey",
            },
            7006: {
              code: "7006",
              rgbApprox: "109-101-082",
              rgbHex: "#6D6552",
              name: "Beige grey",
            },
            7008: {
              code: "7008",
              rgbApprox: "106-095-049",
              rgbHex: "#6A5F31",
              name: "Khaki grey",
            },
            7009: {
              code: "7009",
              rgbApprox: "077-086-069",
              rgbHex: "#4D5645",
              name: "Green grey",
            },
            7010: {
              code: "7010",
              rgbApprox: "076-081-074",
              rgbHex: "#4C514A",
              name: "Tarpaulin grey",
            },
            7011: {
              code: "7011",
              rgbApprox: "067-075-077",
              rgbHex: "#434B4D",
              name: "Iron grey",
            },
            7012: {
              code: "7012",
              rgbApprox: "078-087-084",
              rgbHex: "#4E5754",
              name: "Basalt grey",
            },
            7013: {
              code: "7013",
              rgbApprox: "070-069-049",
              rgbHex: "#464531",
              name: "Brown grey",
            },
            7015: {
              code: "7015",
              rgbApprox: "067-071-080",
              rgbHex: "#434750",
              name: "Slate grey",
            },
            7016: {
              code: "7016",
              rgbApprox: "041-049-051",
              rgbHex: "#293133",
              name: "Anthracite grey",
            },
            7021: {
              code: "7021",
              rgbApprox: "035-040-043",
              rgbHex: "#23282B",
              name: "Black grey",
            },
            7022: {
              code: "7022",
              rgbApprox: "051-047-044",
              rgbHex: "#332F2C",
              name: "Umbra grey",
            },
            7023: {
              code: "7023",
              rgbApprox: "104-108-094",
              rgbHex: "#686C5E",
              name: "Concrete grey",
            },
            7024: {
              code: "7024",
              rgbApprox: "071-074-081",
              rgbHex: "#474A51",
              name: "Graphite grey",
            },
            7026: {
              code: "7026",
              rgbApprox: "047-053-059",
              rgbHex: "#2F353B",
              name: "Granite grey",
            },
            7030: {
              code: "7030",
              rgbApprox: "139-140-122",
              rgbHex: "#8B8C7A",
              name: "Stone grey",
            },
            7031: {
              code: "7031",
              rgbApprox: "071-075-078",
              rgbHex: "#474B4E",
              name: "Blue grey",
            },
            7032: {
              code: "7032",
              rgbApprox: "184-183-153",
              rgbHex: "#B8B799",
              name: "Pebble grey",
            },
            7033: {
              code: "7033",
              rgbApprox: "125-132-113",
              rgbHex: "#7D8471",
              name: "Cement grey",
            },
            7034: {
              code: "7034",
              rgbApprox: "143-139-102",
              rgbHex: "#8F8B66",
              name: "Yellow grey",
            },
            7035: {
              code: "7035",
              rgbApprox: "215-215-215",
              rgbHex: "#D7D7D7",
              name: "Light grey",
            },
            7036: {
              code: "7036",
              rgbApprox: "127-118-121",
              rgbHex: "#7F7679",
              name: "Platinum grey",
            },
            7037: {
              code: "7037",
              rgbApprox: "125-127-120",
              rgbHex: "#7D7F7D",
              name: "Dusty grey",
            },
            7038: {
              code: "7038",
              rgbApprox: "195-195-195",
              rgbHex: "#B5B8B1",
              name: "Agate grey",
            },
            7039: {
              code: "7039",
              rgbApprox: "108-105-096",
              rgbHex: "#6C6960",
              name: "Quartz grey",
            },
            7040: {
              code: "7040",
              rgbApprox: "157-161-170",
              rgbHex: "#9DA1AA",
              name: "Window grey",
            },
            7042: {
              code: "7042",
              rgbApprox: "141-148-141",
              rgbHex: "#8D948D",
              name: "Traffic grey A",
            },
            7043: {
              code: "7043",
              rgbApprox: "078-084-082",
              rgbHex: "#4E5452",
              name: "Traffic grey B",
            },
            7044: {
              code: "7044",
              rgbApprox: "202-196-176",
              rgbHex: "#CAC4B0",
              name: "Silk grey",
            },
            7045: {
              code: "7045",
              rgbApprox: "144-144-144",
              rgbHex: "#909090",
              name: "Telegrey 1",
            },
            7046: {
              code: "7046",
              rgbApprox: "130-137-143",
              rgbHex: "#82898F",
              name: "Telegrey 2",
            },
            7047: {
              code: "7047",
              rgbApprox: "208-208-208",
              rgbHex: "#D0D0D0",
              name: "Telegrey 4",
            },
            7048: {
              code: "7048",
              rgbApprox: "137-129-118",
              rgbHex: "#898176",
              name: "Pearl mouse grey",
            },
            8e3: {
              code: "8000",
              rgbApprox: "130-108-052",
              rgbHex: "#826C34",
              name: "Green brown",
            },
            8001: {
              code: "8001",
              rgbApprox: "149-095-032",
              rgbHex: "#955F20",
              name: "Ochre brown",
            },
            8002: {
              code: "8002",
              rgbApprox: "108-059-042",
              rgbHex: "#6C3B2A",
              name: "Signal brown",
            },
            8003: {
              code: "8003",
              rgbApprox: "115-066-034",
              rgbHex: "#734222",
              name: "Clay brown",
            },
            8004: {
              code: "8004",
              rgbApprox: "142-064-042",
              rgbHex: "#8E402A",
              name: "Copper brown",
            },
            8007: {
              code: "8007",
              rgbApprox: "089-053-031",
              rgbHex: "#59351F",
              name: "Fawn brown",
            },
            8008: {
              code: "8008",
              rgbApprox: "111-079-040",
              rgbHex: "#6F4F28",
              name: "Olive brown",
            },
            8011: {
              code: "8011",
              rgbApprox: "091-058-041",
              rgbHex: "#5B3A29",
              name: "Nut brown",
            },
            8012: {
              code: "8012",
              rgbApprox: "089-035-033",
              rgbHex: "#592321",
              name: "Red brown",
            },
            8014: {
              code: "8014",
              rgbApprox: "056-044-030",
              rgbHex: "#382C1E",
              name: "Sepia brown",
            },
            8015: {
              code: "8015",
              rgbApprox: "099-058-052",
              rgbHex: "#633A34",
              name: "Chestnut brown",
            },
            8016: {
              code: "8016",
              rgbApprox: "076-047-039",
              rgbHex: "#4C2F27",
              name: "Mahogany brown",
            },
            8017: {
              code: "8017",
              rgbApprox: "069-050-046",
              rgbHex: "#45322E",
              name: "Chocolate brown",
            },
            8019: {
              code: "8019",
              rgbApprox: "064-058-058",
              rgbHex: "#403A3A",
              name: "Grey brown",
            },
            8022: {
              code: "8022",
              rgbApprox: "033-033-033",
              rgbHex: "#212121",
              name: "Black brown",
            },
            8023: {
              code: "8023",
              rgbApprox: "166-094-046",
              rgbHex: "#A65E2E",
              name: "Orange brown",
            },
            8024: {
              code: "8024",
              rgbApprox: "121-085-061",
              rgbHex: "#79553D",
              name: "Beige brown",
            },
            8025: {
              code: "8025",
              rgbApprox: "117-092-072",
              rgbHex: "#755C48",
              name: "Pale brown",
            },
            8028: {
              code: "8028",
              rgbApprox: "078-059-049",
              rgbHex: "#4E3B31",
              name: "Terra brown",
            },
            8029: {
              code: "8029",
              rgbApprox: "118-060-040",
              rgbHex: "#763C28",
              name: "Pearl copper",
            },
            9001: {
              code: "9001",
              rgbApprox: "250-244-227",
              rgbHex: "#FDF4E3",
              name: "Cream",
            },
            9002: {
              code: "9002",
              rgbApprox: "231-235-218",
              rgbHex: "#E7EBDA",
              name: "Grey white",
            },
            9003: {
              code: "9003",
              rgbApprox: "244-244-244",
              rgbHex: "#F4F4F4",
              name: "Signal white",
            },
            9004: {
              code: "9004",
              rgbApprox: "040-040-040",
              rgbHex: "#282828",
              name: "Signal black",
            },
            9005: {
              code: "9005",
              rgbApprox: "010-010-010",
              rgbHex: "#0A0A0A",
              name: "Jet black",
            },
            9006: {
              code: "9006",
              rgbApprox: "165-165-165",
              rgbHex: "#A5A5A5",
              name: "White aluminium",
            },
            9007: {
              code: "9007",
              rgbApprox: "143-143-143",
              rgbHex: "#8F8F8F",
              name: "Grey aluminium",
            },
            9010: {
              code: "9010",
              rgbApprox: "255-255-255",
              rgbHex: "#FFFFFF",
              name: "Pure white",
            },
            9011: {
              code: "9011",
              rgbApprox: "028-028-028",
              rgbHex: "#1C1C1C",
              name: "Graphite black",
            },
            9016: {
              code: "9016",
              rgbApprox: "246-246-246",
              rgbHex: "#F6F6F6",
              name: "Traffic white",
            },
            9017: {
              code: "9017",
              rgbApprox: "030-030-030",
              rgbHex: "#1E1E1E",
              name: "Traffic black",
            },
            9018: {
              code: "9018",
              rgbApprox: "215-215-215",
              rgbHex: "#D7D7D7",
              name: "Papyrus white",
            },
            9022: {
              code: "9022",
              rgbApprox: "156-156-156",
              rgbHex: "#9C9C9C",
              name: "Pearl light grey",
            },
            9023: {
              code: "9023",
              rgbApprox: "130-130-130",
              rgbHex: "#828282",
              name: "Pearl dark grey",
            },
            codes: [],
            getCode: function (t) {
              return e[t] || e[1e3];
            },
            getHexColor: function (t) {
              return parseInt(e.getCode(t).rgbHex.substr(1), 16);
            },
          };
          return (
            (e.codes = Object.keys(e).filter(function (e) {
              return /\d\d\d\d/.test(e);
            })),
            e
          );
        };
      })(r || (r = {}));
  },
  function (e, t, n) {
    "use strict";
    var r = function () {
      return (r =
        Object.assign ||
        function (e) {
          for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var i in (t = arguments[n]))
              Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
          return e;
        }).apply(this, arguments);
    };

    function i(e) {
      var t = JSON.stringify(e, function (e, t) {
          return "function" == typeof t ? o(t) : t;
        }),
        n = JSON.parse(t);
      return Object.entries(n).map(function (e) {
        var t = e[0],
          n = e[1];
        return "string" == typeof n && n.startsWith("$function")
          ? "$function(){let _res=" +
              n.substring(1) +
              ';_res.id=_res.id||"' +
              t +
              '";return _res;}()'
          : n instanceof Object
          ? r(r({}, n), {
              id: t,
            })
          : n;
      });
    }

    function o(e) {
      return "$" + e.toString();
    }

    function a(e) {
      return Object.entries(e).map(function (e) {
        return {
          id: e[0],
          formula: o(e[1]).slice(1),
        };
      });
    }

    function s(e) {
      function t(e) {
        return i(e).map(function (e) {
          return r(r({}, e), {
            buildSteps: e.buildSteps.map(function (e) {
              var t = e.id.match(/([^:]+):(.+)/),
                n = (t[0], t[1]),
                i = t[2];
              return r(r({}, e), {
                id: i,
                type: n,
              });
            }),
          });
        });
      }
      return {
        PrepVars: a,
        PrepObject: i,
        ModelsToId: t,
        Element: Element,
        define: {
          vars: function (e) {
            return e;
          },
          textures: function (e) {
            return e;
          },
          materials: function (e, t) {
            return t;
          },
          shapes: function (e) {
            return e;
          },
          borders: function (e, t, n) {
            return n;
          },
          layers: function (e, t, n) {
            return n;
          },
          dropTargets: function (e) {
            return e;
          },
          planes: function (e, t, n, r) {
            return r;
          },
          sidings: function (e, t, n, r) {
            return r;
          },
          glassDecorations: function (e, t, n) {
            return n;
          },
          elements: function (e, t, n) {
            return n;
          },
          models: function (e, t, n, r) {
            return r;
          },
          draggableElements: function (e, t, n) {
            return n;
          },
        },
        build: function (e) {
          return {
            vars: a(e.vars),
            shapes: i(e.shapes),
            textures: i(e.textures),
            materials: i(e.materials),
            layers: i(e.layers),
            elements: i(e.elements),
            glassDecorations: i(e.glassDecorations),
            borders: i(e.layers),
            sidings: i(e.sidings),
            planes: i(e.planes),
            models: t(e.models),
            droppedElements: "$elements.droppedElements",
            draggableElements: i(e.draggableElements),
          };
        },
      };
    }
    t.a = s;
  },
  function (e, t, n) {
    /*!
     * vue-i18n v3.1.1
     * (c) 2016 kazuya kawaguchi
     * Released under the MIT License.
     */
    e.exports = (function () {
      "use strict";

      function e(e, t) {
        return f.call(e, t);
      }

      function t(t) {
        if (null == t) return !0;
        if (Array.isArray(t)) {
          if (t.length > 0) return !1;
          if (0 === t.length) return !0;
        } else if (p.Vue.util.isPlainObject(t))
          for (var n in t) if (e(t, n)) return !1;
        return !0;
      }

      function n(e) {
        if (void 0 === e) return "eof";
        var t = e.charCodeAt(0);
        switch (t) {
          case 91:
          case 93:
          case 46:
          case 34:
          case 39:
          case 48:
            return e;
          case 95:
          case 36:
            return "ident";
          case 32:
          case 9:
          case 10:
          case 13:
          case 160:
          case 65279:
          case 8232:
          case 8233:
            return "ws";
        }
        return (t >= 97 && 122 >= t) || (t >= 65 && 90 >= t)
          ? "ident"
          : t >= 49 && 57 >= t
          ? "number"
          : "else";
      }

      function r(e) {
        function t() {
          var t = e[i + 1];
          return (o === T && "'" === t) || (o === E && '"' === t)
            ? (i++, (l = "\\" + t), f[x](), !0)
            : void 0;
        }
        var r = [],
          i = -1,
          o = M,
          a = 0,
          s = void 0,
          l = void 0,
          c = void 0,
          u = void 0,
          h = void 0,
          d = void 0,
          p = void 0,
          f = [];
        for (
          f[b] = function () {
            void 0 !== c && (r.push(c), (c = void 0));
          },
            f[x] = function () {
              void 0 === c ? (c = l) : (c += l);
            },
            f[w] = function () {
              f[x](), a++;
            },
            f[_] = function () {
              if (a > 0) a--, (o = S), f[x]();
              else {
                if (
                  ((a = 0),
                  !1 ===
                    (c = (function (e) {
                      var t = v.Vue.util,
                        n = t.isLiteral,
                        r = t.stripQuotes,
                        i = e.trim();
                      return (
                        ("0" !== e.charAt(0) || !isNaN(e)) &&
                        (n(i) ? r(i) : "*" + i)
                      );
                    })(c)))
                )
                  return !1;
                f[b]();
              }
            };
          null != o;

        )
          if ((i++, "\\" !== (s = e[i]) || !t())) {
            if (((u = n(s)), (h = (p = P[o])[u] || p.else || C) === C)) return;
            if (
              ((o = h[0]),
              (d = f[h[1]]) &&
                ((l = void 0 === (l = h[2]) ? s : l), !1 === d()))
            )
              return;
            if (o === A) return (r.raw = e), r;
          }
      }

      function i(e) {
        var t = y[e];
        return t || ((t = r(e)) && (y[e] = t)), t;
      }

      function o(e, n) {
        if (!(0, v.Vue.util.isObject)(e)) return null;
        var r = i(n);
        if (t(r)) return null;
        for (var o = e, a = r.length, s = 0; a > s; ) {
          var l = o[r[s]];
          if (void 0 === l) {
            o = null;
            break;
          }
          (o = l), s++;
        }
        return o;
      }

      function a(e) {
        e.locale = function (e, t, n) {
          return void 0 === t
            ? L[e]
            : void (null === t
                ? ((L[e] = void 0), delete L[e])
                : (function (e, t, n) {
                    var r = this;
                    "object" === (void 0 === t ? "undefined" : d.typeof(t))
                      ? n(t)
                      : (function () {
                          var e = t.call(r);
                          "function" == typeof e
                            ? e.resolved
                              ? n(e.resolved)
                              : e.requested
                              ? e.pendingCallbacks.push(n)
                              : (function () {
                                  e.requested = !0;
                                  var t = (e.pendingCallbacks = [n]);
                                  e(
                                    function (n) {
                                      e.resolved = n;
                                      for (var r = 0, i = t.length; i > r; r++)
                                        t[r](n);
                                    },
                                    function () {
                                      n();
                                    }
                                  );
                                })()
                            : (function (e) {
                                return e && "function" == typeof e.then;
                              })(e) &&
                              e
                                .then(
                                  function (e) {
                                    n(e);
                                  },
                                  function () {
                                    n();
                                  }
                                )
                                .catch(function (e) {
                                  console.error(e), n();
                                });
                        })();
                  })(0, t, function (t) {
                    t
                      ? ((L[e] = t), n && n())
                      : (function (e, t) {
                          window.console &&
                            (console.warn("[vue-i18n] " + e),
                            t && console.warn(t.stack));
                        })("failed set `" + e + "` locale");
                  }));
        };
      }

      function s(e, t) {
        var n = e.prototype._init;
        e.prototype._init = function (e) {
          var r = this,
            i = ((e = e || {})._parent || e.parent || this).$lang;
          (this.$lang = i || t),
            (this._langUnwatch = this.$lang.$watch("lang", function (e, t) {
              !(function (e) {
                for (var t = e._watchers.length; t--; )
                  e._watchers[t].update(!0);
              })(r);
            })),
            n.call(this, e);
        };
        var r = e.prototype._destroy;
        e.prototype._destroy = function () {
          this._langUnwatch &&
            (this._langUnwatch(), (this._langUnwatch = null)),
            (this.$lang = null),
            r.apply(this, arguments);
        };
      }

      function l(e, t) {
        var n = (function (e) {
            if (!m) {
              var t = e.$watch("__watcher__", function (e) {});
              (m = e._watchers[0].constructor), t();
            }
            return m;
          })(t),
          r = (function (e) {
            return g || (g = e._data.__ob__.dep.constructor), g;
          })(t);
        Object.defineProperty(e.config, "lang", {
          enumerable: !0,
          configurable: !0,
          get: (function (e, t) {
            var i = new n(t, e, null, {
              lazy: !0,
            });
            return function () {
              return i.dirty && i.evaluate(), r.target && i.depend(), i.value;
            };
          })(function () {
            return t.lang;
          }, t),
          set: e.util.bind(function (e) {
            t.lang = e;
          }, t),
        });
      }

      function c(e) {
        function t() {
          for (var t = arguments.length, n = Array(t), r = 0; t > r; r++)
            n[r] = arguments[r];
          var o = e.config.lang;
          return (
            1 === n.length
              ? a(n[0]) || i(n[0])
                ? (n = n[0])
                : "string" == typeof n[0] && (o = n[0])
              : 2 === n.length &&
                ("string" == typeof n[0] && (o = n[0]),
                (a(n[1]) || i(n[1])) && (n = n[1])),
            {
              lang: o,
              params: n,
            }
          );
        }

        function n(e, t, n) {
          if (!e) return null;
          var r = o(e, t) || e[t];
          return r
            ? n
              ? (function (e) {
                  for (
                    var t = arguments.length,
                      n = Array(t > 1 ? t - 1 : 0),
                      r = 1;
                    t > r;
                    r++
                  )
                    n[r - 1] = arguments[r];
                  return (
                    1 === n.length && "object" === d.typeof(n[0]) && (n = n[0]),
                    (n && n.hasOwnProperty) || (n = {}),
                    e.replace(R, function (t, r, i, o) {
                      var a = void 0;
                      return "{" === e[o - 1] && "}" === e[o + t.length]
                        ? i
                        : null == (a = n.hasOwnProperty(i) ? n[i] : null)
                        ? ""
                        : a;
                    })
                  );
                })(r, n)
              : r
            : null;
        }
        var r = e.util,
          i = r.isArray,
          a = r.isObject;
        return (
          (e.t = function (r) {
            for (
              var i = arguments.length, o = Array(i > 1 ? i - 1 : 0), a = 1;
              i > a;
              a++
            )
              o[a - 1] = arguments[a];
            if (!r) return "";
            var s = t.apply(void 0, o),
              l = s.lang,
              c = s.params;
            return n(e.locale(l), r, c) || r;
          }),
          (e.prototype.$t = function (r) {
            if (!r) return "";
            for (
              var i = arguments.length, o = Array(i > 1 ? i - 1 : 0), a = 1;
              i > a;
              a++
            )
              o[a - 1] = arguments[a];
            var s = t.apply(void 0, o),
              l = s.lang,
              c = s.params;
            return (
              n(this.$options.locales && this.$options.locales[l], r, c) ||
              n(e.locale(l), r, c) ||
              r
            );
          }),
          e
        );
      }

      function u(e) {
        var t =
          (arguments.length <= 1 || void 0 === arguments[1] || arguments[1],
          "en");
        (v.Vue = p.Vue = e), h(e, t), a(e), s(e, I), l(e, I), c(e);
      }

      function h(e, t) {
        var n = e.config.silent;
        (e.config.silent = !0),
          I ||
            (I = new e({
              data: {
                lang: t,
              },
            })),
          (e.config.silent = n);
      }
      var d = {};
      d.typeof =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (e) {
              return typeof e;
            }
          : function (e) {
              return e &&
                "function" == typeof Symbol &&
                e.constructor === Symbol
                ? "symbol"
                : typeof e;
            };
      var p = {},
        f = Object.prototype.hasOwnProperty,
        m = void 0,
        g = void 0,
        v = {},
        y = Object.create(null),
        x = 0,
        b = 1,
        w = 2,
        _ = 3,
        M = 0,
        S = 4,
        T = 5,
        E = 6,
        A = 7,
        C = 8,
        P = [];
      (P[M] = {
        ws: [M],
        ident: [3, x],
        "[": [S],
        eof: [A],
      }),
        (P[1] = {
          ws: [1],
          ".": [2],
          "[": [S],
          eof: [A],
        }),
        (P[2] = {
          ws: [2],
          ident: [3, x],
        }),
        (P[3] = {
          ident: [3, x],
          0: [3, x],
          number: [3, x],
          ws: [1, b],
          ".": [2, b],
          "[": [S, b],
          eof: [A, b],
        }),
        (P[S] = {
          "'": [T, x],
          '"': [E, x],
          "[": [S, w],
          "]": [1, _],
          eof: C,
          else: [S, x],
        }),
        (P[T] = {
          "'": [S, x],
          eof: C,
          else: [T, x],
        }),
        (P[E] = {
          '"': [S, x],
          eof: C,
          else: [E, x],
        });
      var L = Object.create(null),
        R = /(%|)\{([0-9a-zA-Z]+)\}/g,
        I = void 0;
      return (
        (u.version = "3.1.1"),
        "undefined" != typeof window && window.Vue && window.Vue.use(u),
        u
      );
    })();
  },
  function (e, t, n) {
    "use strict";
    n.d(t, "a", function () {
      return R;
    });
    var r,
      i = n(3),
      o = n(1),
      a = n(0),
      s = n(4);

    function l() {
      ["move-hint", "drag-n-drop-hint"].forEach(function (e) {
        var t = "vsl-" + e,
          n = document.getElementById(t);
        n && (n.style.display = "none");
      });
    }
    !(function (e) {
      e.registerPolygonEditor = function (e, t) {
        var n = e.extend({
          props: ["vertices", "key", "otherpolygons", "styles", "readonly"],
          data: function () {
            return {
              itemsToMove: [],
              currentlyActiveIndices: [],
              mouseDownPoint: [0, 0],
              snapToGrid: !0,
              gridSize: 10,
              guidelinesVisible: !1,
              viewBoxCenter: [0, 0],
              viewBoxScale: 1,
              viewBox: "0 0 0 0",
            };
          },
          template:
            '\n  <div :style="{cursor:currentlyActiveIndices.length?\'move\':\'\'}">\n  <svg v-el:svg class="vsl-polygon-editor" v-el="svg"  :view-box.camel="viewBox" preserveAspectRatio="xMinYMax meet"\n    @mousedown.prevent="onMouseDown" @mousemove.prevent="onMouseMove" @mouseup.prevent="onMouseUp"\n    @wheel.stop="onMouseWheel"\n    @mouseenter="guidelinesVisible=true" @mouseleave="guidelinesVisible=false"\n    style="z-index:100"\n  >\n        <style type="text/css" >\n           <![CDATA[\n              text {\n                    font-size: {{14*viewBoxScale}}px;\n              }\n\n             line,polygon {\n              fill:none; \n              stroke-width:{{2*viewBoxScale}}px;\n             }\n\n              {{css}}   \n\n           ]]>\n        </style>\n      <defs>\n      <path v-for="edge in edges"\n      \t\t:id="\'edge\'+$index"\n          :d="edgePath(edge)"\n      />\n    </defs>\n    <template v-if="otherpolygons">\n        <polygon v-for="p in otherpolygons" :points="polygonPoints(p)" class="other" />\n    </template>\n    <template v-if="guidelinesVisible">\n        <line :x1="mouseDownPoint[0]-1000*viewBoxScale" :y1="mouseDownPoint[1]" \n              :x2="mouseDownPoint[0]+1000*viewBoxScale" :y2="mouseDownPoint[1]" \n              class="guideline" />\n        <line :x1="mouseDownPoint[0]" :y1="mouseDownPoint[1]-1000*viewBoxScale"\n              :x2="mouseDownPoint[0]" :y2="mouseDownPoint[1]+1000*viewBoxScale"\n              class="guideline" />\n        <line :x1="mouseDownPoint[0]-1000*viewBoxScale" :y1="mouseDownPoint[1]-1000*viewBoxScale" \n              :x2="mouseDownPoint[0]+1000*viewBoxScale" :y2="mouseDownPoint[1]+1000*viewBoxScale" \n              class="guideline" />\n        <line :x1="mouseDownPoint[0]+1000*viewBoxScale" :y1="mouseDownPoint[1]-1000*viewBoxScale"\n              :x2="mouseDownPoint[0]-1000*viewBoxScale" :y2="mouseDownPoint[1]+1000*viewBoxScale"\n              class="guideline" />\n    </template>\n    <ellipse v-for="vert in vertices"\n    \t\t\t\t:cx="vert[0]" :cy="vert[1]"\n            :rx="4*viewBoxScale" :ry="4*viewBoxScale" :style="pointStyle($index)"\n            />\n    <ellipse v-if="centerPoint"\n    \t\t\t\t:cx="centerPoint[0]" :cy="centerPoint[1]"\n            :rx="4*viewBoxScale" :ry="4*viewBoxScale" style="fill:darkblue"\n            />\n  \t\t<polygon :points="polygonPoints(vertices)" class="current" />\n      <polygon :points="activePolygonPoints" class="current active" />\n      <text v-for="edge in edges" :dy="-10*viewBoxScale">\n      \t\t<textpath xlink:href="#edge{{$index}}"\n          \ttext-anchor="middle"\n            startOffset="50%"\n            >\n         {{Math.round(Math.sqrt(distanceSquared(edge.v1,edge.v2)))}}\n         </textpath>\n      </text>\n  </svg>\n    <div class="vsl-input-container vsl-select" v-if="!readonly">\n        <label>Snap grid</label>\n        <select v-model="gridSize" @change.stop @input.stop number>\n            <option value="5" >50</option>\n            <option value="10" >100</option>\n            <option value="25" >250</option>\n            <option value="50" >500</option>\n            <option value="100" >1000</option>\n            <option value="250" >2500</option>\n        </select>mm\n    </div>\n    <div class="vsl-input-container vsl-select">\n        <label>Zoom</label>\n        <input type="range" v-model="viewBoxScale" @change.stop @input.stop="setViewBox()"  number :min="0.1" :max="4" :step="0.1"/>\n        <a href="#" class="zoom-button" @click.stop="zoomToFit()"><i class="fa fa-home" aria-hidden="true" style="cursor:pointer"></i></a>\n    </div>\n   </div>\n    ',
          computed: {
            activePolygonPoints: function () {
              var e = this;
              return this.currentlyActiveIndices.length < 2
                ? ""
                : this.currentlyActiveIndices
                    .map(function (t) {
                      return e.vertices[t];
                    })
                    .map(function (e) {
                      return e[0] + "," + e[1];
                    })
                    .join(" ");
            },
            css: function () {
              var e = {
                ".current": "fill:none;stroke: black",
                ".other": "fill: none;stroke: gray;",
                ".active": "stroke:darkblue",
                ".guideline":
                  "stroke:rgb(0,0,255);stroke-dasharray: " +
                  5 * this.viewBoxScale +
                  ";",
              };
              return (
                Object.assign(e, this.styles || {}),
                Object.keys(e)
                  .map(function (t) {
                    return t + " { " + e[t] + " }";
                  })
                  .join("\n")
              );
            },
            edges: function () {
              return (this.vertices || []).map(function (e, t, n) {
                return {
                  v1: e,
                  v2: n[(t + 1) % n.length],
                  i1: t,
                  i2: (t + 1) % n.length,
                };
              });
            },
            centerPoint: function () {
              if (2 == this.currentlyActiveIndices.length) {
                var e = this.vertices[this.currentlyActiveIndices[0]],
                  t = this.vertices[this.currentlyActiveIndices[1]];
                return this.divVertexByScalar(this.addVertex(e, t), 2);
              }
            },
            maxGrabDistanceInPixels: function () {
              return this.snapToGrid ? this.gridSize : 15;
            },
          },
          methods: {
            polygonPoints: function (e) {
              return (
                (e = e || []).vertices && (e = e.vertices),
                (e || [])
                  .map(function (e) {
                    return e[0] + "," + e[1];
                  })
                  .join(" ")
              );
            },
            polygonBB: function (e) {
              return (
                (e = e || []).vertices && (e = e.vertices),
                new t.Box2().setFromPoints(
                  e.map(function (e) {
                    return new t.Vector2().fromArray(e);
                  })
                )
              );
            },
            pointStyle: function (e) {
              return {
                fill:
                  this.currentlyActiveIndices.indexOf(e) >= 0
                    ? "darkblue"
                    : "gray",
                stroke: "none",
              };
            },
            edgePath: function (e) {
              var t = e.v1,
                n = e.v2;
              if (t[0] > n[0]) {
                var r = t;
                (t = n), (n = r);
              }
              return "M " + t[0] + " " + t[1] + " L " + n[0] + " " + n[1];
            },
            mouseEventToSVGPoint: function (e) {
              var t = this.$els.svg,
                n = t.createSVGPoint();
              return (
                (n.x = e.clientX),
                (n.y = e.clientY),
                (n = n.matrixTransform(t.getScreenCTM().inverse())),
                this.snapToGrid &&
                  ((n.x = Math.round(n.x / this.gridSize) * this.gridSize),
                  (n.y = Math.round(n.y / this.gridSize) * this.gridSize)),
                [n.x, n.y]
              );
            },
            square: function (e) {
              return e * e;
            },
            addVertex: function (e, t) {
              return [e[0] + t[0], e[1] + t[1]];
            },
            subVertex: function (e, t) {
              return [e[0] - t[0], e[1] - t[1]];
            },
            mulVertex: function (e, t) {
              return [e[0] + t[0], e[1] + t[1]];
            },
            divVertexByScalar: function (e, t) {
              return [e[0] / t, e[1] / t];
            },
            mulVertexByScalar: function (e, t) {
              return [e[0] * t, e[1] * t];
            },
            dotVertex: function (e, t) {
              return e[0] * t[0] + e[1] * t[1];
            },
            distanceSquared: function (e, t) {
              var n = this.subVertex(e, t);
              return this.square(n[0]) + this.square(n[1]);
            },
            distanceToEdgeSquared: function (e, t) {
              var n = this.distanceSquared(e.v1, e.v2);
              if (n <= 1) return this.distanceSquared(e.v1, t);
              var r = this.subVertex(t, e.v1),
                i = this.subVertex(e.v2, e.v1),
                o = this.dotVertex(r, i) / n,
                a = Math.max(0, Math.min(1, o)),
                s = this.mulVertexByScalar(i, a),
                l = this.addVertex(e.v1, s);
              return this.distanceSquared(l, t);
            },
            isInsidePolygon: function (e) {
              var t = e[0],
                n = e[1];
              return this.edges.reduce(function (e, r) {
                var i = r.v1[0],
                  o = r.v1[1],
                  a = r.v2[0],
                  s = r.v2[1],
                  l = o > n != s > n && t < ((a - i) * (n - o)) / (s - o) + i;
                return e ? !l : l;
              }, !1);
            },
            nearbyIndex: function (e, t, n) {
              if (!(t = t || []).length) return -1;
              var r = t.reduce(
                function (t, r, i) {
                  var o = n(r, e);
                  return o < t.distanceSquared
                    ? {
                        index: i,
                        distanceSquared: o,
                      }
                    : t;
                },
                {
                  index: -1,
                  distanceSquared: 1e4,
                }
              );
              return r.distanceSquared >
                this.square(this.maxGrabDistanceInPixels)
                ? -1
                : r.index;
            },
            relevantVertexIndices: function (e) {
              var t = this,
                n = this.nearbyIndex(e, this.vertices, function (e, n) {
                  return t.distanceSquared(e, n);
                });
              if (n >= 0) return [n];
              var r = this.nearbyIndex(e, this.edges, function (e, n) {
                return t.distanceToEdgeSquared(e, n);
              });
              if (r >= 0) {
                var i = this.edges[r];
                return [i.i1, i.i2];
              }
              return this.isInsidePolygon(e)
                ? this.vertices.map(function (e, t) {
                    return t;
                  })
                : [];
            },
            onMouseDown: function (e) {
              if (!this.readonly && this.vertices && this.vertices.length) {
                var t = this.mouseEventToSVGPoint(e);
                if (
                  ((this.itemsToMove = this.relevantVertexIndices(t)),
                  this.centerPoint &&
                    this.distanceSquared(this.centerPoint, t) <
                      this.square(this.maxGrabDistanceInPixels))
                ) {
                  var n = this.itemsToMove[0],
                    r = n + 1;
                  this.vertices.splice(n + 1, 0, this.centerPoint),
                    (this.itemsToMove = [r]);
                }
                1 === this.itemsToMove.length &&
                  this.vertices.$set(this.itemsToMove[0], t),
                  (this.currentlyActiveIndices = this.itemsToMove);
              }
            },
            onMouseMove: function (e) {
              var t = this;
              if (this.vertices && this.vertices.length) {
                var n = this.mouseEventToSVGPoint(e),
                  r = this.subVertex(n, this.mouseDownPoint);
                if (
                  ((this.mouseDownPoint = n),
                  this.itemsToMove.length && !this.readonly)
                ) {
                  this.itemsToMove.forEach(function (e) {
                    var n = t.vertices[e];
                    (n = t.addVertex(n, r)), t.vertices.$set(e, n);
                  });
                  var i = JSON.parse(JSON.stringify(this.vertices));
                  this.$dispatch("valuechanged", this.key, i);
                } else
                  (this.currentlyActiveIndices = this.relevantVertexIndices(n)),
                    e.buttons &&
                      ((this.viewBoxCenter[0] -= r[0]),
                      (this.viewBoxCenter[1] -= r[1]),
                      (this.mouseDownPoint[0] -= r[0]),
                      (this.mouseDownPoint[1] -= r[1]),
                      this.setViewBox());
              }
            },
            onMouseUp: function (e) {
              var t = this;
              this.vertices &&
                this.vertices.length &&
                (this.itemsToMove.length > 0 &&
                  this.itemsToMove.length <= 2 &&
                  this.vertices.length > 3 &&
                  this.itemsToMove.forEach(function (e) {
                    var n = t.vertices[e],
                      r = [
                        (e + 1) % t.vertices.length,
                        (e - 1 + t.vertices.length) % t.vertices.length,
                      ];
                    t.vertices = t.vertices.filter(function (e, i) {
                      return (
                        r.indexOf(i) < 0 ||
                        t.distanceSquared(e, n) >
                          t.square(t.maxGrabDistanceInPixels)
                      );
                    });
                  }),
                (this.itemsToMove = []),
                (this.currentlyActiveIndices = []),
                (this.mouseCursor = ""));
            },
            onMouseWheel: function (e) {
              var t = e.deltaY > 0 ? 0.1 : -0.1;
              (this.viewBoxScale = Math.min(
                4,
                Math.max(0.1, this.viewBoxScale - t)
              )),
                this.setViewBox();
            },
            setViewBox: function () {
              var e = this.$els.svg;
              if (e) {
                var n = new t.Vector2().fromArray(this.viewBoxCenter),
                  r = new t.Vector2(
                    e.clientWidth * this.viewBoxScale,
                    e.clientHeight * this.viewBoxScale
                  ),
                  i = new t.Box2().setFromCenterAndSize(n, r);
                this.viewBox = [i.min.x, i.min.y, r.x, r.y].join(" ");
              }
            },
            zoomToFit: function () {
              var e = this,
                n = this.polygonBB(this.vertices);
              this.otherpolygons.forEach(function (t) {
                return (n = n.union(e.polygonBB(t)));
              }),
                n.expandByScalar(100);
              var r = new t.Vector3();
              n.getSize(r);
              var i = this.$els.svg;
              (this.viewBoxScale = Math.max(
                r.x / i.clientWidth,
                r.y / i.clientHeight
              )),
                (this.viewBoxCenter = n.getCenter(new t.Vector3()).toArray()),
                this.setViewBox();
            },
          },
          ready: function () {
            this.zoomToFit();
          },
        });
        e.component("vsl-polygon-editor", n);
      };
    })(r || (r = {}));
    var c,
      u = function () {
        return (u =
          Object.assign ||
          function (e) {
            for (var t, n = 1, r = arguments.length; n < r; n++)
              for (var i in (t = arguments[n]))
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e;
          }).apply(this, arguments);
      };
    !(function (e) {
      e.registerJoystick = function (e) {
        var t = e.extend({
          name: "vsl-joystick",
          props: {
            movementScale: {
              default: 0.03,
            },
            position: {
              default: null,
            },
            rotation: {
              default: null,
            },
          },
          data: function () {
            return u(u({}, this.position || this.rotation), {
              dragStartTarget: void 0,
              dragLastEvent: void 0,
            });
          },
          template:
            '<div class="vsl-joystick-container"   :class="{\'vsl-joystick-round\': isRotation(), dragging: dragStartEvent }"   @mousedown="dragStart($event)" @touchstart="dragTouchStart($event)" >  <div class="vsl-joystick-inner-container"   :class="{\'vsl-joystick-round\': isRotation()}"   ></div>  <div class="joystick-center "        :class="{\'vsl-joystick-round\': isRotation()}"></div>"  <div class="joystick-handle "        :class="{\'vsl-joystick-round\': isRotation()}"    :style="handleStyle()" ><slot></slot></div></div>',
          methods: {
            isRotation: function () {
              return this.rotation;
            },
            attachEvents: function () {
              document.addEventListener("mousemove", this.dragMove),
                document.addEventListener("touchmove", this.dragTouchMove),
                document.addEventListener("mouseup", this.dragStop),
                document.addEventListener("touchend", this.dragStop);
            },
            detachEvents: function () {
              document.removeEventListener("mousemove", this.dragMove),
                document.removeEventListener("touchmove", this.dragTouchMove),
                document.removeEventListener("mouseup", this.dragStop),
                document.removeEventListener("touchend", this.dragStop);
            },
            handleStyle: function () {
              var e = this.x,
                t = this.y;
              if (this.rotation) {
                var n = Math.sin(t) / 2;
                (t = -Math.sin(e) / 2), (e = n);
                var r = Math.max(Math.sqrt(e * e + t * t), 1);
                (e /= r), (t /= r), (e += 0.5), (t += 0.5);
              }
              return {
                left: 100 * e + "%",
                top: 100 * t + "%",
              };
            },
            moveInRange: function (e, t) {
              if (this.rotation) {
                var n = e;
                (e = -t), (t = n);
              }
              (e *= this.movementScale),
                (t *= this.movementScale),
                this.rotation && ((e *= Math.PI), (t *= Math.PI));
              var r = {
                min: 0,
                max: 1,
              };
              this.rotation &&
                (r = {
                  min: -Math.PI / 2,
                  max: Math.PI / 2,
                });
              var i = Math.max(r.min, Math.min(r.max, this.x + e)),
                o = Math.max(r.min, Math.min(r.max, this.y + t));
              (this.x = i),
                (this.y = o),
                this.$emit("change", {
                  x: i,
                  y: o,
                });
            },
            dragTouchStart: function (e) {
              this.dragStart({
                preventDefault: function () {},
                screenX: e.changedTouches[0].screenX,
                screenY: e.changedTouches[0].screenY,
                target: e.target,
                type: e.type,
              });
            },
            dragStart: function (e) {
              (this.dragStartTarget = {
                clientWidth: e.target.clientWidth,
                clientHeight: e.target.clientHeight,
              }),
                (this.dragLastEvent = {
                  screenX: e.screenX,
                  screenY: e.screenY,
                }),
                (this.dragStarted = !0),
                this.$emit("startdrag"),
                e.preventDefault(),
                this.attachEvents();
            },
            dragStop: function (e) {
              this.dragStarted &&
                ((this.dragStarted = !1),
                (this.dragLastEvent = null),
                this.$emit("stopdrag"),
                e.preventDefault(),
                this.detachEvents());
            },
            dragTouchMove: function (e) {
              this.dragMove({
                preventDefault: function () {},
                screenX: e.changedTouches[0].screenX,
                screenY: e.changedTouches[0].screenY,
                target: e.target,
              });
            },
            dragMove: function (e) {
              if (this.dragLastEvent) {
                var t =
                    (e.screenX - this.dragLastEvent.screenX) /
                    this.dragStartTarget.clientWidth,
                  n =
                    (e.screenY - this.dragLastEvent.screenY) /
                    this.dragStartTarget.clientHeight;
                (this.dragLastEvent = {
                  screenX: e.screenX,
                  screenY: e.screenY,
                }),
                  this.moveInRange(t, n),
                  e.preventDefault();
              }
            },
          },
        });
        e.component("vsl-joystick", t);
      };
    })(c || (c = {}));
    var h,
      d,
      p,
      f,
      m,
      g,
      v = function () {
        return (v =
          Object.assign ||
          function (e) {
            for (var t, n = 1, r = arguments.length; n < r; n++)
              for (var i in (t = arguments[n]))
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e;
          }).apply(this, arguments);
      },
      y = s.a.getRalDict();

    function x(e, t, n) {
      return n.indexOf(e) === t;
    }
    r.registerPolygonEditor(o, a),
      c.registerJoystick(o),
      (d = h || (h = {})),
      (p = {}),
      (f = {}),
      (m = (function () {
        function e() {
          this.components = {};
        }
        return (
          (e.prototype.clone = function () {
            var t = new e();
            return (t.components = this.components), t;
          }),
          (e.prototype.register = function (e, t) {
            return (this.components["c-" + e] = t), this;
          }),
          (e.prototype.getVueClass = function (e, t, n, r, i) {
            function s(e) {
              return e ? (Array.isArray(e) ? e.join("\n") : e) : "";
            }
            void 0 === i && (i = !0);
            var l =
              "<div>" +
              e
                .map(function (e, t) {
                  return (function e(t, n) {
                    var r =
                        s(t.templatePrefix) +
                        '\n                        <component is="c-' +
                        t.kind +
                        '" \n                                    :opts="(' +
                        n +
                        '.opts||{})" \n                        ',
                      i = t.key;
                    return (
                      i &&
                        (r +=
                          ":value='" +
                          i +
                          "' key='" +
                          i +
                          "' \n                    @change.stop='onInput($event,\"" +
                          i +
                          "\")' \n                    @input.stop='onInput($event,\"" +
                          i +
                          "\")' \n                    @valuechanged='onValueChanged' "),
                      (r += ">\n"),
                      (r += (t.children || [])
                        .map(function (t, r) {
                          return e(t, n + ".children[" + r + "]");
                        })
                        .join("\n")),
                      (r +=
                        "</component>\n                        " +
                        s(t.templatePostfix))
                    );
                  })(e, "guiElements[" + t + "]");
                })
                .join("\n");
            i &&
              (l +=
                '\n<div v-if="allDraggables.length" >\n    <div class="vsl-draggables">\n      <h3>{{$t("Drag these elements")}}</h3>\n      <template v-for="(category,draggables) in draggableGroups" :key="category">\n        <h4>{{$t(category)}}</h4>\n        <div class="vsl-input-container vsl-imagelist">\n          <label v-for="(key,draggable) in draggables">\n          <img  :src="imageFor(draggable)" :key="category+key"\n            @pointerdown.stop="setPotentialDraggable(draggable),setHovered(draggable)"\n            @pointermove.stop="maybeStartDrag($event)" \n            @pointerenter.stop="setHovered(draggable)"\n            @pointerleave.stop="setHovered(null)"\n          />\n          <div class="vsl-imagelist-label">{{$t(draggable.elementId)}}</div>\n          </label>\n        </div>\n      </template>\n    </div>\n</div>'),
              (l += "</div>");
            var c = null;
            return o.extend({
              computed: {
                guiElements: {
                  get: function () {
                    return e;
                  },
                },
                dragNDrop: {
                  cache: !1,
                  get: function () {
                    return n;
                  },
                },
                allDraggables: {
                  cache: !1,
                  get: function () {
                    this.draggableFlag;
                    var e = this.dragNDrop,
                      t = e.dropTargets
                        .filter(function (t) {
                          return (
                            e.activeDropTargetIds.indexOf(t.dropTargetId) > -1
                          );
                        })
                        .map(function (e) {
                          return e.dropTargetId;
                        })
                        .filter(x);
                    return e.draggables.filter(function (e) {
                      return e.allowedDropTargets.some(function (e) {
                        return -1 !== t.indexOf(e);
                      });
                    });
                  },
                },
                draggableGroups: {
                  cache: !1,
                  get: function () {
                    this.draggableFlag;
                    var e = {};
                    return (
                      this.allDraggables.map(function (t) {
                        var n = t.category || " ";
                        e[n] || (e[n] = []), e[n].push(t);
                      }),
                      e
                    );
                  },
                },
              },
              data: function () {
                return {
                  draggableFlag: 1,
                  hovered: "",
                  privateCurrentCategory: "",
                };
              },
              ready: function () {
                this.$nextTick(function () {
                  this.draggableFlag += 1;
                });
              },
              methods: {
                onInput: function (e, t) {
                  var n;
                  e && e.detail && e.detail.value
                    ? (n = e.detail.value)
                    : e &&
                      e.target &&
                      ((n = e.target.value),
                      (n =
                        e.target.attributes.type &&
                        "checkbox" === e.target.attributes.type.value
                          ? e.target.checked
                          : parseFloat(n) == n
                          ? parseFloat(n)
                          : e.target.value)),
                    (this.draggableFlag += 1),
                    this.$emit("propertyupdated", t, n);
                },
                onValueChanged: function (e, t) {
                  (this.draggableFlag += 1),
                    this.$emit("propertyupdated", e, t);
                },
                imageFor: function (e) {
                  return (function (e, t) {
                    var n = !!p[e.elementId];
                    if (n) {
                      var r = JSON.stringify({
                        opts: e.opts,
                        wopts: e.windowOpts,
                      });
                      r != f[e.elementId] && ((n = !1), (f[e.elementId] = r));
                    }
                    if (!n) {
                      var i = e.intersectable.object.clone();
                      if (((i.visible = !0), e.renderImage)) {
                        var o = new a.Object3D();
                        o.add(i);
                        var s = v(
                            {
                              position: [0, 0, 0],
                              rotation: [0, 0, 0],
                              scale: [1, 1, 1],
                            },
                            e.renderImage
                          ),
                          l = s.position,
                          c = s.rotation,
                          u = s.scale;
                        (i.rotation.x += c[0]),
                          (i.position.x += l[0]),
                          (i.scale.x *= u[0]),
                          (i.rotation.y += c[1]),
                          (i.position.y += l[1]),
                          (i.scale.y *= u[1]),
                          (i.rotation.z += c[2]),
                          (i.position.z += l[2]),
                          (i.scale.z *= u[2]),
                          (i = o);
                      }
                      (i.rotation.x += 1.15 * Math.PI),
                        (i.rotation.y += -0.15 * Math.PI);
                      var h = t.renderToPng(i, 100, !0);
                      "data:," == h && (h = t.renderToPng(i, 100, !0)),
                        (p[e.elementId] = h);
                    }
                    return p[e.elementId];
                  })(e, r);
                },
                setPotentialDraggable: function (e) {
                  c = e.elementId;
                },
                maybeStartDrag: function (e) {
                  e.buttons && c && (n.beginDrag(c, e), (c = null)),
                    n.processPointerEvent(e);
                },
                setHovered: function (e) {
                  this.hovered = e ? this.$t(e.id) : null;
                },
              },
              template: l,
              components: this.components,
            });
          }),
          e
        );
      })()),
      (g = (function () {
        function e(e, t, n) {
          var r = e.renderer;
          (this.componentBuilder = new m()),
            this.componentBuilder.register(
              "slider",
              o.extend({
                props: ["opts", "value", "key"],
                ready: function () {
                  !(function (e, t) {
                    void 0 === t && (t = null);
                    var n = "vsl-" + e;
                    if (!document.getElementById(n)) {
                      var r = t ? document.getElementById(t) : document.body;
                      if (!r)
                        return (
                          console.error("element with id " + t + " not found"),
                          !1
                        );
                      var i = document.createElement("div");
                      (i.id = n),
                        i.classList.add("vsl-hint", "vsl-hint-hand"),
                        r.appendChild(i);
                    }
                  })("move-hint"),
                    this.value > this.opts.max
                      ? this.$dispatch("valuechanged", this.key, this.opts.max)
                      : this.value < this.opts.min &&
                        this.$dispatch("valuechanged", this.key, this.opts.min);
                },
                template:
                  '\n                <div class="vsl-input-container vsl-slider" :class="{\'multi-line\': opts.multiLine}">\n                <label>{{$t(opts.label)}} </label>\n                 <input v-model="value" type="range" min="{{opts.min}}" max="{{opts.max}}" step="{{opts.step}}" number @change.stop="onChange" @input.stop="onChange"/>\n                 <input v-model="value" type="number" min="{{opts.min}}" max="{{opts.max}}" step="1" number @change.stop="onChange" @input.stop="onChange"/> {{opts.unit}}\n                </div>',
                methods: {
                  onChange: function (e) {
                    var t = parseFloat(e.target.value);
                    (t = Math.max(Math.min(t, this.opts.max), this.opts.min)),
                      this.$dispatch("valuechanged", this.key, t);
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "number",
              o.extend({
                props: ["opts", "value", "key"],
                ready: function () {
                  this.value > this.opts.max
                    ? this.$dispatch("valuechanged", this.key, this.opts.max)
                    : this.value < this.opts.min &&
                      this.$dispatch("valuechanged", this.key, this.opts.min);
                },
                template:
                  '\n                <div class="vsl-input-container vsl-slider" :class="{\'multi-line\': opts.multiLine}">\n                <label>{{$t(opts.label)}} </label>\n                 <input v-model="value" type="number" min="{{opts.min}}" max="{{opts.max}}" step="{{opts.step}}" number @change.stop="onChange" @input.stop="onChange"/> {{opts.unit}}\n                </div>',
                methods: {
                  onChange: function (e) {
                    var t = parseFloat(e.target.value);
                    (t = Math.max(Math.min(t, this.opts.max), this.opts.min)),
                      this.$dispatch("valuechanged", this.key, t);
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "wrapper",
              o.extend({
                props: ["opts"],
                template:
                  '\n                <div class="vsl-wrapper">\n                  <slot></slot>\n                </div>',
              })
            ),
            this.componentBuilder.register(
              "ralcode",
              o.extend({
                props: ["value", "opts", "key"],
                data: function () {
                  return {
                    ralCodes:
                      this.opts && this.opts.codes ? this.opts.codes : y.codes,
                    colorPickerVisible: !1,
                  };
                },
                computed: {
                  info: function () {
                    return this.getInfo(this.value);
                  },
                  isColorPickerVisible: function () {
                    return this.colorPickerVisible || this.opts.alwaysExpand;
                  },
                },
                methods: {
                  toggleVisibility: function () {
                    this.colorPickerVisible = !this.colorPickerVisible;
                  },
                  setRalCode: function (e) {
                    this.toggleVisibility(), (this.value = e.target.value);
                    var t = this.$el.querySelector("input");
                    (t.value = e.target.value),
                      this.$dispatch("valuechanged", this.key, t.value);
                  },
                  getInfo: function (e) {
                    return y.getCode(e);
                  },
                  getInfoStyle: function (e) {
                    var t = y.getCode(e),
                      n = parseInt(t.rgbHex.substring(1), 16),
                      r = (n >> 16) & 255,
                      i = (n >> 8) & 255,
                      o = (n >> 0) & 255,
                      a = r * r + i * i + o * o < 49152;
                    return {
                      backgroundColor: t.rgbHex,
                      color: a ? "white" : "black",
                    };
                  },
                },
                template:
                  '\n            <div class="vsl-input-container vsl-ral-picker">\n                <input type="hidden" :value.sync="value" />\n                <label>{{this.$t(opts.label)}} </label> \n                <input class="vsl-ral-main-button" type="button" :value="value" @click="toggleVisibility"\n                       :style="getInfoStyle(info.code)"  /><span> {{info.name}}</span>\n                <div v-if="isColorPickerVisible" class="vsl-ral-picker-inner-container" :style="{maxHeight: opts.containerHeight}">\n                    <input type="button" v-for="ralCode in ralCodes"\n                     class="vsl-ral-color-button"\n                     :style="getInfoStyle(ralCode)"\n                     :value="ralCode" @click="setRalCode"/>\n                </div>\n            </div>',
              })
            ),
            this.componentBuilder.register(
              "checkbox",
              o.extend({
                props: ["value", "opts"],
                template:
                  '\n            <div class="vsl-input-container vsl-checkbox">\n              <label> <input v-model="value" type="checkbox" /> {{$t(opts.label)}} </label>\n            </div>',
              })
            ),
            this.componentBuilder.register(
              "navigate3D",
              o.extend({
                props: ["value", "opts"],
                template:
                  '\n            <div class="vsl-input-container vsl-navigator3d">\n                <table>\n                    <tr>\n                        <td>\n                           <a class="btn btn-primary" v-on:click=\'ortho(0.5,0.2,-0.5)\'>Left-front</a>\n                        </td>\n                                                <td>\n                            <a class="btn btn-primary" v-on:click=\'ortho(0,0,-1)\'>Front</a>\n                        </td>\n                    <tr/>\n                    <tr>\n                        <td>\n                            <a class="btn btn-primary" v-on:click=\'ortho(1,0,0)\'>Left</a>\n                        </td>\n                        <td>\n                           <a class="btn btn-primary" v-on:click=\'ortho(0,1,0)\'>Top</a>\n                        </td>\n\n                        <td>\n                            <a class="btn btn-primary" v-on:click=\'ortho(-1,0,0)\'>Right</a>\n                        </td>\n                      </tr>\n                      <tr>\n                        <td>\n                          <a class="btn btn-primary" v-on:click=\'perspective()\'>Perspective</a>\n                        </td>\n                        <td>\n                            <a class="btn btn-primary" v-on:click=\'ortho(0,0,1)\'>Back</a>\n                        </td>\n                        <td>\n                           <a class="btn btn-primary" v-on:click=\'ortho(-0.5,0.2,0.5)\'>Right-back</a>\n                        </td>\n                      </tr>\n                </table>\n            </div>',
                methods: {
                  ortho: function (t, n, r) {
                    e.cameraCombiner.toOrthographic(),
                      e.lookAtObject(
                        "Woohoo",
                        1e3 * t,
                        1e3 * n,
                        1e3 * r,
                        function () {
                          0 === t &&
                            0 === r &&
                            ((e.controls.minAzimuthAngle = Math.PI),
                            (e.controls.maxAzimuthAngle = Math.PI),
                            e.controls.update(),
                            (e.controls.minAzimuthAngle = -1 / 0),
                            (e.controls.maxAzimuthAngle = 1 / 0));
                        }
                      ),
                      (e.controls.enableRotate = !1);
                  },
                  perspective: function () {
                    e.cameraCombiner.toPerspective(),
                      (e.controls.enableRotate = !0);
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "textbox",
              o.extend({
                props: ["value", "opts"],
                template:
                  '\n            <div class="vsl-input-container vsl-textbox">\n              <label v-if="opts.label"> {{$t(opts.label)}} </label>\n               <input :value.sync="value" type="textbox" :placeholder="opts.placeholder" :style="opts.style" /> \n            </div>',
              })
            ),
            this.componentBuilder.register(
              "pdf",
              o.extend({
                props: ["value", "opts"],
                template:
                  '<button @click="printPlanViews"> Print to PDF </button>',
                methods: {
                  printPlanViews: function () {
                    this.$parent.printPlanViews();
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "select",
              o.extend({
                props: ["value", "opts"],
                template:
                  '\n            <div class="vsl-input-container vsl-select" :class="{\'multi-line\': opts.multiLine}">\n                <label> {{$t(opts.label)}} </label>\n                <select :v-model="value" :value="value">\n                    <option v-for="item in opts.items" :value="item.key">{{$t(item.label)}}</option>\n                </select>\n            </div>\n            ',
              })
            ),
            this.componentBuilder.register(
              "imagelist",
              o.extend({
                props: ["value", "opts"],
                template:
                  '\n            <div class="vsl-input-container vsl-imagelist" >\n                <label v-for="item in opts.items"> \n                    <input type="radio" v-model="value" :value="item.key" />\n                    <img :alt="item.label||item.key" :src="opts.imagesPath+item.key+opts.imagesExtension"/>\n                    <div v-if="item.label" class="vsl-imagelist-label">{{$t(item.label)}}</div>\n                </label>\n            </div>\n            ',
              })
            ),
            this.componentBuilder.register(
              "contact",
              o.extend({
                props: ["opts"],
                data: function () {
                  return this.$parent.$data;
                },
                template:
                  '<div v-if="wasSubmitted"><form v-if="canOverwrite" @submit.prevent="this.submitForm($event)"><input type="submit" class="btn btn-primary" :value="$t(opts.saveButtonText||\'savebutton\')" /></form></div><div v-else class="contact-form"><form @submit.prevent="this.submitForm($event)"><input v-if="isUsed(\'name\')" :placeholder="$t(\'name\')" type="text" v-model="contact.name" :required="isRequired(\'name\')" /><span class="status"></span><input v-if="isUsed(\'firstName\')" :placeholder="$t(\'firstName\')" type="text" v-model="contact.firstName" :required="isRequired(\'firstName\')" /><span class="status"></span><input v-if="isUsed(\'email\')" :placeholder="$t(\'email\')" name="email" type="email" v-model="contact.email" :required="isRequired(\'email\')" /><span class="status"></span><input v-if="isUsed(\'street\')" :placeholder="$t(\'street\')" class="two-thirds" type="text" v-model="contact.street" :required="isRequired(\'street\')" /><span class="status"></span><input v-if="isUsed(\'number\')" :placeholder="$t(\'nr\')" class="one-third" type="text" v-model="contact.housenumber" :required="isRequired(\'number\')"/><span class="status"></span><input v-if="isUsed(\'zip\')" :placeholder="$t(\'zip\')" class="one-third" type="text" v-model="contact.zip" :required="isRequired(\'zip\')" /><span class="status"></span><input v-if="isUsed(\'city\')" :placeholder="$t(\'city\')" class="two-thirds" type="text" v-model="contact.city" :required="isRequired(\'city\')" /><span class="status"></span><input v-if="isUsed(\'phone\')" :placeholder="$t(\'phone\')" type="tel" v-model="contact.phone" :required="isRequired(\'phone\')" /><span class="status"></span><textarea v-if="isUsed(\'remarks\')" :placeholder="$t(\'remarks\')" v-model="contact.remarks" :required="isRequired(\'remarks\')"></textarea><p v-if="resultUrl">Saved: <a :href="resultUrl"> Link </a></p><div v-else><div v-if="isUsed(\'locator\')" style="height:3em;margin-top:1em;"><a v-if="vars.tenant==\'brustor\'" id="dealer-button" href="#" class="btn btn-primary" onclick="openDealerLocator(event)">{{$t("locateDealer")}}</a></div><div v-if="isUsed(\'subscribeNewsletter\')" class="vsl-checkbox"  key="contact.subscribeNewsletter"><label><input type="checkbox" style="width:2em" v-model="contact.subscribeNewsletter">{{$t(\'subscribeNewsletter\')}}</label></div><div v-if="isUsed(\'GDPR\')" class="gdpr-line"><input type="checkbox" name="gdpr-check" v-model="contact.agreesWithTerms"/><label for= "gdpr-check">I agree to the <a class="gdpr-more">terms &amp; conditions</a><div class="gdpr-explanation">Virtual Sales Lab acts as a data processor: <ul><li>We forward your data to the supplier.</li><li>The supplier has confirmed to us that they comply to the GDPR law. </li><li> We keep your data in our internal database for 3 months.</li><li>After 3 months we anonymize the data, so it no longer references you. </li><li>All our internal log files are cleared within 30 days.</li></ul></div></label></div><input type="submit" class="btn btn-primary" id="send3Dlead" :value="$t(opts.saveButtonText||\'savebutton\')" :disabled="!(isUsed(\'GDPR\') || !contact.agreesWithTerms)"/></div><div v-if="isUsed(\'GDPR message\')" class="gdpr-line"><label for= "gdpr-check">By clicking the above button you agree to the <a class="gdpr-more">terms &amp; conditions</a><div class="gdpr-explanation">Virtual Sales Lab acts as a data processor: <ul><li>We forward your data to the supplier.</li><li>The supplier has confirmed to us that they comply to the GDPR law. </li><li> We keep your data in our internal database for 3 months.</li><li>After 3 months we anonymize the data, so it no longer references you. </li><li>All our internal log files are cleared within 30 days.</li></ul></div></label></div></form></div>',
                methods: {
                  submitForm: function (t) {
                    var n = this;
                    if (!document.body.classList.contains("saving")) {
                      document.body.classList.add("saving");
                      var r = new XMLHttpRequest();
                      return (
                        this.$parent.updateMesh(),
                        this.$set("meta.designId", id),
                        this.$set("meta.designer", designType),
                        this.$set("meta.urlReferrer", document.referrer),
                        e.screenshotAsBase64EncodedJpg(
                          function (e) {
                            var t = {
                                id: n.designId,
                                json: JSON.stringify(n.$data),
                                imageData: e.replace(
                                  /^data:image\/(png|jpg);base64,/,
                                  ""
                                ),
                              },
                              i = postUrl.split(
                                "https://productconfigurator.virtualsaleslab.com/"
                              );
                            i[i.length - 1] = i[i.length - 1].replace(
                              /\-/g,
                              "https://productconfigurator.virtualsaleslab.com/"
                            );
                            var o,
                              a,
                              s,
                              l = i.join(
                                "https://productconfigurator.virtualsaleslab.com/"
                              ),
                              c = n.$get("vars.customRedirectFunction");
                            (o = postUrl),
                              (a = t),
                              (s = function (e) {
                                if (200 != r.status)
                                  return (
                                    alert(
                                      "An error occured during save. If this happens again, please send an email to info@virtualsaleslab.com"
                                    ),
                                    void document.body.classList.remove(
                                      "saving"
                                    )
                                  );
                                this.$emit("posted", r.responseText);
                                var t = window.ga;
                                t &&
                                  t(
                                    "send",
                                    "event",
                                    "contactform",
                                    "submitted"
                                  );
                                var n = JSON.parse(r.responseText);
                                (l = n.url || l),
                                  c && (l = c(l)),
                                  this.redirectAfterPost
                                    ? window.location.assign(l)
                                    : ((this.meta.wasSubmitted = !0),
                                      (this.resultUrl = l)),
                                  document.body.classList.remove("saving");
                              }.bind(n)),
                              (a = JSON.stringify(a)),
                              r.open("POST.html", o),
                              r.setRequestHeader(
                                "Content-Type",
                                "application/json;charset=UTF-8"
                              ),
                              (r.onload = s),
                              r.send(a);
                          },
                          {
                            resize: !0,
                          }
                        ),
                        !1
                      );
                    }
                  },
                  isRequired: function (e) {
                    return (
                      -1 !==
                      (
                        this.opts.requiredFields || [
                          "name",
                          "email",
                          "zip",
                          "city",
                          "phone",
                        ]
                      ).indexOf(e)
                    );
                  },
                  isUsed: function (e) {
                    return (
                      -1 !==
                      (
                        this.opts.usedFields || [
                          "name",
                          "email",
                          "street",
                          "number",
                          "zip",
                          "city",
                          "phone",
                          "remarks",
                          "GDPR message",
                        ]
                      ).indexOf(e)
                    );
                  },
                },
                computed: {
                  redirectAfterPost: function () {
                    return this.opts.redirectAfterPost;
                  },
                  wasSubmitted: function () {
                    return this.meta.wasSubmitted || window.serverParameters;
                  },
                  canOverwrite: function () {
                    return (
                      this.wasSubmitted &&
                      (this.meta.allowEdit || (this.meta.loginRequired && t))
                    );
                  },
                },
                locales: {
                  en: {
                    name: "Name",
                    firstName: "First name",
                    mail: "email@domain.com",
                    street: "Street",
                    nr: "N°",
                    zip: "ZIP",
                    city: "City",
                    phone: "Phone number",
                    savebutton: "Send",
                    remarks: "Remarks",
                    subscribeNewsletter:
                      "My data may be used to get more information about our products.",
                  },
                  nl: {
                    name: "Naam",
                    firstName: "Voornaam",
                    mail: "email@domain.com",
                    street: "Straat",
                    nr: "Nr",
                    zip: "Postcode",
                    city: "Stad",
                    phone: "Telefoonnummer",
                    savebutton: "Verzend",
                    remarks: "Opmerkingen",
                    subscribeNewsletter:
                      "Mijn gegevens mogen gebruikt worden om meer info te krijgen over onze producten.",
                  },
                  de: {
                    name: "Name",
                    firstName: "Vorname",
                    mail: "email@domain.com",
                    street: "Straße",
                    nr: "N°",
                    zip: "Postleitzahl",
                    city: "Stadt",
                    phone: "Telefonnummer",
                    savebutton: "Senden",
                    remarks: "Bemerkungen",
                    subscribeNewsletter:
                      "Meine Daten dürfen verwendet werden, um weitere Informationen zu unseren Produkten zu erhalten.",
                  },
                  fr: {
                    name: "Nom",
                    firstName: "Prénom",
                    mail: "email@domain.com",
                    street: "Rue",
                    nr: "N°",
                    zip: "Code Postal",
                    city: "Localité",
                    phone: "N° de téléphone",
                    savebutton: "Envoyer",
                    remarks: "Remarques",
                    subscribeNewsletter:
                      "Mes données peuvent être utilisées pour obtenir plus d'informations sur nos produits.",
                  },
                  it: {
                    name: "Nome",
                    firstName: "Prenome",
                    mail: "email@domain.com",
                    street: "Strada",
                    nr: "N°",
                    zip: "ZIP",
                    city: "Città",
                    phone: "N° di telephono",
                    savebutton: "Invia",
                    remarks: "Osservazioni",
                    subscribeNewsletter:
                      " I miei dati possono essere utilizzati per ricevere informazioni su nostri prodotti",
                  },
                  es: {
                    name: "Nombre",
                    firstName: "Primer nombre",
                    mail: "email@domain.com",
                    street: "Calle",
                    nr: "Nr",
                    zip: "CP",
                    city: "Ciudad",
                    phone: "Tel",
                    savebutton: "Enviar",
                    remarks: "Observaciones",
                    subscribeNewsletter:
                      "Mis datos se pueden utilizar para obtener más información sobre nuestros productos.",
                  },
                  pt: {
                    name: "Nome",
                    firstName: "Pr. nome",
                    mail: "email@domain.com",
                    street: "Rua",
                    nr: "N°",
                    zip: "ZIP",
                    city: "Cidade",
                    phone: "N° de telefone",
                    savebutton: "Enviar",
                    remarks: "Observações",
                    subscribeNewsLetter:
                      "Meus dados podem ser usados para obter mais informações sobre nossos produtos.",
                  },
                  ru: {
                    name: "Фамилия",
                    firstName: "Имя",
                    mail: "email@domain.com",
                    street: "Улица",
                    nr: "H.P.",
                    zip: "почтовый индекс",
                    city: "город",
                    phone: "телефон",
                    savebutton: "Отправить",
                    remarks: "замечания",
                    subscribeNewsLetter:
                      "Мои данные могут быть использованы для получения дополнительной информации о наших продуктах.",
                  },
                  hu: {
                    name: "vezetéknév",
                    firstName: "keresztnév",
                    mail: "email@domain.com",
                    street: "utca",
                    nr: "sz",
                    zip: "Irányítószám",
                    city: "város",
                    phone: "telefonszám",
                    savebutton: "küldeni",
                    remarks: "megjegyzések",
                    subscribeNewsLetter:
                      "Adataimat felhasználhatjuk arra, hogy további információkat szerezzünk termékeinkről.",
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "button",
              o.extend({
                props: ["opts"],
                data: function () {
                  return this.$parent.$data;
                },
                template:
                  '\n                    <div style="color: white">\n                        <a class="btn btn-primary" v-on:click=\'executeAction($event)\'>\n                            <i class="fa {{icon}}" aria-hidden="true" style="color: white"></i>\n                            {{label}}\n                        </a>\n                    </div>',
                computed: {
                  icon: function () {
                    return this.opts.icon || "fa-camera";
                  },
                  label: function () {
                    return this.opts.label || "Take a screenshot";
                  },
                },
                methods: {
                  screenshot: function () {
                    var t = this;
                    e.screenshotAsBase64EncodedJpg(function (e) {
                      fetch(e)
                        .then(function (e) {
                          return e.blob();
                        })
                        .then(function (n) {
                          switch (t.opts.action) {
                            case "screenshot":
                              var r = document.createElement("a");
                              (r.href = URL.createObjectURL(n)),
                                (r.download = "snapshot.html"),
                                r.click();
                              break;
                            case "print":
                              var i =
                                  '<!DOCTYPE html>\n                                                <html>\n                                                <head>\n                                                  <meta charset="utf-8">\n                                                  <meta name="viewport" content="width=device-width">\n                                                  <title>Snapshot</title>\n                                                </head>\n                                                <body>\n                                                    <img src="' +
                                  e +
                                  '" style="width: 100%; height: 100%">\n                                                </body>\n                                                </html>',
                                o = document.createElement("iframe");
                              document.body.appendChild(o),
                                o.contentWindow.document.open(),
                                o.contentWindow.document.write(i),
                                o.contentWindow.document.close(),
                                (o.onload = function () {
                                  o.contentWindow.document.execCommand(
                                    "print",
                                    !1,
                                    null
                                  ) ||
                                    (o.contentWindow.focus(),
                                    o.contentWindow.print()),
                                    document.body.removeChild(o);
                                });
                          }
                        });
                    });
                  },
                  executeAction: function (e) {
                    var t = this;
                    switch (this.opts.action) {
                      case "screenshot":
                      case "print":
                        this.screenshot();
                        break;
                      case "fn":
                        if (!this.opts.fn)
                          return void alert("No fn defined in opts");
                        var n = {
                            event: e,
                          },
                          r = ["event"];
                        Object.keys(this.$parent.$data).forEach(function (e) {
                          (n[e] = t.$parent.$data[e]), r.push(e);
                        });
                        var i =
                          " var " +
                          (r = r.map(function (e) {
                            return e + "=__pars__['" + e + "']";
                          })).join(",") +
                          ";" +
                          this.opts.fn +
                          ";";
                        new Function("__pars__", i)(n);
                    }
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "polygon",
              o.extend({
                props: ["value", "opts", "key"],
                data: function () {
                  return {
                    currentKeyIndex: 0,
                  };
                },
                template:
                  '\n            <div class="vsl-input-container vsl-polygon">\n                <vsl-polygon-editor \n                    :vertices="currentVertices" :key="currentKey" \n                    :view-box="opts.viewBox || 500 500 -500 -500" \n                    @change="onChange"\n                    :otherpolygons="otherPolygons"\n                    :readonly="opts.readOnly"\n                    >\n                </vsl-polygon-editor>\n                <template v-if="allKeys.length>1">\n                  <div class="vsl-input-container vsl-select">\n                    <label> {{$t(opts.label)}} </label>\n                    <select v-model="currentKeyIndex" @change.stop @input.stop>\n                        <option v-for="k in allKeys" :value="$index">{{$t(k)}}</option>\n                    </select>\n                  </div>\n                </template>\n            </div>\n            ',
                methods: {
                  onChange: function (e) {
                    this.$dispatch("change", e);
                  },
                },
                computed: {
                  allKeys: function () {
                    return [this.key].concat(this.opts.otherpolygonkeys || []);
                  },
                  allPolygons: function () {
                    var e = this,
                      t = (this.opts.otherpolygonkeys || []).map(function (t) {
                        return e.$parent.$get(t);
                      });
                    return [this.value].concat(t);
                  },
                  currentKey: function () {
                    return this.allKeys[this.currentKeyIndex];
                  },
                  otherPolygons: function () {
                    var e = this;
                    return this.allPolygons.filter(function (t, n) {
                      return n !== e.currentKeyIndex;
                    });
                  },
                  currentVertices: function () {
                    return this.allPolygons[this.currentKeyIndex];
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "floorplan",
              o.extend({
                props: ["value", "opts", "key"],
                data: function () {
                  return {
                    currentPolyIndex: 0,
                    newPolygonLabel: "",
                    newPolygonLayer: "",
                    vertices: [],
                    otherPolygons: [],
                    hiddenLayers: [],
                  };
                },
                template:
                  '\n            <div class="vsl-input-container vsl-polygon">\n                <vsl-polygon-editor \n                    :vertices="vertices" :key="key+\'[\'+currentPolyIndex+\'].vertices\'" \n                    :view-box="opts.viewBox || 500 500 -500 -500" \n                    :otherpolygons="otherPolygons"\n                    @change.stop\n                    @valuechanged.stop\n                    >\n                </vsl-polygon-editor>\n                <div class="input-line">\n                <h4>Rooms</h4>\n                    <table class="rooms">\n                        <thead>\n                           <tr>\n                                <th>{{opts.floorLabel ||\'Floor\'}}</th>\n                                <th>{{opts.roomLabel ||\'Room name\'}}</th>\n                                <th><i class="fa fa-pencil" aria-hidden="true"></i></th>\n                                <th><i class="fa fa-trash-o" aria-hidden="true"></i></th>\n                           </tr>\n                        </thead>\n                        <tbody>\n                        <tr v-for="room in value" :class="{selected: currentPolyIndex == room.index}">\n                            <td><input type="text" list="roomlayers" v-model="room.layer" @change.stop="cleanupData()" @input.stop /></td>\n                            <td><input type="text" v-model="room.label" @change.stop="cleanupData()" @input.stop  /></td>\n                            <td><a href="#" @click.stop="selectRoom(room.index)"><i class="fa fa-pencil" aria-hidden="true"></i></a></td>\n                            <td><a href="#" @click.stop="removeRoom(room.index)"><i class="fa fa-trash-o" aria-hidden="true"></i></a></td>\n                        </tr>\n                        <tr>\n                          <td><input type="text" list="roomlayers" class="new-polygon-layer" v-model="newPolygonLayer" :placeholder="(opts.floorLabel ||\'Floor\') + \' 1\'" @change.stop @input.stop /></td>\n                          <td><input type="text" v-model="newPolygonLabel" :placeholder="(opts.roomLabel || \'Room name\') + \'1\'" @change.stop @input.stop  /></td>\n                          <td><a href="#" @click.stop="addPolygon"><i class="fa fa-plus" aria-hidden="true"></i></a></td>\n                          <td><a href="#" @click.stop="resetAdd"><i class="fa fa-trash" aria-hidden="true"></i></a></td>\n                        </tr>\n                        </tbody>\n                    </table>\n                    <datalist id="roomlayers">\n                        <option v-for="layer in layers" :value="layer">\n                    </datalist>\n                    <template v-if="layers.length">\n                        <h4>Floors</h4>\n                        <table class="rooms">\n                            <thead>\n                                <tr>\n                                    <th>Layer</th>\n                                    <th><i class="fa fa-eye" aria-hidden="true"></i></th>\n                                    <th><i class="fa fa-trash-o" aria-hidden="true"></i></th>\n                                </tr>\n                            </thead>\n                            <tbody>\n                                <tr v-for="layer in layers" :class="{selected: currentPoly().layer == layer}">\n                                    <td><input type="text" list="roomlayers" :value="layer" @change.stop="changeLayer(layer,$event)" @input.stop /></td>\n                                    <td><a href="#" @click.stop="toggleLayerVisibility(layer)">\n                                            <i v-if="hiddenLayers.indexOf(layer)==-1" class="fa fa-eye" aria-hidden="true"></i>\n                                            <i v-else class="fa fa-eye-slash" aria-hidden="true"></i>\n                                            </a></td>\n                                    <td><a href="#" @click.stop="removeLayer(layer)"><i class="fa fa-trash-o" aria-hidden="true"></i></a></td>\n                                </tr>\n                            </tbody>\n                        </table>\n                    </template>\n                </div>\n            </div>\n            ',
                methods: {
                  onChange: function (e) {
                    (this.currentPoly().vertices = this.vertices),
                      this.$dispatch("valuechanged", this.key, this.value);
                  },
                  toggleLayerVisibility: function (e) {
                    var t = this.hiddenLayers.indexOf(e);
                    t > -1
                      ? this.hiddenLayers.splice(t, 1)
                      : this.hiddenLayers.push(e),
                      this.setCurrentPoly();
                  },
                  changeLayer: function (e, t) {
                    this.value.forEach(function (n) {
                      n.layer == e && (n.layer = t.target.value);
                    }),
                      this.cleanupData();
                  },
                  removeLayer: function (e, t) {
                    for (var n = this.value.length - 1; n >= 0; n--)
                      this.value[n].layer === e && this.removeRoom(n);
                    this.cleanupData();
                  },
                  resetAdd: function () {
                    (this.newPolygonLayer = ""), (this.newPolygonLabel = "");
                  },
                  addPolygon: function (e) {
                    var t = this,
                      n = {
                        index: this.value.length,
                        layer: this.newPolygonLayer,
                        label: this.newPolygonLabel,
                        vertices: [
                          [50, 350],
                          [50, 50],
                          [350, 50],
                          [350, 350],
                        ],
                      };
                    this.value.push(n),
                      this.cleanupData(),
                      (this.currentPolyIndex = n.index),
                      (this.vertices = n.vertices),
                      this.$dispatch("valuechanged", this.key, this.value),
                      (this.newPolygonLabel = ""),
                      (this.newPolygonLayer = ""),
                      o.nextTick(function () {
                        t.$el.querySelector(".zoom-button").click(),
                          t.$el.querySelector(".new-polygon-layer").focus();
                      }),
                      this.setCurrentPoly();
                  },
                  setCurrentPoly: function (e) {
                    var t = this;
                    (this.vertices = this.currentPoly().vertices),
                      (this.otherPolygons = this.value
                        .filter(function (e) {
                          return (
                            e.index !== t.currentPolyIndex &&
                            -1 === t.hiddenLayers.indexOf(e.layer)
                          );
                        })
                        .map(function (e) {
                          return e.vertices;
                        }));
                  },
                  currentPoly: function () {
                    var e = this,
                      t = this.value.filter(function (t) {
                        return t.index === e.currentPolyIndex;
                      })[0];
                    return (t = t || {
                      index: this.currentPolyIndex,
                      label: "unknown",
                      layer: "unknown",
                      vertices: [],
                    });
                  },
                  selectRoom: function (e) {
                    (this.currentPolyIndex = e), this.setCurrentPoly();
                  },
                  removeRoom: function (e) {
                    this.value.splice(e, 1),
                      this.value.forEach(function (e, t) {
                        return (e.index = t);
                      }),
                      (this.currentPolyIndex = Math.max(
                        this.currentPolyIndex,
                        0
                      )),
                      this.setCurrentPoly();
                  },
                  cleanupData: function () {
                    this.value.sort(function (e, t) {
                      return (
                        e.layer + "////" + e.label > t.layer + "////" + t.label
                      );
                    }),
                      this.value.forEach(function (e, t) {
                        return (e.index = t);
                      });
                  },
                },
                computed: {
                  allKeys: function () {
                    return this.value.map(function (e) {
                      return e.index;
                    });
                  },
                  currentKey: function () {
                    return this.currentPolyIndex;
                  },
                  layers: function () {
                    return this.value
                      .map(function (e) {
                        return e.layer;
                      })
                      .filter(function (e, t, n) {
                        return n.indexOf(e) === t;
                      });
                  },
                },
                watch: {
                  vertices: function (e, t) {
                    (this.currentPoly().vertices = e),
                      this.$dispatch("valuechanged", this.key, this.value);
                  },
                },
                ready: function () {
                  var e = this;
                  this.setCurrentPoly(),
                    o.nextTick(function () {
                      e.$el.querySelector(".zoom-button").click(),
                        e.$el.querySelector(".new-polygon-layer").focus();
                    });
                },
              })
            ),
            this.componentBuilder.register(
              "panouploader",
              o.extend({
                props: ["value", "opts", "key"],
                data: function () {
                  return {
                    currentImageIndex: this.value.length - 1,
                    isLoading: !1,
                    prevMouseEvent: null,
                    eventListeners: [],
                    groundMesh: null,
                  };
                },
                template:
                  '\n            <div class="vsl-input-container vsl-images-uploader">\n                <div class="input-line">\n                    <h4>Pictures</h4>\n                    <div v-if="isLoading">Loading...</div>\n                    <div v-else><input type="file" multiple v-el:file-input @change.stop="addFile" @input.stop accept="image/*" /></div>\n\n                    <div class="piclist">\n                        <template  v-if="currentPic">\n                            <select :value="currentImageIndex" v-model="currentImageIndex" @change.stop @input.stop="selectPic($event.target.value)" style="width:15em" >\n                                <option v-for="pic in value" :value="pic.index">{{pic.label}}</option>\n                            </select>\n                            <div class="pano-preview" @click.stop="selectPic(currentPic.index)" :style="picStyle(currentPic)" \n                                    @pointerdown.stop="prevMouseEvent=$event"\n                                    @pointermove="changeRotation(currentPic,$event)"\n                                    @pointerup="commitRotation(currentPic,$event)"\n                                    @pointerleave="commitRotation(currentPic,$event)"\n                            >\n                            <div style="width:1px;height:15em;position:absolute;left:50%;border:1px dashed purple;pointer-events: none;"></div>\n                            </div>\n                            <input type="text" v-model="value[currentImageIndex].label" @change.stop="reOrder" @input.stop/>\n                            <a href="#" @click.stop="removePic(currentPic.index)"><i class="fa fa-trash-o" aria-hidden="true"></i></a>\n                            <a href="#" @click.stop="lookFromPic(currentPic)"><i class="fa fa-eye" aria-hidden="true"></i></a>\n                            <label>Floor</label>\n                            <input type="range" min="0" max="4" step="1" v-model="value[currentImageIndex].position[2]"  number @input.stop="changePosition" @change.stop style="width:6em"/>\n                            <input type="number" min="0" max="4" step="1" v-model="value[currentImageIndex].position[2]"  number @input.stop="changePosition" @change.stop/>\n                            <br/>\n                            <label>Cam height</label>\n                            <input type="range" min="100" max="300" step="5" v-model="value[currentImageIndex].camHeight" :value="value[currentImageIndex].camHeight" number @input.stop="changeCamHeight" @change.stop style="width:6em"/>\n                            <input type="number" min="100" max="300" step="5" v-model="value[currentImageIndex].camHeight" :value="value[currentImageIndex].camHeight" number @input.stop="changeCamHeight" @change.stop/>\n                        </template>\n                    </div>\n                </div>\n            </div>\n            ',
                attached: function () {
                  e.renderer.domElement.addEventListener(
                    "pointerdown",
                    this.rayCastMouseDown
                  ),
                    e.renderer.domElement.addEventListener(
                      "pointermove",
                      this.rayCastMouseMove
                    ),
                    e.renderer.domElement.addEventListener(
                      "pointerup",
                      this.rayCastMouseUp
                    ),
                    e.renderer.domElement.addEventListener(
                      "pointerleave",
                      this.rayCastMouseUp
                    );
                  var t = new a.PlaneBufferGeometry(1e4, 1e4),
                    n = new a.Mesh(t);
                  (n.rotation.x -= Math.PI / 2),
                    (n.position.y -= 180),
                    (n.visible = !1),
                    e.scene.add(n);
                  var r = new a.TorusBufferGeometry(100, 5, 10, 15),
                    i = new a.Mesh(r);
                  (i.rotation.x = -Math.PI / 2),
                    (i.visible = !1),
                    e.scene.add(i),
                    (this.groundMesh = n),
                    (this.cursorMesh = i),
                    (this.draggingIndex = -1);
                },
                detached: function () {
                  e.renderer.domElement.removeEventListener(
                    "pointerdown",
                    this.rayCastMouseDown
                  ),
                    e.renderer.domElement.removeEventListener(
                      "pointermove",
                      this.rayCastMouseMove
                    ),
                    e.renderer.domElement.removeEventListener(
                      "pointerup",
                      this.rayCastMouseUp
                    ),
                    e.renderer.domElement.removeEventListener(
                      "pointerleave",
                      this.rayCastMouseUp
                    ),
                    e.scene.remove(this.groundMesh),
                    e.scene.remove(this.cursorMesh);
                },
                methods: {
                  rayCastPositionOnPlane: function (t) {
                    var n = new a.Raycaster(),
                      i = new a.Vector2();
                    (i.x = (t.clientX / r.domElement.clientWidth) * 2 - 1),
                      (i.y = (-t.clientY / r.domElement.clientHeight) * 2 + 1),
                      n.setFromCamera(i, e.camera),
                      (this.groundMesh.visible = !0);
                    var o = n.intersectObject(this.groundMesh);
                    if (((this.groundMesh.visible = !1), !o.length))
                      return null;
                    var s = this.groundMesh.worldToLocal(o[0].point.clone());
                    if (((s.y *= -1), this.draggingIndex > -1))
                      return {
                        newIndex: this.draggingIndex,
                        local: s,
                      };
                    var l = this.value.reduce(
                      function (e, t) {
                        var n = new a.Vector3()
                          .fromArray(t.position)
                          .distanceToSquared(s);
                        return n >= e.distanceSQ
                          ? e
                          : {
                              index: t.index,
                              distanceSQ: n,
                            };
                      },
                      {
                        index: -1,
                        distanceSQ: 1e4,
                      }
                    ).index;
                    return (
                      l > -1 || this.cursorMesh.scale.setScalar(1),
                      {
                        newIndex: l,
                        local: s,
                      }
                    );
                  },
                  rayCastMouseDown: function (t) {
                    var n = new a.Raycaster(),
                      r = new a.Vector2();
                    (r.x =
                      (t.clientX / e.renderer.domElement.clientWidth) * 2 - 1),
                      (r.y =
                        (-t.clientY / e.renderer.domElement.clientHeight) * 2 +
                        1),
                      n.setFromCamera(r, e.camera);
                    var i,
                      o = e.scene.getObjectByName("panos"),
                      s = n.intersectObjects(
                        o.children.map(function (e) {
                          return e.children[1];
                        })
                      );
                    if (s.length) {
                      (this.cursorMesh.visible = !0),
                        this.cursorMesh.position.copy(s[0].point),
                        (this.cursorMesh.position.y = -170);
                      var l = e.camera.localToWorld(new a.Vector3(0, 0, 0));
                      if (
                        ((i = s[0].object.localToWorld(new a.Vector3(0, 0, 0))),
                        l.distanceToSquared(i) < 1e4)
                      ) {
                        var c = o.children.indexOf(s[0].object.parent);
                        this.lookFromPic(this.value[c]), s.shift();
                      }
                    }
                    if (s.length) {
                      (this.currentImageIndex = o.children.indexOf(
                        s[0].object.parent
                      )),
                        (i = s[0].object.localToWorld(new a.Vector3(0, 0, 0))),
                        (this.groundMesh.position.y = i.y);
                      var u = this.rayCastPositionOnPlane(t);
                      if (u) {
                        (e.controls.enabled = !1),
                          (this.draggingIndex = this.currentImageIndex);
                        var h =
                          e.scene.getObjectByName("panos").children[
                            this.currentImageIndex
                          ].position;
                        (h.x = u.local.x),
                          (h.y = u.local.y),
                          t.preventDefault();
                      }
                    }
                  },
                  rayCastMouseMove: function (t) {
                    var n = this.rayCastPositionOnPlane(t);
                    if (n && this.draggingIndex > -1) {
                      var r =
                        e.scene.getObjectByName("panos").children[
                          this.currentImageIndex
                        ].position;
                      (r.x = n.local.x),
                        (r.y = n.local.y),
                        (this.cursorMesh.position.x = n.local.x),
                        (this.cursorMesh.position.z = n.local.y),
                        t.preventDefault();
                    }
                  },
                  rayCastMouseUp: function (t) {
                    if (-1 !== this.draggingIndex) {
                      (e.controls.enabled = !0), (this.draggingIndex = -1);
                      var n =
                        e.scene.getObjectByName("panos").children[
                          this.currentImageIndex
                        ].position;
                      (this.currentPic.position[0] = n.x),
                        (this.currentPic.position[1] = n.y),
                        this.changePosition();
                    }
                  },
                  addFile: function (e) {
                    var t = this.$els.fileInput,
                      n = t.files.length;

                    function r(e, t, r) {
                      if (e.type.match(/image.*/)) {
                        var i = e.name,
                          o = new FormData();
                        o.append("id", id), o.append("image", e, e.name);
                        var a = new XMLHttpRequest();
                        a.open("POST.html", postImageUrl),
                          (a.onload = function (e) {
                            if (200 === a.status) {
                              var r = JSON.parse(a.responseText),
                                o = {
                                  label: i,
                                  url: r.url,
                                  index: t.value.length,
                                  rotation: 0,
                                  position: [0, 0, 0],
                                  camHeight: 145,
                                };
                              Object.assign(o, t.opts.defaultFileOpts || {}),
                                t.value.push(o),
                                (t.currentImageIndex = o.index),
                                0 == --n &&
                                  (t.reOrder(),
                                  t.resetAdd(),
                                  (t.isLoading = !1),
                                  t.$dispatch("valuechanged", t.key, t.value));
                            } else
                              alert(
                                "Unable to send the file " +
                                  i +
                                  " to the server; please try again"
                              );
                          }),
                          a.send(o);
                      }
                    }
                    this.isLoading = !0;
                    for (var i = 0; i < t.files.length; i++)
                      r(t.files[i], this, t.files.length);
                  },
                  lookFromPic: function (t) {
                    var n = e.scene
                      .getObjectByName("panos")
                      .children[t.index].children[0].localToWorld(
                        new a.Vector3(0, 0, 0)
                      );
                    e.controls.object.position.set(n.x, n.y, n.z - 10),
                      e.controls.target.set(n.x, n.y, n.z),
                      e.controls.update();
                  },
                  changeRotation: function (e, t) {
                    if (t.buttons) {
                      this.prevMouseEvent = this.prevMouseEvent || t;
                      var n = t.clientX - this.prevMouseEvent.clientX;
                      (n /= 2 * t.target.clientWidth),
                        (e.rotation += n),
                        e.rotation < 1 && (e.rotation += 1),
                        e.rotation > 1 && (e.rotation -= 1),
                        t.preventDefault(),
                        (this.prevMouseEvent = t);
                    }
                  },
                  commitRotation: function (e, t) {
                    (this.prevMouseEvent = null),
                      this.$dispatch(
                        "valuechanged",
                        this.key + "[" + e.index + "].rotation",
                        e.rotation
                      ),
                      t.preventDefault();
                  },
                  changePosition: function () {
                    this.$dispatch(
                      "valuechanged",
                      this.key + "[" + this.currentImageIndex + "].position",
                      this.currentPic.position
                    );
                  },
                  changeCamHeight: function () {
                    this.$dispatch(
                      "valuechanged",
                      this.key + "[" + this.currentImageIndex + "].camHeight",
                      this.currentPic.camHeight
                    );
                  },
                  resetAdd: function () {
                    o.nextTick(
                      function () {
                        this.$els.fileInput.value = "";
                      }.bind(this)
                    );
                  },
                  selectPic: function (e) {
                    (this.currentImageIndex = e),
                      (this.cursorMesh.position.x = this.value[e].position[0]),
                      (this.cursorMesh.position.z = this.value[e].position[1]);
                  },
                  removePic: function (e) {
                    this.value.splice(e, 1),
                      this.value.forEach(function (e, t) {
                        e.index = t;
                      }),
                      (this.currentImageIndex = Math.min(
                        this.value.length - 1,
                        this.currentImageIndex
                      )),
                      this.$dispatch("valuechanged", this.key, this.value),
                      (this.cursorMesh.visible = !1);
                  },
                  picStyle: function (e) {
                    return {
                      backgroundImage: 'url("' + e.url + '")',
                      backgroundSize: "cover",
                      backgroundPositionX: 30 * e.rotation + "em",
                      width: "15em",
                      height: "15em",
                    };
                  },
                  reOrder: function () {
                    var e = this.currentPic;
                    this.value.sort(function (e, t) {
                      return e.label > t.label;
                    }),
                      this.value.forEach(function (e, t) {
                        e.index = t;
                      }),
                      (this.currentImageIndex = e.index),
                      this.$dispatch("valuechanged", this.key, this.value);
                  },
                },
                computed: {
                  currentPic: function () {
                    return this.currentImageIndex < 0
                      ? null
                      : this.value[this.currentImageIndex];
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "fileuploader",
              o.extend({
                props: ["value", "opts", "key"],
                data: function () {
                  return {
                    currentImageIndex: this.value.length - 1,
                    isLoading: !1,
                    prevMouseEvent: null,
                    eventListeners: [],
                    groundMesh: null,
                  };
                },
                template:
                  '\n            <div class="vsl-input-container vsl-images-uploader">\n                <div class="input-line">\n                    <h4>Pictures</h4>\n                    <div v-if="isLoading">Loading...</div>\n                    <div v-else>\n                      <input type="file" multiple v-el:file-input @change.stop="addFile" @input.stop :accept="opts.allowedExtensions" />\n                    </div>\n                    <div v-for="(objs,i) in value.\n\n                </div>\n            </div>\n            ',
                attached: function () {},
                detached: function () {},
                methods: {
                  addFile: function (e) {
                    var t = this.$els.fileInput,
                      n = t.files.length;

                    function r(e, t, r) {
                      var i = e.name,
                        o = new FormData();
                      o.append("id", id), o.append("customcontent", e, e.name);
                      var a = new XMLHttpRequest();
                      a.open("POST.html", postContentUrl),
                        (a.onload = function (e) {
                          if (200 === a.status) {
                            var r = JSON.parse(a.responseText).url;
                            if (r) {
                              var o = new URL(a.html);
                              (o.pathname = r), (r = o.toString());
                            }
                            var s = {
                              label: i,
                              url: r,
                              index: t.value.length,
                            };
                            Object.assign(
                              s,
                              JSON.parse(
                                JSON.stringify(t.opts.defaultFileOpts || {})
                              )
                            ),
                              t.value.push(s),
                              (t.currentImageIndex = s.index);
                          } else
                            alert(
                              "Unable to send the file " +
                                i +
                                " to the server; please try again"
                            );
                          0 == --n &&
                            ((t.isLoading = !1),
                            t.$dispatch("valuechanged", t.key, t.value));
                        }),
                        a.send(o);
                    }
                    new URL(postContentUrl.html), (this.isLoading = !0);
                    for (var i = 0; i < t.files.length; i++)
                      r(t.files[i], this, t.files.length);
                  },
                  removePic: function (e) {
                    var t = new XMLHttpRequest(),
                      n = this.value[this.currentImageIndex].url;
                    t.open("DELETE.html", n),
                      this.value.splice(e, 1),
                      this.value.forEach(function (e, t) {
                        e.index = t;
                      }),
                      (this.currentImageIndex = Math.min(
                        this.value.length - 1,
                        this.currentImageIndex
                      )),
                      this.$dispatch("valuechanged", this.key, this.value),
                      (this.cursorMesh.visible = !1);
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "backgroundpic",
              o.extend({
                props: ["value", "opts", "key"],
                data: function () {
                  var e = this.$parent.$data,
                    t = e.homography || {
                      position: {
                        x: 0.5,
                        y: 0.5,
                      },
                      rotation: {
                        x: 0,
                        y: 0,
                      },
                      scale: 0.4,
                      imageSrc: null,
                    };
                  return (
                    (e.homography = t),
                    (e.homography.available = !0),
                    (e.homography.enabled = !0),
                    {
                      uploading: !1,
                      homography: t,
                      originalHomographyJSON: JSON.stringify(t),
                    }
                  );
                },
                template:
                  '<template v-if="allowPicture"><input type="file" @change="readFile" accept="image/*"/></template><template v-if="uploading">\n                    <div class="m-1 spinner-border" role="status">\n                        <span class="sr-only">Loading...</span>\n                    </div>\n                </template>\n                <div class="homography-container"><div class="btn-group vsl-perspective-scaler"> <a href="#" class="btn btn-primary" @click.prevent="scalePlane(0.97)">  <i class="fa fa-compress-alt" aria-hidden="true"></i></a> <a href="#" class="btn btn-primary" @click.prevent="resetPlane()">  <i class="fas fa-sync-alt" aria-hidden="true"></i></a> <a href="#" class="btn btn-primary" @click.prevent="scalePlane(1/0.97)">  <i class="fa fa-expand-alt" aria-hidden="true"></i></a></div><div style="width:50vw;position:fixed;bottom:1em;left:25vw;background-color:white;height:3em;border-radius:2px" >\n                <i class="fa fa-arrow-left" style="position:fixed;left:25.5vw;bottom:2em"/>\n                <input type="range" style="position:fixed;width:46vw;left:27vw;bottom:2em" :value="homography.rotation.y" \n                    @input="updateRotation({y:parseFloat($event.target.value),x:homography.rotation.x})" :min="-Math.PI / 2" :max="Math.PI / 2" step="0.01" \n                    @mouseenter="homography.gridsVisible = true" @mouseleave="homography.gridsVisible = false"/>\n                <i class="fa fa-arrow-right" style="position:fixed;right:25.5vw;bottom:2em"/>\n                </div><div style="width:3em;position:fixed;top:25vh;right:1em;background-color:white;height:50vh;border-radius:2px" >\n                <i class="fa fa-arrow-up" style="position:fixed;right:2em;top:25.1vh"/>\n                <input type="range" :value="homography.rotation.x" @input="updateRotation({x:parseFloat($event.target.value),y:homography.rotation.y})" :min="-Math.PI / 2" :max="Math.PI / 2" step="0.01" \n                    style="width:46vh;position:fixed;right:2.5em;transform-origin: 100% 50%;transform:rotate(-90deg)"  @mouseenter="homography.gridsVisible = true" @mouseleave="homography.gridsVisible = false"/>\n                <i class="fa fa-arrow-down" style="position:fixed;right:2em;bottom:25.1vh"/>\n                </div>',
                ready: function () {
                  this.$dispatch("valuechanged", "homography.enabled", !0);
                },
                attached: function () {
                  r.domElement.addEventListener(
                    "pointermove",
                    this.onMouseMove
                  ),
                    r.domElement.addEventListener(
                      "pointerdown",
                      this.onMouseDown
                    ),
                    r.domElement.addEventListener("pointerup", this.onMouseUp),
                    r.domElement.addEventListener(
                      "pointerleave",
                      this.onMouseUp
                    ),
                    (r.domElement.style.cursor = "move");
                },
                detached: function () {
                  r.domElement.removeEventListener(
                    "pointermove",
                    this.onMouseMove
                  ),
                    r.domElement.removeEventListener(
                      "pointerdown",
                      this.onMouseDown
                    ),
                    r.domElement.removeEventListener(
                      "pointerup",
                      this.onMouseUp
                    ),
                    r.domElement.removeEventListener(
                      "pointerleave",
                      this.onMouseUp
                    ),
                    (r.domElement.style.cursor = null);
                },
                methods: {
                  onMouseMove: function (e) {
                    if (this.homography.enabled && e.buttons) {
                      var t = e.target;
                      this.updatePosition({
                        x: e.clientX / t.clientWidth / 2 + 0.25,
                        y: e.clientY / t.clientHeight / 2 + 0.25,
                      });
                    }
                  },
                  onMouseDown: function (e) {
                    this.homography.enabled &&
                      ((this.homography.gridsVisible = !0),
                      this.$dispatch(
                        "valuechanged",
                        "homography",
                        this.homography
                      ),
                      e.preventDefault());
                  },
                  onMouseUp: function (e) {
                    this.homography.enabled &&
                      ((this.homography.gridsVisible = !1),
                      this.$dispatch(
                        "valuechanged",
                        "homography",
                        this.homography
                      ),
                      e.preventDefault());
                  },
                  readFile: function (e) {
                    var t = this,
                      n = e.target.files[0];
                    if (n.type.match(/image.*/)) {
                      var r = n.name,
                        i = new FormData();
                      i.append("id", id), i.append("image", n, r);
                      var o = new XMLHttpRequest();
                      o.open("POST.html", postImageUrl),
                        (this.uploading = !0),
                        (o.onload = function (e) {
                          if (200 === o.status) {
                            var n = JSON.parse(o.responseText);
                            (t.homography.imageSrc = n.url),
                              t.$dispatch(
                                "valuechanged",
                                "homography",
                                t.homography
                              );
                          } else
                            alert(
                              "Unable to send the file " +
                                r +
                                " to the server; please try again"
                            );
                          t.uploading = !1;
                        }),
                        o.send(i);
                    }
                  },
                  updatePosition: function (e) {
                    (this.homography.position.x = e.x),
                      (this.homography.position.y = e.y),
                      this.$dispatch(
                        "valuechanged",
                        "homography",
                        this.homography
                      );
                  },
                  updateRotation: function (e) {
                    (this.homography.rotation.x = e.x),
                      (this.homography.rotation.y = e.y),
                      this.$dispatch(
                        "valuechanged",
                        "homography",
                        this.homography
                      );
                  },
                  updateScale: function (e) {
                    (this.homography.scale = e),
                      this.$dispatch(
                        "valuechanged",
                        "homography",
                        this.homography
                      );
                  },
                  startDrag: function () {
                    (this.homography.gridsVisible = !0),
                      this.$dispatch(
                        "valuechanged",
                        "homography",
                        this.homography
                      );
                  },
                  stopDrag: function () {
                    (this.homography.gridsVisible = !1),
                      this.$dispatch(
                        "valuechanged",
                        "homography",
                        this.homography
                      );
                  },
                  scalePlane: function (e) {
                    this.updateScale(this.homography.scale * e);
                  },
                  resetPlane: function () {
                    var e = JSON.parse(this.originalHomographyJSON);
                    (e.enabled = !0),
                      (e.imageSrc = this.homography.imageSrc),
                      Object.assign(this.homography, e),
                      this.$dispatch(
                        "valuechanged",
                        "homography",
                        this.homography
                      );
                  },
                  movePlane: function (e, t) {
                    this.updatePosition({
                      x: this.homography.position.x + e,
                      y: this.homography.position.y + t,
                    });
                  },
                },
                watch: {},
                computed: {
                  allowPicture: function () {
                    return (
                      "always" === this.$parent.meta.allowPicture ||
                      this.$parent.meta.wasSubmitted
                    );
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "homographyPlacement",
              o.extend({
                props: ["value", "opts", "key"],
                data: function () {
                  return {
                    homography: JSON.parse(
                      JSON.stringify(
                        this.value || {
                          position: {
                            x: 0.5,
                            y: 0.5,
                          },
                          rotation: {
                            x: 0,
                            y: 0,
                          },
                          scale: 0.4,
                          imageSrc: null,
                        }
                      )
                    ),
                    originalHomographyJSON: JSON.stringify(this.value),
                    joystickInUse: !1,
                  };
                },
                template:
                  '\n                <vsl-joystick :rotation="value.rotation" @change="updateRotation" \n                    @startdrag="startDrag" @stopdrag="stopDrag" style="left:25vw">\n                    <i class="fa fa-undo" aria-hidden="true"></i>\n                </vsl-joystick>\n                <vsl-joystick :position="value.position" @change="updatePosition" \n                    @startdrag="startDrag" @stopdrag="stopDrag" style="right:25vw">\n                    <i class="fa fa-arrows" aria-hidden="true"></i>\n                </vsl-joystick>\n                <div class="homography-container">\n\t\t\t\t\t\t\t\t\t<div class="btn-group vsl-perspective-scaler">\n\t\t\t\t\t\t\t\t\t <a href="#" class="btn btn-primary" @click.prevent="scalePlane(0.97)">\n\t\t\t\t\t\t\t\t\t\t<i class="fa fa-compress-alt" aria-hidden="true"></i></a>\n\t\t\t\t\t\t\t\t\t <a href="#" class="btn btn-primary" @click.prevent="resetPlane()">\n\t\t\t\t\t\t\t\t\t\t<i class="fas fa-sync-alt" aria-hidden="true"></i></a>\n\t\t\t\t\t\t\t\t\t <a href="#" class="btn btn-primary" @click.prevent="scalePlane(1/0.97)">\n\t\t\t\t\t\t\t\t\t\t<i class="fa fa-expand-alt" aria-hidden="true"></i></a>\n\t\t\t\t\t\t\t\t\t</div>\n                </div>\n                ',
                attached: function () {
                  r.domElement.addEventListener(
                    "pointermove",
                    this.onMouseMove
                  ),
                    r.domElement.addEventListener(
                      "pointerdown",
                      this.onMouseDown
                    ),
                    r.domElement.addEventListener("pointerup", this.onMouseUp),
                    r.domElement.addEventListener(
                      "pointerleave",
                      this.onMouseUp
                    ),
                    r.domElement.addEventListener("wheel", this.onScroll),
                    (r.domElement.style.cursor = "move");
                },
                detached: function () {
                  r.domElement.removeEventListener(
                    "pointermove",
                    this.onMouseMove
                  ),
                    r.domElement.removeEventListener(
                      "pointerdown",
                      this.onMouseDown
                    ),
                    r.domElement.removeEventListener(
                      "pointerup",
                      this.onMouseUp
                    ),
                    r.domElement.removeEventListener(
                      "pointerleave",
                      this.onMouseUp
                    ),
                    r.domElement.removeEventListener("wheel", this.onScroll),
                    (r.domElement.style.cursor = null);
                },
                methods: {
                  onMouseMove: function (e) {
                    if (this.value.enabled && !this.joystickInUse) {
                      var t = e.target;
                      1 === e.buttons &&
                        this.updateRotation({
                          x: this.value.rotation.x - e.movementY / 100,
                          y: this.value.rotation.y + e.movementX / 100,
                        }),
                        2 === e.buttons &&
                          this.updatePosition({
                            x: e.clientX / t.clientWidth / 2 + 0.25,
                            y: e.clientY / t.clientHeight / 2 + 0.25,
                          });
                    }
                  },
                  onMouseDown: function (e) {
                    this.value.enabled &&
                      !this.joystickInUse &&
                      (this.$dispatch(
                        "valuechanged",
                        "homography.gridsVisible",
                        !0
                      ),
                      e.preventDefault());
                  },
                  onMouseUp: function (e) {
                    this.value.enabled &&
                      !this.joystickInUse &&
                      (this.$dispatch(
                        "valuechanged",
                        "homography.gridsVisible",
                        !1
                      ),
                      e.preventDefault());
                  },
                  onScroll: function (e) {
                    if (this.value.enabled && !this.joystickInUse) {
                      var t = Math.max(0.1, this.value.scale - 3e-4 * e.deltaY);
                      (t = Math.min(1.5, t)), this.updateScale(t);
                    }
                  },
                  updatePosition: function (e) {
                    var t = e.x,
                      n = e.y;
                    this.$dispatch("valuechanged", "homography.position", {
                      x: t,
                      y: n,
                    });
                  },
                  updateRotation: function (e) {
                    var t = e.x,
                      n = e.y;
                    this.$dispatch("valuechanged", "homography.rotation", {
                      x: t,
                      y: n,
                    });
                  },
                  updateScale: function (e) {
                    this.$dispatch("valuechanged", "homography.scale", e);
                  },
                  startDrag: function () {
                    (this.joystickInUse = !0),
                      this.$dispatch(
                        "valuechanged",
                        "homography.gridsVisible",
                        !0
                      );
                  },
                  stopDrag: function () {
                    (this.joystickInUse = !1),
                      this.$dispatch(
                        "valuechanged",
                        "homography.gridsVisible",
                        !1
                      );
                  },
                  scalePlane: function (e) {
                    this.updateScale(this.value.scale * e);
                  },
                  resetPlane: function () {
                    var e = JSON.parse(this.originalHomographyJSON);
                    (e.enabled = !0),
                      (e.imageSrc = this.homography.imageSrc),
                      Object.assign(this.homography, e),
                      this.$dispatch(
                        "valuechanged",
                        "homography",
                        this.homography
                      );
                  },
                  movePlane: function (e, t) {
                    this.updatePosition({
                      x: this.homography.position.x + e,
                      y: this.homography.position.y + t,
                    });
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "backgroundPicWithChoice",
              o.extend({
                props: ["value", "opts", "key"],
                data: function () {
                  var e = this.$parent.$data,
                    t = e.homography || {
                      position: {
                        x: 0.5,
                        y: 0.5,
                      },
                      rotation: {
                        x: 0,
                        y: 0,
                      },
                      scale: 0.4,
                      imageSrc: null,
                    };
                  return (
                    (e.homography = t),
                    (e.homography.available = !0),
                    {
                      uploading: !1,
                      homography: t,
                      originalHomographyJSON: JSON.stringify(t),
                    }
                  );
                },
                template:
                  '\n\t\t\t\t\t\t\t\t<input type="file" @change="readFile" accept="image/*"/>\n                <template v-if="uploading">\n                    <div class="m-1 spinner-border" role="status">\n                        <span class="sr-only">Loading...</span>\n                    </div>\n                </template>\n                ',
                methods: {
                  readFile: function (e) {
                    var t = this,
                      n = e.target.files[0];
                    if (n.type.match(/image.*/)) {
                      var r = n.name,
                        i = new FormData();
                      i.append("id", id), i.append("image", n, r);
                      var o = new XMLHttpRequest();
                      o.open("POST.html", postImageUrl),
                        (this.uploading = !0),
                        (o.onload = function (e) {
                          if (200 === o.status) {
                            var n = JSON.parse(o.responseText);
                            (t.homography.imageSrc = n.url),
                              t.$dispatch(
                                "valuechanged",
                                "homography",
                                t.homography
                              );
                          } else
                            alert(
                              "We were unable to save your photo " +
                                r +
                                " on our server. Feel free to try again or just continue."
                            );
                          t.uploading = !1;
                        }),
                        o.send(i);
                    }
                  },
                },
              })
            ),
            this.componentBuilder.register(
              "positioner",
              o.extend({
                props: ["value", "opts", "key"],
                data: function () {
                  return {};
                },
                template:
                  '\n                    <div class="vsl-input-container vsl-positioner">\n                      <template v-if="element">\n                       <h4>Positie {{element.elementId}}</h4>\n                       <table>\n                         <tbody>\n                            <tr>\n                                <td>\n                                   <input  type="number" :min="0" :max="bboxSize.y-size.y" step="1" number \n                                      :value="Math.round(bboxSize.y/2-position.y-size.y/2)"\n                                      @change.stop="setY(-$event.target.value+bboxSize.y/2-size.y/2)" @input.stop="" /> \n                                </td>\n                                <td rowspan="5" colspan="3" style="border: 1px solid black;position: relative">\n                                    <div style="position:absolute;top:33.33%;left:33.33%;width:33.33%;height:33.33%;border: 1px dashed gray" />\n                                </td>\n                            <tr/>\n                            <tr>\n                                <td>\n                                   <input :value="size.y" type="number" id="height" :min="minSize.y" :max="maxSize.y" step="1" number\n                                      @change.stop="setHeight($event.target.value)" @input.stop="" /> \n                                </td>\n                            <tr/>\n                            <tr>\n                                <td>\n                                    <input type="number" :min="0" :max="bboxSize.y-size.y" step="1" number\n                                      :value="Math.round(bboxSize.y/2+position.y-size.y/2)" \n                                      @change.stop="setY($event.target.value-bboxSize.y/2+size.y/2)" @input.stop="" /> \n                                </td>\n                            <tr/>\n                            <tr>\n                                <td>&nbsp;</td>\n                                <td>\n                                    <input type="number" :min="0" :max="bboxSize.x-size.x" step="1" number \n                                        :value="Math.round(bboxSize.x/2+position.x-size.x/2)"\n                                      @change.stop="setX($event.target.value-bboxSize.x/2+size.x/2)" @input.stop="" /> \n                                </td>\n                                <td>\n                                   <input :value="size.x" type="number" :min="minSize.x" :max="maxSize.x" step="1" number\n                                      @change.stop="setWidth($event.target.value)" @input.stop="" /> \n                                </td>\n                                <td>\n                                   <input type="number" :min="0" :max="bboxSize.x-size.x" step="1" number \n                                        :value="Math.round(bboxSize.x/2-position.x-size.x/2)" \n                                        @change.stop="setX(-$event.target.value+bboxSize.x/2-size.x/2)" @input.stop="" /> \n                                </td>\n                            <tr/>\n                         </tbody>\n                        </table>\n                        <template v-if="element.float">\n                            <label>Rotatie</label>\n                            <input type="range" min="0" max="360" v-model="rotation" @change.stop @input.stop step="5"/>\n                        </template>\n                        </template>\n                    </div>',
                computed: {
                  element: function () {
                    if (this.value && this.value.length) {
                      var e = this.value[this.value.length - 1];
                      if (
                        n.activeDropTargetIds.some(function (t) {
                          return t === e.dropTargetId;
                        })
                      )
                        return e;
                    }
                    return null;
                  },
                  position: function () {
                    return new a.Vector2().fromArray(this.element.position);
                  },
                  size: function () {
                    return new a.Vector2(
                      this.element.width,
                      this.element.height
                    );
                  },
                  bbox: function () {
                    var e = this,
                      t = n.dropTargets.filter(function (t) {
                        return t.name === e.element.dropTargetName;
                      })[0],
                      r = (t.grid || []).filter(function (t) {
                        return t.containsPoint(e.position);
                      });
                    return r.length ? r[0] : t.localBoundingBox;
                  },
                  bboxSize: function () {
                    return this.bbox.getSize(new a.Vector3());
                  },
                  bboxCenter: function () {
                    return this.bbox.getCenter(new a.Vector3());
                  },
                  minSize: function () {
                    return {
                      x:
                        this.element.minWidth > 0
                          ? this.element.minWidth
                          : this.bboxSize.width - this.element.minWidth,
                      y:
                        this.element.minHeight > 0
                          ? this.element.minHeight
                          : this.bboxSize.height - this.element.minHeight,
                    };
                  },
                  maxSize: function () {
                    return {
                      x: Math.min(
                        this.bboxSize.width - 1,
                        this.element.maxWidth > 0
                          ? this.element.maxWidth
                          : this.bboxSize.width - this.element.maxWidth
                      ),
                      y: Math.min(
                        this.bboxSize.height - 1,
                        this.element.maxHeight > 0
                          ? this.element.maxHeight
                          : this.bboxSize.height - this.element.maxHeight
                      ),
                    };
                  },
                  rotation: {
                    get: function () {
                      return Math.round(
                        (180 * this.element.rotation[2]) / Math.PI
                      );
                    },
                    set: function (e) {
                      (e = (e / 180) * Math.PI),
                        (this.element.rotation[2] = e),
                        this.$dispatch(
                          "valuechanged",
                          this.key +
                            "[" +
                            (this.value.length - 1) +
                            "].rotation[2]",
                          e
                        );
                    },
                  },
                },
                methods: {
                  setY: function (e) {
                    (e += this.bboxCenter.y),
                      (this.element.position[1] = e),
                      this.$dispatch(
                        "valuechanged",
                        this.key +
                          "[" +
                          (this.value.length - 1) +
                          "].position[1]",
                        e
                      );
                  },
                  setHeight: function (e) {
                    (this.element.height = e),
                      this.$dispatch(
                        "valuechanged",
                        this.key + "[" + (this.value.length - 1) + "].height",
                        e
                      );
                  },
                  setX: function (e) {
                    (e += this.bboxCenter.x),
                      (this.element.position[0] = e),
                      this.$dispatch(
                        "valuechanged",
                        this.key +
                          "[" +
                          (this.value.length - 1) +
                          "].position[0]",
                        e
                      );
                  },
                  setWidth: function (e) {
                    (this.element.width = e),
                      this.$dispatch(
                        "valuechanged",
                        this.key + "[" + (this.value.length - 1) + "].width",
                        e
                      );
                  },
                },
              })
            );
        }
        return (
          (e.prototype.buildClass = function (e, t, n, r, i) {
            return (
              void 0 === i && (i = !0),
              this.componentBuilder.getVueClass(e, t, n, r, i)
            );
          }),
          e
        );
      })()),
      (d.UIBuilder = g);
    class b {
      parse(e) {
        let t = "",
          n = 0,
          r = 0,
          i = 0;
        const o = new a.Vector3(),
          s = new a.Color(),
          l = new a.Vector3(),
          c = new a.Vector2(),
          u = [];
        return (
          e.traverse(function (e) {
            !0 === e.isMesh &&
              (function (e) {
                let s = 0,
                  h = 0,
                  d = 0;
                const p = e.geometry,
                  f = new a.Matrix3();
                if (!0 !== p.isBufferGeometry)
                  throw new Error(
                    "THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry."
                  );
                const m = p.getAttribute("position"),
                  g = p.getAttribute("normal"),
                  v = p.getAttribute("uv"),
                  y = p.getIndex();
                if (
                  ((t += "o " + e.name + "\n"),
                  e.material &&
                    e.material.name &&
                    (t += "usemtl " + e.material.name + "\n"),
                  void 0 !== m)
                )
                  for (let n = 0, r = m.count; n < r; n++, s++)
                    (o.x = m.getX(n)),
                      (o.y = m.getY(n)),
                      (o.z = m.getZ(n)),
                      o.applyMatrix4(e.matrixWorld),
                      (t += "v " + o.x + " " + o.y + " " + o.z + "\n");
                if (void 0 !== v)
                  for (let e = 0, n = v.count; e < n; e++, d++)
                    (c.x = v.getX(e)),
                      (c.y = v.getY(e)),
                      (t += "vt " + c.x + " " + c.y + "\n");
                if (void 0 !== g) {
                  f.getNormalMatrix(e.matrixWorld);
                  for (let e = 0, n = g.count; e < n; e++, h++)
                    (l.x = g.getX(e)),
                      (l.y = g.getY(e)),
                      (l.z = g.getZ(e)),
                      l.applyMatrix3(f).normalize(),
                      (t += "vn " + l.x + " " + l.y + " " + l.z + "\n");
                }
                if (null !== y)
                  for (let e = 0, o = y.count; e < o; e += 3) {
                    for (let t = 0; t < 3; t++) {
                      const o = y.getX(e + t) + 1;
                      u[t] =
                        n +
                        o +
                        (g || v
                          ? "/" + (v ? r + o : "") + (g ? "/" + (i + o) : "")
                          : "");
                    }
                    t += "f " + u.join(" ") + "\n";
                  }
                else
                  for (let e = 0, o = m.count; e < o; e += 3) {
                    for (let t = 0; t < 3; t++) {
                      const o = e + t + 1;
                      u[t] =
                        n +
                        o +
                        (g || v
                          ? "/" + (v ? r + o : "") + (g ? "/" + (i + o) : "")
                          : "");
                    }
                    t += "f " + u.join(" ") + "\n";
                  }
                (n += s), (r += d), (i += h);
              })(e),
              !0 === e.isLine &&
                (function (e) {
                  let r = 0;
                  const i = e.geometry,
                    a = e.type;
                  if (!0 !== i.isBufferGeometry)
                    throw new Error(
                      "THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry."
                    );
                  const s = i.getAttribute("position");
                  if (((t += "o " + e.name + "\n"), void 0 !== s))
                    for (let n = 0, i = s.count; n < i; n++, r++)
                      (o.x = s.getX(n)),
                        (o.y = s.getY(n)),
                        (o.z = s.getZ(n)),
                        o.applyMatrix4(e.matrixWorld),
                        (t += "v " + o.x + " " + o.y + " " + o.z + "\n");
                  if ("Line" === a) {
                    t += "l ";
                    for (let e = 1, r = s.count; e <= r; e++) t += n + e + " ";
                    t += "\n";
                  }
                  if ("LineSegments" === a)
                    for (
                      let e = 1, r = e + 1, i = s.count;
                      e < i;
                      e += 2, r = e + 1
                    )
                      t += "l " + (n + e) + " " + (n + r) + "\n";
                  n += r;
                })(e),
              !0 === e.isPoints &&
                (function (e) {
                  let r = 0;
                  const i = e.geometry;
                  if (!0 !== i.isBufferGeometry)
                    throw new Error(
                      "THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry."
                    );
                  const a = i.getAttribute("position"),
                    l = i.getAttribute("color");
                  if (((t += "o " + e.name + "\n"), void 0 !== a))
                    for (let n = 0, i = a.count; n < i; n++, r++)
                      o.fromBufferAttribute(a, n),
                        o.applyMatrix4(e.matrixWorld),
                        (t += "v " + o.x + " " + o.y + " " + o.z),
                        void 0 !== l &&
                          (s.fromBufferAttribute(l, n),
                          (t += " " + s.r + " " + s.g + " " + s.b)),
                        (t += "\n");
                  t += "p ";
                  for (let e = 1, r = a.count; e <= r; e++) t += n + e + " ";
                  (t += "\n"), (n += r);
                })(e);
          }),
          t
        );
      }
    }
    var w,
      _ = n(6),
      M = n.n(_);
    (w || (w = {})).getSidebar = function () {
      return o.extend({
        template:
          '<div class="sidebar-container" :class="{collapsed: isCollapsed}">\n                   <div v-show="!isCollapsed" class="sidebar-item" transition="expand">\n                  \n\t\t\t\t\t\t\t\t <div class="sidebar-content">\n\t\t\t\t\t\t\t\t\t\t\t <component :is="currentComponentName" >\n\t\t\t\t\t\t\t\t\t\t\t </component>\n\t\t\t\t\t\t\t\t </div>\n                 </div>\n            </div>',
        data: function () {
          return {
            componentInfo: [],
            currentComponentName: "none",
            nextButtonText: "Next",
            prevButtonText: "Previous",
            isCollapsed: !1,
          };
        },
        computed: {
          componentNames: function () {
            return this.componentInfo.map(function (e) {
              return e.name;
            });
          },
          isFirstStep: function () {
            return this.componentInfo[0].name === this.currentComponentName;
          },
          isLastStep: function () {
            return (
              this.componentInfo[this.componentInfo.length - 1].name ===
              this.currentComponentName
            );
          },
        },
        ready: function () {
          var e = (window.location.hash || "").match(/\d+/);
          if (e) {
            var t = parseInt(e[0]) - 1;
            -1 == t
              ? (this.isCollapsed = !0)
              : t <= this.componentNames.length &&
                (this.currentComponentName = this.componentNames[t]);
          }
        },
        methods: {
          goDirectly: function (e) {
            l(), (this.isCollapsed = !1);
          },
          go: function (e) {
            l();
            var t = this.componentNames,
              n = t.indexOf(this.currentComponentName) + e;
            if (!(n < 0 || n >= t.length)) {
              (this.currentComponentName = t[n]),
                (window.location.hash = "" + (n + 1));
              var r = r;
              r &&
                r("send", "pageview", {
                  page: location.pathname + "?tab=" + (n + 1),
                });
            }
          },
        },
      });
    };
    var S = (function () {
        var e = e || {};
        (e.svdcmp = function (t, n, r, i, o) {
          var a,
            s,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m,
            g,
            v,
            y,
            x,
            b,
            w = 0,
            _ = 0,
            M = 0,
            S = [];
          for (s = 0; s < r; ++s) {
            if (((d = s + 1), (S[s] = M * _), (_ = v = M = 0), s < n)) {
              for (h = s; h < n; ++h) M += Math.abs(t[h][s]);
              if (0 !== M) {
                for (h = s; h < n; ++h)
                  (t[h][s] /= M), (v += t[h][s] * t[h][s]);
                for (
                  g = (m = t[s][s]) * (_ = -e.sign(Math.sqrt(v), m)) - v,
                    t[s][s] = m - _,
                    c = d;
                  c < r;
                  ++c
                ) {
                  for (v = 0, h = s; h < n; ++h) v += t[h][s] * t[h][c];
                  for (m = v / g, h = s; h < n; ++h) t[h][c] += m * t[h][s];
                }
                for (h = s; h < n; ++h) t[h][s] *= M;
              }
            }
            if (((i[s] = M * _), (_ = v = M = 0), s < n && s !== r - 1)) {
              for (h = d; h < r; ++h) M += Math.abs(t[s][h]);
              if (0 !== M) {
                for (h = d; h < r; ++h)
                  (t[s][h] /= M), (v += t[s][h] * t[s][h]);
                for (
                  g = (m = t[s][d]) * (_ = -e.sign(Math.sqrt(v), m)) - v,
                    t[s][d] = m - _,
                    h = d;
                  h < r;
                  ++h
                )
                  S[h] = t[s][h] / g;
                for (c = d; c < n; ++c) {
                  for (v = 0, h = d; h < r; ++h) v += t[c][h] * t[s][h];
                  for (h = d; h < r; ++h) t[c][h] += v * S[h];
                }
                for (h = d; h < r; ++h) t[s][h] *= M;
              }
            }
            w = Math.max(w, Math.abs(i[s]) + Math.abs(S[s]));
          }
          for (s = r - 1; s >= 0; --s) {
            if (s < r - 1) {
              if (0 !== _) {
                for (c = d; c < r; ++c) o[c][s] = t[s][c] / t[s][d] / _;
                for (c = d; c < r; ++c) {
                  for (v = 0, h = d; h < r; ++h) v += t[s][h] * o[h][c];
                  for (h = d; h < r; ++h) o[h][c] += v * o[h][s];
                }
              }
              for (c = d; c < r; ++c) o[s][c] = o[c][s] = 0;
            }
            (o[s][s] = 1), (_ = S[s]), (d = s);
          }
          for (s = Math.min(r, n) - 1; s >= 0; --s) {
            for (d = s + 1, _ = i[s], c = d; c < r; ++c) t[s][c] = 0;
            if (0 !== _) {
              for (_ = 1 / _, c = d; c < r; ++c) {
                for (v = 0, h = d; h < n; ++h) v += t[h][s] * t[h][c];
                for (m = (v / t[s][s]) * _, h = s; h < n; ++h)
                  t[h][c] += m * t[h][s];
              }
              for (c = s; c < n; ++c) t[c][s] *= _;
            } else for (c = s; c < n; ++c) t[c][s] = 0;
            ++t[s][s];
          }
          for (h = r - 1; h >= 0; --h)
            for (l = 1; l <= 30; ++l) {
              for (a = !0, d = h; d >= 0; --d) {
                if (((p = d - 1), Math.abs(S[d]) + w === w)) {
                  a = !1;
                  break;
                }
                if (Math.abs(i[p]) + w === w) break;
              }
              if (a)
                for (
                  f = 0, v = 1, s = d;
                  s <= h && ((m = v * S[s]), Math.abs(m) + w !== w);
                  ++s
                )
                  for (
                    _ = i[s],
                      g = e.pythag(m, _),
                      i[s] = g,
                      f = _ * (g = 1 / g),
                      v = -m * g,
                      c = 1;
                    c <= n;
                    ++c
                  )
                    (x = t[c][p]),
                      (b = t[c][s]),
                      (t[c][p] = x * f + b * v),
                      (t[c][s] = b * f - x * v);
              if (((b = i[h]), d === h)) {
                if (b < 0)
                  for (i[h] = -b, c = 0; c < r; ++c) o[c][h] = -o[c][h];
                break;
              }
              if (30 === l) return !1;
              for (
                y = i[d],
                  m =
                    (((x = i[(p = h - 1)]) - b) * (x + b) +
                      ((_ = S[p]) - (g = S[h])) * (_ + g)) /
                    (2 * g * x),
                  _ = e.pythag(m, 1),
                  m =
                    ((y - b) * (y + b) + g * (x / (m + e.sign(_, m)) - g)) / y,
                  f = v = 1,
                  c = d;
                c <= p;
                ++c
              ) {
                for (
                  _ = S[(s = c + 1)],
                    x = i[s],
                    g = v * _,
                    _ *= f,
                    b = e.pythag(m, g),
                    S[c] = b,
                    m = y * (f = m / b) + _ * (v = g / b),
                    _ = _ * f - y * v,
                    g = x * v,
                    x *= f,
                    u = 0;
                  u < r;
                  ++u
                )
                  (y = o[u][c]),
                    (b = o[u][s]),
                    (o[u][c] = y * f + b * v),
                    (o[u][s] = b * f - y * v);
                for (
                  b = e.pythag(m, g),
                    i[c] = b,
                    0 !== b && ((f = m * (b = 1 / b)), (v = g * b)),
                    m = f * _ + v * x,
                    y = f * x - v * _,
                    u = 0;
                  u < n;
                  ++u
                )
                  (x = t[u][c]),
                    (b = t[u][s]),
                    (t[u][c] = x * f + b * v),
                    (t[u][s] = b * f - x * v);
              }
              (S[d] = 0), (S[h] = m), (i[h] = y);
            }
          return !0;
        }),
          (e.pythag = function (e, t) {
            var n,
              r = Math.abs(e),
              i = Math.abs(t);
            return r > i
              ? ((n = i / r), r * Math.sqrt(1 + n * n))
              : 0 === i
              ? 0
              : ((n = r / i), i * Math.sqrt(1 + n * n));
          }),
          (e.sign = function (e, t) {
            return t >= 0 ? Math.abs(e) : -Math.abs(e);
          });
        var t = t || {};
        return (
          (t.Posit = function (e, t, n) {
            t.length
              ? (this.objectPoints = t)
              : (this.objectPoints = this.buildModel(t, n)),
              (this.focalLength = e),
              (this.objectVectors = []),
              (this.objectNormal = []),
              (this.objectMatrix = [[], [], []]),
              this.init();
          }),
          (t.Posit.prototype.buildModel = function (e, t) {
            t || (t = e);
            var n = e / 2,
              r = t / 2;
            return [
              [-n, r, 0],
              [n, r, 0],
              [n, -r, 0],
              [-n, -r, 0],
            ];
          }),
          (t.Posit.prototype.init = function () {
            var e,
              n = this.objectPoints.length,
              r = [],
              i = [],
              o = 0,
              a = 2;
            for (e = 0; e < n; ++e)
              (this.objectVectors[e] = [
                this.objectPoints[e][0] - this.objectPoints[0][0],
                this.objectPoints[e][1] - this.objectPoints[0][1],
                this.objectPoints[e][2] - this.objectPoints[0][2],
              ]),
                (r[e] = [
                  this.objectVectors[e][0],
                  this.objectVectors[e][1],
                  this.objectVectors[e][2],
                ]);
            for (; 0 === o; )
              (i[0] =
                this.objectVectors[1][1] * this.objectVectors[a][2] -
                this.objectVectors[1][2] * this.objectVectors[a][1]),
                (i[1] =
                  this.objectVectors[1][2] * this.objectVectors[a][0] -
                  this.objectVectors[1][0] * this.objectVectors[a][2]),
                (i[2] =
                  this.objectVectors[1][0] * this.objectVectors[a][1] -
                  this.objectVectors[1][1] * this.objectVectors[a][0]),
                (o = Math.sqrt(i[0] * i[0] + i[1] * i[1] + i[2] * i[2])),
                ++a;
            for (e = 0; e < 3; ++e) this.objectNormal[e] = i[e] / o;
            t.pseudoInverse(r, n, this.objectMatrix);
          }),
          (t.Posit.prototype.pose = function (e) {
            var n,
              r,
              i,
              o,
              a,
              s,
              l = [[], [], []],
              c = [[], [], []],
              u = [],
              h = [[], [], []],
              d = [[], [], []],
              p = [],
              f = [];
            for (
              this.pos(e, l, c, u),
                n = (i = this.isValid(l, u))
                  ? this.iterate(e, l, u, h, p)
                  : {
                      euclidean: -1,
                      pixels: -1,
                      maximum: -1,
                    },
                r = (o = this.isValid(c, u))
                  ? this.iterate(e, c, u, d, f)
                  : {
                      euclidean: -1,
                      pixels: -1,
                      maximum: -1,
                    },
                a = 0;
              a < 3;
              ++a
            )
              for (s = 0; s < 3; ++s)
                i && (p[a] -= h[a][s] * this.objectPoints[0][s]),
                  o && (f[a] -= d[a][s] * this.objectPoints[0][s]);
            return n.euclidean < r.euclidean
              ? new t.Pose(n.pixels, h, p, r.pixels, d, f)
              : new t.Pose(r.pixels, d, f, n.pixels, h, p);
          }),
          (t.Posit.prototype.pos = function (e, t, n, r) {
            var i,
              o,
              a,
              s,
              l,
              c,
              u,
              h,
              d,
              p,
              f = this.objectPoints.length,
              m = [],
              g = [],
              v = [],
              y = [],
              x = [],
              b = [],
              w = [],
              _ = [];
            for (d = 0; d < f; ++d) m[d] = [e[d].x - e[0].x, e[d].y - e[0].y];
            for (d = 0; d < 3; ++d)
              for (g[d] = 0, v[d] = 0, p = 0; p < f; ++p)
                (g[d] += this.objectMatrix[d][p] * m[p][0]),
                  (v[d] += this.objectMatrix[d][p] * m[p][1]);
            for (
              i = g[0] * g[0] + g[1] * g[1] + g[2] * g[2],
                s =
                  ((o = v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) - i) *
                    (o - i) +
                  (a = g[0] * v[0] + g[1] * v[1] + g[2] * v[2]) * a * 4,
                u =
                  (l =
                    o - i >= 0
                      ? (o - i + Math.sqrt(s)) / 2
                      : (o - i - Math.sqrt(s)) / 2) >= 0
                    ? 0 === (c = Math.sqrt(l))
                      ? 0
                      : -a / c
                    : 0 === (c = Math.sqrt((-a * a) / l))
                    ? Math.sqrt(i - o)
                    : -a / c,
                d = 0;
              d < 3;
              ++d
            )
              (y[d] = g[d] + c * this.objectNormal[d]),
                (x[d] = v[d] + u * this.objectNormal[d]);
            for (
              h = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]), d = 0;
              d < 3;
              ++d
            )
              (b[d] = y[d] / h), (w[d] = x[d] / h);
            for (
              _[0] = b[1] * w[2] - b[2] * w[1],
                _[1] = b[2] * w[0] - b[0] * w[2],
                _[2] = b[0] * w[1] - b[1] * w[0],
                d = 0;
              d < 3;
              ++d
            )
              (t[0][d] = b[d]), (t[1][d] = w[d]), (t[2][d] = _[d]);
            for (d = 0; d < 3; ++d)
              (y[d] = g[d] - c * this.objectNormal[d]),
                (x[d] = v[d] - u * this.objectNormal[d]);
            for (d = 0; d < 3; ++d) (b[d] = y[d] / h), (w[d] = x[d] / h);
            for (
              _[0] = b[1] * w[2] - b[2] * w[1],
                _[1] = b[2] * w[0] - b[0] * w[2],
                _[2] = b[0] * w[1] - b[1] * w[0],
                d = 0;
              d < 3;
              ++d
            )
              (n[0][d] = b[d]), (n[1][d] = w[d]), (n[2][d] = _[d]);
            (r[0] = e[0].x / h),
              (r[1] = e[0].y / h),
              (r[2] = this.focalLength / h);
          }),
          (t.Posit.prototype.isValid = function (e, t) {
            for (
              var n, r = this.objectPoints.length, i = 1 / 0, o = 0;
              o < r;
              ++o
            )
              (n =
                t[2] +
                (e[2][0] * this.objectVectors[o][0] +
                  e[2][1] * this.objectVectors[o][1] +
                  e[2][2] * this.objectVectors[o][2])) < i && (i = n);
            return i >= 0;
          }),
          (t.Posit.prototype.iterate = function (e, t, n, r, i) {
            var o,
              a,
              s,
              l,
              c,
              u,
              h,
              d,
              p,
              f = this.objectPoints.length,
              m = [],
              g = [],
              v = [[], [], []],
              y = [[], [], []],
              x = [],
              b = [],
              w = !1,
              _ = 0;
            for (d = 0; d < f; ++d)
              m[d] = {
                x: e[d].x,
                y: e[d].y,
              };
            for (d = 0; d < 3; ++d) {
              for (p = 0; p < 3; ++p) r[d][p] = t[d][p];
              i[d] = n[d];
            }
            for (d = 0; d < f; ++d) {
              for (s = 0, p = 0; p < 3; ++p)
                s += (this.objectVectors[d][p] * r[2][p]) / i[2];
              g[d] = {
                x: (1 + s) * e[d].x,
                y: (1 + s) * e[d].y,
              };
            }
            for (a = 0, d = 0; d < f; ++d)
              (a += Math.abs(g[d].x - m[d].x)),
                (a += Math.abs(g[d].y - m[d].y));
            for (d = 0; d < 3; ++d)
              x[d] =
                i[d] -
                (r[d][0] * this.objectPoints[0][0] +
                  r[d][1] * this.objectPoints[0][1] +
                  r[d][2] * this.objectPoints[0][2]);
            for (
              l = c = this.error(e, r, x), w = 0 === c.pixels || a < 0.01;
              _++ < 1e3 && !w;

            ) {
              for (d = 0; d < f; ++d) (m[d].x = g[d].x), (m[d].y = g[d].y);
              for (this.pos(g, v, y, i), d = 0; d < 3; ++d)
                (x[d] =
                  i[d] -
                  (v[d][0] * this.objectPoints[0][0] +
                    v[d][1] * this.objectPoints[0][1] +
                    v[d][2] * this.objectPoints[0][2])),
                  (b[d] =
                    i[d] -
                    (y[d][0] * this.objectPoints[0][0] +
                      y[d][1] * this.objectPoints[0][1] +
                      y[d][2] * this.objectPoints[0][2]));
              if (
                ((c = this.error(e, v, x)),
                (u = this.error(e, y, b)),
                c.euclidean >= 0 && u.euclidean >= 0)
              )
                if (u.euclidean < c.euclidean)
                  for (l = u, d = 0; d < 3; ++d)
                    for (p = 0; p < 3; ++p) r[d][p] = y[d][p];
                else
                  for (l = c, d = 0; d < 3; ++d)
                    for (p = 0; p < 3; ++p) r[d][p] = v[d][p];
              if (c.euclidean < 0 && u.euclidean >= 0)
                for (l = u, d = 0; d < 3; ++d)
                  for (p = 0; p < 3; ++p) r[d][p] = y[d][p];
              if (u.euclidean < 0 && c.euclidean >= 0)
                for (l = c, d = 0; d < 3; ++d)
                  for (p = 0; p < 3; ++p) r[d][p] = v[d][p];
              for (d = 0; d < f; ++d) {
                for (s = 0, p = 0; p < 3; ++p)
                  s += (this.objectVectors[d][p] * r[2][p]) / i[2];
                (g[d].x = (1 + s) * e[d].x), (g[d].y = (1 + s) * e[d].y);
              }
              for (o = a, a = 0, d = 0; d < f; ++d)
                (a += Math.abs(g[d].x - m[d].x)),
                  (a += Math.abs(g[d].y - m[d].y));
              (h = Math.abs(a - o)), (w = 0 === l.pixels || h < 0.01);
            }
            return l;
          }),
          (t.Posit.prototype.error = function (e, t, n) {
            var r,
              i,
              o,
              a = this.objectPoints.length,
              s = [],
              l = [],
              c = [],
              u = 0,
              h = 0,
              d = 0;
            if (!this.isValid(t, n))
              return {
                euclidean: -1,
                pixels: -1,
                maximum: -1,
              };
            for (r = 0; r < a; ++r)
              for (s[r] = [], i = 0; i < 3; ++i) s[r][i] = n[i];
            for (r = 0; r < a; ++r)
              for (i = 0; i < 3; ++i)
                for (o = 0; o < 3; ++o)
                  s[r][i] += t[i][o] * this.objectPoints[r][o];
            for (r = 0; r < a; ++r)
              for (l[r] = [], i = 0; i < 2; ++i)
                l[r][i] = (this.focalLength * s[r][i]) / s[r][2];
            for (r = 0; r < a; ++r) c[r] = [l[r][0] - e[r].x, l[r][1] - e[r].y];
            for (r = 0; r < a; ++r)
              (u += Math.sqrt(c[r][0] * c[r][0] + c[r][1] * c[r][1])),
                (h +=
                  Math.abs(Math.round(l[r][0]) - Math.round(e[r].x)) +
                  Math.abs(Math.round(l[r][1]) - Math.round(e[r].y))),
                Math.abs(c[r][0]) > d && (d = Math.abs(c[r][0])),
                Math.abs(c[r][1]) > d && (d = Math.abs(c[r][1]));
            return {
              euclidean: u / a,
              pixels: h,
              maximum: d,
            };
          }),
          (t.pseudoInverse = function (t, n, r) {
            var i,
              o,
              a,
              s = [],
              l = [[], [], []],
              c = [[], [], []],
              u = 0,
              h = 0;
            for (e.svdcmp(t, n, 3, s, l), i = 0; i < 3; ++i)
              s[i] > u && (u = s[i]);
            for (u *= 0.01, i = 0; i < 3; ++i) s[i] < u && (s[i] = 0);
            for (o = 0; o < 3; ++o)
              if (0 === s[o])
                for (++h, a = o; a < 2; ++a) {
                  for (i = 0; i < n; ++i) t[i][a] = t[i][a + 1];
                  for (i = 0; i < 3; ++i) l[i][a] = l[i][a + 1];
                }
            for (o = 0; o < 2; ++o) 0 === s[o] && (s[o] = s[o + 1]);
            for (i = 0; i < 3; ++i)
              for (o = 0; o < 3 - h; ++o) c[i][o] = l[i][o] / s[o];
            for (i = 0; i < 3; ++i)
              for (o = 0; o < n; ++o)
                for (r[i][o] = 0, a = 0; a < 3 - h; ++a)
                  r[i][o] += c[i][a] * t[o][a];
          }),
          (t.Pose = function (e, t, n, r, i, o) {
            (this.bestError = e),
              (this.bestRotation = t),
              (this.bestTranslation = n),
              (this.alternativeError = r),
              (this.alternativeRotation = i),
              (this.alternativeTranslation = o);
          }),
          function (e, n, r, i) {
            e = e.map(function (e) {
              return {
                x: (e.x * window.innerWidth) / 2,
                y: (e.y * window.innerHeight) / 2,
              };
            });
            var o = new t.Posit(480, n, r).pose(e),
              a = o.bestRotation,
              s = o.bestTranslation;
            (i.rotation.x = Math.asin(-a[1][2])),
              (i.rotation.y = -Math.atan2(a[0][2], a[2][2])),
              (i.rotation.z = Math.atan2(a[1][0], a[1][1]) + Math.PI),
              (i.position.x = -s[0]),
              (i.position.y = -s[1]),
              (i.position.z = s[2]);
          }
        );
      })(),
      T = s.a.getRalDict(),
      E = [],
      A = [],
      C = [],
      P = new a.MeshStandardMaterial(),
      L = new a.LineBasicMaterial({
        color: 3355443,
      }),
      R = (function () {
        function e(e, t) {
          if (
            Math.min(screen.width, screen.height) < 800 &&
            document.body.requestFullscreen
          ) {
            var n = document.createElement("div");
            n.innerHTML =
              '\n            <div id="fs-popup">\n                <div class="q">SMALL SCREEN DETECTED<br/>GO FULLSCREEN?</div>\n                <div class="btn-c">\n                    <a href="#" class="btn-no">NO</a>\n                    <a href="#" class="btn-yes">YES</a>\n                </div>\n            </div>\n            ';
            var r = document.createElement("style");
            (r.innerHTML =
              "\n                #fs-popup {\n                    display: block;\n                    position: fixed;\n                    width: 100vw;\n                    height: 100vh;\n                    left: 0px;\n                    top: 0px;\n                    text-align: center;\n                    background: rgba(0,0,0,0.75);\n                    z-index: 1000;\n                    color: white;\n                    padding:20%;\n                }\n\n                #fs-popup > div {\n                    display: block;\n                    position: relative;\n                    height: 4em;\n                }\n\n                #fs-popup > .btn-c > a {\n                    width:4em;\n                    background-color: #000;\n                    color: white;\n                    border:1px gray solid;\n                    padding: 0.5em;\n                    width: 5em;\n                    font-weight: bolder;\n                    display: inline-block;\n                }\n\n                #fs-popup > .btn-c > a.btn-yes {\n                    background-color: #fff;\n                    color: black;\n                }\n            "),
              document.body.appendChild(n),
              document.head.appendChild(r),
              n.querySelectorAll("a").forEach(function (e) {
                e.addEventListener("click", function (e) {
                  e.target.classList.contains("btn-yes") &&
                    document.body.requestFullscreen(),
                    n.remove(),
                    r.remove();
                });
              });
          }
          var i,
            a = innerWidth,
            s = document.getElementsByName("viewport")[0];

          function l() {
            document.documentElement.style.setProperty(
              "--viewport-width",
              window.innerWidth + "px"
            ),
              document.documentElement.style.setProperty(
                "--viewport-height",
                window.innerHeight + "px"
              ),
              c.env.renderer.setSize(window.innerWidth, window.innerHeight);
          }
          s ||
            ((s = document.createElement("meta")).setAttribute(
              "name",
              "viewport"
            ),
            document.head.append(s)),
            s.setAttribute(
              "content",
              "width = " +
                a +
                ", minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
            ),
            document.addEventListener("DOMContentLoaded", l),
            document.addEventListener("resize", l),
            window.addEventListener("orientationchange", l),
            document.body.requestFullscreen &&
              document.body.addEventListener("fullscreenchange", l),
            window.addEventListener("focus", l),
            (this.context = e),
            (this.environment = t),
            this.setLocales(e),
            (i = e.logoUrl),
            o.component("vsl-logo", {
              data: function () {
                return {
                  logoUrl: i,
                };
              },
              template: '<img :src="logoUrl" class="vsl-logo"/>',
            });
          var c = t.renderer,
            u = t.env;
          (E = e.config.floatGuis || []),
            (A = E.map(function (e) {
              return e.elementId;
            })),
            (C = []);
          var h = function () {
            return console.warn("empty updatemesh called");
          };
          if (
            (I(c, e.config.builders.materials, t),
            e.serverParameters && e.serverParameters.meta.openInVR)
          ) {
            var d = window.location.href.replace(
              /\/share\//gi,
              "https://productconfigurator.virtualsaleslab.com/vr/"
            );
            window.location.replace(d);
          } else if (e.config.data.meta.loginRequired && !e.isLoggedIn)
            window.location.replace(e.loginUrl);
          else if (
            !e.serverParameters ||
            e.serverParameters.meta.allowEdit ||
            (e.serverParameters &&
              e.serverParameters.meta.loginRequired &&
              e.isLoggedIn)
          ) {
            e.serverParameters && (e.config.data = e.serverParameters);
            var p = this.getViewerGui(this.context.config, h, void 0, t, c);
            (this.gui = new p({
              el: "#sidebar-container",
            })),
              this.registerPopupListener(c, h, t),
              this.hideProgressIndicatorWhenDone(
                this.gui.$children[0].updateMesh
              );
          } else
            this.getEditorGui(c, t, u, e),
              this.hideProgressIndicatorWhenDone(this.gui.updateMesh),
              this.registerPopupListener(c, h, t);
          t.newBuilder.loadTexturesAndMaterial(
            e.config.builders,
            new o({
              data: e.config.data,
            })
          ),
            this.registerKeyEventListeners(t),
            e.config.floatGui && this.buildFloatGui(t, e);
        }
        return (
          (e.prototype.refreshConfig = function (e) {
            this.environment.newBuilder.resetConfigurationParser();
            var t =
                JSON.stringify(this.context.config.locales) !=
                JSON.stringify(e.locales),
              n =
                t ||
                JSON.stringify(this.context.config.gui) !=
                  JSON.stringify(e.gui),
              r =
                t ||
                JSON.stringify(this.context.config.floatGui) !=
                  JSON.stringify(e.floatGui);
            if (((this.context.config = e), n)) {
              var i = this.getViewerGui(
                this.context.config,
                function () {},
                null,
                this.environment,
                this.environment.renderer
              );
              this.gui = new i({
                el: "#sidebar-container",
              });
            }
            r &&
              this.context.config.floatGui &&
              this.buildFloatGui(this.environment, this.context),
              this.gui.$children[0].updateMesh.call(this.gui.$children[0]);
          }),
          (e.prototype.getViewerGui = function (e, t, n, r, i) {
            var o = this,
              s = this.context.serverParameters || e.data,
              l = this;
            s.interactive.dragAndDropGridSize =
              s.interactive.dragAndDropGridSize || 1;
            var c = (function () {
                var e = new a.Mesh(
                  new a.PlaneBufferGeometry(3e3, 3e3, 30, 30),
                  new a.MeshBasicMaterial()
                );
                e.material.color.setHex(0), (e.material.wireframe = !0);
                var t = e.clone();
                t.position.y += 1500;
                var n = e.clone();
                (n.rotation.x += Math.PI / 2),
                  (n.position.z += 1500),
                  (n.material = e.material.clone()),
                  e.material.color.setHex(16777215);
                var r = new a.Object3D();
                return (
                  (r.name = "grids"),
                  r.add(n),
                  r.add(t),
                  (r.rotation.x = Math.PI),
                  r
                );
              })(),
              u = e.gui.map(function (e, a) {
                var s, u;
                return (
                  (u = (s = o.getEditorComponent(r, e, t, n, i, l, c, null, a))
                    .__return),
                  (t = s.updatemesh),
                  (n = s.mainGui),
                  u
                );
              });
            return w.getSidebar().extend({
              data: function () {
                return {
                  currentComponentName: u[0].name,
                  componentInfo: u,
                  prevButtonText: this.$t("generalbuttonprevious"),
                  nextButtonText: this.$t("generalbuttonnext"),
                };
              },
              methods: {
                propertyUpdated: function (e, t) {
                  this.$children.length &&
                    this.$children[0].propertyUpdated(e, t);
                },
              },
              watch: {
                currentComponentName: function () {
                  "none" != this.currentComponentName &&
                    this.vars &&
                    (this.vars.currentUI = this.currentUI);
                },
              },
              components: u.reduce(function (e, t) {
                return (e[t.name] = t.component), e;
              }, {}),
              locales: {
                nl: {
                  generalbuttonnext: "Volgende",
                  generalbuttonprevious: "Vorige",
                },
                en: {
                  generalbuttonnext: "Next",
                  generalbuttonprevious: "Back",
                },
                de: {
                  generalbuttonnext: "Weiter",
                  generalbuttonprevious: "Zurück",
                },
                fr: {
                  generalbuttonnext: "Suivant",
                  generalbuttonprevious: "Précédent",
                },
              },
            });
          }),
          (e.prototype.getEditorComponent = function (
            e,
            t,
            n,
            r,
            o,
            s,
            l,
            c,
            u,
            d
          ) {
            void 0 === d && (d = this.context);
            var p = o.env;
            return {
              __return: {
                name: "item" + u,
                component: new h.UIBuilder(e.env, d.isLoggedIn, e.dragNDrop)
                  .buildClass(t.ui, !0, e.dragNDrop, e.newBuilder)
                  .extend({
                    data: function () {
                      return d.config.data;
                    },
                    ready: function () {
                      var t = this;
                      (n = this.updateMesh),
                        (r = this),
                        this.$on("propertyupdated", function (e, n) {
                          return t.propertyUpdated(e, n);
                        }),
                        this.$on("valuechanged", function (e, n) {
                          return t.propertyUpdated(e, n);
                        });
                      var s = this.updateMesh();
                      this.homography && this.homography.enabled
                        ? o.lookFromTo(
                            new a.Vector3(0, 0, 0),
                            new a.Vector3(0, 0, 100)
                          )
                        : o.lookAtObject(s.name, 0, 0, 3 * -this.size.width),
                        e.attachComponent();
                      var l = function (e, t) {
                        return Math.round(e / t) * t;
                      };
                      (e.dragNDrop.emitEvent = function (e) {
                        e.dropped.forEach(function (e) {
                          (e.height = l(
                            e.height,
                            t.interactive.dragAndDropGridSize
                          )),
                            (e.width = l(
                              e.width,
                              t.interactive.dragAndDropGridSize
                            )),
                            (e.position[0] = l(
                              e.position[0],
                              t.interactive.dragAndDropGridSize / 2
                            )),
                            (e.position[1] = l(
                              e.position[1],
                              t.interactive.dragAndDropGridSize / 2
                            ));
                        }),
                          t.$set("elements.droppedElements", e.dropped),
                          t.$emit(
                            "propertyupdated",
                            "elements.droppedElements",
                            e.dropped
                          ),
                          t.updateMesh();
                      }),
                        (this.updateImg = function () {
                          window.setTimeout(function () {
                            if (t.homography.enabled) {
                              var e = new Image();
                              (e.onload = function () {
                                o.setBackgroundImage(e);
                              }),
                                (e.src = Object(i.c)(
                                  t.homography.imageSrc ||
                                    "textures/perspectivebg.jpg"
                                ));
                            }
                          }, 1e3);
                        }),
                        window.addEventListener("resize", this.updateImg),
                        window.addEventListener(
                          "orientationchange",
                          this.updateImg
                        );
                    },
                    beforeDestroy: function () {
                      e.detachComponent(),
                        this.$off("propertyupdated"),
                        this.$off("valuechanged"),
                        window.removeEventListener("resize", this.updateImg),
                        window.removeEventListener(
                          "orientationchange",
                          this.updateImg
                        );
                    },
                    methods: {
                      propertyUpdated: function (t, n) {
                        var r =
                            /([^\.]+)(RalColorId|Roughness|Metalness)$/i.exec(
                              t
                            ),
                          i = r ? e.materials[r[1]] : null;
                        if (i) {
                          switch (r[2]) {
                            case "RalColorId":
                              i.color.setHex(T.getHexColor(n));
                              break;
                            case "Roughness":
                              i.roughness = n;
                              break;
                            case "Metalness":
                              i.metalness = n;
                              break;
                            case "imageUrl":
                              new a.TextureLoader().load(n, function (e) {
                                i.map = e;
                              });
                          }
                          i.needsUpdate = !0;
                        } else {
                          if ("interactive.sunRotation" === t) {
                            var l = p.scene.getObjectByName("sun"),
                              c = (n / 180) * Math.PI,
                              u = Math.sin(c),
                              h = Math.cos(c);
                            return (l.position.x = u), void (l.position.z = -h);
                          }
                          if ("interactive.isNight" === t) {
                            var f = n ? "hof_night" : "hof";
                            I(o, d.config.builders.materials, e, f),
                              ((l = p.scene.getObjectByName("sun")).visible =
                                !n),
                              (p.scene.getObjectByName("ambient").intensity = n
                                ? 0.001
                                : 0.3);
                          } else this.$set(t, n);
                        }
                        var m = this.updateMesh();
                        "homography.enabled" === t &&
                          (n
                            ? o.lookFromTo(
                                new a.Vector3(0, 0, 0),
                                new a.Vector3(0, 0, 100)
                              )
                            : o.lookAtObject(
                                m.name,
                                0,
                                0,
                                3 * -this.size.width
                              )),
                          s.floatGui &&
                            (s.floatGui.$emit("propertyupdated", t, n),
                            s.floatGui.$children.length &&
                              s.floatGui.$children[0].$set(
                                "vars",
                                JSON.parse(JSON.stringify(this.vars))
                              ));
                      },
                      updateMesh: function () {
                        var n = this,
                          r = e.newBuilder.build(
                            this.style.type,
                            d.config.builders,
                            this,
                            A
                          ),
                          i = r.obj;
                        i.name = "Woohoo";
                        var s = new a.Object3D();
                        s.add(i),
                          (s.name = "wrapped " + i.name),
                          (e.dragNDrop.dropTargets = r.dropTargets),
                          (e.dragNDrop.dropped = r.dropped),
                          i.traverse(function (t) {
                            var r = t;
                            if (
                              r.material &&
                              r.material !== e.materials.shadowMaterial &&
                              "arrow" != (r.material.name || "xyz")
                            ) {
                              if (
                                n.interactive.inArchitectureMode &&
                                r.visible
                              ) {
                                var o = P;
                                if (
                                  (r.material.opacity &&
                                    r.material.opacity < 1 &&
                                    (((o = o.clone()).opacity =
                                      r.material.opacity),
                                    (o.transparent = !0)),
                                  (r.material = o),
                                  r.geometry &&
                                    r.geometry.hasAttribute("position"))
                                ) {
                                  var s = new a.EdgesGeometry(r.geometry, 5),
                                    l = new a.LineSegments(s, L);
                                  r.parent.add(l),
                                    l.position.copy(r.position),
                                    l.rotation.copy(r.rotation),
                                    l.scale.copy(r.scale);
                                }
                              }
                              var c = r.material;
                              t.castShadow = !c.transparent || c.opacity > 0.7;
                            }
                            (t.receiveShadow = r.receiveShadow =
                              "noshading" != i.name),
                              "target" in r &&
                                "updateMatrixWorld" in r.target &&
                                r.target.updateMatrixWorld(!0);
                          }),
                          (C = r.actionableObjects),
                          o.addOrReplaceObject(s),
                          o.scene.updateMatrixWorld(),
                          (e.dragNDrop.activeDropTargetIds =
                            t.activeDropTargetIds);
                        var c = e.newBuilder.buildDraggableElements(
                          e.dragNDrop.activeDropTargetIds,
                          d.config.builders,
                          this,
                          A
                        );
                        if (
                          (e.updateDraggableElements(c),
                          this.interactive.inArchitectureMode)
                        )
                          this.backgroundImage;
                        else if ("photo" == this.mode);
                        else if (
                          "homography" == this.mode ||
                          (this.homography && this.homography.enabled)
                        ) {
                          var u = 0.1,
                            h = (u * window.innerWidth) / window.innerHeight,
                            p = [
                              {
                                x: -u,
                                y: -h,
                              },
                              {
                                x: u,
                                y: -h,
                              },
                              {
                                x: u,
                                y: h,
                              },
                              {
                                x: -u,
                                y: h,
                              },
                            ].map(
                              function (e) {
                                return {
                                  x:
                                    e.x +
                                    1.5 * (this.homography.position.x - 0.5),
                                  y:
                                    e.y +
                                    1.5 * (this.homography.position.y - 0.5),
                                };
                              }.bind(this)
                            ),
                            f = i;
                          S(p, 200, 200, f.parent),
                            f.scale.setScalar(this.homography.scale),
                            (f.parent.rotation.x += this.homography.rotation.x),
                            (f.parent.rotation.y +=
                              this.homography.rotation.y + Math.PI);
                          this.backgroundImage;
                          if (this.homography.gridsVisible)
                            (f.getObjectByName("gridanchor") || f).add(l);
                        } else
                          o.setBackgroundImage(null),
                            i.parent.rotation.set(0, 0, 0);
                        return i;
                      },
                      mesh: function () {
                        return null === c && this.updateMesh(), c;
                      },
                      printPlanViews: function () {
                        var e = document.getElementById("js-pdf-lib"),
                          t = this,
                          n = function () {
                            var e = new window.jsPDF({
                              orientation: "l",
                            });
                            e.setProperties({
                              title: "Report",
                            });
                            e.rect(10, 10, 277, 190);
                            var n = Math.min(138.5, 95),
                              r = 138.5 - n,
                              i = 95 - n;
                            Object.values(t.planViews).forEach(function (t, o) {
                              var a = 138.5 * (1 & o) + 10 + r / 2,
                                s = 95 * ((o >> 1) & 1) + 10 + i / 2;
                              e.addImage(t, "JPG", a, s - 20, n, n);
                            }),
                              window.open(e.output("bloburl"), "_blank"),
                              e.addH;
                          };
                        if (e) n();
                        else {
                          var r = document.createElement("script");
                          (r.id = "js-pdf-lib"),
                            r.setAttribute(
                              "src",
                              "../../../assets/jspdf/jspdf.min.js"
                            ),
                            (r.onload = n),
                            document.head.appendChild(r);
                        }
                      },
                    },
                    computed: {
                      renderer: function () {
                        return o;
                      },
                      backgroundImage: function () {
                        var e = this;
                        if (
                          !this.homography.enabled &&
                          !this.interactive.inArchitectureMode
                        )
                          return null;
                        var t = new Image();
                        t.onload = function () {
                          o.setBackgroundImage(
                            t,
                            !e.interactive.inArchitectureMode
                          );
                        };
                        var n = this.interactive.inArchitectureMode
                          ? "images/papergrid_bg.png"
                          : this.homography.imageSrc ||
                            "textures/perspectivebg.jpg";
                        return (t.src = Object(i.c)(n)), t;
                      },
                      planViews: function () {
                        var t = this,
                          n = JSON.parse(JSON.stringify(this.$data));
                        n.interactive.inArchitectureMode = !0;
                        var r = e.newBuilder.build(
                          n.style.type,
                          d.config.builders,
                          n,
                          A
                        ).obj;
                        r.traverse(function (n) {
                          var i = n;
                          if (
                            i.material &&
                            i.material !== e.materials.shadowMaterial &&
                            "arrow" != (i.material.name || "xyz")
                          ) {
                            if (t.interactive.inArchitectureMode && i.visible) {
                              var o = P;
                              if (
                                (i.material.opacity &&
                                  i.material.opacity < 1 &&
                                  (((o = o.clone()).opacity =
                                    i.material.opacity),
                                  (o.transparent = !0)),
                                (i.material = o),
                                i.geometry &&
                                  i.geometry.hasAttribute("position"))
                              ) {
                                var s = new a.EdgesGeometry(i.geometry, 5),
                                  l = new a.LineSegments(s, L);
                                i.parent.add(l),
                                  l.position.copy(i.position),
                                  l.rotation.copy(i.rotation),
                                  l.scale.copy(i.scale);
                              }
                            }
                            var c = i.material;
                            n.castShadow = !c.transparent || c.opacity > 0.7;
                          }
                          (n.receiveShadow = i.receiveShadow =
                            "noshading" != r.name),
                            "target" in i &&
                              "updateMatrixWorld" in i.target &&
                              i.target.updateMatrixWorld(!0);
                        });
                        var i = Math.max(
                            this.size.width,
                            this.size.depth,
                            this.size.height
                          ),
                          o = new a.Vector3().setScalar(i + 100),
                          s = new a.Vector3(0, 0, 0),
                          l = new a.Box3().setFromCenterAndSize(s, o),
                          c = {
                            Front: [0, 0, Math.PI],
                            Right: [0, Math.PI / 2, Math.PI],
                            Top: [Math.PI / 2, 0, Math.PI],
                            Isometric: [Math.PI / 6, 1.75 * Math.PI, Math.PI],
                          },
                          u = Object.entries(c).map(function (t, n) {
                            var o = t[0],
                              a = t[1];
                            return (
                              r.rotation.fromArray(a),
                              3 == n && l.expandByScalar(i / 4),
                              [o, e.newBuilder.renderToPng(r, 500, !0, l)]
                            );
                          });
                        return {
                          images: Object.fromEntries(u),
                          timestamp: Date.now(),
                        }.images;
                      },
                      inExperimentalMode: {
                        cached: !1,
                        get: function () {
                          return !!document.baseURI.match(
                            /experimental=(1|true)/i
                          );
                        },
                      },
                    },
                    locales: d.config.locales,
                  }),
                icon: t.faIcon,
              },
              updatemesh: n,
              mainGui: r,
            };
          }),
          (e.prototype.getEditorGui = function (e, t, n, r) {
            this.gui = new o({
              el: "#sidebar-container",
              data: function () {
                return (
                  (r.serverParameters.newUrl = r.newUrl), r.serverParameters
                );
              },
              ready: function () {
                var t = this.updateMesh();
                this.homography.enabled
                  ? e.lookFromTo(
                      new a.Vector3(0, 0, 0),
                      new a.Vector3(0, 0, 100)
                    )
                  : e.lookAtObject(t.name, 0, 0, 3 * -this.size.width);
              },
              template:
                '<div class="share-container"><vsl-logo></vsl-logo><h5>{{$t("step6tiltle1")}}</h5><template v-if="allowNew"><p>{{{$t("step6description0")}}}</p><p>{{{$t("step6description1")}}}</p><a class="btn btn-primary" :href="newUrl"><i class="fa fa-sign-in" aria-hidden="true"></i>{{$t("step6clickbutton")}}</a></template><template v-if="inExperimentalMode"><button  @click.stop="printPlanViews" style="float:right">Print to PDF</button></template></div>',
              methods: {
                propertyUpdated: function (r, i) {
                  var o = /([^\.]+)RalColorId$/i.exec(r);
                  if (o) {
                    var s = o[1];
                    t.materials[s].color.setHex(T.getHexColor(i));
                  } else {
                    if ("interactive.sunRotation" === r) {
                      var l = n.scene.getObjectByName("sun"),
                        c = (i / 180) * Math.PI,
                        u = Math.sin(c),
                        h = Math.cos(c);
                      return (l.position.x = u), void (l.position.z = -h);
                    }
                    this.$set(r, i);
                    var d = this.updateMesh();
                    "homography.enabled" === r &&
                      (i
                        ? e.lookFromTo(
                            new a.Vector3(0, 0, 0),
                            new a.Vector3(0, 0, 100)
                          )
                        : e.lookAtObject(d.name, 0, 0, 3 * -this.size.width));
                  }
                },
                updateMesh: function () {
                  var n = this,
                    i = t.newBuilder.build(
                      this.style.type,
                      r.config.builders,
                      this,
                      A
                    ),
                    o = i.obj;
                  o.name = "Woohoo";
                  var s = new a.Object3D();
                  if (
                    (s.add(o),
                    (s.name = "wrapped " + o.name),
                    o.traverse(function (e) {
                      var r = e;
                      if (r.material) {
                        if (n.interactive.inArchitectureMode && r.visible) {
                          var i = P;
                          if (
                            (r.material.opacity &&
                              r.material.opacity < 1 &&
                              (((i = i.clone()).opacity = r.material.opacity),
                              (i.transparent = !0)),
                            (r.material = i),
                            r.geometry && r.geometry.hasAttribute("position"))
                          ) {
                            var o = new a.EdgesGeometry(r.geometry, 5),
                              s = new a.LineSegments(o, L);
                            r.parent.add(s),
                              s.position.copy(r.position),
                              s.rotation.copy(r.rotation),
                              s.scale.copy(r.scale);
                          }
                        }
                        if (
                          r.material &&
                          r.material !== t.materials.shadowMaterial
                        ) {
                          var l = r.material;
                          e.castShadow = !l.transparent || l.opacity > 0.7;
                        }
                        e.receiveShadow = !0;
                      }
                    }),
                    e.addOrReplaceObject(s),
                    this.interactive.inArchitectureMode)
                  )
                    this.backgroundImage;
                  else if ("photo" == this.mode);
                  else if (
                    "homography" == this.mode ||
                    (this.homography && this.homography.enabled)
                  ) {
                    var l = 0.1,
                      c = (l * window.innerWidth) / window.innerHeight,
                      u = [
                        {
                          x: -l,
                          y: -c,
                        },
                        {
                          x: l,
                          y: -c,
                        },
                        {
                          x: l,
                          y: c,
                        },
                        {
                          x: -l,
                          y: c,
                        },
                      ].map(
                        function (e) {
                          return {
                            x: e.x + 1.5 * (this.homography.position.x - 0.5),
                            y: e.y + 1.5 * (this.homography.position.y - 0.5),
                          };
                        }.bind(this)
                      ),
                      h = o;
                    S(u, 200, 200, h.parent),
                      h.scale.setScalar(this.homography.scale),
                      (h.parent.rotation.x += this.homography.rotation.x),
                      (h.parent.rotation.y +=
                        this.homography.rotation.y + Math.PI);
                    this.backgroundImage;
                    e.scene.updateMatrixWorld();
                  } else
                    e.setBackgroundImage(null),
                      o.parent.rotation.set(0, 0, 0),
                      e.scene.updateMatrixWorld(),
                      e.lookAtObject(o.name, 0, 0, 3 * -this.size.width);
                  return i.obj;
                },
                printPlanViews: function () {
                  var e = document.getElementById("js-pdf-lib"),
                    t = this,
                    n = function () {
                      var e = new window.jsPDF({
                        orientation: "l",
                      });
                      e.setProperties({
                        title: "Report",
                      });
                      e.rect(10, 10, 277, 190);
                      var n = Math.min(138.5, 95),
                        r = 138.5 - n,
                        i = 95 - n;
                      Object.values(t.planViews).forEach(function (t, o) {
                        var a = 138.5 * (1 & o) + 10 + r / 2,
                          s = 95 * ((o >> 1) & 1) + 10 + i / 2;
                        e.addImage(t, "JPG", a, s - 20, n, n);
                      }),
                        window.open(e.output("bloburl"), "_blank"),
                        e.addH;
                    };
                  if (e) n();
                  else {
                    var r = document.createElement("script");
                    (r.id = "js-pdf-lib"),
                      r.setAttribute(
                        "src",
                        "../../../assets/jspdf/jspdf.min.js"
                      ),
                      (r.onload = n),
                      document.head.appendChild(r);
                  }
                },
              },
              computed: {
                renderer: function () {
                  return e;
                },
                environment: function () {
                  return t;
                },
                config: function () {
                  return r.config;
                },
                allowNew: function () {
                  return !r.serverParameters.meta.loginRequired;
                },
                backgroundImage: function () {
                  var t = this;
                  if (
                    !this.homography.enabled &&
                    !this.interactive.inArchitectureMode
                  )
                    return null;
                  var n = new Image();
                  n.onload = function () {
                    e.setBackgroundImage(n, !t.interactive.inArchitectureMode);
                  };
                  var r = this.interactive.inArchitectureMode
                    ? "images/papergrid_bg.png"
                    : this.homography.imageSrc || "textures/perspectivebg.jpg";
                  return (n.src = Object(i.c)(r)), n;
                },
                planViews: function () {
                  var e = JSON.parse(JSON.stringify(this.$data));
                  e.interactive.inArchitectureMode = !0;
                  var n = t.newBuilder.build(
                    e.style.type,
                    r.config.builders,
                    e,
                    A
                  ).obj;
                  n.traverse(function (e) {
                    var r = e;
                    if (
                      r.material &&
                      r.material !== t.materials.shadowMaterial &&
                      "arrow" != (r.material.name || "xyz")
                    ) {
                      if (r.visible) {
                        var i = P;
                        if (
                          (r.material.opacity &&
                            r.material.opacity < 1 &&
                            (((i = i.clone()).opacity = r.material.opacity),
                            (i.transparent = !0)),
                          (r.material = i),
                          r.geometry && r.geometry.hasAttribute("position"))
                        ) {
                          var o = new a.EdgesGeometry(r.geometry, 5),
                            s = new a.LineSegments(o, L);
                          r.parent.add(s),
                            s.position.copy(r.position),
                            s.rotation.copy(r.rotation),
                            s.scale.copy(r.scale);
                        }
                      }
                      var l = r.material;
                      e.castShadow = !l.transparent || l.opacity > 0.7;
                    }
                    (e.receiveShadow = r.receiveShadow = "noshading" != n.name),
                      "target" in r &&
                        "updateMatrixWorld" in r.target &&
                        r.target.updateMatrixWorld(!0);
                  });
                  var i = Math.max(
                      this.size.width,
                      this.size.depth,
                      this.size.height
                    ),
                    o = new a.Vector3().setScalar(i + 100),
                    s = new a.Vector3(0, 0, 0),
                    l = new a.Box3().setFromCenterAndSize(s, o),
                    c = {
                      Front: [0, 0, Math.PI],
                      Right: [0, Math.PI / 2, Math.PI],
                      Top: [Math.PI / 2, 0, Math.PI],
                      Isometric: [Math.PI / 6, 1.75 * Math.PI, Math.PI],
                    },
                    u = Object.entries(c).map(function (e, r) {
                      var o = e[0],
                        a = e[1];
                      return (
                        n.rotation.fromArray(a),
                        3 == r && l.expandByScalar(i / 4),
                        [o, t.newBuilder.renderToPng(n, 500, !0, l)]
                      );
                    });
                  return {
                    images: Object.fromEntries(u),
                    timestamp: Date.now(),
                  }.images;
                },
                inExperimentalMode: {
                  cached: !1,
                  get: function () {
                    return !!document.baseURI.match(/experimental=(1|true)/i);
                  },
                },
              },
              watch: {
                interactive: {
                  deep: !0,
                  handler: function () {
                    this.updateMesh();
                  },
                },
                homography: {
                  deep: !0,
                  handler: function (t) {
                    e.controls.enabled == t.enabled &&
                      (e.controls.enabled = !t.enabled),
                      this.updateMesh();
                  },
                },
              },
              locales: r.config.locales,
            });
          }),
          (e.prototype.registerPopupListener = function (e, t, n, r, i) {
            void 0 === r && (r = this.gui), void 0 === i && (i = this.context);
            var s,
              l = new a.Raycaster(),
              c = null,
              u = !1,
              d = 0,
              p = 0;
            e.domElement.addEventListener("pointermove", function (t) {
              if (C.length) {
                var n = e.domElement.getBoundingClientRect();
                (d = ((t.clientX - n.left) / n.width) * 2 - 1),
                  (p = (-(t.clientY - n.top) / n.height) * 2 + 1),
                  l.setFromCamera(
                    {
                      x: d,
                      y: p,
                    },
                    e.camera
                  ),
                  (s = l.intersectObjects(C, !0)),
                  (e.domElement.style.cursor = s.length ? "pointer" : "");
              }
            }),
              e.domElement.addEventListener("click", function (e) {
                if (s && s.length) {
                  for (
                    var a = s[0].object;
                    !A.some(function (e) {
                      return e === a.name;
                    });

                  )
                    a = a.parent;
                  (u = !1),
                    E.map(function (s) {
                      s.elementId == a.name &&
                        s.handlers
                          .filter(function (t) {
                            return t.event == e.type;
                          })
                          .map(function (a) {
                            if (a.function) {
                              var s = r.$children[0].$data,
                                l = Object.keys(s);
                              new Function(
                                "q",
                                "var " +
                                  l
                                    .map(function (e) {
                                      return e + "= q." + e;
                                    })
                                    .join(",") +
                                  ";" +
                                  a.function
                              )(r.$children[0]),
                                t && t();
                            }
                            if (a.popup) {
                              var d = new h.UIBuilder(
                                n.env,
                                i.isLoggedIn,
                                n.dragNDrop
                              )
                                .buildClass(
                                  a.popup,
                                  !1,
                                  n.dragNDrop,
                                  n.newBuilder
                                )
                                .extend({
                                  data: function () {
                                    return JSON.parse(
                                      JSON.stringify(
                                        i.serverParameters || i.config.data
                                      )
                                    );
                                  },
                                  ready: function () {
                                    this.$on(
                                      "propertyupdated",
                                      function (e, t) {
                                        r.$children[0].$set(e, t),
                                          r.propertyUpdated(e, t);
                                      }
                                    );
                                  },
                                });
                              c && (c.$destroy(!0), (c = null));
                              var p = document.createElement("div");
                              (p.id = "popup"),
                                document.body.appendChild(p),
                                (c = new o({
                                  el: "#popup",
                                  template:
                                    "<template v-if='!closed()'><div class='popup center-popup' style='animation: center-popup 300ms linear 1 forwards;position:absolute;left:" +
                                    e.clientX +
                                    "px;top:" +
                                    e.clientY +
                                    'px\'><i class="fas fa-times" aria-hidden="true" @click="close()" style="float:right"></i>  <mycomponent :value=\'[key]\'></mycomponent></div></template>',
                                  components: {
                                    mycomponent: d,
                                  },
                                  methods: {
                                    closed: function () {
                                      return u;
                                    },
                                    close: function () {
                                      this.$destroy(!0), (c = null);
                                    },
                                  },
                                }));
                            }
                          });
                    });
                } else c && c.close();
              });
            var f = document.createElement("style");
            return (
              (f.innerHTML =
                "\n            @keyframes center-popup {\n                from {\n                    transform-origin: 0 0;\n                    transform: translate(0,0) scale(0.3);\n                }\n                to {\n                    transform: translate(-50%,-50%) scale(1);\n                    top: 50%;\n                    left: 50%;\n                }\n            }\n        "),
              document.head.appendChild(f),
              {
                popupClosed: u,
                popup: c,
              }
            );
          }),
          (e.prototype.buildFloatGui = function (e, t) {
            void 0 === t && (t = this.context);
            var n = this.gui,
              r = new h.UIBuilder(e.env, t.isLoggedIn, e.dragNDrop)
                .buildClass(
                  t.config.floatGui.ui,
                  !1,
                  e.dragNDrop,
                  e.newBuilder,
                  !1
                )
                .extend({
                  data: function () {
                    return JSON.parse(
                      JSON.stringify(t.serverParameters || t.config.data)
                    );
                  },
                  ready: function () {
                    this.$on("propertyupdated", function (e, t) {
                      n.$children[0].$set(e, t), n.propertyUpdated(e, t);
                    });
                  },
                  computed: {
                    inExperimentalMode: {
                      cached: !1,
                      get: function () {
                        return !!document.baseURI.match(
                          /experimental=(1|true)/i
                        );
                      },
                    },
                  },
                });
            this.floatGui = new o({
              el: "#float-gui",
              data: {
                closed: window.innerWidth < 800,
              },
              template:
                '<template v-if=\'closed\'><div class=\'float-gui\' style=\'min-width:1.5em;font-size:2em;padding: 0em 0.25em\'><i class="fa fa-sun" aria-hidden="true" @click="closed=false"></i></div></template><template v-if=\'!closed\'><div class=\'float-gui\'><i class="fas fa-times" aria-hidden="true" @click="closed=true" style="float:right"></i>  <mycomponent></mycomponent></div></template>',
              components: {
                mycomponent: r,
              },
            });
          }),
          (e.prototype.registerKeyEventListeners = function (e) {
            var t = this.gui;
            document.body.addEventListener("keydown", function (n) {
              if (n.altKey)
                switch (n.key) {
                  case "p":
                    var r = function () {
                      console.log("tracing");
                      var t = window.LGLTracer,
                        n = t.LGLTracerRenderer,
                        r = t.DisneyMaterial,
                        i = t.DirectionalLight,
                        o = new a.SphereGeometry(1e3, 128, 64),
                        s = new a.MeshStandardMaterial();
                      (s.emissiveMap = s.map =
                        e.materials.environmentSphere.map),
                        (s.map.needsUpdate = !0),
                        (s.emissiveIntensity = 0.5);
                      var l = new a.Mesh(o, s);
                      l.geometry.scale(1, 0.01, 1),
                        l.geometry.rotateX(Math.PI / 2);
                      var c = new n();
                      (c.enableDenoise = !0),
                        (c.bounces = 2),
                        (c.envMapIntensity = 2.2);
                      var u = c.domElement;
                      u.setAttribute(
                        "style",
                        "display:block;position:absolute;width:30vw;height:30vh;top:65vh;left:65vw;z-index:1000"
                      ),
                        document.body.appendChild(c.domElement),
                        (u.onclick = function () {
                          u.remove(), (u = null), (c = null);
                        });
                      var h = e.env,
                        d = h.scene,
                        p = h.camera;
                      p = p.clone();
                      var f = e.env.scene.getObjectByName("Woohoo").clone(!0);
                      f.traverse(function (t) {
                        if (t instanceof a.Mesh) {
                          if (
                            ((t.visible =
                              t.visible &&
                              !!t.geometry.getAttribute("position")),
                            t.material === e.materials.shadowMaterial)
                          )
                            (t.visible = !1),
                              l.position.copy(t.position),
                              (l.position.z += 10),
                              t.parent.add(l);
                          else if (
                            t.material.isMeshStandardMaterial ||
                            t.material.isMeshBasicMaterial
                          ) {
                            var n = t.geometry.getAttribute("uv");
                            if (n && t.material.map) {
                              for (var i = 0; i < n.count; i++) {
                                var o = n.getX(i),
                                  s = n.getY(i);
                                (o =
                                  o * t.material.map.repeat.x +
                                  t.material.map.offset.x),
                                  (s =
                                    s * t.material.map.repeat.y +
                                    t.material.map.offset.y),
                                  n.setXY(i, o, s);
                              }
                              n.needsUpdate = !0;
                            }
                            t.material.isMeshStandardMaterial
                              ? (t.material = new r().fromStandardMaterial(
                                  t.material
                                ))
                              : (t.material = new r().fromBasicMaterial(
                                  t.material
                                ));
                          }
                          t.geometry.index || t.geometry.toInd;
                        }
                      }),
                        [].forEach(function (e) {
                          var t;
                          return null === (t = e.parent) || void 0 === t
                            ? void 0
                            : t.remove(e);
                        }),
                        ((d = new a.Scene()).environment =
                          e.materials.environmentSphere.map),
                        d.add(f);
                      var m = new i(16777215, 1);
                      m.position.copy(
                        e.env.scene.getObjectByName("sun").position
                      ),
                        d.add(m);
                      var g = u.getBoundingClientRect();

                      function v() {
                        c.render(d, p), u && requestAnimationFrame(v);
                      }
                      c.setSize(g.width, g.height),
                        c.buildScene(d, p).then(function () {
                          v();
                        });
                    };
                    if (document.getElementById("lgl-tracer-script")) r();
                    else {
                      var i = document.createElement("script");
                      (i.id = "lgl-tracer-script"),
                        i.setAttribute(
                          "src",
                          "../../../../../../../lgltracer.com/release/lglTracer.umd.html"
                        ),
                        (i.onload = r),
                        document.head.appendChild(i);
                    }
                    break;
                  case "i":
                    var o = window.prompt(
                      "Please enter the URL of the design you wish to import"
                    );
                    if (o && o.match(/^http/)) {
                      var s = new XMLHttpRequest();
                      (o = o.replace(
                        /\/(share|vr)\//i,
                        "https://productconfigurator.virtualsaleslab.com/designdata/"
                      )),
                        (s.onreadystatechange = function () {
                          if (4 == this.readyState && 200 == this.status) {
                            var e = JSON.parse(this.responseText);
                            if (
                              e.meta.designer !=
                              t.$children[0].$data.meta.designer
                            )
                              return void alert(
                                'You can not import this design because it is a design from the "' +
                                  e.meta.designer +
                                  '".'
                              );
                            delete e.extra,
                              delete e.contact,
                              delete e.meta,
                              delete e.vars,
                              Object.assign(t.$children[0].$data, e),
                              t.propertyUpdated();
                          }
                        }),
                        s.open("GET-2.html", o, !0),
                        s.send();
                    } else window.alert("No data imported");
                    break;
                  case "x":
                  case "j":
                    var l = JSON.stringify(t.$children[0].$data, null, "\t"),
                      c = document.createElement("a");
                    c.setAttribute(
                      "href",
                      "data:text/plain;charset=utf-8," + encodeURIComponent(l)
                    ),
                      c.setAttribute("download", "export.json"),
                      (c.style.display = "none"),
                      document.body.appendChild(c),
                      c.click(),
                      document.body.removeChild(c);
                    break;
                  case "o":
                    var u = new b().parse(
                        e.env.scene.getObjectByName("Woohoo")
                      ),
                      h = document.createElement("a"),
                      d = new Blob([u], {
                        type: "text/obj",
                      });
                    (h.href = URL.createObjectURL(d)),
                      (h.download = "model.obj"),
                      h.click();
                }
            });
          }),
          (e.prototype.hideProgressIndicatorWhenDone = function (e) {
            a.DefaultLoadingManager.onProgress = function (e, t, n) {
              if (t == n) {
                var r = document.querySelector(".loader");
                r && r.classList.remove("loader");
              }
            };
          }),
          (e.prototype.setLocales = function (e) {
            var t = e.config;
            t.locales
              ? t.locales[e.language] ||
                (e.language.length > 2 &&
                  t.locales[e.language.substr(0, 2)] &&
                  (e.language = e.language.substr(0, 2)),
                t.locales[e.language] ||
                  alert(
                    "Sorry, the language " + e.language + " is not supported"
                  ))
              : (t.locales = {
                  nl: {
                    step6tiltle1: "3D Configurator",
                    step6description0:
                      "Bedankt voor uw simulatie, we behandelen uw aanvraag zo spoedig mogelijk.",
                    step6description1: "Start een nieuwe configuratie",
                    step6clickbutton: "Start",
                  },
                  en: {
                    step6tiltle1: "3D Configurator",
                    step6description0:
                      "Thank you for your simulation, we will process your request as soon as possible.",
                    step6description1: "Start a new configuration",
                    step6clickbutton: "Start",
                  },
                  fr: {
                    step6tiltle1: "Configurateur 3D",
                    step6description0:
                      "Merci pour votre simulation, nous traiterons votre demande dans les plus brefs délais.",
                    step6description1: "Lancez une nouvelle configuration",
                    step6clickbutton: "Démarrez",
                  },
                  de: {
                    step6tiltle1: "3D-Konfigurator",
                    step6description0:
                      "Vielen Dank für Ihre Simulation. Wir werden Ihre Anfrage so schnell wie möglich bearbeiten.",
                    step6description1: "Eine neue Konfiguration starten ",
                    step6clickbutton: "Start",
                  },
                  it: {
                    step6tiltle1: "Configuratore 3D",
                    step6description0:
                      "Grazie per la vostra simulazione. Daremo segiuto alla tua richiesta a brevissimo.",
                    step6description1: "Inizia una nuova configurazione",
                    step6clickbutton: "Inizia",
                  },
                  es: {
                    step6tiltle1: "Configurador 3D",
                    step6description0:
                      "Gracias por su simulación, procesaremos su solicitud lo antes posible.",
                    step6description1: "Iniciar una nueva configuración",
                    step6clickbutton: "Comienzo",
                  },
                }),
              o.use(M.a),
              (o.config.lang = e.language),
              Object.keys(t.locales || {}).forEach(function (e) {
                o.locale(e, t.locales[e]);
              });
          }),
          e
        );
      })();

    function I(e, t, n, r) {
      void 0 === r && (r = "reynaers2"),
        e.setBackgroundConfigurationKey(r, function () {
          t.filter(function (e) {
            return e.useEnvMap;
          }).forEach(function (e) {
            var t = n.materials[e.id];
            t &&
              ((t.envMap = n.materials.environmentSphere.map),
              (t.needsUpdate = !0));
          });
        });
    }
  },
  function (e, t) {
    var n,
      r,
      i = (e.exports = {});

    function o() {
      throw new Error("setTimeout has not been defined");
    }

    function a() {
      throw new Error("clearTimeout has not been defined");
    }

    function s(e) {
      if (n === setTimeout) return setTimeout(e, 0);
      if ((n === o || !n) && setTimeout)
        return (n = setTimeout), setTimeout(e, 0);
      try {
        return n(e, 0);
      } catch (t) {
        try {
          return n.call(null, e, 0);
        } catch (t) {
          return n.call(this, e, 0);
        }
      }
    }
    !(function () {
      try {
        n = "function" == typeof setTimeout ? setTimeout : o;
      } catch (e) {
        n = o;
      }
      try {
        r = "function" == typeof clearTimeout ? clearTimeout : a;
      } catch (e) {
        r = a;
      }
    })();
    var l,
      c = [],
      u = !1,
      h = -1;

    function d() {
      u &&
        l &&
        ((u = !1), l.length ? (c = l.concat(c)) : (h = -1), c.length && p());
    }

    function p() {
      if (!u) {
        var e = s(d);
        u = !0;
        for (var t = c.length; t; ) {
          for (l = c, c = []; ++h < t; ) l && l[h].run();
          (h = -1), (t = c.length);
        }
        (l = null),
          (u = !1),
          (function (e) {
            if (r === clearTimeout) return clearTimeout(e);
            if ((r === a || !r) && clearTimeout)
              return (r = clearTimeout), clearTimeout(e);
            try {
              r(e);
            } catch (t) {
              try {
                return r.call(null, e);
              } catch (t) {
                return r.call(this, e);
              }
            }
          })(e);
      }
    }

    function f(e, t) {
      (this.fun = e), (this.array = t);
    }

    function m() {}
    (i.nextTick = function (e) {
      var t = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
      c.push(new f(e, t)), 1 !== c.length || u || s(p);
    }),
      (f.prototype.run = function () {
        this.fun.apply(null, this.array);
      }),
      (i.title = "browser"),
      (i.browser = !0),
      (i.env = {}),
      (i.argv = []),
      (i.version = ""),
      (i.versions = {}),
      (i.on = m),
      (i.addListener = m),
      (i.once = m),
      (i.off = m),
      (i.removeListener = m),
      (i.removeAllListeners = m),
      (i.emit = m),
      (i.prependListener = m),
      (i.prependOnceListener = m),
      (i.listeners = function (e) {
        return [];
      }),
      (i.binding = function (e) {
        throw new Error("process.binding is not supported");
      }),
      (i.cwd = function () {
        return "/";
      }),
      (i.chdir = function (e) {
        throw new Error("process.chdir is not supported");
      }),
      (i.umask = function () {
        return 0;
      });
  },
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  function (e, t, n) {
    "use strict";
    var r;
    n.r(t),
      n.d(t, "CSSTerraceroof", function () {
        return c;
      }),
      (function (e) {
        var t = function () {};
        (e.EditorData = t),
          (e.defaultData = {
            size: {
              width: 600,
              height: 220,
              depth: 450,
            },
            style: {
              type: "patioroof",
              baseColorRAL: "9007",
              roofColorRAL: "9007",
              screenColorRAL: "9007",
              roofAngleDegrees: 10,
              roofType: "glass",
            },
            wallHeights: {
              front: 0,
              left: 350,
              right: 0,
              back: 350,
            },
            elements: {
              droppedElements: [
                {
                  id: "dropped schuifraam",
                  allowedDropTargets: [
                    "sideLeft",
                    "sideRight",
                    "sideFront",
                    "sideBack",
                  ],
                  droppableId: "schuifraam",
                  dropTargetId: "sideRight",
                  dropTargetName: "sideplan edge 1",
                  elementId: "schuifraam",
                  intersectable: {
                    localBoundingBox: {
                      min: {
                        x: -107,
                        y: -105.5,
                      },
                      max: {
                        x: 107,
                        y: 105.5,
                      },
                    },
                    mesh: null,
                  },
                  shouldClone: !1,
                  localBoundingBox: {
                    min: {
                      x: -107,
                      y: -105.5,
                    },
                    max: {
                      x: 107,
                      y: 105.5,
                    },
                  },
                  position: [-113, 0],
                  rotation: [0, 0, 0],
                  screenScale: 0.005,
                  screenPosition: {
                    x: 0,
                    y: 0,
                  },
                  originalScale: {
                    x: 1,
                    y: 1,
                    z: 1,
                  },
                  minWidth: 0,
                  maxWidth: 0,
                  width: 214,
                  minHeight: 0,
                  maxHeight: 0,
                  height: 211,
                  originalBoundingBox: {
                    min: {
                      x: -220,
                      y: -105.5,
                    },
                    max: {
                      x: -6,
                      y: 105.5,
                    },
                  },
                  windowOpts: {},
                  float: !1,
                  asDropTargetUniqueId: "bvx60gwfr5n2qnh08159r",
                  droppedOnUniqueId: null,
                },
                {
                  id: "dropped vast raam",
                  allowedDropTargets: [
                    "sideLeft",
                    "sideRight",
                    "sideFront",
                    "sideBack",
                  ],
                  droppableId: "vast raam",
                  dropTargetId: "sideFront",
                  dropTargetName: "sideplan edge 2",
                  elementId: "vast raam",
                  intersectable: {
                    localBoundingBox: {
                      min: {
                        x: -295,
                        y: -105.5,
                      },
                      max: {
                        x: 295,
                        y: 105.5,
                      },
                    },
                    mesh: null,
                  },
                  shouldClone: !1,
                  localBoundingBox: {
                    min: {
                      x: -295,
                      y: -105.5,
                    },
                    max: {
                      x: 295,
                      y: 105.5,
                    },
                  },
                  position: [0, 0],
                  rotation: [0, 0, 0],
                  screenScale: 0.005,
                  screenPosition: {
                    x: 0,
                    y: 0,
                  },
                  originalScale: {
                    x: 1,
                    y: 1,
                    z: 1,
                  },
                  minWidth: 0,
                  maxWidth: 0,
                  width: 590,
                  minHeight: 0,
                  maxHeight: 0,
                  height: 211,
                  originalBoundingBox: {
                    min: {
                      x: -295,
                      y: -105.5,
                    },
                    max: {
                      x: 295,
                      y: 105.5,
                    },
                  },
                  windowOpts: {},
                  float: !1,
                  asDropTargetUniqueId: "xrex8aqebhir9tmtfrqrhm",
                  droppedOnUniqueId: null,
                },
                {
                  droppableId: "schuifraam",
                  dropTargetId: "sideRight",
                  dropTargetName: "sideplan edge 1",
                  position: [113, 0],
                  rotation: [0, 0, 0],
                  intersectable: {
                    localBoundingBox: {
                      min: {
                        x: -107,
                        y: -105.5,
                      },
                      max: {
                        x: 107,
                        y: 105.5,
                      },
                    },
                    mesh: null,
                  },
                  allowedDropTargets: [
                    "sideLeft",
                    "sideRight",
                    "sideFront",
                    "sideBack",
                  ],
                  elementId: "schuifraam",
                  id: "schuifraam",
                  localBoundingBox: {
                    min: {
                      x: -107,
                      y: -105.5,
                    },
                    max: {
                      x: 107,
                      y: 105.5,
                    },
                  },
                  originalScale: {
                    x: 1,
                    y: 1,
                    z: 1,
                  },
                  shouldClone: !1,
                  screenScale: 0.005,
                  screenPosition: {
                    x: 0,
                    y: 0,
                  },
                  minWidth: 0,
                  maxWidth: 0,
                  width: 214,
                  height: 211,
                  minHeight: 0,
                  maxHeight: 0,
                  originalBoundingBox: {
                    min: {
                      x: -115,
                      y: -90,
                    },
                    max: {
                      x: 115,
                      y: 90,
                    },
                  },
                  windowOpts: {},
                  float: !1,
                  grid: [
                    {
                      min: {
                        x: -220,
                        y: -105.5,
                      },
                      max: {
                        x: -6,
                        y: 105.5,
                      },
                    },
                    {
                      min: {
                        x: 6,
                        y: -105.5,
                      },
                      max: {
                        x: 220,
                        y: 105.5,
                      },
                    },
                  ],
                  asDropTargetUniqueId: "hlxdmr7hftkf0kb2rkfa",
                  droppedOnUniqueId: null,
                },
              ],
            },
            interactive: {
              pctOpen: 15,
              blindsOpenPct: 40,
              sunRotation: 0,
            },
            contact: {
              name: "",
              street: "",
              housenumber: "",
              zip: "",
              city: "",
              email: "",
              phone: "",
              visitme: !0,
              remark: "",
            },
            meta: {
              id: "",
              designer: "terraceroof2",
              wasSubmitted: !1,
              allowPicture: "always",
            },
            homography: {
              position: {
                x: 0.5265624999999998,
                y: 0.49918749999999995,
              },
              rotation: {
                x: 0.11272621556370213,
                y: -1.0094292649401475,
              },
              scale: 0.5290085248221333,
              imageSrc: null,
              enabled: !1,
              available: !1,
              gridsVisible: !1,
            },
            vars: {
              hasScreens: !0,
            },
          });
      })(r || (r = {}));
    var i,
      o = n(5),
      a = Object(o.a)(r.defaultData),
      s = a.define,
      l = a.PrepVars;
    (i || (i = {})).config = {
      data: r.defaultData,
      gui: [
        // {
        //   faIcon: "fa-home",
        //   activeDropTargetIds: [],
        //   ui: [
        //     {
        //       kind: "wrapper",
        //       templatePrefix: [
        //         "<vsl-logo></vsl-logo>",
        //         "<h3>{{$t('step1title1')}}</h3>",
        //         "<p>{{$t('step1description1')}}</p>",
        //         "<p>{{$t('step1action')}}</p>",
        //       ],
        //     },
        //   ],
        // },
        {
          faIcon: "fa-cube",
          activeDropTargetIds: [],
          ui: [
            // {
            //   key: "style.baseColorRAL",
            //   kind: "ralcode",
            //   opts: {
            //     label: "step2framecolor",
            //     codes: ["9016", "9007", "9017"],
            //   },
            // },
            // {
            //   key: "style.roofColorRAL",
            //   kind: "ralcode",
            //   opts: {
            //     label: "step2roofcolor",
            //     codes: ["9016", "9007", "9017"],
            //   },
            // },
            {
              key: "size.width",
              kind: "slider",
              templatePrefix: ["<h4>{{$t('step2title2')}}</h4>"],
              opts: {
                label: "step2width",
                min: 200,
                max: 600,
                step: 1,
                unit: "cm",
              },
            },
            {
              key: "size.depth",
              kind: "slider",
              templatePrefix: "",
              opts: {
                label: "step2depth",
                min: 200,
                max: 400,
                step: 1,
                unit: "cm",
              },
            },
            {
              key: "size.height",
              kind: "slider",
              templatePrefix: "",
              opts: {
                label: "step2height",
                min: 250,
                max: 529,
                step: 1,
                unit: "cm",
              },
            },
          ],
        },
        // {
        //   faIcon: "fa-sun",
        //   activeDropTargetIds: [
        //     "sideLeft",
        //     "sideRight",
        //     "sideFront",
        //     "sideBack",
        //   ],
        //   ui: [
        //     {
        //       key: "style.screenColorRAL",
        //       kind: "ralcode",
        //       opts: {
        //         label: "step2screencolor",
        //         codes: ["9016", "9007", "9017"],
        //       },
        //       templatePrefix: [
        //         "<h3>{{$t('step3title1')}}</h3>",
        //         "<p>{{$t('step3description1')}}</p>",
        //         "<h4>{{$t('step3title2')}}</h4>",
        //       ],
        //     },
        //     {
        //       key: "wallHeights.front",
        //       kind: "slider",
        //       templatePrefix: "<h4>{{$t('step3title3')}}</h4>",
        //       opts: {
        //         label: "step3front",
        //         min: 0,
        //         max: 550,
        //         step: 10,
        //         unit: "cm",
        //       },
        //     },
        //     {
        //       key: "wallHeights.back",
        //       kind: "slider",
        //       opts: {
        //         label: "step3back",
        //         min: 0,
        //         max: 550,
        //         step: 10,
        //         unit: "cm",
        //       },
        //     },
        //     {
        //       key: "wallHeights.left",
        //       kind: "slider",
        //       opts: {
        //         label: "step3left",
        //         min: 0,
        //         max: 550,
        //         step: 10,
        //         unit: "cm",
        //       },
        //     },
        //     {
        //       key: "wallHeights.right",
        //       kind: "slider",
        //       opts: {
        //         label: "step3right",
        //         min: 0,
        //         max: 550,
        //         step: 10,
        //         unit: "cm",
        //       },
        //     },
        //   ],
        // },
        // {
        //   faIcon: "fa-camera-retro",
        //   activeDropTargetIds: [],
        //   ui: [
        //     {
        //       key: "homography.enabled",
        //       kind: "checkbox",
        //       templatePrefix:
        //         "\n                            <h3>{{$t('photoTitle')}}</h3>\n                            <p>{{$t('photoDescription')}}</p>\n                        ",
        //       opts: {
        //         label: "photoShowBackgroundPicture",
        //       },
        //     },
        //     {
        //       kind: "backgroundPicWithChoice",
        //       templatePrefix:
        //         "<template v-if='homography.enabled'>\n              {{{$t('photoUploadDescription')}}}\n                        <h4>{{$t('photoUploadTitle')}}</h4>",
        //       templatePostfix:
        //         "<br/><hr/>{{{$t('photoGridDescription')}}}</template>",
        //     },
        //     {
        //       kind: "homographyPlacement",
        //       templatePrefix: "<template v-if='homography.enabled'>",
        //       templatePostfix: "</template>",
        //       key: "homography",
        //     },
        //   ],
        // },
        // {
        //   faIcon: "fa-thumbs-up",
        //   activeDropTargetIds: [],
        //   ui: [
        //     {
        //       kind: "contact",
        //       opts: {
        //         generatePin: !1,
        //         redirectAfterPost: !0,
        //       },
        //       templatePrefix: [
        //         "<h3>{{$t('step5title1')}}</h3>",
        //         "<p>{{$t('step5description1')}}</p>",
        //       ],
        //       templatePostfix: "",
        //     },
        //   ],
        // },
      ],
      floatGui: {
        faIcon: "fa-sun",
        activeDropTargetIds: [],
        ui: [
          {
            key: "interactive.pctOpen",
            kind: "slider",
            templatePrefix:
              "<i class='fa fa-sun' aria-hidden='true'></i><h4>{{$t('sideMenuTitle1')}}</h4 ><template v-if='vars.hasScreens'>",
            templatePostfix: ["</template>"],
            opts: {
              label: "sideMenuScreens",
              min: 0,
              max: 100,
              step: 5,
              unit: "%",
            },
          },
          {
            key: "interactive.sunRotation",
            kind: "slider",
            opts: {
              label: "sideMenuSun",
              min: -180,
              max: 180,
              step: 5,
              unit: "%",
            },
          },
          {
            key: "homography.enabled",
            kind: "checkbox",
            templatePrefix: "<template v-if='homography.available'>",
            opts: {
              label: "Use background picture",
            },
            templatePostfix: "</template>",
          },
        ],
      },
      builders: {
        vars: l(
          s.vars({
            hasScreens: function (e) {
              return e.elements.droppedElements.some(function (e) {
                return "screen" == e.elementId || "vast raam" != e.elementId;
              });
            },
            leftFrontVisible: function (e) {
              var t = e.wallHeights,
                n = e.size;
              return Math.max(t.left, t.front) < n.height - 10;
            },
            rightFrontVisible: function (e) {
              var t = e.wallHeights,
                n = e.size;
              return Math.max(t.right, t.front) < n.height - 10;
            },
            leftBackVisible: function (e) {
              var t = e.wallHeights,
                n = e.size;
              return Math.max(t.left, t.back) < n.height - 10;
            },
            rightBackVisible: function (e) {
              var t = e.wallHeights,
                n = e.size;
              return Math.max(t.right, t.back) < n.height - 10;
            },
            roofDetails: function (e) {
              var t = e.size,
                n = (25 / 360) * Math.PI,
                r = t.width / 2 - 5.5,
                i = t.depth / 2 - 5.5;
              return {
                edgeVerts: [
                  [r, i],
                  [r, -i],
                  [-r, -i],
                  [-r, i],
                ],
                topVerts: [
                  [r, i],
                  [-r, i],
                ],
                edgeTopIndexes: [0, 0, 1, 1],
                height: t.depth * Math.sin(n),
              };
            },
          })
        ),
        glassDecorations: [
          {
            id: "palen voor/achter",
            type: "grid",
            maxGridWidth: 700,
            maxGridHeight: 400,
            meshThickness: 12,
            meshDepth: 12,
            materialId: "base",
            offset: [0, 5, 0],
          },
          {
            id: "palen links/rechts",
            type: "grid",
            maxGridWidth: 400,
            maxGridHeight: 400,
            meshThickness: 12,
            meshDepth: 12,
            materialId: "base",
            offset: [0, 5, 0],
          },
        ],
        textures: [
          {
            id: "brick",
            imageUrl: "textures/house/brick-wall.jpg",
          },
          {
            id: "bluestone tiles",
            imageUrl: "textures/floor/featuredflooring.jpg",
          },
          {
            id: "fabric",
            imageUrl: "textures/sidingtypes/fabric.jpg",
            repeat: {
              x: 0.5,
              y: 0.5,
            },
          },
        ],
        materials: [
          {
            id: "brick",
            metalness: 0.1,
            roughness: 0.7,
            map: {
              textureId: "brick",
            },
          },
          {
            id: "fabric",
            bump: {
              textureId: "fabric",
              bumpScale: 0.1,
            },
            opacity: 0.93,
            colorRAL: "$style.screenColorRAL",
          },
          {
            id: "bluestone tiles",
            metalness: 0.1,
            roughness: 0.7,
            map: {
              textureId: "bluestone tiles",
            },
            bump: {
              textureId: "bluestone tiles",
              bumpScale: 0.1,
            },
          },
          {
            id: "base",
            colorRAL: "$style.baseColorRAL",
            roughness: 0.4,
            metalness: 0.3,
            useEnvMap: !0,
          },
          {
            id: "roof",
            colorRAL: "$style.roofColorRAL",
            roughness: 0.4,
            metalness: 0.3,
            useEnvMap: !0,
          },
        ],
        elements: [
          {
            id: "diningtable",
            elementType: "meshFromFile",
            height: 100,
            width: 100,
            opts: {
              url: "models/diningroom.dae",
            },
            baseMaterialId: "blackMetal",
            swapUV: !1,
            scale: [4.75, 4.75, 4.75],
            position: [-80, 0, 0],
            float: !0,
            rotation: [-Math.PI / 2, 0, 0],
          },
          {
            id: "glass",
            elementType: "flexroof",
            baseMaterialId: "roof",
            height: "$vars.roofDetails.height",
            opts: {
              edgeVerts: "$vars.roofDetails.edgeVerts",
              topVerts: "$vars.roofDetails.topVerts",
              edgeTopIndexes: "$vars.roofDetails.edgeTopIndexes",
              spanWidth: 90,
            },
            position: [0, 0, -15],
          },
          {
            id: "pole",
            elementType: "pole",
            height: 12,
            width: 12,
            opts: {
              height: "$size.height",
            },
            baseMaterialId: "base",
            swapUV: !1,
          },
          {
            id: "screen",
            baseMaterialId: "fabric",
            elementType: "horizontalScreen",
            width: 230,
            height: 180,
            pctOpen: "$interactive.pctOpen",
            minWidth: 0,
            maxWidth: 0,
            minHeight: 0,
            maxHeight: 0,
          },
          {
            id: "gondula",
            baseMaterialId: "fabric",
            elementType: "gondula",
            width: 230,
            height: 180,
            pctOpen: "$interactive.pctOpen",
            minWidth: 0,
            maxWidth: 0,
            minHeight: 0,
            maxHeight: 0,
          },
          {
            id: "schuifraam",
            elementType: "slidingDoorLeft",
            baseMaterialId: "base",
            window: {
              elementType: "window",
              id: "window",
              width: 118,
              height: 180,
            },
            width: 230,
            minWidth: 0,
            maxWidth: 0,
            height: 180,
            minHeight: 0,
            maxHeight: 0,
            pctOpen: "$interactive.pctOpen",
            position: [0, -6, -2],
          },
          {
            id: "vast raam",
            elementType: "windowPanel",
            baseMaterialId: "base",
            width: 230,
            minWidth: 0,
            maxWidth: 0,
            height: 180,
            minHeight: 0,
            maxHeight: 0,
            position: [0, -6, -2],
          },
          {
            id: "Glazen schuifdeuren",
            elementType: "slidingGlassDoors",
            baseMaterialId: "aluminium",
            height: "$size.height-16",
            width: 150,
            minHeight: 0,
            maxHeight: 0,
            minWidth: 0,
            maxWidth: 0,
            swapUV: !1,
            pctOpen: "$interactive.pctOpen",
            position: [0, -6, -2],
          },
        ],
        models: [
          {
            id: "patioroof",
            buildSteps: [
              {
                name: "floor",
                type: "plane",
                id: "floor",
                visible: "$!homography.enabled",
              },
              {
                name: "shadow floor",
                type: "plane",
                id: "shadow floor",
              },
              {
                name: "pole links voor",
                type: "element",
                id: "pole",
                position: [
                  "$size.width/2-6",
                  "$size.height/2",
                  "$-size.depth/2+6",
                ],
                visible: "$vars.leftFrontVisible",
              },
              {
                name: "pole rechts voor",
                cloneStepWithName: "pole links voor",
                position: [
                  "$-size.width/2+6",
                  "$size.height/2",
                  "$-size.depth/2+6",
                ],
                visible: "$vars.rightFrontVisible",
              },
              {
                name: "pole links achter",
                cloneStepWithName: "pole links voor",
                position: [
                  "$size.width/2-6",
                  "$size.height/2",
                  "$size.depth/2-6",
                ],
                visible: "$vars.leftBackVisible",
              },
              {
                name: "pole rechts achter",
                cloneStepWithName: "pole links voor",
                position: [
                  "$-size.width/2+6",
                  "$size.height/2",
                  "$size.depth/2-6",
                ],
                visible: "$vars.rightBackVisible",
              },
              {
                name: "roof",
                type: "element",
                id: "$style.roofType",
                position: [0, "$size.height", 0],
              },
              {
                name: "sideLeft",
                type: "siding",
                id: "sideLeft",
                position: [0, "$wallHeights.left+9", 0],
                visible: "$wallHeights.left<=size.height-10",
              },
              {
                name: "sideRight",
                type: "siding",
                id: "sideRight",
                position: [0, "$wallHeights.right+9", 0],
                visible: "$wallHeights.right<=size.height-10",
              },
              {
                name: "sideBack",
                type: "siding",
                id: "sideBack",
                position: [0, "$wallHeights.back+9", 0],
                visible: "$wallHeights.back<=size.height-10",
              },
              {
                name: "sideFront",
                type: "siding",
                id: "sideFront",
                position: [0, "$wallHeights.front+9", 0],
                visible: "$wallHeights.front<=size.height-10",
              },
              {
                name: "wallLeft",
                type: "siding",
                id: "wallLeft",
                position: [0, 6, 0],
                visible:
                  "$wallHeights.left>0 && !(wallHeights.left>size.height-10 && homography.enabled)",
              },
              {
                name: "wallRight",
                type: "siding",
                id: "wallRight",
                position: [0, 6, 0],
                visible:
                  "$wallHeights.right>0  && !(wallHeights.right>size.height-10 && homography.enabled)",
              },
              {
                name: "wallBack",
                type: "siding",
                id: "wallBack",
                position: [0, 6, 0],
                visible:
                  "$wallHeights.back>0  && !(wallHeights.back>size.height-10 && homography.enabled)",
              },
              {
                name: "wallFront",
                type: "siding",
                id: "wallFront",
                position: [0, 6, 0],
                visible:
                  "$wallHeights.front>0  && !(wallHeights.front>size.height-10 && homography.enabled)",
              },
              {
                name: "top frame",
                type: "siding",
                id: "top frame",
                position: [0, "$size.height", 0],
              },
              {
                name: "furniture",
                type: "element",
                id: "diningtable",
                position: [0, 0, 0],
                visible: "$!homography.enabled",
              },
              {
                name: "gridanchor",
                type: "placeholder",
                id: "gridanchor",
                position: [0, 0, "$size.depth/2"],
              },
            ],
          },
        ],
        shapes: [
          {
            id: "floorplan",
            vertices: [
              ["$-size.width/2", "$size.depth/2"],
              ["$-size.width/2", "$-size.depth/2"],
              ["$size.width/2", "$-size.depth/2"],
              ["$size.width/2", "$size.depth/2"],
            ],
          },
          {
            id: "sideplan",
            vertices: [
              [
                "$-size.width/2-(wallHeights.right<size.height-10?-6:8)",
                "$size.depth/2+(wallHeights.back<size.height-10?-6:8)",
              ],
              [
                "$-size.width/2-(wallHeights.right<size.height-10?-6:8)",
                "$-size.depth/2-(wallHeights.front<size.height-10?-6:8)",
              ],
              [
                "$size.width/2+(wallHeights.left<size.height-10?-6:8)",
                "$-size.depth/2-(wallHeights.front<size.height-10?-6:8)",
              ],
              [
                "$size.width/2+(wallHeights.left<size.height-10?-6:8)",
                "$size.depth/2+(wallHeights.back<size.height-10?-6:8)",
              ],
            ],
          },
        ],
        sidings: [
          {
            id: "sideFront",
            height: "$size.height-wallHeights.front+3",
            shapeId: "sideplan",
            sides: [
              {
                id: "sideplan edge 2",
                layerIds: "front/back",
                dropTargetId: "$size.height>wallHeights.front?'sideFront':''",
              },
            ],
          },
          {
            id: "sideBack",
            height: "$size.height-wallHeights.back+3",
            shapeId: "sideplan",
            sides: [
              {
                id: "sideplan edge 0",
                layerIds: "front/back",
                dropTargetId: "$size.height>wallHeights.back?'sideBack':''",
              },
            ],
          },
          {
            id: "sideLeft",
            height: "$size.height-wallHeights.left+3",
            shapeId: "sideplan",
            sides: [
              {
                id: "sideplan edge 3",
                layerIds: "left/right",
                dropTargetId: "$size.height>wallHeights.left?'sideLeft':''",
              },
            ],
          },
          {
            id: "sideRight",
            height: "$size.height-wallHeights.right+3",
            shapeId: "sideplan",
            sides: [
              {
                id: "sideplan edge 1",
                layerIds: "left/right",
                dropTargetId: "$size.height>wallHeights.right?'sideRight':''",
              },
            ],
          },
          {
            id: "wallFront",
            height: "$wallHeights.front>0?wallHeights.front-6:0",
            shapeId: "sideplan",
            sides: [
              {
                id: "sideplan edge 2",
                layerIds: "wall",
              },
            ],
          },
          {
            id: "wallBack",
            height: "$wallHeights.back>0?wallHeights.back-6:0",
            shapeId: "sideplan",
            sides: [
              {
                id: "sideplan edge 0",
                layerIds: "wall",
              },
            ],
          },
          {
            id: "wallLeft",
            height: "$wallHeights.left>0?wallHeights.left-6:0",
            shapeId: "sideplan",
            sides: [
              {
                id: "sideplan edge 3",
                layerIds: "wall",
              },
            ],
          },
          {
            id: "wallRight",
            height: "$wallHeights.right>0?wallHeights.right-6:0",
            shapeId: "sideplan",
            sides: [
              {
                id: "sideplan edge 1",
                layerIds: "wall",
              },
            ],
          },
          {
            id: "top frame",
            height: 20,
            shapeId: "floorplan",
            sides: [
              {
                id: "$wallHeights.back<size.height-10?'floorplan edge 0':'blah'",
                layerIds: "top frame",
              },
              {
                id: "$wallHeights.right<size.height-10?'floorplan edge 1':'blah'",
                layerIds: "top frame",
              },
              {
                id: "$wallHeights.front<size.height-10?'floorplan edge 2':'blah'",
                layerIds: "top frame",
              },
              {
                id: "$wallHeights.left<size.height-10?'floorplan edge 3':'blah'",
                layerIds: "top frame",
              },
            ],
          },
        ],
        planes: [
          {
            id: "floor",
            shapeId: "floorplan",
            layerIds: ["floor"],
          },
          {
            id: "wall",
            shapeId: "wallplan",
            layerIds: ["wall"],
          },
          {
            id: "shadow floor",
            shapeId: "floorplan",
            layerIds: ["shadow plane"],
          },
        ],
        layers: [
          {
            id: "floor",
            materialId: "bluestone tiles",
            height: 0,
            expand: 50,
            thickness: 5,
          },
          {
            id: "wall",
            materialId: "brick",
            height: -7.5,
            expand: 7.5,
            thickness: 15,
          },
          {
            id: "shadow plane",
            materialId: "shadowMaterial",
            height: -5,
            expand: 5e3,
            thickness: 1,
          },
          {
            id: "front/back",
            materialId: "base",
            height: 0,
            expand: 0,
            thickness: 1.8,
            visible: !1,
            glassDecorationId: "palen voor/achter",
          },
          {
            id: "left/right",
            materialId: "base",
            height: 0,
            expand: 0,
            thickness: 1.8,
            visible: !1,
            glassDecorationId: "palen links/rechts",
          },
          {
            id: "top frame",
            materialId: "base",
            height: -10,
            expand: 0,
            thickness: 10,
          },
        ],
        borders: [],
        droppedElements: "$elements.droppedElements",
        draggableElements: [
          {
            elementId: "screen",
            allowedDropTargets: [
              "sideLeft",
              "sideRight",
              "sideFront",
              "sideBack",
            ],
          },
          {
            elementId: "gondula",
            allowedDropTargets: [
              "sideLeft",
              "sideRight",
              "sideFront",
              "sideBack",
            ],
          },
          {
            elementId: "schuifraam",
            allowedDropTargets: [
              "sideLeft",
              "sideRight",
              "sideFront",
              "sideBack",
            ],
          },
          {
            elementId: "vast raam",
            allowedDropTargets: [
              "sideLeft",
              "sideRight",
              "sideFront",
              "sideBack",
            ],
          },
          {
            elementId: "Glazen schuifdeuren",
            allowedDropTargets: [
              "sideLeft",
              "sideRight",
              "sideFront",
              "sideBack",
            ],
          },
        ],
      },
      locales: {
        nl: {
          sideMenuTitle1: "Interactief",
          sideMenuScreens: "Dicht/open",
          sideMenuSun: "Positie Zon",
          sideMenuRoof: "Dak",
          generalbuttonnext: "Volgende",
          generalbuttonprevious: "Vorige",
          generalno: "Neen",
          generalyes: "Ja",
          step1title1: "Veranda designer",
          step1description1:
            "Ontwerp uw eigen lammellendak in een paar minuten tijd, en bekijk het op een foto.",
          step1action: "Druk op Volgende om te beginnen.",
          step2title1: "Stijl",
          step2Roof: "Dak",
          step2GlassRoof: "Glazen dak",
          step2Blinds: "Lamellen",
          step2framecolor: "Basiskleur",
          step2freeStanding: "Vrijstaand model",
          step2roofcolor: "Dak",
          step2screencolor: "Screens",
          step2title2: "Bepaal de afmetingen",
          step2width: "Breedte",
          step2depth: "Diepte",
          step2height: "Hoogte voorzijde",
          step3title1: "Screens, deuren en ramen",
          step3description1:
            "Versleep de elementen rechts naar de gewenste wanden.",
          step3title2: "Kleuren",
          step3title3: "Muren",
          step3front: "Voor",
          step3back: "Achter",
          step3left: "Links",
          step3right: "Rechts",
          step5title1: "Uw ontwerp is klaar",
          step5description1:
            "Geef uw gegevens door en ontvang een gepersonaliseerd antwoord.",
          step5name: "Name",
          step5mail: "email@domain.com",
          step5street: "Street",
          step5nr: "nr",
          step5zip: "zip",
          step5city: "city",
          step5phone: "phone",
          step5remarks: "Opmerkingen",
          step5savebutton: "Verzenden",
          step6tiltle1: "3D Configurator",
          step6description1: "Start een nieuwe configuratie",
          step6clickbutton: "Start",
          photoDescription: "Bekijk  de terrasoverkapping in uw eigen tuin.",
          photoShowBackgroundPicture: "Achtergrondfoto zichtbaar",
          photoTitle: "Integreer uw ontwerp",
          photoUploadDescription:
            "Upload een foto en plaats uw ontwerp op de gewenste positie",
          photoGridDescription:
            "Plaats het 3D model op de gewenste positie. Gebruik de ronde bol om te roteren, het vierkant om te plaatsen. Pas de schaal aan door het model te vergroten en te verkleinen met de blauwe knoppen",
          photoBackgroundPicked: "Foto:",
          photoBackgroundStockModern: "Modern huis",
          photoBackgroundUpload: "Upload een foto van uw tuin / terras",
          photoUploadTitle: "Upload",
        },
        en: {
          sideMenuTitle1: "Interaction",
          sideMenuScreens: "Closed/open",
          sideMenuSun: "Position Sun",
          sideMenuRoof: "Louvers",
          generalbuttonnext: "next",
          generalbuttonprevious: "back",
          generalno: "No",
          generalyes: "Yes",
          step1title1: "Louvered roof designer",
          step1description1:
            "Create your own louvered roof in a few minutes and see it on a picture",
          step1action: "Click on next to start",
          step2title1: "Style",
          step2Roof: "Roof",
          step2GlassRoof: "Glass roof",
          step2Blinds: "Louvers",
          step2framecolor: "Base color",
          step2freeStanding: "Freestanding model",
          step2roofcolor: "Louvers",
          step2screencolor: "Screens",
          step2title2: "Dimensions",
          step2width: "Width",
          step2depth: "Depth",
          step2height: "Height",
          step3title1: "Screens, doors and windows",
          step3description1:
            "Drag the elements on the right to the desired sidings.",
          step3title2: "Colors",
          step3title3: "Walls",
          step3front: "front",
          step3back: "back",
          step3left: "left",
          step3right: "right",
          step5title1: "Your design is ready",
          step5description1: "Send your details and get a personalised answer",
          step5name: "Name",
          step5mail: "email@domain.com",
          step5street: "Street",
          step5nr: "nr",
          step5zip: "zip",
          step5city: "city",
          step5phone: "phone",
          step5remarks: "",
          step5savebutton: "sent",
          step6tiltle1: "3D Configurator",
          step6description1: "Start a new configurator",
          step6clickbutton: "Start",
          photoDescription:
            "Below you can choose to put your design on a picture.",
          photoShowBackgroundPicture: "Show background picture.",
          photoTitle: "Integrate your design",
          photoUploadDescription:
            "Upload a picture and place your design in the desired position.",
          photoGridDescription:
            "Place the 3D model in the desired position. Use the circle to rotate the square to place. Adjust the scale of the model with the blue buttons.",
          photoBackgroundPicked: "Picture:",
          photoBackgroundStockModern: "Modern house",
          photoBackgroundUpload: "Upload your own picture",
          photoUploadTitle: "Upload",
          Colour: "Color",
        },
        de: {
          sideMenuTitle1: "Interaktiv",
          sideMenuScreens: "schließen/offen",
          sideMenuSun: "Position der Sonne",
          sideMenuRoof: "Lamellen",
          generalbuttonnext: "Weiter",
          generalbuttonprevious: "Zurück",
          generalno: "Nein",
          generalyes: "Ja",
          step1title1: "Lamellendach designer",
          step1description1:
            "Entwerfen Sie in wenigen Minuten Ihr eigenes Lamellendach und sehen Sie sich das Ergebnis gleich an!",
          step1action: "Zum Start auf „Weiter“ klicken.",
          step2title1: "Stil",
          step2Roof: "Dach",
          step2GlassRoof: "Glasdach",
          step2Blinds: "Lamellen",
          step2framecolor: "Basisfarbe",
          step2freeStanding: "Freistehend Model",
          step2roofcolor: "Lamellen",
          step2screencolor: "Markisen",
          step2title2: "Legen Sie die Größe fest",
          step2width: "Breite",
          step2depth: "Tiefe",
          step2height: "Höhe",
          step3title1: "Sonnenschutzmarkisen, Türen und Fenster",
          step3description1:
            "Ziehen Sie die richtigen Elemente auf die gewünschten Wände.",
          step3title2: "Farbe",
          step3title3: "Mauerwerk",
          step3front: "Vorn",
          step3back: "Hinten",
          step3left: "Links",
          step3right: "Rechts",
          step5title1: "Ihr Entwurf ist fertig",
          step5description1:
            "Wenn Sie eine persönliche Antwort wünschen, übermitteln Sie uns bitte Ihre Kontaktdaten.",
          step5name: "Name",
          step5mail: "magers@nachmann.com",
          step5street: "Straße",
          step5nr: "Hausnr.",
          step5zip: "PLZ",
          step5city: "Ort",
          step5phone: "Telefon",
          step5remarks: "Anmerkungen",
          step5savebutton: "Absenden",
          step6tiltle1: "3D-Konfigurator",
          step6description1: "Eine neue Konfiguration starten",
          step6clickbutton: "Start",
          photoDescription:
            "So sieht die Terrassenüberdachung in Ihrem eigenen Garten aus",
          photoShowBackgroundPicture: "Hintergrundfoto sichtbar ",
          photoTitle: "Integrieren Sie Ihren Entwurf",
          photoUploadDescription:
            "Laden Sie ein Foto Ihre Terrasse hoch und platzieren Sie Ihre Terrassenüberdachung.",
          photoGridDescription:
            "Platzieren Sie das 3D-Modell an der gewünschten Position. Verwenden Sie die runde Kugel zum Drehen, das Quadrat zum Platzieren. Passen Sie den Maßstab an, indem Sie das 3D-Modell mit den blauen Tasten vergrößern oder verkleinern.",
          photoBackgroundPicked: "Foto :",
          photoBackgroundStockModern: "Modernes Haus",
          photoBackgroundUpload:
            "Laden Sie ein Foto Ihres Gartens / Ihrer Terrasse hoch.",
          photoUploadTitle: "Hochladen",
        },
        fr: {
          sideMenuTitle1: "Interactif",
          sideMenuScreens: "Fermés/ouverts",
          sideMenuSun: "Position du soleil",
          sideMenuRoof: "Lames",
          generalbuttonnext: "Suivant",
          generalbuttonprevious: "Précédent",
          generalno: "Non",
          generalyes: "Oui",
          step1title1: "Concepteur de toiture à lames",
          step1description1:
            "Concevez votre propre toiture à lames en l‘espace de quelques minutes, et visualisez-la sur photo.",
          step1action: "Cliquez sur Suivant pour commencer.",
          step2title1: "Style",
          step2Roof: "Toit",
          step2GlassRoof: "Toit en verre",
          step2Blinds: "Lames",
          step2framecolor: "Base",
          step2freeStanding: "Model autoportant",
          step2roofcolor: "Lames",
          step2screencolor: "Écrans",
          step2title2: "Définissez les dimensions",
          step2width: "Largeur",
          step2depth: "Profondeur",
          step2height: "Hauteur",
          step3title1: "Écrans pare-soleil, portes et fenêtres",
          step3description1:
            "Faites glisser les bons éléments aux parois désirées.",
          step3title2: "Couleur",
          step3title3: "Murs",
          step3front: "Avant",
          step3back: "Arrière",
          step3left: "Gauche",
          step3right: "Droite",
          step5title1: "Votre projet est prêt",
          step5description1:
            "Indiquez vos coordonnées pour recevoir une réponse personnalisée.",
          step5name: "Nom",
          step5mail: "email@domain.com",
          step5street: "Rue",
          step5nr: "n°",
          step5zip: "Code postal",
          step5city: "Localité",
          step5phone: "Téléphone",
          step5remarks: "Remarques",
          step5savebutton: "Envoyer",
          step6tiltle1: "Configurateur 3D",
          step6description1: "Commencer une nouvelle configuration",
          step6clickbutton: "Début",
          photoDescription: "Vue d'ensemble ou implanter votre pergola",
          photoShowBackgroundPicture: "Photo d'arrière-plan visible",
          photoTitle: "Visualisez votre pergola",
          photoUploadDescription:
            "Téléchargez une photo et placez votre pergola dans la position souhaitée.",
          photoGridDescription:
            "Placez le modèle 3D dans la position souhaitée. Utilisez la sphère ronde pour faire pivoter, le carré pour placer. Ajustez l'échelle en augmentant et en diminuant le modèle avec les boutons bleus",
          photoBackgroundPicked: "Fond avec photo choisi",
          photoBackgroundStockModern: "Fond avec maison moderne",
          photoBackgroundUpload:
            "Téléchargez une photo de votre jardin / terrasse",
          photoUploadTitle: "Téléchargez",
        },
      },
    };
    var c,
      u = n(3),
      h = n(7),
      d = n(0);
    !(function (e) {
      new h.a(new u.a(i.config), new u.b());
      (window.THREE = d), (window.scene = window.env.scene);
    })(c || (c = {}));
  },
]);
